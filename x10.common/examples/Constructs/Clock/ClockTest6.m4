define(`C',
`
		/*Activity kind:$1 clocks=$4*/
		async(here)clocked$4
		for(point [tick]:0:($3)-1){
			// do work
			doWork("$1_",$2,"$4",tick);
			next;//barrier
			// verify that work in prior phase is correct
			verify("$1_",$2,tick); 
			next;//barrier
		}')
// Automatically generated by the command
// m4 ClockTest6.m4 > ClockTest6.x10
// Do not edit
/**
 * Clock test for  multiple clocks.
 * Testing semantics of next with multiple clocks. 
 *
 * 
 * For a clock c: I cannot advance to my next phase 
 * until all activities registered with me have executed next
 * and all activities scheduled for completion
 * in my current phase (with now(c)) have globally finished.
 *
 * My phase zero starts when I am declared/created.
 * 
 * For an activity a: My next cannot advance to the 
 * following statement, until all clocks
 * that I am currently registered with have advanced to 
 * their next phase.
 *
 * I get registered with a clock c by creating/declaring c,
 * or by being enclosed in a clocked(...,c,...) statement.
 *
 * I can register a child activity of mine with some of the clocks 
 * I am already registered with by
 * async(P) clocked(c1,..,cn) S
 * 
 * I can post  a child activity for global completion during the
 * current phase of some of the clocks I am registered with, 
 * by now(c1) ... now(cn) S
 *
 * I can deregister with the clocks I am registered with, by terminating
 *
 * Expected result of this test: should not deadlock
 * and should not throw Error
 *
 * Like ClockTest5, but
 * when the parent terminates, it is as if 
 * it executed a next on the clocks it is still registered with.
 * Children should be able to proceed with their next statements
 * after the parent terminates.
 *
 *
 * @author kemal 4/2005
 */
public class ClockTest6 {

	const int N_INSTANCES=8;//number of instances of each async activity kind
	const int N_NEXTS=4;//number of next pairs in each async activity
	const int N_KINDS=7;// number of kinds of async activities
	int globalCounter=0;

	public boolean run() {
          finish async(here) {
		// create and register with multiple clocks
      		final clock c = clock.factory.clock();
      		final clock d = clock.factory.clock();
      		final clock e = clock.factory.clock();
		// Spawn subactivities using each subset of the clocks
		// The subactivities will perform N_NEXTS next pairs each
		for(point [i]:1:N_INSTANCES) {
			C(1,i,N_NEXTS,(c))
			C(2,i,N_NEXTS,(d))
			C(3,i,N_NEXTS,(e))
			C(4,i,N_NEXTS,(c,d))
			C(5,i,N_NEXTS,(c,e))
			C(6,i,N_NEXTS,(d,e))
			C(7,i,N_NEXTS,(c,d,e))
		}
		// Here all children have registered with
		// their clocks, but have not advanced beyond their first next
		// Parent terminates so children can proceed.
	  }
	  // Wait until all activities are finished
	  return true;
	}
	/**
	 * Each activity increments a global counter and prints a message
	 */
	void doWork(String kind, int instance, String clocks,int tick) {
		atomic globalCounter++;

		System.out.println("Actitivity "+kind+instance+" in phase "+ tick+" of clocks " + clocks);
	}

	/**
	 * This verifies that in the prior phase all
	 * activities have incremented the counter
	 */
	void verify(String kind, int instance, int tick) {
		int tmp;
		atomic {tmp=globalCounter;}
		if((tick+1)*N_KINDS*N_INSTANCES!=tmp) throw new Error(kind+instance+" "+tick);
	}
	

	/**
	 * main method
	 */
	public static void main(String args[]) {
		boolean b= (new ClockTest6()).run();
		System.out.println("++++++ "+(b?"Test succeeded.":"Test failed."));
		System.exit(b?0:1);
	}

}
