This document explains the mechanics behind support of the x10 'extern' keyword.

Simple usage of the keyword looks like:

class C {
  public static extern void foo();
  public static extern long doit(int x);
  public static extern long doit(float f,int i);
  };
  
  ...
  C.foo();          //-- (1)
  x = C.doit(12);   //-- (2)
  float f = ...
  y = C.doit(f,11); //-- (3)
  
  
  in some X10 program.  At the call points, the user will expect that a C routine with the
  format <ContainingClass> "_" <methodName> will be called  ie for foo, a C routine
  C_foo(void) would be called.
  
  The Java specification does not say what happens with overloaded methods, so we've taken the
  JNI approach of adding a suffix "__"+<signature> ie two '_' characters and a string
  of characters, one for each parameter, the mapping being the same as in JNI (e.g. V = void, J = long
  F = float, I= int etc).
  
  So, for the two overloaded methods doit, we'd expect
  C_doit__I
  and
  C_doit__FI
  
  The x10 compiler will produce C files with a suffix "_x10stub.c" for each of the classes containing
  an extern declaration.  These will contain the JNI calls wrapping the C calls the user expects.
  Within the X10 program, the java equivalent would create wrappers, and look like:
  --- java program---
  class C {
  public static native void C_foo();
  public static native long C_doit(int x);
  public static native long C_doit(float f,int i);
  public static  void foo() { C_foo();}
  public static  long doit(int x){ return C_doit(x);}
  public static  long doit(float f,int i){ return C_doit(f,i);}
  };
  
  A file called C_x10stub.c would be created, and it would look like:
  
 ---- file begins--- 
  *
 * Filename:C_x10stub.c
 * Generated: 1/11/05 7:34 PM */
/*Automatically generated -- DO NOT EDIT THIS FILE */
#include <jni.h>
#ifdef __cplusplus
extern "C" {
#endif

/* * * * * * * */
extern void C_foo();
JNIEXPORT void JNICALL
Java_C_C_1foo(JNIEnv *env, jobject obj){
   C_foo()
}

/* * * * * * * */
extern long C_doit__I(int x);
JNIEXPORT jlong JNICALL
Java_C_C_1foo__I(JNIEnv *env, jobject obj,jint x){
   return C_doit__I(x);
}

/* * * * * * * */
extern long C_doit__IF(float f,int i);
JNIEXPORT jlong JNICALL
Java_C_C_1foo__FI(JNIEnv *env, jobject obj,jfloat f ,jint i){
   return C_doit__FI(f,i);
}
#ifdef __cplusplus
}
#endif

--- file ends ---
  
  The Java_... methods are what the java JNI framework will call from the JVM, which in turn
  will call the user's routine.
  The user will have to create a dynamically linked library containing the stub files, and in addition call
  System.loadLibrary() to load this library.
  
  MORE COMPLICATED ISSUES
  There are curerntly two major issues identified when interfacing to native code.  First, 'long'
  variables,    secondly multiply dimensioned arrays.
  
  Longs:
    Long in java is different from a long in C or C++.  In java, a long is always 64 bits.  In C/C++,
    it's the 'natural' size of the architecture ie could be 32 or 64 bits.  So, on a 32 bit machine,
    passing a long to native code could easily lead to errors.  JNI has the same issue, and we solve
    the problem in the same way: we utilize the JNI typedefs found in jni.h for long, specifically
    jlong, which is typecast to a 64 bit type for all platforms.  Manipulating this value in native
    code may require some work, however, as arithmetic operators may or may not work, depending
    on compiler support.
  
  Arrays:
    The native code must know the layout in memory of any multidimensioned array passed from an x10 program.  Single dimension arrays are trivial
    to traverse, however with multiple-dimension arrays, the native code must know whether the arrays is row or column major, and the size of the row/column,
    in order to scale the indicies correctly.  In X10, all arrays are allocated in row-major order ie in C style.
    X10 generates array descriptors to help deal with this issue.  An array descriptor consists of an array of integers, where the first element (index 0) is the
    rank (number of dimensions) of the array.  Each subsequent element is the size of each dimension, from left to right.  An array descriptor is generated for each 
    array passed to a native routine, and is found immediately following the argument declaration for the array itself ie if the nth argument is an array, a
    descriptor will be generated as the n+1th, and all argument declarations shifted by one.
    
    
    Example of usage:
   class X{ ...
     final region R= [0:(N+3), 0:(N+1)];
     final distribution D = distribution.factory.block(R);
     
     ...
     static void extern Initialize(double[.] dbl a);
     ...
     void runit(){
        final double[D] a= new double unsafe[D];
     ...
        Initialize(a);
        ...
     }
     
     and corresponding C code called by the generated wrapper:
     
     void X_Initialize(double arrPtr[],int a_descriptor[]){
       int i,j,rank,innerSize,outerSize;
       rank = a_descriptor[0];
       
       //Expecting 2-dimensional arrays
       if(rank != 2) {
          printf("Unexpected rank %d != 2\n",rank);
          return;
       }
       
       outerSize = a_descriptor[1]; //This will be  N+4
       innerSize = a_descriptor[2]; //This will be  N+2
       
       for(i=0;i<outerSize;++i)
         for(j=0;j<innerSize;++j)
            arrPtr[i*innerSize + j] = 0; /* scale by rowSize*/
      }
  
  
  LIMITATIONS:
  Currently extern method names with unicode characters are not handled.
  
  Only primitive values (ie int, float, double, long, char, byte, short and boolean) and X10 arrays can be passed
  into extern methods.  Currently only primitive values can be returned.

  For performance reasons, the actual memory representing X10 arrays is passed to the extern method, which has two
  consequences for this release:

  1) There is currently no storage protection mechanism for X10 arrays passed to extern methods, so if the extern 
  method corrupts memory, there can be no guarantee of the correctness or stability of the X10 program.

  2) The X10 VM garbage collector (GC) currently does not support pinning of objects, and so GC must be suspended 
  during extern calls to avoid moving the object while possibly being referenced.  In a multi-threaded X10
  application, a long running extern call, or a sequence of parallel extern invocations from independent threads 
  (whose running times overlap), will essentially prevent GC from running.  This is an issue if there is a risk
  of memory exhaustion.

