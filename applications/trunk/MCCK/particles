./src/MC_Comm.c:31:  sdispl = (int *) calloc(mc->nprocs,sizeof(int));
./src/MC_Comm.c:32:  displ = (int *) calloc(mc->nprocs,sizeof(int));
./src/MC_Comm.c:41:    int maxBlocks = mc->sizep/(int)MADRE_BLOCK_LENGTH;
./src/MC_Comm.c:46:    MADRE_particle = MADRE_create(mc->particles, "phBred", maxBlocks, MADRE_BLOCK_LENGTH, mc->ParticleType, MPI_COMM_WORLD); 
./src/MC_Comm.c:77:  p = mc->particles;
./src/MC_Comm.c:83:  recvBuf = p+mc->nparticles;
./src/MC_Comm.c:86:  for (i=1;i<(mc->nprocs);++i) displ[i] = displ[i-1] + myRecvCount[i-1];
./src/MC_Comm.c:89:  for (i=1;i<(mc->nprocs);++i) sdispl[i] = sdispl[i-1] + mySendCount[i-1];
./src/MC_Comm.c:91:  for (i=0;i<(mc->nprocs);i++){
./src/MC_Comm.c:92:    if (mySendCount[i] > 0 && (i != mc->mype)){
./src/MC_Comm.c:94:      MPI_Isend(p+sdispl[i],mySendCount[i],mc->ParticleType,i,99,
./src/MC_Comm.c:98:    if (myRecvCount[i] > 0 && (i != mc->mype)){
./src/MC_Comm.c:99:      MPI_Irecv(recvBuf+displ[i],myRecvCount[i],mc->ParticleType,i,MPI_ANY_TAG,
./src/MC_Comm.c:107:  mc->nparticles += isum(myRecvCount,mc->nprocs);
./src/MC_Comm.c:116:  p = mc->particles;
./src/MC_Comm.c:121:  assert(mc->nparticles % (int)MADRE_BLOCK_LENGTH == 0);
./src/MC_Comm.c:122:  int liveBlocks = mc->nparticles/blockLength;
./src/MC_Comm.c:126:  myRecvCount[mc->mype] = mySendCount[mc->mype];
./src/MC_Comm.c:130:  for (i=1;i<(mc->nprocs);++i) displ[i] = displ[i-1] + myRecvCount[i-1]/blockLength;
./src/MC_Comm.c:142:  mc->nparticles = isum(myRecvCount, mc->nprocs);
./src/MC_Comm.c:144:  assert(mc->nparticles % (int)MADRE_BLOCK_LENGTH == 0);
./src/MC_Comm.c:150:  int *mycoords = mc->grid.proc_coords;
./src/MC_Comm.c:151:  int *nabes = mc->grid.nabes;
./src/MC_Comm.c:152:  MPI_Datatype ParticleType = mc->ParticleType;
./src/MC_Comm.c:156:  p = mc->particles;
./src/MC_Comm.c:160:  recvBuf = p+mc->nparticles;
./src/MC_Comm.c:163:  for (i=1;i<(mc->nprocs);++i) displ[i] = displ[i-1] + myRecvCount[i-1];
./src/MC_Comm.c:166:  for (i=1;i<(mc->nprocs);++i) sdispl[i] = sdispl[i-1] + mySendCount[i-1];
./src/MC_Comm.c:209:  mc->nparticles += isum(myRecvCount,mc->nprocs);
./src/MC_Utils.c:5:  for (j=0;j<mc->nprocs;++j){
./src/MC_Utils.c:6:    if (mc->mype == j){
./src/MC_Utils.c:7:      printf("PE %d\n",mc->mype);
./src/MC_Utils.c:8:      printf("nparticles: %d\n", mc->nparticles);
./src/MC_Utils.c:9:      printf("nprocs: %d\n", mc->nprocs);
./src/MC_Utils.c:10:      printf("mype: %d\n", mc->mype);
./src/MC_Utils.c:11:      printf("leakage: %f\n", mc->leakage);
./src/MC_Utils.c:12:      printf("grid.size[]: %f %f %f\n", mc->grid.size[0],mc->grid.size[1],mc->grid.size[2]);
./src/MC_Utils.c:14:	printf("grid.coords[%d]: %f\n", i,mc->grid.coords[i]);
./src/MC_Utils.c:16:	printf("grid.nabes[%d]: %d\n", i,mc->grid.nabes[i]);
./src/MC_Utils.c:18:	printf("grid.proc_coords[%d]: %d\n", i,mc->grid.proc_coords[i]);
./src/MC_Cycle.c:32:  srand(mc->seed);
./src/MC_Cycle.c:34:  p           = mc->particles;
./src/MC_Cycle.c:35:  mySendCount = (int *)      calloc(mc->nprocs,sizeof(int));
./src/MC_Cycle.c:36:  myRecvCount = (int *)      calloc(mc->nprocs,sizeof(int));
./src/MC_Cycle.c:38:  diag->p0 = mc->nparticles;
./src/MC_Cycle.c:50:    npl = mc->nparticles;
./src/MC_Cycle.c:55:    MPI_Reduce(&mc->nparticles, &np_min, 1, MPI_INT, MPI_MIN, MASTERPE, MPI_COMM_WORLD);
./src/MC_Cycle.c:56:    MPI_Reduce(&mc->nparticles, &np_max, 1, MPI_INT, MPI_MAX, MASTERPE, MPI_COMM_WORLD);
./src/MC_Cycle.c:57:    if (mc->mype == MASTERPE) {
./src/MC_Cycle.c:63:    if (mc->mype == MASTERPE){
./src/MC_Cycle.c:74:      np_mean = (float) npg/(float) mc->nprocs;
./src/MC_Cycle.c:82:       for mc->strict=0, determinstically otherwise  */
./src/MC_Cycle.c:84:    if (mc->strict)
./src/MC_Cycle.c:96:      mc->nparticles = pack();
./src/MC_Cycle.c:98:      /* includes fake data for madre. Preserves accuracy of mc->nparticles for statistics */
./src/MC_Cycle.c:105:    MPI_Allreduce(&mc->nparticles,&np_max,1,MPI_INT,MPI_MAX,MPI_COMM_WORLD);
./src/MC_Cycle.c:110:    if (comm_choice == MC_MADRE) mc->nparticles = includingFakes;
./src/MC_Cycle.c:113:    for (i=0;i<mc->nparticles;++i) ++mySendCount[p[i].proc];
./src/MC_Cycle.c:123:    myRecvCount[mc->mype] = 0;
./src/MC_Cycle.c:136:      mc->nparticles = elim_sent();
./src/MC_Cycle.c:139:      mc->nparticles = madre_unpack();
./src/MC_Cycle.c:144:    for (i=0;i<mc->nprocs;++i) mySendCount[i]= 0;  
./src/MC_Cycle.c:150:  diag->nprocs = mc->nprocs;
./src/MC_Cycle.c:171:  mc->leakage = new_leakage;
./src/MC_Cycle.c:179:  Particle *particles = mc->particles;
./src/MC_Cycle.c:180:  int np = mc->nparticles;
./src/MC_Cycle.c:181:  double leakage = mc->leakage;
./src/MC_Cycle.c:182:  int boundary_flag = mc->boundary_flag;
./src/MC_Cycle.c:200:    nabe = mc->grid.nabes[j];
./src/MC_Cycle.c:202:      particles[npa+i].proc = mc->mype; /* bounce back boundary condition */
./src/MC_Cycle.c:217:  Particle *particles = mc->particles;
./src/MC_Cycle.c:218:  int np = mc->nparticles;
./src/MC_Cycle.c:219:  double leakage = mc->leakage;
./src/MC_Cycle.c:220:  int boundary_flag = mc->boundary_flag;
./src/MC_Cycle.c:229:	random_nabe = mc->grid.nabes[random_nabe_index];
./src/MC_Cycle.c:234:	  particles[i].proc = mc->mype; /* bounce back boundary condition */  
./src/MC_Cycle.c:246:	random_nabe = mc->grid.nabes[random_nabe_index];
./src/MC_Cycle.c:255:	    particles[i].proc = mc->mype;
./src/MC_Cycle.c:267:	random_nabe = mc->grid.nabes[random_nabe_index];
./src/MC_Cycle.c:284:  Particle *p = mc->particles;
./src/MC_Cycle.c:285:  int np = mc->nparticles;
./src/MC_Cycle.c:310:  Particle *p = mc->particles;
./src/MC_Cycle.c:311:  int np = mc->nparticles;
./src/MC_Cycle.c:312:  int nprocs = mc->nprocs;
./src/MC_Cycle.c:330:    for (i=0; fakeSpots>0 && i<mc->sizep;++i){           /* use existing dead data to create remainder ...*/
./src/MC_Cycle.c:339:    if (i==mc->sizep){
./src/MC_Cycle.c:340:      printf("error: can't find enough free blocks for madre_pack: pe[%d], toproc[%d]",mc->mype,j);
./src/MC_Cycle.c:353:  mc->nparticles = totParticleSendCount; //only actual particles
./src/MC_Cycle.c:358:  Particle *p = mc->particles;
./src/MC_Cycle.c:362:  if (comm_choice != MC_MADRE) total_np = (mc->nparticles + isum(myRecvCount,mc->nprocs) - myRecvCount[mc->mype]);
./src/MC_Cycle.c:363:  else total_np = isum(myRecvCount,mc->nprocs);
./src/MC_Cycle.c:364:  if (mc->sizep < total_np){
./src/MC_Cycle.c:366:	   total_np,(isum(myRecvCount,mc->nprocs) - myRecvCount[mc->mype]),mc->mype);
./src/MC_Cycle.c:370:      mc->particles = tmp;
./src/MC_Cycle.c:371:      mc->sizep = total_np + 1;
./src/MC_Cycle.c:374:      printf("ERROR: resizing reallocation of particle array failed on proc: %d\n", mc->mype);
./src/MC_Cycle.c:384:  Particle *p = mc->particles;
./src/MC_Cycle.c:385:  for (i=0;i<mc->nprocs;++i){
./src/MC_Cycle.c:386:    if (mc->mype == i){
./src/MC_Cycle.c:387:      printf("PE[%d]:(%d) ",mc->mype,mc->nparticles);
./src/MC_Cycle.c:388:      for (j=0;j<mc->nparticles;++j){
./src/MC_Cycle.c:407:  Particle *p = mc->particles;
./src/MC_Cycle.c:408:  int np = mc->nparticles;
./src/MC_Cycle.c:409:  int mype = mc->mype;
./src/MC_Cycle.c:426:  if (p1->proc == mc->mype) p1_proc_match =1;
./src/MC_Cycle.c:427:  if (p2->proc == mc->mype) p2_proc_match =1;
./src/MC_Cycle.c:468:  Particle *p = mc->particles;
./src/MC_Cycle.c:469:  int np = mc->nparticles;
./src/MC_Cycle.c:470:  int nprocs = mc->nprocs;
./src/MC_Set_particles.c:4:  mc->particles = p;
./src/MC_Set_particles.c:5:  mc->nparticles = np;
./src/MC_Set_particles.c:6:  mc->sizep = sizep;
./src/MC_Init.c:15:    MPI_Comm_size(comm,&mc->nprocs);
./src/MC_Init.c:16:    MPI_Comm_rank(comm,&mc->mype);
./src/MC_Init.c:18:    mc->particles = NULL;
./src/MC_Init.c:19:    mc->boundary_flag = BNDRY_REFLECT; //default boundary condition is reflective
./src/MC_Init.c:20:    mc->strict = 0; //default is to use random number generator for stochastic particle passing
./src/MC_Init.c:21:    mc->seed = time(NULL)*mc->mype; //default seed for random number generator is time-dependent, not constant
./src/MC_Init.c:24:    mc->ParticleType = create_mpi_particle_type();
./src/MC_Init.c:25:    for (i=0;i<3;++i) mc->grid.size[i] = size[i];
./src/MC_Init.c:26:    mc->cartComm = setup_grid();
./src/MC_Init.c:59:    if (mc->boundary_flag == BNDRY_PERIODIC) for (i=0; i<3; ++i) periods[i] = 1;
./src/MC_Init.c:62:    MPI_Dims_create(mc->nprocs, 3, dims);
./src/MC_Init.c:65:    MPI_Cart_shift(cart_comm, 0,+1, &mc->grid.nabes[1], &mc->grid.nabes[0]);
./src/MC_Init.c:66:    MPI_Cart_shift(cart_comm, 1,+1, &mc->grid.nabes[3], &mc->grid.nabes[2]);
./src/MC_Init.c:67:    MPI_Cart_shift(cart_comm, 2,+1, &mc->grid.nabes[5], &mc->grid.nabes[4]);
./src/MC_Init.c:68:    MPI_Cart_coords(cart_comm,mc->mype,3,mc->grid.proc_coords);
./src/MC_Init.c:70:    dx = mc->grid.size[0]/dims[0];
./src/MC_Init.c:71:    dy = mc->grid.size[1]/dims[1];
./src/MC_Init.c:72:    dz = mc->grid.size[2]/dims[2];
./src/MC_Init.c:74:    mc->grid.coords[0] = mc->grid.proc_coords[0]*dx;
./src/MC_Init.c:75:    mc->grid.coords[1] = mc->grid.coords[0]+dx;
./src/MC_Init.c:77:    mc->grid.coords[2] = mc->grid.proc_coords[1]*dy;
./src/MC_Init.c:78:    mc->grid.coords[3] = mc->grid.coords[2]+dy;
./src/MC_Init.c:80:    mc->grid.coords[4] = mc->grid.proc_coords[2]*dz;
./src/MC_Init.c:81:    mc->grid.coords[5] = mc->grid.coords[4]+dz;
./src/MC_Init.c:111:	  mc->strict = 1;
./src/MC_Init.c:113:	  mc->strict = 0;
./src/MC_Init.c:120:	mc->boundary_flag = BNDRY_REFLECT;
./src/MC_Init.c:122:	mc->boundary_flag = BNDRY_LEAK;
./src/MC_Init.c:124:	mc->boundary_flag = BNDRY_PERIODIC;
./src/MC_Init.c:129:	mc->seed = 3333.3;
./src/MC_Init.c:135:	if (mc->mype == MASTERPE) {
./src/MC_Init.c:136:	  leakage_array = (double *) malloc(mc->nprocs*sizeof(double));
./src/MC_Init.c:137:	  np_array = (int *) malloc(mc->nprocs*sizeof(int));
./src/MC_Init.c:147:	    if (header != mc->nprocs){
./src/MC_Init.c:151:	    for (i=0;i<mc->nprocs;++i){
./src/MC_Init.c:161:	MPI_Scatter(leakage_array, 1, MPI_DOUBLE, &(mc->leakage), 1, MPI_DOUBLE, MASTERPE, MPI_COMM_WORLD);
./src/MC_Init.c:162:	MPI_Scatter(np_array, 1, MPI_INT, &(mc->nparticles), 1, MPI_INT, MASTERPE, MPI_COMM_WORLD);  
./src/MC_Init.c:173:      mc->nparticles = atoi(argv[optind]);
./src/MC_Init.c:174:      mc->leakage = atof(argv[optind+1]);	
./main/Main.c:33:  p  = (Particle *) malloc((1.0+bufsize)*(mc->nparticles)*sizeof(Particle));
./main/Main.c:38:  init_particles(p,mc->nparticles,mc->grid.coords,mype);
./main/Main.c:41:  MC_Set_particles(mc,p,mc->nparticles,(1.0+bufsize)*(mc->nparticles));
