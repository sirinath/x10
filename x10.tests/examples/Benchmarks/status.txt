------- KEY ISSUES:

Parallel UTS is 42x slower than sequential UTS with Java back
end. (Parallel version does not yet work with C++ back end). Probably
due to excessive memory allocation.

Using generic classes vs non-generic costs 30x in peformance with C++
back end. Profiling shows probably due to 16 extra method calls per
update (=apply/set pair) in generic vs non-generic.

C++ back-end X10-style loop test without GC fails by running out of
memory due to unnecessary allocation of Point.

Rail access is 5x slower than hand-coded with Java back end. Profiling
shows likely due to boxing.

Sequential UTS is 4.5x slower than hand-coded with C++ back
end. Profiling shows likely due to handling of primitive casts.

Sequential random access is 3.6x slower than hand-coded with C++ back
end. Profiling shows likely due to handling of primitive casts and
slower rail access.

Rail access is 2x slower than hand-coded with C++ back-end. 

Wrapping rail access in a minimal array-like class (with apply and
set) costs 2x in peformance with both Java and C++ back end.

C++ back-end is faster than Java back-end for the simple tests (rail,
non-generic pseudo-array), slower for the more complex tests (generic
array, sequential UTS).

Matrix multiply is 450x slower than hand-coded with C++ back-end and
80x slower than hand-coded with Java back-end. Profiling doesn't seem
to show any additional sources of inefficiency besides those already
revealed by the above more focussed tests.

With C++ back-end distributed stream shows a slowdown relative to
sequential. (Two processes, sockets, Cygwin.) A little surprising even
given the issues with the implementation of distribution because this
app does very coarse-grained operations. Needs more investigation.

With C++ back-end distributed random access is substantially slower
than sequential. (Two processes, sockets, Cygwin.) Not surprising
given the current distribution implementation issues and the use of
sockets for this test.


------- PERFORMANCE DATA:

                    cpp-opt        x10-cpp-opt    java-opt       x10-java-opt   

SeqRail2            a: 248  Mop/s  b: 115  Mop/s  c: 250  Mop/s  d: 45.2 Mop/s
SeqPseudoArray2a    e: 250  Mop/s  f: 61.3 Mop/s  g: 248  Mop/s  h: 24.5 Mop/s
SeqPseudoArray2b                   i: 2.15 Mop/s                 j: 25.2 Mop/s
SeqArray2a                         k: 2.12 Mop/s                 l: 15.9 Mop/s
SeqArray2b                                                       m: 9.95 Mop/s

SeqUTSBin1          n: 7.16 Mop/s  o: 1.61 Mop/s  p: 9.72 Mop/s  q: 7.96 Mop/s
ParUTSBin1                                                       r: 190  kop/s

SeqMatMultAdd1a     s: 235  Mop/s  t: 525  kop/s  u: 333  Mop/s  v: 3.30 Mop/s

SeqStream1          w: 111  Mop/s  x: 44.3 Mop/s  y: 111  Mop/s  z: 16.6 Mop/s
ParStream1                         A: 101  Mop/s                 B: 37.6 Mop/s
DistStream1                        C: 37.2 Mop/s                 D: 38.4 Mop/s

SeqRandomAccess1    E: 51.8 Mop/s  F: 14.2 Mop/s  G: 34.2 Mop/s  H: 4.35 Mop/s
ParRandomAccess1                   I: 24.1 Mop/s                 J: 3.07 Mop/s
DistRandomAccess1                  K: 2.96 kop/s                 L: 193  kop/s


------- COMPARISONS:

C++ back end relative to hand-coded
    rail access                  2.2x slower (b/c)
    non-generic pseudo-array     4.1x slower (f/g)
    generic pseudo-array       116.3x slower (f/j)
    array w/ c-style loop      117.9x slower (f/l)
    sequential UTS               4.4x slower (o/p)
    matrix multiply            448.4x slower (t/u)
    sequential frag. stream      2.5x slower (x/y)
    sequential random access     3.6x slower (F/G)

Java back end relative to hand-coded
    rail access                  5.5x slower (d/e)
    non-generic pseudo-array    10.1x slower (h/i)
    generic pseudo-array         9.8x slower (h/k)
    array w/ c-style loop       15.6x slower (h/m)
    array w/ x10-style loop     24.9x slower (h/n)
    sequential UTS               1.2x slower (q/r)
    matrix multiply            100.7x slower (v/w)
    sequential frag. stream      6.7x slower (z/A)
    sequential random access     7.9x slower (H/I)

C++ back end relative to Java back end
    rail access                  2.5x faster (c/e)
    non-generic pseudo-array     2.5x faster (g/i)
    generic pseudo-array        11.7x slower (k/j)
    array w/ c-style loop        7.5x slower (m/l)
    sequential UTS               4.9x slower (r/p)
    matrix multiply              6.3x slower (w/u)
    sequential frag. stream      2.7x faster (y/A)
    sequential random access     3.3x faster (G/I)

C++ generic vs non-generic      28.6x slower (g/j)

UTS par. speedup (Java)         41.9x slower (r/s)

Stream par. speedup (Java)       2.3x faster (C/A)
Stream par. speedup (C++)        2.3x faster (B/y)

Stream dist. speedup (Java)      2.3x faster (E/A)
Stream dist. speedup (C++)       1.2x slower (y/D)

Rand. access par. speedup (Java)   1.4x slower (I/K)
Rand. access par. speedup (C++)   1.7x faster (J/G)

Rand. access dist. speedup (Java)  22.5x slower (I/M)
Rand. access dist. speedup (C++) 4802.1x slower (G/L)


------- COLUMNS:

cpp-opt       hand coded C++, compiled g++ -O3

x10-cpp-opt   X10 with C++ back end, compiled g++ -O3 with checking off

java-opt      hand coded Java

x10-java-opt  X10 with Java back end, checking off

------- ROWS (TESTS):

The first five tests are grouped together because they do essentially
the same work (from the application perspective) and so should ideally
perform the same.

SeqRail2

    Basic rail performance test. Allocate a rail, assign values to
    each element, read it back. Test is written to simulate treating
    the rail as a 2-d array in order (nested loop with index
    calculation) to facilitate comparisons with array performance
    tests SeqPseudoArray2{a,b} and SeqArray2

SeqPseudoArray2a

    Does the same work as SeqRail2, but wrapped in a class with an
    apply and set method to simulate the "best possible" X10 code for
    a 2-d double (non-generic) array class.

SeqPseudoArray2b

    Like SeqPseudoArray2a, but generic instead of double.

SeqArray2a

    The actual x10.lang.Array code, using a C-style loop.

SeqArray2b

    The actual x10.lang.Array code, using an X10-style loop with
    destructured points.

SeqUTSBin1

    Sequential version of an the Unbalanced Tree Search
    benchmark. Recursively visits nodes of a randomly generated tree.

ParUTSBin1

    Parallel version of an the Unbalanced Tree Search
    benchmark. Recursively visits nodes of a randomly generated tree.

SeqStream1

    Sequential simplified (rail-only) fragmented stream.

ParStream1

    Parallel version of above.

DistStream1

    Distributed version of above.

SeqRandomAccess1

    Sequential simplified (rail-only) fragmented random access.

ParRandomAccess1

    Parallel version of above.

DistRandomAccess1

    Distributed version of above.
