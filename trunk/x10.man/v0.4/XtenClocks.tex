\chapter{Clocks}\label{XtenClocks}\index{clocks}
\cbstart
The standard library for \Xten{}, {\cf x10.lang} defines a {\cf final
value class}, {\tt clock} intended for repeated quiescence detection
of arbitrary, data-dependent collection of activities. Clocks are a
generalization of {\em barriers}. They permit dynamically created
activities to register and deregister. An activity may be registered
with multiple clocks at the same time. In particular, nested clocks
are permitted: an activity may create a nested clock and within one
phase of the outer clock schedule activities to run to completion on
the nested clock.  Neverthless the design of clocks ensures that
deadlock cannot be introduced by using clock operations.

This chapter describes the syntax and semantics of clocks and
statements in the language that have parameters of type {\cf clock}. 

The key invariants associated with clocks are as follows.  At any
stage of the computation, a clock has zero or more {\em registered}
activities. An activity may perform operations only on those clocks it
is registered with (these clocks constitute its {\em clock set}).  An
activity is registered with one or more clocks when it is created.
During its lifetime the only additional clocks it is registered with
are exactly those that it creates. In particular it is not possible
for an activity to register itself with a clock it discovers by
reading a data-structure.

An activity may perform the following operations on a clock {\cf
c}. It may {\em unregister} with {\cf c} by executing {\cf
c.drop();}. After this, it may perform no further actions on {\cf c}
for its lifetime. It may {\em check} to see if it is unregistered on a
clock. It may {\em register} a newly forked activity with {\cf c}.  It
may {\em post} a statement {\cf S} for completion in the current phase
of {\cf c} by executing the statement {\cf now(c) S}. It may {\em
resume} the clock by executing {\cf c.resume();}. This indicates to
{\cf c} that it has finished posting all statements it wishes to
perform in the current phase. Finally, it may {\em block} (by
executing {\cf next;}) on all the clocks that it is registered
with. (This operation implicitly {\cf resume}'s all clocks for the
activity.) It will resume from this statement only when all these
clocks are ready to advance to the next phase.

A clock becomes ready to advance to the next phase when every activity
registered with the clock has executed at least one {\cf resume}
operation on that clock and all statements posted for completion in
the current phase have been completed.

Though clocks introduce a blocking statement ({\cf next}) an important
property of \Xten{} is that clocks cannot introduce deadlocks. That is,
the system cannot reach a quiescent state (in which no activity is
progressing) from which it is unable to progress. For, before blocking
each activity resumes all clocks it is registered with. Thus if a
configuration were to be stuck (that is, no activity can progress) all
clocks will have been resumed. But this implies that all activities
blocked on {\cf next} may continue and the configuration is not stuck.

\section{Clock operations}
The special statements introduced for clock operations are listed below.
\begin{x10}
462 Statement ::= ClockedStatement
472 StatementNoShortIf ::= 
      ClockedStatementNoShortIf
479 NowStatement ::= 
      now ( Clock ) Statement
480 ClockedStatement ::= 
      clocked ( ClockList ) Statement
490 ClockedStatementNoShortIf ::= 
      clocked ( ClockList ) 
         StatementNoShortIf
501 NextStatement ::= next ;
\end{x10}

Note that {\tt x10.lang.clock} provides several useful methods on
clocks (e.g. {\tt drop}).

\subsection{Creating new clocks}\index{clock!creation}
Clocks are created using the nullary constructor for {\cf
x10.lang.clock} via a factory method:

\begin{x10}
clock timeSynchronizer = clock.factory.clock();
\end{x10}

All clocked variables are implicitly final. The initializer for a
local variable declaration of type {\tt clock} must be a new clock
expression. Thus \Xten{} does not permit aliasing of clocks.
Clocks are created in the place global heap and hence outlive the
lifetime of the creating activity.  Clocks are instances of value
classes, hence may be freely copied from place to
place. (Clock instances typically contain references to mutable state
that maintains the current state of the clock.)

The current activity is automatically registered with the newly
created clock.  It may deregister using the {\tt drop} method on
clocks (see the documentation of {\tt x10.lang.clock}). All activities
are automatically deregistered from all clocks they are registered
with on termination (normal or abrupt).

\subsection{Registering new activities on clocks}\index{clock!clocked statements}

The programmer may specify which clocks a new activity is to be registered with using the {\tt clocked} clause:
\begin{x10}
\end{x10}


\paragraph{Static semantics.} An activity may 
transmit only those clocks that is registered with and has not
quiesced on.  (\S~\ref{resume}). The compiler checks this
statically, inserting code to throw a {\tt ClockUseException}
if a violation is detected at runtime.

An activity may check that it is registered on a clock {\tt c} by
executing:
\begin{x10}
c.registered()
\end{x10}
\noindent This call returns a {\cf boolean} value: {\cf true} iff the
activity is registered on {\cf c}.

\paragraph{Note.} 
\Xten{} does not contain a ``register'' statement that would allow an
activity to discover a clock in a datastructure and register itself on
it. Therefore, while clocks may be stored in a datastructure by one
activity and read from that by another, the new activity cannot
``use'' the clock unless it is already registered with it.

\todo{Add text on arrays of clocks.}

\subsection{Resuming clocks}\index{clock!resume}\label{resume}
\Xten{} permits {\em split phase} clocks. An activity may wish
to indicate that it has completed whatever work it wishes to perform
in the current phase of a  clock {\tt c} it is registered with, without
suspending all activity. It may do so  by executing the method
invocation:
\begin{x10}
  c.resume();
\end{x10}
\noindent on a clock {\tt c} it is registered with.  

Nothing happens if the activity invokes this method on a clock it is
not registered with, or if it has already invoked a {\tt resume} on
this clock in the current phase.  Otherwise execution of this
statement indicates that the activity will not transmit {\cf c} to an
async or invoke {\cf now} until it terminates, drops {\cf c} or
executes a {\tt next}. The runtime throws a {\tt ClockUseException} if
it detects a violation of this condition.

\paragraph{Static semantics.} 
The compiler should issue an error if any activity has a potentially
live execution path from a {\cf resume} statement on a clock {\tt c}
to a {\cf now} or async spawn statement (which registers the new
activity on {\cf c}) unless the path goes through a {\cf next}
statement. (A {\cf c.drop()} following a {\cf c.resume()} is legal,
as is {\cf c.resume()} following a {\cf c.resume()}.

\subsection{Advancing clocks}\index{clock!next}
An activity may execute the statement
\begin{x10}
  next;
\end{x10}

\noindent 
Execution of this statement blocks until all the clocks that the
activity is registered with (if any) have advanced. (The activity
implicitly issues a {\cf resume} on all clocks it is registered
with before suspending.)

An \Xten{} computation is said to be {\em quiescent} on a clock {\cf
c} if each activity registered with {\cf c} has continued {\cf c}.
Note that once a computation is quiescent on {\cf c}, it will remain
quiescent on {\cf c} forever (unless the system takes some action),
since no other activity can become registered with {\cf c}.  That is,
quiescence on a clock is a {\em stable property}.

Once the implementation has detected quiecence on {\cf c}, the system
marks all activities registered with {\cf c} as being able to progress
on {\cf c}. An activity blocked on {\cf next} resumes execution once
it is marked for progress by all the clocks it is registered with.

\subsection{Dropping clocks}\index{clock!drop}
An activity may drop a clock by executing:
\begin{x10}
c.drop();
\end{x10}

\noindent{} 
The method does nothing if the activity has already dropped {\cf c}. 

\paragraph{Static semantics.}
The compiler should issue an error if it discovers a potentially live
execution path from a {\tt c.drop()} to a statement using {\tt c}.

\subsection{Posting statements on a clock}\index{clock!now}
\Xten{} provides syntactic support for a common idiom. Often it may be
necessary for an activity $A$ to require that a certain set of
statements be executed to completion before a clock $c$ can move
forward, without $A$ actually waiting for the completion
of the statement. We introduce the syntax:
\begin{x10}
461 Statement ::= NowStatement
471 StatementNoShortIf ::= 
       NowStatementNoShortIf
479 NowStatement ::= 
       now ( Clock ) Statement
489 NowStatementNoShortIf ::= 
       now ( Clock ) StatementNoShortIf
\end{x10}
\noindent 

A statement {\tt now (c) s} may be considered as shorthand for
\begin{x10}
  async clocked(c) \{ 
     finish async s; 
  \}
\end{x10}

\paragraph{Note.} Because of the static semantics of {\tt finish}
it is not possible to nest {\cf now} statements. Instead if it proves
useful, we may introduce a multi-clocked {\tt now} statement,
which permits the statement to be posted on multiple clocks
simultaneously.
\begin{x10}
479' NowStatement ::= 
       now ( ClockList ) Statement
489' NowStatementNoShortIf ::= 
       now ( ClockList ) StatementNoShortIf  
\end{x10}

\subsection{Program equivalences}

From the discussion above it should be clear that the following
equivalences hold:

\begin{eqnarray}
 {\cf c.resume(); next;}       &=& {\cf next;}\\
 {\cf c.resume(); d.resume();} &=& {\cf d.resume(); c.resume();}\\
 {\cf c.resume(); c.resume();} &=&  {\cf c.resume();}
\end{eqnarray}

Note that {\cf next; next;} is not the same as {\cf next;}. The
first will wait for clocks to advance twice, and the second
once.  

\cbend
%%\subsection{Implementation Notes}
%%Clocks may be implemented efficiently with message passing, e.g.{} by
%%using short-circuit ideas in \cite{SaraswatPODC88}.  Recall that every
%%activity is spawned with references to a fixed number of clocks. Each
%%reference should be thought of as a global pointer to a location in
%%some place representing the clock. (We shall discuss a further
%%optimization below.) Each clock keeps two counters: the total number
%%of outstanding references to the clock, and the number of activities
%%that are currently suspended on the clock.
%%
%%When an activity $A$ spawns another activity $B$ that will reference a
%%clock $c$ referenced by $A$, $A$ {\em splits} the reference by sending
%%a message to the clock. Whenever an activity drops a reference to a
%%clock, or suspends on it, it sends a message to the clock. 
%%
%%The optimization is that the clock can be represented in a distributed
%%fashion. Each place keeps a local counter for each clock that is
%%referenced by an activity in that place. The global location for the
%%clock simply keeps track of the places that have references and that
%%are quiescent. This can reduce the inter-place message traffic
%%significantly.

\todo{Reintroduce clocked types}
%%\section{Clocked types}\index{types!clocked}
%%
%%%We allow types to specify clocks, via a {\cf clocked(c)} modifier,
%%%e.g.{}
%%
%%%\begin{x10}
%%%  clocked(c) int r;
%%%\end{x10}
%%
%%%This declaration asserts that {\cf r} is accessible
%%%(readable/writable) only by those statements that are clocked on {\cf
%%%c}. Thus propagation of the clock provides some control over the
%%%``visibility'' of {\cf r}.
%%
%%The declaration 
%%
%%\begin{x10}
%%  clocked(c) final int l = r;
%%\end{x10}
%%
%%\noindent asserts additionally that in each clock instant {\cf l} is final, 
%%i.e.{} the value of {\cf l} may be reset at the beginning of each phase
%%of {\tt c} but stays constant during the phase.
%%
%%This statement terminates when the computation of {\tt r} has
%%terminated and the assignment has been performed.
%%
%%\todo{Generalize the syntax so that aggregate variables can be clocked with an aggregate clock of the same shape.}
%%
%%\subsection{Clocked assignment}\index{assignment!clocked}
%%We expect that most arrays containing application data will be
%%declared to be {\cf clocked final}. We support this very powerful type
%%declaration by providing a new statement:
%%{\footnotesize
%%\begin{verbatim}
%%  next(c) l = r; 
%%\end{verbatim}}
%%
%%
%%\noindent 
%%for a variable $l$ declared to be clocked on $c$. The statement
%%assigns $r$ to the {\em next} value of $l$. There may be multiple such
%%assignments before the clock advances. The last such assignment
%%specifies the value of the variable that will be visible after the
%%clock has advanced.  If the variable is {\cf clocked final} it is
%%guaranteed that {\em all} readers of the variable throughout this
%%phase will see the value $r$.
%%
%%The expression {\tt r} is implicitly treated as {\tt now(c) r}. That
%%is, the clock {\tt c} will not advance until the computation of {\tt r} has
%%terminated.
%%
%%\section{Examples}
%%
%%Consider the core of the ASCI Benchmark Sweep3D program for computing
%%solutions to mass transport problems.
%%
%%In a nutshell the core computation is a triply nested sequential loop
%%in which the value of a variable in the current iteration is dependent
%%on the values of neighboring variables in a past iteration. Such a
%%problem can be parallelized through pipelining. One visualizes a
%%diagonal wavefront sweeping through the array. An MPI version of the
%%program may be described as follows. There is a two dimensional grid
%%of processors which performs the following computation
%%repeatedly. Each processor synchronously receives a value from the
%%processor to its west, then to its north, then computes some function
%%of these values and computes a new value to be sent to the processor
%%to its east and then to its south.  Ignoring the behavior of the
%%boundary processors for the moment such a computation may be described
%%by the following \Xten{} program:
%%
%%\begin{x10}
%%region R = [1..n0,1..m0];
%%clock[R] W,N;
%%clock(W) final double [cyclic(R)] A; 
%%for (int t : 1..TMax) \{
%%  ateach( i,j:A) 
%%    clock (W[i-1,j],N[i,j-1],W[i,j],N[i,j]) \{
%%      double west = now (W[i-1,j]) future\{A[i-1,j]\}; 
%%      W[i-1,j].continue();           
%%      double north = now (N[i,j-1]) future\{A[i,j-1]\}; 
%%      N[i,j-1].continue();
%%      next(W[i,j]) A[i,j] = compute(west, north);
%%      next W[i-1,j],N[i,j-1],W[i,j],N[i,j];
%%  \}
%%\}
%%\end{x10}

