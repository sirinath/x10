\chapter{Variable declarations}
\label{exploded-syntax}\index{variable declarator!exploded}
\index{variable declaration}

Variables declarations are used to declare formal parameters,
fields, properties, and local variables.

\begin{grammar}
VarDeclaratorWithType \: Identifier ResultType \\
VarDeclarator \: Identifier ResultType\opt \\
              \| Identifier \xcd"(" VarDeclaratorList \xcd")" ResultType\opt \\
              \| \xcd"(" VarDeclaratorList \xcd")" ResultType\opt \\
VarDeclaratorList \: VarDeclarator ( \xcd"," VarDeclarator )\star \\
ResultType \: \xcd":" Type \\
\end{grammar}

Property declarations are always declared with a type and are
always final (either declared \xcd"val" or by default).

\begin{grammar}
Property
        \: \xcd"val" VarDeclaratorWithType \\
        \| VarDeclaratorWithType \\
\end{grammar}

Formal parameters are always declared with a type.
Formals may be declared either
final using the \xcd"val" or \xcd"var"; a declaration with
neither keyword is final.
The
variable name can be omitted if it is not to be used in the
scope of the declaration.

\begin{grammar}
Formal
        \: \xcd"var" VarDeclaratorWithType \\
        \| \xcd"val" VarDeclaratorWithType \\
        \| VarDeclaratorWithType \\
        \| Type \\
\end{grammar}

Fields are declared either \xcd"var" (non-final, non-static),
\xcd"val" (final, non-static), or \xcd"const" (final, static);
the default is \xcd"val".
Field declarations may have optional
initializer expressions.  The initializer must be a subtype of
the declared type of the variable.  If the variable is final,
the type may be omitted and
inferred from the initializer type (\Sref{TypeInference}).
Mutable fields must be declared with a type.
A field declaration may have an optional
\grammarrule{WhereClause}, restricting how the field may be accessed.
The compiler is free to not allocate storage for the field if
the where clause of a field cannot be satisfied for a given containing
object.

\begin{grammar}
FieldDeclaration
        \: \xcd"var" FieldDeclaratorsWithType ( \xcd"," FieldDeclaratorsWithType )\star \\
        \| \xcd"const" FieldDeclarators ( \xcd"," FieldDeclarators )\star \\
        \| \xcd"val" FieldDeclarators ( \xcd"," FieldDeclarators )\star \\
        \| FieldDeclaratorsWithType ( \xcd"," FieldDeclaratorsWithType )\star \\
FieldDeclarators
        \: FieldDeclaratorsWithType \\
        \: FieldDeclaratorWithInit \\
FieldDeclaratorWithInit
        \: Identifier WhereClause\opt Init \\
        \| Identifier WhereClause\opt \xcd":" Type Init \\
FieldDeclaratorsWithType
        \: Identifier WhereClause\opt
                ( \xcd"," Identifier WhereClause\opt )\star \xcd":" Type \\
Init \: \xcd"=" Expression \\
\end{grammar}

\begin{grammar}
LocalDeclaration
        \: \xcd"var" VarDeclarator Init\opt ( \xcd"," VarDeclarator Init\opt )\star \\
        \| \xcd"val" VarDeclarator Init\opt ( \xcd"," VarDeclarator Init\opt )\star \\
        \| VarDeclaratorWithType Init\opt ( \xcd"," VarDeclaratorWithType Init\opt )\star \\
\end{grammar}

Local variable and field declarations may have optional
initializer expressions.  The initializer must be a subtype of
the declared type of the variable.  If the variable is final
(i.e., is declared \xcd"val" or \xcd"const")
the type may be omitted and
inferred from the initializer type (\Sref{TypeInference}).

Formal parameter and property declarations do not have
initializers and cannot omit the type.

\Xten{} permits a \emph{destructuring} syntax for variable
declarations.
At present, \XtenCurrVer{} supports this feature only for
variables of
type \xcd"Point"; future versions of the language may support 
general pattern matching.
Intuitively, this syntax allows a
point to be ``destructured'' into its corresponding \xcd"Int" 
indices in a pattern-matching style.
The $k$th identifier in the \grammarrule{IdentifierList}
is treated as a variable of type \xcd"Int"
that is initialized with the value of the $k$th index of the point. 
The second form of the syntax permits the specification of only
the index variables.

For example, the following code binds the \xcd"Int" variable \xcd"x" to
\xcd"0" and \xcd"y" to \xcd"1", and the variable \xcd"p" to the
point object.
\begin{xten}
p(i,j): Point = new Point(0,1);
\end{xten}
