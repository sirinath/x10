\section{Expressions}\label{XtenExpressions}\index{expressions}

{}\Xten{} inherits all the standard expressions of \Java{}
\cite[\S~15]{jls2}---as modified to permit generics \cite{gjspec} --
with the expected semantics, unless otherwise mentioned below:

\begin{verbatim}
Assignment MethodInvocation 
Cast Class
ClassInstanceCreationExpression FieldAccessExpression   
ArrayCreationExpression ArrayAccessExpression
PostfixExpression PrefixExpression 
InfixExpression UnaryOperators
MultiplicativeOperators AdditiveOperators 
ShiftOperators RelationalOperators  
EqualityOperators BitwiseOperators
ConditionalOperators AssignmentOperators
\end{verbatim}

Expressions are evaluated in the same order as they would in \java{}
(primarily
left-to-right).\label{FieldAccess}\label{ClassCreation}\label{MethodInvocation}

We focus on the expressions in \Xten{} which have a different
semantics.

\subsection{The cast operator}\label{ClassCast}\index{classcast}

The cast operation may be used to cast an expression to a given type:
\begin{grammar}
UnaryExpressionNotPlusMinus \: CastExpression \\
CastExpression \: UnaryExpressionNotPlusMinus \xcd"as" Type \\
\| UnaryExpressionNotPlusMinus \xcd"to" Type \\
\end{grammar}

The result of this operation is a value of the given type if the cast
is permissible at runtime. Both the data type and place type of the
value are checked. Data type conversion is checked according to the
rules of the \java{} language (e.g.{}\cite[\S 5.5]{jls2}). If the
value cannot be cast to the appropriate data type, a
\xcd"ClassCastException"
is thrown. Otherwise, if the value cannot be cast to the
appropriate place type a \xcd"BadPlaceException" is thrown. 

Any attempt to cast an expression of a reference type to a value type
(or vice versa) results in a compile-time error. Some casts---such as
those that seek to cast a value of a subtype to a supertype---are
known to succeed at compile-time. Such casts should not cause extra
computational overhead at runtime.

\subsection{\Xcd{instanceof} operator}\label{instanceOf}\index{instanceof@\xcd"instanceof"}

\Xten{} permits types to be used in an in instanceof expression
to determine whether an object is an instance of the given type:

\begin{grammar}
RelationalExpression \: RelationalExpression \xcd"instanceof" Type
\end{grammar}

In the above expression, \grammarrule{Type} is any type including
constrained types and value types. 
At run time, the result of this operator is
\xcd"true" if the \grammarrule{RelationalExpression} can be cast
to \grammarrule{Type} without a \xcd" ClassCastException" being
thrown.  Otherwise the result is \xcd"false".
This determination may involve checking
that the
constraint, if any, associated with the type is true for the
given expression.


\subsection{Stable equality.}\label{StableEquality}\index{==}\index{!=}

Reference equality (\xcd"==", \xcd"!=") is replaced in \Xten{} by the
notion of {\em stable equality} so that it can apply uniformly to value and
reference types.

Two values may be compared with the infix predicate \xcd"==". The call
returns the value \xcd"true" if and only if no action taken by any
user program can distinguish between the two values.  In more detail
the rules are as follows.

If the values have a reference type, then both must be references to
the same object (even if the object has no mutable fields). 

If the values have a value type then they must be structurally equal,
that is, they must be instances of the same value class or value array
data type and all their fields or components must be \xcd"==". 

If one of the values is \xcd"null" then the predicate succeeds iff the
other value is also \xcd"null".

The predicate \xcd"!=" returns \xcd"true" (\xcd"false") on two
arguments if and only if the predicate \xcd"==" returns \xcd"false"
(\xcd"true") on the same arguments.

The predicates \xcd"==" and \xcd"!=" may not be overridden by the
programmer.

