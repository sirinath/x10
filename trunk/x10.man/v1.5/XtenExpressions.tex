\chapter{Expressions}\label{XtenExpressions}\index{expressions}

\Xten{} supports a rich expression language similar to
\Java{}'s.
Evaluating an expression produces a value, which may be either
an instance of a value class or an instance of a reference
class. Expressions may also be \xcd"void"; that is, they produce no
value.
Expression evaluation may have side effects: assignment to a
variable, allocation, method calls, or exceptional control-flow.
Evaluation is strict and is performed left to right.

\section{Literals}

\Xten{} supports the following literal expressions: 
\begin{itemize}
\item An 32-bit integer literal is a value of type \xcd"x10.lang.Int".
\item An 64-bit long literal is a value of type \xcd"x10.lang.Long".
\item A 32-bit floating-point literal is a value of type \xcd"x10.lang.Float".
\item A 64-bit floating-point literal is a value of type \xcd"x10.lang.Double".
\item A character literal is a value of type \xcd"x10.lang.Char".
\item A string literal is a value of type \xcd"x10.lang.String".
\item The boolean literals \xcd"true" and \xcd"false" are of type
\xcd"x10.lang.Boolean".
\item The \xcd"null" literal is of the null type,
a subtype of all reference types.
\end{itemize}

\section{\Xcd{this}}

\begin{grammar}
ThisExpression \: \xcd"this" \\
\| ClassName \xcd"." \xcd"this" \\
\end{grammar}

The expression \xcd"this" is a final local variable containing a reference
to an instance of the lexically enclosing class.
It may be used only within the body of an instance method, a
constructor, or in the initializer of a instance field.

Within an inner class, \xcd"this" may be qualified with the
name of a lexically enclosing class.  In this case, it
represents an instance of that enclosing class.

The type of a \xcd"this" expression is the
innermost enclosing class, or the qualifying class,
constrained by the class invariant and the
method where clause, if any.

\section{Local variables}



\section{Field access}
\label{FieldAccess}


\begin{grammar}
FieldExpression \: Expression \xcd"." Identifier \\
                \| \xcd"super" \xcd"." Identifier \\
                \| ClassName \xcd"." Identifier \\
                \| ClassName \xcd"." \xcd"super" \xcd"." Identifier \\
\end{grammar}

A field of an object instance may be  accessed
with a field access expression.

The type of the access is the declared type of the field with the
actual target substituted for \xcd"this" in the type.  If the actual
target is not a final access path, an anonymous path is
substituted for \xcd"this".

The field accessed is selected from the fields and value properties
of the static type of the target and its superclasses.

If the field target is given by the keyword \xcd"super",
the target's type is
the superclass of the enclosing class, as
constrained by the superclass's class invariant, if any.

If the field target is \xcd"null", a \xcd"NullPointerException"
is thrown.

If the field target is a class name, a static field is selected.

It is illegal to access  a field that is not visible from
the current context.
It is illegal to access a non-static field
through a static field access expression.

\section{Calls}
\label{MethodInvocation}
\label{MethodInvocationSubstitution}

\section{Closures}
\label{Closures}
\input{Closures}

\section{Increment and decrement}

The operators \xcd"++" and \xcd"--" increment and decrement
a variable, respectfully.  The variable must be non-final
and of numeric type.

When the operator is prefix, the variable is
incremented or decremented by \xcd"1" and the result of the expression is
the new value of the variable.
When the operator is postfix, the variable is incremented or
decremented by \xcd"1" and the result of the expression is the old value of
the variable.

The new value of the variable $v$ is identical to the result of
the expressions
\xcdmath"$v$+1" or \xcdmath"$v$-1", as appropriate.

\section{Numeric promotion}

The unary and binary operators promote their operands as
follows.
Values are sign extended and converted to instances of the
promoted type.

\begin{itemize}
\item  The unary promotion of \xcd"Byte", \xcd"Short",
\xcd"Char", and \xcd"Int" is \xcd"Int".
\item  The unary promotion of \xcd"Long" is \xcd"Long".
\item  The unary promotion of \xcd"Float" is \xcd"Float".
\item  The unary promotion of \xcd"Double" is \xcd"Double".
\item The binary promotion of two types is the  
greater of the unary promotion of each type
according to the following order:
\xcd"Int", \xcd"Long", \xcd"Float", \xcd"Double".
\end{itemize}

\section{Unary plus and unary minus}

The unary \xcd"+" operator applies unary numeric promotion to
its operand.   The operand must be of numeric type.

The unary \xcd"-" operator
applies unary numeric promotion to its operand
and then
subtracts the promoted operand from \xcd"0".
The operand must be of numeric type.
The type of the result is promoted type.

\section{Bitwise complement}

 The unary \xcd"~" operator
applies unary numeric promotion to its operand
and then
 evaluates to the bitwise complement of
 the promoted operand.
  The operand must be of integral type.
The type of the result is promoted type.

\section{Binary arithmetic operations} 

The binary arithmetic operations apply binary numeric promotion
to their operands. The operands must be of numeric type.
The type of the result is the promoted type.
The
\xcd"+" operator adds the promoted operands. The \xcd"-" operator
subtracts the second operand from the first. The \xcd"*" operator
multiplies the  promoted  operands. The \xcd"/" operator
divides the
first  operand  by the second.
The \xcd"%" operator evaluates to
the remainder of the division of the first operand by the
second.

Floating point operations are determined by the IEEE 754
standard. 



\section{Binary shift operations}

Unary promotion is performed on each operand separately. 
The operands must be of integral type.
The type of the result is the promoted type of the left operand.

If the promoted type of the left operand is \xcd"Int",
the right operand is masked with \xcd"0x1f" using the bitwise
AND (\xcd"&") operator.
If the promoted type of the left operand is \xcd"Long",
the right operand is masked with \xcd"0x3f" using the bitwise
AND (\xcd"&") operator.

The \xcd"<<" operator left-shifts the left operand by the number of
bits given by the right operand.

The \xcd">>" operator right-shifts the left operand by the number of
bits given by the right operand.  The result is sign extended;
that is, if the right operand is $k$,
the most significant $k$ bits of the result are set to the most
significant bit of the operand.

The \xcd">>>" operator right-shifts the left operand by the number of
bits given by the right operand.  The result is not sign extended;
that is, if the right operand is $k$,
the most significant $k$ bits of the result are set to \xcd"0".

\section{Binary bitwise operations}

The binary bitwise operations apply binary numeric promotion
to their operands. The operands must be of integral type.
The type of the result is the promoted type.
The \xcd"&" operator  performs the bitwise AND of the promoted operands.
The \xcd"|" operator  performs the bitwise inclusive OR of the promoted operands.
The \xcd"^" operator  performs the bitwise exclusive OR of the promoted operands.

\section{String concatenation}

The \xcd"+"  operator is used for string concatenation 
 as well as addition.
If either operand is of static type \xcd"x10.lang.String",
 the other operand is converted to a \xcd"String", if needed,
  and  the two strings  are concatenated.

 String conversion of a non-\xcd"null" value is  performed by invoking the
 \xcd"toString()" method of the value.
  If the value is \xcd"null", the value is converted to 
  \xcd'"null"'.

The type of the result is \xcd"String".

\section{Logical negation}

The operand of the  unary \xcd"!" operator 
must be of type \xcd"x10.lang.Boolean".
The type of the result is \xcd"Boolean".
If the value of the operand is \xcd"true", the result is \xcd"false"; if
if the value of the operand  is \xcd"false", the result is \xcd"true".

\section{Boolean logical operations}

Operands of the binary boolean logical operators must be of type \xcd"Boolean".
The type of the result is \xcd"Boolean"

The \xcd"&" operator  evaluates to \xcd"true" if both of its
operands evaluate to \xcd"true"; otherwise, the operator
evaluates to \xcd"false".

The \xcd"|" operator  evaluates to \xcd"false" if both of its
operands evaluate to \xcd"false"; otherwise, the operator
evaluates to \xcd"true".

The \xcd"^" operator  evaluates to \xcd"false" if both of its
operands are equal; otherwise, the operator
evaluates to \xcd"true".

\section{Relational operations} 

The relational operations apply binary numeric promotion
to their operands. The operands must be of numeric type.
The type of the result is \xcd"Boolean".

The \xcd"<" operator evalutates to \xcd"true" if the left operand is
less than the right.
The \xcd"<=" operator evalutates to \xcd"true" if the left operand is
less than or equal to the right.
The \xcd">" operator evalutates to \xcd"true" if the left operand is
greater than the right.
The \xcd">=" operator evalutates to \xcd"true" if the left operand is
greater than or equal to the right.

Floating point comparison is determined by the IEEE 754
standard.  Thus,
if either operand is NaN, the result is \xcd"false".
Negative zero and positive zero are considered to be equal.
All finite values are less than positive infinity and greater
than negative infinity.

\section{Stable equality}\label{StableEquality}\index{==}\index{!=}

The \xcd"==" and \xcd"!=" operators provide \emph{stable equality}.

Two operands may be compared with the infix predicate \xcd"==".
The operation
evaluates to \xcd"true" if and only if no action taken by any
user program can distinguish between the two operands.  In more detail,
the rules are as follows.

If the operands both have reference type, then the operation
evaluates to \xcd"true" if both are references to
the same object (even if the object has no mutable fields). 

If one operand evaluates to \xcd"null" then the predicate
evaluates to \xcd"true" if and only if the
other operand is also \xcd"null".

If the operands both have value type, then they must be structurally equal;
that is, they must be instances of the same value class or value array
data type and all their fields or components must be \xcd"==". 

If one operand is of reference type and the other is of value type,
the result is \xcd"false".

The predicate \xcd"!=" returns \xcd"true" (\xcd"false") on two
arguments if and only if the operand \xcd"==" returns \xcd"false"
(\xcd"true") on the same operands.

The predicates \xcd"==" and \xcd"!=" may not be overridden by the
programmer.

\section{Allocation}
\label{ClassCreation}

\begin{grammar}
NewExpression \: \xcd"new" ClassName TypeArguments\opt ValueArguments
        ClassBody\opt \\
  \| \xcd"new" InterfaceName TypeArguments\opt ValueArguments
        ClassBody
\end{grammar}

An allocation expression creates a new instance of a class and
invokes a constructor of the class.
The expression designates the class name and passes
type and value arguments to be constructor.

The allocation expression may have an optional class body.
In this case, an anonymous subclass of the given class is
allocated.   An anonymous class allocation may also specify a
single super-interface rather than a superclass; the superclass
of the anonymous class is \xcd"x10.lang.Object".

If the class is anonymous---that is, if a class body is
provided---in the constructor is selected from the superclass.
The constructor to invoke is selected using the same rules as
for method invocation (\Sref{MethodInvocation}).

The type of an allocation expression
is the return type of the constructor invoked, with appropriate
substitutions  of actual arguments for formal parameters, as
specified in \Sref{MethodInvocationSubstitution}.

It is illegal to allocate an instance of an \xcd"abstract" class.
It is illegal to allocate an instance of a class or to invoke a
constructor that is not visible at
the allocation expression.


\section{Casts}\label{ClassCast}\index{classcast}

The cast operation may be used to cast an expression to a given type:

\begin{grammar}
UnaryExpressionNotPlusMinus \: CastExpression \\
CastExpression \: UnaryExpressionNotPlusMinus \xcd"as" Type \\
\| UnaryExpressionNotPlusMinus \xcd"to" Type \\
\end{grammar}

The result of this operation is a value of the given type if the cast
is permissible at runtime. Both the data type and place type of the
value are checked. Data type conversion is checked according to the
rules of the \java{} language (e.g., \cite[\S 5.5]{jls2}). If the
value cannot be cast to the appropriate data type, a
\xcd"ClassCastException"
is thrown. Otherwise, if the value cannot be cast to the
appropriate place type a \xcd"BadPlaceException" is thrown. 

Any attempt to cast an expression of a reference type to a value type
(or vice versa) results in a compile-time error. Some casts---such as
those that seek to cast a value of a subtype to a supertype---are
known to succeed at compile-time. Such casts should not cause extra
computational overhead at runtime.

\section{\Xcd{instanceof}}\label{instanceOf}\index{instanceof@\xcd"instanceof"}

\Xten{} permits types to be used in an in instanceof expression
to determine whether an object is an instance of the given type:

\begin{grammar}
RelationalExpression \: RelationalExpression \xcd"instanceof" Type
\end{grammar}

In the above expression, \grammarrule{Type} is any type including
constrained types and value types. 
At run time, the result of this operator is
\xcd"true" if the \grammarrule{RelationalExpression} can be cast
to \grammarrule{Type} without a \xcd" ClassCastException" being
thrown.  Otherwise the result is \xcd"false".
This determination may involve checking
that the
constraint, if any, associated with the type is true for the
given expression.

\section{Rail constructors}

The rail constructor \xcdmath"{ a$_1$, $\dots$, a$_k$ }"
is creates an instance of \xcd"valrail" with distribution
\xcdmath"(0..$k$-1)->here" where the $i$th element is
\xcdmath"a$_{i+1}$".  The element type of the array (\xcd"T") is
bound to the least common ancestor of the types of the
\xcdmath"a$_i$".  Since arrays are subtypes of \xcd"point => T",
rail constructors can be passed into the \xcd"Array" and
\xcd"valarray" constructors as initializer functions.

\section{Point construction}\label{point-syntax}\index{point syntax}

\Xten{} specifies a simple syntax for the construction of points.

\begin{grammar}
ArgumentList \: Expression ( \xcd"," Expression )\star \\
Primary \: \xcd"Point" \xcd"(" ArgumentList \xcd")"
\end{grammar}

Each element in the argument list must be of type
\xcd"Int" or \xcd"Long".  The expression
\xcdmath"Point(a$_1$, $\dots$, a$_k$)" is treated as syntactic shorthand for
\begin{xtenmath}
new Point({ a$_1$, $\dots$, a$_k$ })
\end{xtenmath}

\section{Region construction}\label{region-syntax}\index{region syntax}

\Xten{} specifies a simple syntax for the construction of regions.

\begin{grammar}
Primary \: Expression \xcd".." Expression \\
Primary \: Expression \xcd"*" Expression \\
\end{grammar}

The expression \xcdmath"a$_1$..a$_2$"
is shorthand for the rectangular, rank-1 region
\begin{xten}
new Region(a$_1$, a$_2$)
\end{xten}
Each subexpression of \xcdmath"a$_i$" must be of type \xcd"Int".

The expression \xcdmath"r$_1$ * r$_2$" is shorthand for the
cross-product region formed by pairing each point in \xcdmath"r$_1$"
with every the point in \xcdmath"r$_2$".  Thus, \xcd"(1..2) * (3..4)"
is the region \xcd"(1,3), (1,4), (2,3), (2,4)".

\section{Exploded variable declarations}\label{exploded-syntax}\index{variable declarator!exploded}

XXX

\Xten{} permits a richer form of specification for variable
declarators in method arguments, local variables and loop variables
(the ``exploded'' or {\em destructuring} syntax).

\begin{grammar}
VariableDeclaratorId \:
           Identifier \xcd"(" IdentifierList \xcd")" \\
           \| \xcd"(" IdentifierList \xcd")" \\
\end{grammar}

In \XtenCurrVer{} the \grammarrule{VariableDeclaratorId} must be declared at
type \xcd{x10.lang.Point}. Intuitively, this syntax allows a
point to be ``destructured'' into its corresponding \xcd{int} 
indices in a pattern-matching style.
The $k$th identifier in the \grammarrule{
IdentifierList} is treated as a \xcd{final} variable of type \xcd{int}
that is initialized with the value of the $k$th index of the point. 
The second form of the syntax (Rule 82) permits the specification of only
the index variables.

Future versions of the language may allow destructuring syntax for all
value classes.

\paragraph{Example.}
The following example succeeds when executed.
\begin{xten}
public class Array1Exploded {
  public def select(p(i,j): Point, (k,l): Point): int {
      return i+k;
  }
  public def run(): boolean {
    d: Dist = new Region(1..10, 1..10) -> here;
    ia: Array[int] = new array[int](d);
    for (p(i,j): Point in new Region(1..10,1..10)) {
        if (ia(p) != 0) return false;
        ia(p) = i+j;
    }
    for (p(i,j): Point in d) {
      q1: Point = (i,j);
      if (i != q1(0)) return false;
      if (j != q1(1)) return false;
      if(ia(i,j) != i+j) return false;
      if(ia(i,j) != ia(p)) return false;
      if(ia(q1)  != ia(p)) return false;
    }
    if (! (4 == select([1,2],[3,4]))) return false;
    return true;
  }
        
  public static def main(args: array[String]) {
     b: boolean = (new Array1Exploded()).run();
     System.out.println("++++++ "
                        + (b ? "Test succeeded."
                             : "Test failed."));
     System.exit(b ? 0 : 1);
  }
}
\end{xten}



