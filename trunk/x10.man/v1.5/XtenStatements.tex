\chapter{Statements and expressions}\label{XtenStatements}\index{statements}

\Xten{} inherits all the standard statements of \Java{}, with the expected semantics:

\begin{verbatim}
EmptyStatement      LabeledStatement  
ExpressionStatement IfStatement
SwitchStatement     WhileDo
DoWhile             ForLoop           
BreakStatement      ContinueStatement  
ReturnStatement     ThrowStatement
TryStatement
\end{verbatim}

We focus on the new statements in \Xten. 

\section{Assignment}\index{assignment}\label{AssignmentStatement}

%It is often the case that an \Xten{} variable is assigned to only
%once. The user may declare such variables as \xcd"final". However,
%this is sometimes syntactically cumbersome.
%
%{}\Xten{} supports the syntax \xcd"l := r" for assignment to mutable
%variables.  The user is strongly enouraged to use this syntax to
%assign variables that are intended to be assigned to more than
%once. The \Xten{} compiler may issue a warning if it detects code 
%that uses \xcd"=" assignment statements on \xcd"mutable" variables.

{}\Xten{} supports assignment \xcd{l = r} to array variables. In this
case \xcd{r} must have the same distribution \xcd{D} as \xcd{l}. This
statement involves control communication between the sites hosting
\xcd{D}. Each site performs the assignment(s) of array components
locally. The assignment terminates when assignment has terminated at
all sites hosting \xcd{D}.

%% TODO: Sectional assignment??

\section{Point and region construction}\label{point-syntax}\index{[] syntax}
\Xten{} specifies a simple syntax for the construction of points and regions.
\begin{verbatim}
281   ArgumentList ::= Expression
282      | ArgumentList , Expression
512   Primary ::= [ ArgumentList ]
\end{verbatim}
Each element in the argument list must be either of type \xcd{int} or 
of type \xcd{region}. In the former case the expression 
\xcd{(a1,..., ak)} is treated as syntactic shorthand for
\begin{xten}
point.factory.point(a1,..., ak)
\end{xten}
\noindent and in the latter case as shorthand for
\begin{xten}
region.factory.region(a1,..., ak)
\end{xten}

\section{Exploded variable declarations}\label{exploded-syntax}\index{variable declarator!exploded}

\Xten{} permits a richer form of specification for variable
declarators in method arguments, local variables and loop variables
(the ``exploded'' or {\em destructuring} syntax).
\begin{verbatim}
81    VariableDeclaratorId ::= 
           identifier [ IdentifierList ]
82       | [ IdentifierList ]
\end{verbatim}
In \XtenCurrVer{} the \grammarrule{VariableDeclaratorId} must be declared at
type \xcd{x10.lang.point}. Intuitively, this syntax allows a
point to be ``destructured'' into its corresponding \xcd{int} 
indices in a pattern-matching style.
The $k$th identifier in the \grammarrule{
IdentifierList} is treated as a \xcd{final} variable of type \xcd{int}
that is initialized with the value of the $k$th index of the point. 
The second form of the syntax (Rule 82) permits the specification of only
the index variables.

Future versions of the language may allow destructuring syntax for all
value classes.

\paragraph{Example.}
The following example succeeds when executed.
\begin{xten}
public class Array1Exploded {
  public def select(p(i,j): point, (k,l): point): int {
      return i+k;
  }
  public def run(): boolean {
    d: distribution = [1:10, 1:10] -> here;
    ia: array[int] = new array[int](d);
    for (p(i,j): point in [1:10,1:10]) {
        if (ia(p) != 0) return false;
        ia(p) = i+j;
    }
    for (p(i,j): point in d) {
      q1: point = (i,j);
      if (i != q1(0)) return false;
      if (j != q1(1)) return false;
      if(ia(i,j) != i+j) return false;
      if(ia(i,j) != ia(p)) return false;
      if(ia(q1)  != ia(p)) return false;
    }
    if (! (4 == select([1,2],[3,4]))) return false;
    return true;
  }
        
  public static def main(args: array[String]) {
     b: boolean = (new Array1Exploded()).run();
     System.out.println("++++++ "
                        + (b ? "Test succeeded."
                             : "Test failed."));
     System.exit(b ? 0 : 1);
  }
}
\end{xten}

\input{XtenExpressions} \par  % empty



