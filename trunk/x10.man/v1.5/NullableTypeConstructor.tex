\section{The \Xcd{nullable} type constructor}
\label{NullableTypeConstructor}\index{nullable@{\tt nullable}}

\Xten{} supports the type constructor, \xcd"nullable[T]".  For any
type \xcd"T", the type \xcd"nullable[T]" contains all the values of
type \xcd"T", and a special \xcd"null" value, unless \xcd"T" already
contains \xcd"null". This value is designated by the literal
\xcd"null", which is special in that it has the type
\xcd"nullable T" for all types \xcd"T".\index{null@{\tt null}}

The visibility of the type \xcd"nullable[T]" is the same as the
visibility of \xcd"T". The members of the type \xcd"nullable[T]" are
the same as those of type \xcd"T". Note that because of this
\xcd"nullable" may not be regarded as a generic class; rather it is a
special type constructor.  In fact, \xcd"nullable[T]" can be
considered a mixin; it is a subtype of \xcd"T".

%% TODO: Visibility of nullable^T.

This type constructor can be used in any type expression used to
declare variables (e.g., local variable{s}, method parameter{s},
class field{s}, iterator parameter{s}, try/catch parameter{s} etc).
It may be applied to value types, reference types or aggregate types.
It may not be used in an \xcd"extends" clause or an \xcd"implements"
clause in a class or interface declaration. It may not be used 
in a \xcd"new" expression---a \xcd"new" expression is used only to construct 
non-null values.

If \xcd"T" is a value
(respectively, reference) type, then \xcd"nullable[T]" is defined to be
a value (respectively, reference) type.

An immediate consequence of the definition of \xcd"nullable" is that
for any type \xcd"T", the type \xcd"nullable[nullable[T]]" is equal to
the type \xcd"nullable[T]".

Any attempt to access a field or invoke a method on the value
\xcd"null" results in a \xcd"NullPointerException".

An expression \xcd"e" of type \xcd"nullable[T]" may be checked for nullity
using the expression \xcd"e==null". (It is a compile-time error for
the static type of \xcd"e" to not be \xcd"nullable[T]", for some \xcd"T".)

\paragraph{Conversions}
\xcd"null" can be passed as an argument to a method call whose
corresponding formal parameter is of type \xcd"nullable[T]" for some type
\xcd"T". (This is a widening reference conversion, per \cite[Sec
5.1.4]{jls2}.) Similarly it may be returned from a method call of
return type \xcd"nullable T" for some type \xcd"T".

For any value \xcd"v" of type \xcd"T", the class cast expression
\xcd"(nullable[T]) v" succeeds and specifies a value of type \xcd"nullable[T]".
This value may be seen as the ``boxed'' version of \xcd"v".

\Xten{} permits the widening reference conversion from any type \xcd"T"
to the type \xcd"nullable[T1]" if \xcd"T" can be widened to the
type \xcd"T1". Thus, the type \xcd"T" is a subtype of the type \xcd"nullable[T]".
%in accordance with the LiskovSubstitutionPrinciple.

Correspondingly, a value \xcd"e" of type \xcd"nullable[T]" can be cast to the
type \xcd"T", resulting in a \xcd"NullPointerException" if \xcd"e" is
\xcd"null" and \xcd"nullable[T]" is not equal to \xcd"T", and in the
corresponding value of type \xcd"T" otherwise.  If \xcd"T" is a value
type this may be seen as the ``unboxing'' operator.

The expression \xcd"(T) null" throws a \xcd"ClassCastException"
if \xcd"T" is not equal to \xcd"nullable[T]"; otherwise it
returns \xcd"null" at type \xcd"T". Thus it may be used to check
whether \xcd"T" = \xcd"nullable[T]".

\paragraph{Arrays of nullary type}
The nullary type constructor may also be used in (aggregate) instance
creation expressions (e.g., \xcd"new nullable[T](R)"). In such a
case \xcd"T" must designate a class. Each member of the array is
initialized to \xcd"null", unless an explicit array initializer is
specified.

\paragraph{Implementation notes}
A value of type \xcd"nullable[T]" may be implemented by boxing a value of
type \xcd"T" unless the value is already boxed. The literal \xcd"null"
may be represented as the unique null reference.

\paragraph{\Java{} compatibility}

\java{} provides a somewhat different treatment of \xcd"null".  A
class definition extends a nullable type to produce a nullable type,
whereas primitive types such as \xcd"int" are not nullable---the
programmer has to explicitly use a boxed version of \xcd"int",
\xcd"Integer", to get the effect of \xcd"nullable int". Wherever \Java{} uses a
variable at reference type \xcd"T", and at runtime the variable may
carry the value \xcd"null", the \Xten{} programmer should declare the
variable at type \xcd"nullable[T]". However, there are many situations
in \java{} in which a variable at reference type \xcd"T" can be
statically determined to not carry null as a value. Such variables
should be declared at type \xcd"T" in \Xten{}.

\paragraph{Design rationale}

The need for \xcd"nullable" arose because \Xten{} has value types and
reference types, and arguably the ability to add a \xcd"null" value to
a type is orthogonal to whether the type is a value type or a
reference type. This argues for the notion of nullability as a type
constructor.

The key question that remains is whether it should be possible to
define ``towers'', that is, define the type constructor in such a way
that \xcd"nullable[nullable[T]]" is distinct from \xcd"nullable[T]". Here
one would think of nullable as a disjoint sum type constructor that
adds a value \xcd"null" to the interpretation of its argument type
even if it already has that value. Thus \xcd"nullable[nullable[T]]" is
distinct from \xcd"nullable T" because it has one more \xcd"null"
value. Explicit injection and projection functions of signature
\xcd"T => nullable[T]" and \xcd"nullable[T] => T", respectively,
would need to be provided.

The designers of \Xten{} felt that while such a definition might be
mathematically tenable, and programmatically interesting, it was
likely to be too confusing for programmers. More importantly, it would
be a deviation from current practice that is not forced by the core
focus of \Xten{} (concurrency and distribution). Hence the decision to
collapse the tower.  As discussed below, this results in no loss of
expressiveness because towers can be obtained through explicit
programming.

\paragraph{Examples}

Consider the following class:

\begin{xten}
final value Box { 
  public def this(v: nullable[Object]) { this.datum = v; }
  public var datum: nullable[Object];
}
\end{xten}

Now one may use a variable \xcd"x" at type \xcd"nullable[Box]" to
distinguish between the \xcd"null" at type \xcd"nullable[Box]" and at type
\xcd"nullable[Object]". In the first case the value
of \xcd"x" will be \xcd"null", in the second case the value of \xcd"x.datum"
will be \xcd"null".

Such a type may be used to define efficient code for memoization:

\begin{xten}
abstract class Memo {
  var values: Array[nullable[Box]];
  def this(n: int) {
    // initialized to all nulls
    values = new nullable[Box](n); 
  }
  abstract def compute(key: int): nullable[Object];
  def lookup(key: int) nullable[Object] = { 
   if (values(key) != null) 
     return values(key).datum;
   val v = compute(key);
   values(key) = new Box(v);
   return v;
  }
}
\end{xten}


% C#: http://blogs.msdn.com/ericgu/archive/2004/05/27/143221.aspx
% Nice: http://nice.sourceforge.net/cgi-bin/twiki/view/Doc/OptionTypes

 


