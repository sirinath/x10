\chapter{API}\label{XtenAPI}

The \Xten{} implementation is required to implement a number of
classes in the package \xcd"x10.lang".

\section{Primitive types}

\begin{xten}
package x10.lang;

public class Object(location: Place) { }
public value Value extends Object { }

public value Boolean extends Value { }

public value Number  extends Value { }

public value Byte    extends Number { }
public value Short   extends Number { }
public value Char    extends Number { }
public value Int     extends Number { }
public value Long    extends Number { }
public value Float   extends Number { }
public value Double  extends Number { }

// Type aliases
public type boolean = Boolean;
public type byte = Byte;
public type short = Short;
public type char = Char;
public type int = Int;
public type long = Long;
public type float = Float;
public type double = Double;

public type Int8    = Byte;
public type Int16   = Short;
public type Int32   = Int;
public type Int64   = Long;
public type Float32 = Float;
public type Float64 = Double;

public type Boolean(x: Boolean) = Boolean{self == x};
public type Byte   (x: Byte)    = Byte   {self == x};
public type Short  (x: Short)   = Short  {self == x};
public type Char   (x: Char)    = Char   {self == x};
public type Int    (x: Int)     = Int    {self == x};
public type Long   (x: Long)    = Long   {self == x};
public type Float  (x: Float)   = Float  {self == x};
public type Double (x: Double)  = Double {self == x};

public type Byte  (lo: Byte,   hi: Byte)  
          = Byte  {lo <= self, self <= hi};
public type Short (lo: Short,  hi: Short) 
          = Short {lo <= self, self <= hi};
public type Char  (lo: Char,   hi: Char)  
          = Char  {lo <= self, self <= hi};
public type Int   (lo: Int,    hi: Int)   
          = Int   {lo <= self, self <= hi};
public type Long  (lo: Long,   hi: Long)  
          = Long  {lo <= self, self <= hi};
public type Float (lo: Float,  hi: Float) 
          = Float {lo <= self, self <= hi};
public type Double(lo: Double, hi: Double)
          = Double{lo <= self, self <= hi};

public value Complex(x: Double, y: Double) { }
public type Complex(x: Complex) = Complex{self == x};
\end{xten}

\section{String}

\begin{xten}
public value String  {
    // methods of java.lang.String
}

public type String (x: String) = String {self == x};

public type string = String;

public class StringBuffer {
    // methods of java.lang.StringBuilder
}
\end{xten}

\section{Points, regions, distributions}

\begin{xten}
public value Point(rank: Int{self >= 0}) {
}

public value Region(rank: Int{self >= 0},
                    zeroBased: Boolean,
                    rect: Boolean) {
}

public value Dist(region: Region, onePlace: Box[Place]) extends ValArray[Place](region) {
    property rank = region.rank;
    property zeroBased = region.zeroBased;
    property rect = region.rect;
    property rail = zeroBased && rect && onePlace != null;
}
\end{xten}

\section{Clocks}

\begin{xten}
public value Clock { }
\end{xten}

\section{Places}

\begin{xten}
public value Place { }
\end{xten}

\section{Arrays}

\begin{xten}
public class Array[T](dist: Dist) {
    property region = dist.region;
    property rank = region.rank;
    property zeroBased = region.zeroBased;
    property rail = region.rail;
    property rect = region.rect;
    property onePlace = dist.onePlace;

    def this[T](dist: Dist, init: Point{self in dist.region} => T);
    def this[T](n: Int, init: Point{self in dist.region} => T) = {
        this[T](0..n-1 -> here, init);
    }

    def get(p: Point{self in region}): T;
    def set(p: Point{self in region}, v: T): T;
}
\end{xten}

\begin{xten}
public class ValArray[T](region: Region)
    implements Fun_0_1[Point{self in region},T] {

    property rank = region.rank;
    property zeroBased = region.zeroBased;
    property rail = region.rail;
    property rect = region.rect;

    def this[T](dist: Dist);

    def get(p: Point{self in region}): T;

    def add(a: Array[T](region)){T has add: (T,T) => T};
    def sub(a: Array[T](region)){T has sub: (T,T) => T};
    ...
}
\end{xten}

  The type \xcd"Array[double]{rail}" is the Java type \xcd"double[]".
  The type \xcd"Array[Array[double]{rail}]{rail}" is the Java type \xcd"double[][]".

  The type \xcd"Array[double]{rank==N}" is the type of all N-dimensional arrays of
  \xcd"double"s.

  The type \xcd"Array[double]{rank==N&&onePlace==here}" is the
  type of all \xcd"N"-dimensional
  arrays of \xcd"double"s that are local (mapped to one place).  

\section{Boxed types}

\begin{xten}
public class Box[T](value: T) { }
\end{xten}

\section{Function types}

The library contains the following family of interfaces.

\begin{xtenmath}
public interface Fun_$k$_$n$[X$_1$, $\dots$, X$_k$] {
    def __apply__(x$_1$: T$_1$, $\dots$, x$_n$: T$_n$): T;
}
\end{xtenmath}

A closure call \xcd"e1(e2)" is equivalent to 
the method call \xcd"e1.__apply__(e2)".
