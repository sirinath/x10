\chapter{Variables}\label{XtenVariables}\index{variables}

A variable is a storage location.  \Xten{} supports seven kinds of
variables: constant {\em class variables} (static variables), {\em
  instance variables} (the instance fields of a class), {\em array
  components}, {\em method parameters}, {\em constructor parameters},
{\em exception-handler parameters} and {\em local variables}.

Variables are declared thus:

\begin{grammar}
VarDeclaratorWithType \: VarDeclaratorId ResultType \\
VarDeclarator \: VarDeclaratorId ResultType\opt \\
VarDeclaratorId \: Annotation\star Identifier \\
              \| Annotation\star Identifier \xcd"(" VarDeclaratorList \xcd")" \\
              \| Annotation\star \xcd"(" VarDeclaratorList \xcd")" \\
VarDeclaratorList \: VarDeclarator ( \xcd"," VarDeclarator )\star \\
ResultType \: \xcd":" Type \\
\end{grammar}

\label{exploded-syntax}
\label{VariableDeclarations}
\index{variable declaration}

All variables are initialized with a value and cannot be observed without
a value. 

Variables whose value may not be changed after initialization
are said to be  {\em immutable}, or {\em constants} (\Sref{FinalVariables}).
The programmer indicates that a variable is immutable by declaring
it with the \xcd"val" keyword rather than the \xcd"var" keyword.
Variables that are annotated neither \xcd"val" nor \xcd"var"
are considered immutable.

A variable of a reference data type \xcd"T" where \xcd"T" is the name
of a reference class (possibly with type arguments) always holds a
reference to an instance of the class \xcd"T" or a class that is a
subclass of \xcd"T", or a \xcd"null" reference.



A variable of a rail type \xcd"Rail[T]" has
as many variables as the size of the rail.
A variable of a rail type \xcd"ValRail[T]" has
as many variables as the size of the rail.
Each of these variables is immutable and has the type \xcd"T".

%XXX
%A variable of a nullable (reference or value) data type \xcd"nullable[T]"
%always holds either the value (named by) \xcd"null" or a value of
%type \xcd"T" (these cases are not mutually exclusive).

A variable of an interface type \xcd"I" always holds either a
reference to a reference class implementing \xcd"I" (including possibly
a boxed struct that implements \xcd"I"), or a \xcd"null"
reference.

A variable of a struct data type \xcd"T"  always takes as much
space as necessary to represent an instance of \xcd"T". That is
structs are implemented ``inline'' or in an unboxed fashion.

A variable of a function type always holds a reference to enough
memory to represent the constants accessed within the body of the
function.

\section{Immutable variables}
\label{FinalVariables}
\index{variable!immutable}
\index{immutable variable}
An immutable variable satisfies two conditions: 
\begin{itemize}
\item it can be assigned to at most once, 
\item it must be assigned to before use. 
\end{itemize}

\Xten{} follows \java{} language rules in this respect \cite[\S
4.5.4,8.3.1.2,16]{jls2}. Briefly, the compiler must undertake a
specific analysis to statically guarantee the two properties above.

Immutable local variables and fields are defined by the \xcd"val"
keyword.  Elements of value arrays are also immutable.

\oldtodo{Check if this analysis needs to be revisited.}

\section{Initial values of variables}
\label{NullaryConstructor}\index{nullary constructor}

Every variable declared to be a given type must always contain a value of that type.

Every class variable must be initialized before it is read, through
the execution of an explicit initializer or a static block. Every
instance variable must be initialized before it is read, through the
execution of an explicit initializer or a constructor.
Mutable instance variables of class type are initialized to 
to \xcd"null".
Mutable instance variables of struct type are 
assumed to have an initializer that sets the value to the
result of invoking the nullary constructor on the class. 
An initializer is required if the default initial value is not
assignable to the variable's type.

Each method and constructor parameter is initialized to the
corresponding argument value provided by the invoker of the method. An
exception-handling parameter is initialized to the object thrown by
the exception. A local variable must be explicitly given a value by
initialization or assignment, in a way that the compiler can verify
using the rules for definite assignment \cite[\S~16]{jls2}.

\section{Destructuring syntax}
\index{variable declarator!destructuring}
\Xten{} permits a \emph{destructuring} syntax for local variable
declarations and formal parameters.
At present, \XtenCurrVer{} supports this feature only for
variables of
type \xcd"Point"; future versions of the language may support 
general pattern matching.
Intuitively, this syntax allows a
point to be ``destructured'' into its corresponding \xcd"Int" 
indices in a pattern-matching style.
The $k$th declarator in a \xcd"Point"
\grammarrule{VarDeclaratorList}
is treated as a variable of type \xcd"Int"
that is initialized with the value of the $k$th index of the point. 
The second form of the syntax permits the specification of only
the index variables.

For example, the following code binds the \xcd"Int" variable \xcd"i" to
\xcd"0" and \xcd"j" to \xcd"1", and the variable \xcd"p" to the
point object.
\begin{xten}
p(i,j): Point = new Point(0,1);
\end{xten}

\section{Formal parameters}
Formal parameters are always declared with a type.
The variable name can be omitted if it is not to be used in the
scope of the declaration.

\begin{grammar}
Formal
        \: FormalModifier\star \xcd"var" VarDeclaratorWithType \\
        \| FormalModifier\star \xcd"val" VarDeclaratorWithType \\
        \| FormalModifier\star VarDeclaratorWithType \\
        \| Type \\
FormalModifier \: Annotation \\
              \| \xcd"shared" \\
\end{grammar}

\section{Local variables}
Local variable declarations may have optional
initializer expressions.  The initializer must be a subtype of
the declared type of the variable.  If the variable is immutable
(\xcd"val")
the type may be omitted and
inferred from the initializer type (\Sref{TypeInference}).

\begin{grammar}
LocalDeclaration
        \: LocalModifier\star \xcd"var" LocalDeclaratorsWithType \\&& ( \xcd"," LocalDeclaratorsWithType )\star \\
        \| LocalModifier\star \xcd"val" LocalDeclarators \\&& ( \xcd"," LocalDeclarators )\star \\
        \| LocalModifier\star LocalDeclaratorsWithType \\&& ( \xcd"," LocalDeclaratorsWithType )\star \\
LocalDeclarators
        \: LocalDeclaratorsWithType \\
        \: LocalDeclaratorWithInit \\
LocalDeclaratorWithInit
        \: VarDeclarator Init \\
LocalDeclaratorsWithType
        \: VarDeclaratorId
                ( \xcd"," VarDeclaratorId )\star ResultType \\
LocalModifier \: Annotation \\
              \| \xcd"shared" \\
Init \: \xcd"=" Expression \\
\end{grammar}

\section{Fields}
Fields are declared either \xcd"var" (mutable, non-static),
\xcd"val" (immutable, non-static), or \xcd"const" (immutable, static);
the default is \xcd"val".
Field declarations may have optional
initializer expressions.  The initializer must be a subtype of
the declared type of the variable.
For \xcd"var" fields,
if the initializer is omitted, the constructor must initialize
the field, or else the field is initialized with
\xcd"null" if a reference type, \xcd"0" if an \xcd"Int", \xcd"0L"
if a \xcd"Long",
\xcd"0.0F" if a \xcd"Float", \xcd"0.0" if a \xcd"Double", or
\xcd"false" if a \xcd"Boolean".  It is a static error if the
default value is not a member of the type (e.g., it is a static
error to elide the initializer for \xcd"Int{self==1}").

If the variable is immutable,
the type may be omitted and
inferred from the initializer type (\Sref{TypeInference}).
Mutable fields must be declared with a type.

\begin{grammar}
FieldDeclaration
        \: FieldModifier\star \xcd"var" FieldDeclaratorsWithType \\&& ( \xcd"," FieldDeclaratorsWithType )\star \\
        \| FieldModifier\star \xcd"const" FieldDeclarators \\&& ( \xcd"," FieldDeclarators )\star \\
        \| FieldModifier\star \xcd"val" FieldDeclarators \\&& ( \xcd"," FieldDeclarators )\star \\
        \| FieldModifier\star FieldDeclaratorsWithType \\&& ( \xcd"," FieldDeclaratorsWithType )\star \\
FieldDeclarators
        \: FieldDeclaratorsWithType \\
        \: FieldDeclaratorWithInit \\
FieldDeclaratorId
        \: Identifier  \\
FieldDeclaratorWithInit
        \: FieldDeclaratorId Init \\
        \| FieldDeclaratorId ResultType Init \\
FieldDeclaratorsWithType
        \: FieldDeclaratorId ( \xcd"," FieldDeclaratorId )\star ResultType \\
FieldModifier \: Annotation \\
                \| \xcd"static" \\
\end{grammar}

\section{Properties}
Property declarations are always declared with a type and are
always immutable (either explicitly declared \xcd"val" or implicitly by default).

\begin{grammar}
Property
        \: PropertyModifier\star \xcd"val" Identifier ResultType \\
        \| PropertyModifier\star Identifier ResultType \\
PropertyModifier \: Annotation \\
\end{grammar}
