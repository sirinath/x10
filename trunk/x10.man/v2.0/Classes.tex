\chapter{Classes}
\label{XtenClasses}\index{class}

\section{Principles of X10 Objects}\label{XtenObjects}\index{Object}

\subsection{Basic Design}
An object is an instance of a scalar class or an array type.  It is
created by using an allocation expression
(\Sref{ClassCreation}) or an array creation
(\Sref{ArrayInitializer}) expression, such as an array
initializer. 

All classes subclass from \xcd"x10.lang.Object".
This class has one property \xcd"home" of type
\xcd"x10.lang.Place". \index{place.home} Thus all objects in \Xten{}
are located (have a place). 

In \XtenCurrVer{} an object stays resident at the place at
which it was created for its entire lifetime. However, the
programmer may designate certain immutable field of an object
as \Xcd{global}. The value of these fields is accessible 
at every place the object can be referenced.

{}\Xten{} has no operation to dispose of a reference.  Instead, the
collection of all objects across all places is globally garbage
collected.

Unlike \java{},
{}\Xten{} objects do not have any synchronization information (e.g.,
a lock) associated with them. 
Instead, programmers should use atomic blocks
(\Sref{AtomicBlocks}) for mutual exclusion and clocks
(\Sref{XtenClocks}) for sequencing multiple parallel operations.

An object may have many references, stored in fields of
objects or components of arrays. A change to an object made through
one reference is visible through another reference. 

Note that the creation of a remote async activity
(\Sref{AsyncActivity}) \xcd"A" at \xcd"P" may cause the automatic creation of
references to remote objects at \xcd"P". (A reference to a remote
object is called a {\em remote object reference}, to a local object a
{\em local object reference}.)  For instance \xcd"A" may be created
with a reference to an object at \xcd"P" held in a variable referenced
by the statement in \xcd"A".  Similarly the return of a value by a
\xcd"future" may cause the automatic creation of a remote object
reference, incurring some communication cost.  An {}\Xten{}
implementation should try to ensure that the creation of a second or
subsequent reference to the same remote object at a given place does
not incur any (additional) communication cost.

A reference to an object carries with it the values of  \Xcd{global} \xcd`val`
fields
of the object. The implementation should try to ensure that the cost
of communicating the values of \xcd`val` fields of an object from the
place where it is hosted to any other place is not incurred more than
once for each target place.

{}\Xten{} does not have an operation (such as Pascal's ``dereference''
operation) which returns an object given a reference to the
object. Rather, most operations on object references are transparently
performed on the bound object, as indicated below. The operations on
objects and object references include:
\begin{itemize}

{}\item Field access (\Sref{FieldAccess}). An activity holding a
reference to an object may perform this operation only if the
object is local.  (By contrast, an activity holding a reference to a struct
may perform this operation regardless of the location of the struct, 
since structs can be copied freely from place to place.).  The
implementation should try to ensure that the cost of copying the field
from the place where the object was created to the referencing place
will be incurred at most once per referencing place, according to the
rule for \xcd`val` fields discussed above.

{}\item Method invocation (\Sref{MethodInvocation}).  
\label{GlobalAnnotation}
A method may be
marked \Xcd{global}. A \Xcd{global} method may be invoked at any
place. It may access only the global fields of the object. The
mutable fields of an object may be accessed only by activities
operating in its home.  Any activity may use an \Xcd{at} statement
to place-shift to the place of the object. Methods may also be
marked \Xcd{pinned}, \Xcd{nonblocking}, \Xcd{sequential},
\Xcd{safe}, and \Xcd{pure} (\Sref{MethodQualifier})..

{}\item Casting (\Sref{ClassCast}).  An activity can perform this
operation on local or remote objects, and should not incur
communication costs (to bring over type information) more than once
per place.

{}\item \xcd"instanceof" operator (\Sref{instanceOf}).  An activity
can perform this operation on local or remote objects, and should not
incur communication costs (to bring over type information) more than
once per place.

\item The equality operators \xcd"==" and \xcd"!="
(\Sref{StableEquality}). On creation, each object is associated with a globally
unique identifier (guid). Two object references are \xcd"==" iff they refer to objects
with the  same guid.

\end{itemize}

\Xten{} has a rather simple \emph{distributed object model}. 

The state of an object is partitioned into \emph{global} state (a
programmer defined subset of \Xcd{val} fields, \Sref{GlobalField}) and
\emph{non-global} state.

 \begin{itemize}
\item Field definitions are marked with the qualifier \Xcd{global} if
  they are intended to be included in the global state.
\item If the \Xcd{global} qualifier is omitted, the field is
  considered non-global.
\item Properties and static fields are implicitly marked \Xcd{global}.
\item \Xcd{var} fields cannot be marked \Xcd{global}.
%\item  Fields marked \Xcd{global} cannot be overriden by fields not marked \Xcd{global}.
\end{itemize}
 
Similarly, the methods of an object may be qualified as
\Xcd{global}(\Sref{GlobalMethod}) ; if they are not global they are
said to be \emph{non-global}. 
Global methods cannot be overridden by non-global methods.

Consider the execution of an \Xcd{at (P) S} statement at a place
\Xcd{Q} different from \Xcd{P}. Suppose \Xcd{x} is an in-scope
immutable local variable and contains a reference to an object \Xcd{o}
created at \Xcd{Q}. Then within \Xcd{S}, \Xcd{x} is said to be a
\emph{remote reference} to \Xcd{o}. References to \Xcd{o} from place
\Xcd{Q} are said to be \emph{local references}. \Xten{} permits
\Xcd{global} fields to be read and \Xcd{global} methods to be invoked
through a remote reference.

Like local references, remote references are first-class entities:
they may be passed as arguments to methods, returned from methods,
stored in fields of objects.

Remote references may also be compared for equality (\Xcd{==}). Two
remote reference are equal if they are references to the same
object. Equality is guaranteed to be a constant-time operation and not
involve any communication.

When a remote reference to an object \Xcd{o} located at place \Xcd{P} is
transmitted to \Xcd{P} it automatically becomes a local reference to
\Xcd{o}. Therefore the situation in which a local reference can be compared
to a remote reference simply cannot arise.

The \Xten{} compiler ensures that non-global methods on \Xcd{o} can
only be invoked in a place where \Xcd{here== o.home()}, i.e. the place
where \Xcd{o} was created.

\paragraph{Implementation notes}
Remote references to an object \Xcd{o} are intended to be implemented
by serializing the global state of \Xcd{o} across the network,
together with a globally unique id (guid). The data is deserialized at
the receiver to create an implementation-level entity that is the
remote reference. There is no requirement that the implementation
intern such entities; however the implementation must correctly
implement equality (see below).

There is no requirement that a remote reference use only as much space as a local reference.

  
\paragraph{Local execution}
 The semantics of \Xcd{atomic} and \Xcd{when} constructs requires that their
 bodies do not execute any \Xcd{at} operations, implicitly or
 explicitly. Hence the compiler must establish that if a non-global method
\Xcd{m} is being invoked on a reference \Xcd{o} in the body of such a construct,
 then \Xcd{o} is a local reference. This can be done using place types (\Sref{PlaceType}).

  
\subsection{Examples}
Assume the class declarations. 

\begin{xten}
class C { } 
class D {
   var f:C=null;
}
\end{xten}

%%TODO--Add a variant of the following code to the test suite
Then the following code behaves as stated.
%~~gen
% package objects.dwiffle.and.a.half.a.moon;
% class C { } 
% class D {
%    var f:C=null;
% }
% class Fudders {
% def plongent(P:Place, Q:Place) throws Exception {
%~~vis
\begin{xten}

val x = new C(); 
// C object o1 created, reference stored in x. 
at (P) { 
      // In the body x contains a remote reference to o
      val d = new D();
      d.f  = x; // remote reference stored in d.f
      Console.OUT.println(d.f == x);        // must print true
      Console.OUT.println(x == x);          // must print true
      at (Q) { 
         // x continues to be a remote reference to o1.
         at (P) {  
             Console.OUT.println(d.f == x);   // must print true
             Console.OUT.println(x == x);   // must print true
         }
      }
}
\end{xten}
%~~siv
%}}
%~~neg
  
%%TODO--Add a variant of the following code to the test suite
%%TODO--rewrite this
Here is another example.
%~~gen
% package objects.armor.of.eyeballs;
% class C { } 
% class D {
%    var f:C=null;
% }
% class Fudders {
% def plongent(P:Place, Q:Place) throws Exception {
%~~vis
\begin{xten}
val x = new C(); 
// C object o created, reference stored in x. 
// The type inferred for x is C!
at (P) { 
    val x1 = x; 
    // The type inferred for x1 is C, not C!;
    // the change is due to the place shift 'at(P)'
  at (x.home) {
        // x is now bound to o through a local reference. So is x1.
    Console.OUT.println(x1==x); // Must print true.
      // non-global methods can be invoked on x or x1 and will 
      // execute locally on o
      // type of both x and x1 is C!.
  }
}
\end{xten}
%~~siv
%}}
%~~neg
 
\subsection{Programming Methodology}

A programmer wishing to ensure that a \Xcd{val} field is not serialized when
the containing object is serialized (e.g. because it contains a large
cache which makes sense only in the current place) must ensure the
field is \emph{not} marked global.




The {\em class declaration} has a list of type \params, properties, a
constraint (the {\em class invariant}), a single superclass, one or
more interfaces, and a class body containing the the definition of
fields, properties, methods, and member types.  Each such declaration introduces a
class type (\Sref{ReferenceTypes}).


\begin{grammar}
NormalClassDeclaration \:
      ClassModifiers\opt \xcd"class" Identifier  \\
   && TypeParameterList\opt PropertyList\opt Guard\opt \\
   && Super\opt Interfaces\opt ClassBody \\
\\
TypeParameterList     \:  \xcd"[" TypeParameters \xcd"]" \\
TypeParameters        \:  TypeParameter ( \xcd"," TypeParameter )\star \\
TypeParameter         \:  Variance\opt Annotation\star Identifier     \\
Variance \: \xcd"+" \\
         && \xcd"-" \\
\\
PropertyList     \:  \xcd"(" Properties \xcd")" \\
Properties       \:  Property ( \xcd"," Property )\star \\
Property         \:  Annotation\star \xcd"val"\opt Identifier \xcd":" Type \\
\\
Super \: \xcd"extends" ClassType \\
Interfaces \: \xcd"implements" InterfaceType ( \xcd"," InterfaceType)\star \\
\\
ClassBody \: ClassMember\star \\
ClassMember \: ClassDeclaration \\
            \| InterfaceDeclaration \\
            \| FieldDeclaration \\
            \| MethodDeclaration \\
            \| ConstructorDeclaration \\
\end{grammar}

A type parameter declaration is given by an optional variance tag and an identifier.
A type parameter must be bound to a concrete type when an instance of the class is created.
 
\subsection{Properties}
\label{PropertiesInClasses}

A property has a name and a type.   Properties
are accessible in the same way as \xcd"public" \xcd"val"
fields.

\begin{staticrule*}
It is a compile-time error for a class
defining a property \xcd"x: T" to have an ancestor class that defines
a property with the name \xcd"x".  
\end{staticrule*}

Each class \xcd"C" defining a property \xcd"x: T" implicitly has a field

\begin{xten}
public val x : T;
\end{xten} 

\noindent and a getter method

\begin{xten}
public final def x()=x;
\end{xten}

\noindent Each interface \xcd"I" defining a property \xcd"x: T"
implicitly has a getter method

\begin{xten}
public def x(): T;
\end{xten}

\begin{staticrule*}
It is a compile-time error for a class or
interface defining a property \xcd"x :T" to have an existing method with
the signature \xcd"x(): T".
\end{staticrule*}

Properties are used to build dependent types from classes, as
described in \Sref{DepType:DepType}.

Properties are initialized by the invocation of a special \Xcd{property} call in each constructor
of the class:
\begin{xten}
property(e1,..., en);
\end{xten}
The number and type of arguments to the \Xcd{property} call must match the number
and type of properties in the class declaration, in left to right lexical order. Each constructor is required to initialize its properties before normal termination.
\index{property!call}
\index{property!initialization}
\label{PropertyCall}

\label{ClassGuard}

The \grammarrule{Guard} in a class or interface declaration specifies an
explicit condition on the properties of the type, and is discussed further
in \Sref{DepType:ClassGuard}.

\begin{staticrule*}
     Every constructor for a class defining
   properties \xcdmath"x$_1$: T$_1$, $\ldots$, x$_n$: T$_n$" must ensure that each of the fields
   corresponding to the properties is definitely initialized
   (cf. requirement on initialization of final fields in Java) before the
   constructor returns.
\end{staticrule*}

Type \params{} are used to define generic classes and
interfaces, as described in \Sref{Generics}.

Classes are structured in a single-inheritance code
hierarchy, may implement multiple interfaces, may have static and
instance fields, may have static and instance methods, may have
constructors, may have static and instance initializers, may have
static and instance inner classes and interfaces. \Xten{} does not
permit mutable static state.

Method signatures may specify checked exceptions. Method definitions
may be overridden by subclasses; the overriding definition may have a
declared return type that is a subclass of the return type of the
definition being overridden. Multiple methods with the same name but
different signatures may be provided on a class (ad hoc
polymorphism). The \Xcd{public}/\Xcd{private}/\Xcd{protected}/default-protected access
modification framework may be used.


\oldtodo{Figure out class modifiers. Figure out which new ones need to be added to support IEEE FP.}

\index{class}\label{ReferenceClasses}

Class declarations may
be used to construct class types (\Sref{ReferenceTypes}). Classes may
have mutable fields. Instances of a class are always created in a
fixed place and in \XtenCurrVer{} stay there for the lifetime of the
object.  Variables declared at a class type always store a reference
to the object, regardless of whether the object is local or remote.


\section{Type invariants}\label{DepType:ClassGuard}
\index{type invariants}
\index{class invariants}
\index{guards}

There is a general recipe for constructing a list of parameters or
properties \xcdmath"x$_1$: T$_1${c$_1$}, $\dots$, x$_k$: T$_k${c$_k$}" that must satisfy a given
(satisfiable) constraint \xcd"c". 

\begin{xtenmath}
class Foo(x$_1$: T1{x$_2$: T$_2$; $\dots$; x$_k$: T$_k$; c},
          x$_2$: T2{x$_3$: T$_3$; $\dots$; x$_k$: T$_k$; c},
          $\dots$
          x$_k$: T$_k${c}) {
  $\dots$
}
\end{xtenmath}

The first type \xcdmath"x$_1$: T$_1${x$_2$: T$_2$; $\dots$; x$_k$: T$_k$; c}" is consistent iff
\xcdmath"$\exists$x$_1$: T$_1$, x$_2$: T$_2$, $\dots$, x$_k$: T$_k$. c" is consistent. The second is
consistent iff
\begin{xtenmath}
$\forall$x$_1$: T$_1${x$_2$: T$_2$; $\dots$; x$_k$: T$_k$; c}
$\exists$x$_2$: T$_2$. $\exists$x$_3$: T$_3$, $\dots$, x$_k$: T$_k$. c
\end{xtenmath}
\noindent But this is always true. Similarly for the conditions for the other
properties.

Thus logically every satisfiable constraint \xcd"c" on a list of parameters
\xcdmath"x$_1$", \dots, \xcdmath"x$_k$"
can be expressed using the dependent types of 
\xcdmath"x$_i$", provided
that the constraint language is rich enough to permit existential
quantifiers.

Nevertheless we will find it convenient to permit the programmer to
explicitly specify a depclause after the list of properties, thus:
\begin{xten}
class Point(i: Int, j: Int) { ... }
class Line(start: Point, end: Point){end != start} { ... }
class Triangle (a: Line, b: Line, c: Line)
   {a.end == b.start,  b.end == c.start,
    c.end == a.start} { ... }
\end{xten}

Consider the definition of the class \xcd"Line". This may be thought of as
saying: the class \xcd"Line" has two fields, \xcd"start: Point" and
\xcd"end: Point".
Further, every instance of \xcd"Line" must satisfy the constraint that
\xcd"end != start". Similarly for the other class definitions. 

In the general case, the production for \grammarrule{NormalClassDeclaration}
specifies that the list of properties may be followed by a
\grammarrule{Guard}.

\begin{grammar}
NormalClassDeclaration \:
      ClassModifiers\opt \xcd"class" Identifier  \\
   && TypeParameterList\opt PropertyList\opt Guard\opt \\
   && Extends\opt Interfaces\opt ClassBody \\
\\
NormalInterfaceDeclaration \:
      InterfaceModifiers\opt \xcd"interface" Identifier  \\
   && TypeParameterList\opt PropertyList\opt Guard\opt \\
   && ExtendsInterfaces\opt InterfaceBody \\
\end{grammar}

All the properties in the list, together with inherited properties,
may appear in the \grammarrule{Guard}. A guard \xcd"c" with
property list \xcdmath"x$_1$: T$_1$, $\dots$, x$_n$: T$_n$"
for a class \xcd"C" is said to be consistent if each of the \xcdmath"T$_i$" are
consistent and the constraint
\begin{xtenmath}
$\exists$x$_1$: T$_1$, $\dots$, x$_n$: T$_n$, self: C. c
\end{xtenmath}
\noindent is valid (always true).

\label{DepType:TypeInvariant}
\index{Class invariant}
\label{DepType:ClassGuardDef}

The guard is an invariant on all instances of the class or interface.

With every defined class or interface \xcd"T" we associate a {\em type
invariant} $\mathit{inv}($\xcd"T"$)$ as follows. The type
invariant associated with \xcd"x10.lang.Object" is 
\xcd"true".

The type invariant associated with any interface \xcd"I" that extends
interfaces \xcdmath"I$_1$, $\dots$, I$_k$" and defines properties
\xcdmath"x$_1$: P$_1$, $\dots$, x$_n$: P$_n$" and
specifies a guard \xcd"c" is given by:

\begin{xtenmath}
$\mathit{inv}$(I$_1$), $\dots$, $\mathit{inv}$(I$_k$),
    self.x$_1$: P$_1$,  $\dots$,  self.x$_n$: P$_n$, c  
\end{xtenmath}

Similarly the type invariant associated with any class \xcd"C" that
implements interfaces \xcdmath"I$_1$, $\dots$, I$_k$",
extends class \xcd"D" and defines properties
\xcdmath"x$_1$: P$_1$, $\dots$, x$_n$: P$_n$" and
specifies a guard \xcd"c" is
given by:
\begin{xtenmath}
$\mathit{inv}$(D), $\mathit{inv}$(I$_1$),  $\dots$, $\mathit{inv}$(I$_k$),
    self.x$_1$: P$_1$,  $\dots$, self.x$_n$: P$_n$,  c  
\end{xtenmath}

It is required that the type invariant associated with a class entail
the type invariants of each interface that it implements.

It is guaranteed that for any variable \xcd"v" of
type \xcd"T{c}" (where \xcd"T" is an interface name or a class name) the only
objects \xcd"o" that may be stored in \xcd"v" are such that \xcd"o" satisfies
$\mathit{inv}(\mbox{\xcd"T"}[\mbox{\xcd"o"}/\mbox{\xcd"this"}])
\wedge \mbox{\xcd"c"}[\mbox{\xcd"o"}/\mbox{\xcd"self"}]$.

\section{\Xcd{implements} and \Xcd{extends} clauses}\label{DepType:Implements}
\label{DepType:Extends}
\index{type-checking!implements clause}
\index{type-checking!extends clause}
\index{implements clause}
\index{extends  clause}
Consider a class definition
\begin{xtenmath}
$\mbox{\emph{ClassModifiers}}^{\mbox{?}}$
class C(x$_1$: P$_1$, $\dots$, x$_n$: P$_n$) extends D{d}
   implements I$_1${c$_1$}, $\dots$, I$_k${c$_k$}
$\mbox{\emph{ClassBody}}$
\end{xtenmath}

Each of the following static semantics rules must be satisfied:

\begin{staticrule}{Int-implements}
The type invariant \xcdmath"$\mathit{inv}$(C)" of \xcd"C" must entail
\xcdmath"c$_i$[this/self]" for each $i$ in $\{1, \dots, k\}$
\end{staticrule}

\begin{staticrule}{Super-extends}
The return type \xcd"c" of each constructor in \grammarrule{ClassBody}
must entail \xcd"d".
\end{staticrule}

\section{Constructor definitions}

A constructor for a class \xcd"C" is guaranteed to return an object of the
class on successful termination. This object must satisfy  \xcdmath"$\mathit{inv}$(C)", the
class invariant associated with \xcd"C" (\Sref{DepType:TypeInvariant}).
However,
often the objects returned by a constructor may satisfy {\em stronger}
properties than the class invariant. \Xten{}'s dependent type system
permits these extra properties to be asserted with the constructor in
the form of a constrained type (the ``return type'' of the constructor):

\begin{grammar}
ConstructorDeclarator \:
  \xcd"def" \xcd"this" TypeParameterList\opt \xcd"(" FormalParameterList\opt \xcd")" \\
  && ReturnType\opt Guard\opt Throws\opt \\
ReturnType    \: \xcd":" Type \\
Guard   \: "\{" DepExpression "\}" \\
Throws    \: \xcd"throws" ExceptionType  ( \xcd"," ExceptionType )\star \\
ExceptionType \: ClassBaseType Annotation\star \\
\end{grammar}

\label{ConstructorGuard}

The parameter list for the constructor
may specify a \emph{guard} that is to be satisfied by the parameters
to the list.

\begin{example}
%%TODO--rewrite this
Here is another example, constructed as a simplified 
version of \Xcd{x10.lang.Region}.  The \xcd`mockUnion` method 
has the type that a true \xcd`union` method would have.

%~~gen
%package Classes.Are.For.Wussies.Wimps.And.People.With.Vowels.In.Their.Names;
%~~vis
\begin{xten}
class MyRegion(rank:Int) {
  static type MyRegion(n:Int)=MyRegion{self.rank==n};
  def this(r:Int):MyRegion(r) {
    property(r);
  }
  def this(diag:ValRail[Int]):MyRegion(diag.length){ 
    property(diag.length);
  }
  def mockUnion(r:MyRegion(rank)):MyRegion(rank) = this;
  def example() {
    val R1 : MyRegion(3)! = new MyRegion([4,4,4]); 
    val R2 : MyRegion(3)! = new MyRegion([5,4,1]); 
    val R3 = R1.mockUnion(R2); // inferred type MyRegion(3)
  }
}
\end{xten}
%~~siv
%
%~~neg
The first constructor returns the empty region of rank \Xcd{r}.  The
second constructor takes a \Xcd{ValRail[Int]} of arbitrary length
\Xcd{n} and returns a \Xcd{MyRegion(n)} (intended to represent the set
of points in the rectangular parallelopiped between the origin and the
\Xcd{diag}.)

The code in \xcd`example` typechecks, and \xcd`R3`'s type is inferred as
\xcd`MyRegion(3)`.  


\end{example}

\begin{staticrule}{Super-invoke}
   Let \xcd"C" be a class with properties
   \xcdmath"p$_1$: P$_1$, $\dots$, p$_n$: P$_n$", invariant \xcd"c"
   extending the constrained type \xcd"D{d}" (where \xcd"D" is the name of a class).

   For every constructor in \xcd"C" the compiler checks that the call to
   super invokes a constructor for \xcd"D" whose return type is strong enough
   to entail \xcd"d". Specifically, if the call to super is of the form 
     \xcdmath"super(e$_1$, $\dots$, e$_k$)"
   and the static type of each expression \xcdmath"e$_i$" is
   \xcdmath"S$_i$", and the invocation
   is statically resolved to a constructor
\xcdmath"def this(x$_1$: T$_1$, $\dots$, x$_k$: T$_k$){c}: D{d$_1$}"
   then it must be the case that 
\begin{xtenmath}
x$_1$: S$_1$, $\dots$, x$_i$: S$_i$ $\vdash$ x$_i$: T$_i$  (for $i \in \{1, \dots, k\}$)
x$_1$: S$_1$, $\dots$, x$_k$: S$_k$ $\vdash$ c  
d$_1$[a/self], x$_1$: S$_1$, ..., x$_k$: S$_k$ $\vdash$ d[a/self]      
\end{xtenmath}
\noindent where \xcd"a" is a constant that does not appear in 
\xcdmath"x$_1$: S$_1$ $\wedge$ ... $\wedge$ x$_k$: S$_k$".
\end{staticrule}

\begin{staticrule}{Constructor return}
   The compiler checks that every constructor for \xcd"C" ensures that
   the properties \xcdmath"p$_1$,..., p$_n$" are initialized with values which satisfy
   \xcdmath"t(C)", and its own return type \xcd"c'" as follows.  In each constructor, the
   compiler checks that the static types \xcdmath"T$_i$" of the expressions \xcdmath"e$_i$"
   assigned to \xcdmath"p$_i$" are such that the following is
   true:
\begin{xtenmath}
p$_1$: T$_1$, $\dots$, p$_n$: T$_n$ $\vdash$ t(C) $\wedge$ c'     
\end{xtenmath}
\end{staticrule}
(Note that for the assignment of \xcdmath"e$_i$" to \xcdmath"p$_i$"
to be type-correct it must be the
    case that \xcdmath"p$_i$: T$_i$ $\wedge$ p$_i$: P$_i$".) 


\begin{staticrule}{Constructor invocation}
The compiler must check that every invocation \xcdmath"C(e$_1$, $\dots$, e$_n$)" to a
constructor is type correct: each argument \xcdmath"e$_i$" must have a static type
that is a subtype of the declared type \xcdmath"T$_i$" for the $i$th
argument of the
constructor, and the conjunction of static types of the argument must
entail the \grammarrule{Guard} in the parameter list of the constructor.
\end{staticrule}

\section{\Xcd{ proto} qualifier on types}
\label{Prototypes}
\index{proto}
\Xten{} ensures that every variable must have a value consistent with its type
before it is read.

For local variables, this is ensured by using a pre-specified static
analysis to ensure that every local variable is written into before it
is read. Type-checking of assignment ensures the value written is
consistent with the static type of the variable.

For fields, this is ensured by introducing a form of ownership types
called {\em incomplete types} to address the {\em escaping-this}
problem.  To permit flexibility in writing constructors, \Xten{} v1.7
permits \Xcd{this} to be used in a constructor as a reference to the
object currently being constructed. Unfortunately there are no
restrictions on the usage of \Xcd{this}. In particular, this reference
can be permitted to escape: it may be stored in variables on the heap
(thereby permitting concurrently executing activities to read the
value of fields that may not yet have been initialized), passed as an
argument to method invocations, or used as the target for a method
invocation. Indeed, the method may be invoked in a super constructor,
and may have been overridden at a subclass, guaranteeing that accesses
to fields defined in the subclass are accesses to uninitialized
variables. For instance an immutable field may be observed containing
a value (the value the field was initialized with) which may be
different from the value it will contain once the constructor has
returned.

Incomplete types are designed with the following goals:
 \begin{itemize}

\item Guarantee that fields are not read before they are initialized.

\item  Allow the creation of immutable cyclic object graphs.\footnote{(Mutable
       graphs can be created without escaping \Xcd{this} 
    by initializing the backpointer to \Xcd{null} and then
    changing it later.}  This requires that it be possible to pass an
  object under construction into a constructor invocation.

\item Allow appropriate user-defined methods can be called during object
  creation (so that the transformation between the values supplied as
  parameters to a constructor and the values actually placed in fields
  is determined by arbitrary user-defined code).

\item Keep the design minimally invasive. Most programmers should
  not have to be concerned about this problem.

\item Ensure that there is no runtime overhead. 
\end{itemize}

These goals are met by introducing incomplete types through the type
qualifier \Xcd{proto}. Types of the form \Xcd{proto T} are said to be
{\em incomplete types}; types that do not have the qualifier are said to be
{\em complete}.
 Say that an object \Xcd{o} is {\em confined}
to a given activity \Xcd{A} if it can be reached only from stack
frames of \Xcd{A} or from objects which are, recursively, confined to
\Xcd{A}. Thus confined objects cannot be accessed by activities other
than \Xcd{A}.

Incomplete types ensure that objects whose construtors have not exited
are confined. Further, all references to such objects on the stack
are contained in variables of incomplete types. The compiler does not
permit the fields of variables of incomplete types to be read. 
Thus incomplete types permit the construction of graphs of objects
while ensuring that these objects are confined and their fields are not
read during construction. 

The return value of a constructor for class \Xcd{C} that takes no
incomplete arguments is (a subtype of) \Xcd{C}, that is, a complete
type. It will point only to completed objects. It can now be
assigned to any (type-consistent) field of any object, that is, it is
now allowed to escape.

\subsubsection{\Xcd{proto} Rules}
\label{protorules}
\label{ProtoRules}
\index{proto!rules}

For every type \Xcd{T} (where \Xcd{T} is not a type variable), we
introduce the type \Xcd{proto T}. 

There is no relationship between types \Xcd{T} and \Xcd{proto T} --
neither is a subtype of the other.\footnote{Clearly, a value of type
  \Xcd{proto T} cannot be used anywhere that a \Xcd{T} is needed,
  since its fields cannot be read.  As discussed below, an incomplete
  value \Xcd{v} can be assigned to a field {\tt f} of an object {\tt
    o} only if {\tt o} is incomplete. This ensures that \Xcd{v} cannot
  escape through this assignment. A completed value \Xcd{p} cannot be
  substituted for \Xcd{o} -- it may permit \Xcd{v} to escape through
  an assignment to its field. Therefore \Xcd{T} cannot be a subtype of
  \Xcd{proto T}.}

Incomplete types are permitted to occur only as types of method
parameters or local variables or as return types for methods and
constructors. They may not occur in (the source or target of) cast
statements, \Xcd{extends} or \Xcd{implements} clauses, \Xcd{catch}
clauses, or as types of class fields.

Within the body of a class \Xcd{C} the type of \Xcd{this} in
constructors, instance initializers and instance variable initializers
is \Xcd{proto C}.

Let \Xcd{v} be a value of type \Xcd{proto C}, for some class \Xcd{C}. 

No fields of \Xcd{v} can be read.  (This is the defining property of
\Xcd{proto} types.)  However, \Xcd{v}'s (accessible) instance fields
can be assigned.

\Xcd{v} can be assigned to an instance field \Xcd{o.f} only if \Xcd{f}
is of some type \Xcd{S} such that \Xcd{T <: S} and \Xcd{o} has an
incomplete type.

\Xcd{v} can be assigned to local variables  only if they are of some type
\Xcd{proto S} (such that \Xcd{T <: S}).

Instance methods of class \Xcd{C} may be qualified with \Xcd{proto}
(these methods are called {\em incomplete methods}). The type of \Xcd{this}
in incomplete methods is \Xcd{proto C}. Incomplete methods can be
overridden only by incomplete methods.  Only incomplete methods can be
invoked on \Xcd{v}. Incomplete methods which do not take an argument of incomplete
type can be invoked on completed values. 


\Xcd{v} can be passed as argument into a constructor or method call,
or returned from a method.  The return type of a method taking an
argument at an incomplete type must be \Xcd{void} or incomplete.  The
return type of a constructor taking an argument at a \Xcd{proto} type
must be incomplete.
 
A generic type parameter \Xcd{T} can be instantiated with the type \Xcd{proto
  S} (where \Xcd{S} is not a type parameter itself), provided that the body of
the entity being instantiated satisfies the conditions above for \Xcd{proto
  S}.

During code generation, the type \Xcd{proto T} is treated as if it were
\Xcd{T}. That is, there is no run-time cost to \Xcd{proto} types.

The invariants maintained by the design are as follows.  Say that an
object field or stack variable (local variable) contains an incomplete
value if a value of type \Xcd{proto T} (for some \Xcd{T}) was written
into it.

\begin{itemize}
\item If an object \Xcd{o} has a field containing an incomplete value \Xcd{v},
then either \Xcd{v}'s constructor has exited or \Xcd{o} is confined.
Further, every reference to \Xcd{o} on the stack is held at an incomplete type.

\item If a stack variable contains an incomplete value, then
  the variable's type is incomplete.

\end{itemize}

Say that a constructor invocation for a class \Xcd{C} on the call
stack is a {\em root} if it takes no incomplete arguments. Such a
constructor invocation will return an object of type \Xcd{C} whose
fields may point to an arbitrary graph of newly created objects
(objects created by the activity after the constructor
invocation). Since the object returned is at type \Xcd{C} -- and not
\Xcd{proto C} -- It may be assigned to any field of any object on the
heap of type \Xcd{D} such that \Xcd{C <: D}.  It is no longer
confined. Thus the ``magic moment'' when an incomplete value becomes
complete is when the last constructor for any incomplete value it
references (including itself) returns.

\subsubsection{Example}

\begin{example}
This example shows how to create a fixed-size circular buffer.
(Its pointer structure is immutable, though the contents of each
field are mutable.)
{\footnotesize

%~~gen
% package CircularBuffers.Are.For.The.Weak.And.Sickly.And.Also.Klingons.And.Romulans;
%~~vis
\begin{xten}
class  CircularBuffer[A] {
  var a: A;
  val next: CircularBuffer[A];
  private def this(x: proto CircularBuffer[A]): proto CircularBuffer[A] {
    next = x;
  }
  def this(var n:Int) {
    var temp: proto CircularBuffer[A] = this;
    while (--n > 0) 
      temp = new CircularBuffer[A](temp);
    next = temp;
  }
}
\end{xten}}
%~~siv
%
%~~neg

\end{example}
\section{Field definitions}
\label{FieldDefinitions}

A class may have zero or more mutable or immutable fields. 
No two fields declared in a class may have the same name. 

Fields may be marked \xcd{static}. Only one instance of such a field
exists, and it may be accessed through the name of the class in which
it is defined (\Sref{StaticInitialization}).  Fields not marked
\xcd{static} are said to be {\em instance} fields. One copy of such a
field exists for every instance of the class.

To avoid an ambiguity, it is a static error for a class to
declare a field with a function type (\Sref{FunctionTypes}) with
the same name and signature  as a method of the same class.

\subsection{Field hiding}

A subclass that defines a field \xcd"f" hides any field \xcd"f"
declared in a superclass, regardless of their types.  The
superclass field \xcd"f" may be accessed within the body of
the subclass via the reference \xcd"super.f".

\subsection{Field qualifiers}
\label{FieldQualifier}
\index{Qualifier!field}

\subsubsection{\Xcd{global} qualifier}
\index{global!field}
\label{GlobalField}

A field may be declared \xcd"global".

\begin{grammar}
  FieldModifier \: \xcd"global"  
\end{grammar}

A \Xcd{global} field must be immutable. It may be read from any place.
Properties and static fields are implicitly marked \Xcd{global}.
Fields not marked \Xcd{global} cannot be overridden by fields marked
\Xcd{global}.

\section{Method definitions}

\Xten{} permits guarded method definitions. 

\begin{grammar}
MethodDeclaration \: MethodHeader \xcd";" \\
                  \| MethodHeader \xcd"=" ClosureBody \\
MethodHeader \:  
  MethodModifiers\opt \xcd"def" Identifier TypeParameters\opt \\
&& \xcd"(" 
  FormalParameterList\opt \xcd")" Guard\opt \\
  && ReturnType\opt Throws\opt \\
\end{grammar}

A formal parameter may optionally have a \xcd"val" or \xcd"var"
modifier (default: \xcd"val").  
The body of the method is executed in an environment in which 
each formal parameter corresponds to a local variable
and is initialized with the value of the actual parameter.
The local variable  is mutable if and only if the
parameter is a \xcd"var" parameter.

\label{MethodGuard}

The guard (specified by \grammarrule{Guard})
specifies a constraint \xcd"c" on the
properties of the class \xcd"C" on which the method is being defined. The
method exists only for those instances of \xcd"C" which satisfy \xcd"c".  It is
illegal for code to invoke the method on objects whose static type is
not a subtype of \xcd"C{c}".

\begin{staticrule*}
    The compiler checks that every method invocation
    \xcdmath"o.m(e$_1$, $\dots$, e$_n$)"
    for a method is type correct. Each argument
    \xcdmath"e$_i$" must have a
    static type \xcdmath"S$_i$" that is a subtype of the declared type
    \xcdmath"T$_i$" for the $i$th
    argument of the method, and the conjunction of static types
    of the arguments must entail the guard in the parameter list
    of the method.

    The compiler checks that in every method invocation
    \xcdmath"o.m(e$_1$, $\dots$, e$_n$)"
    the static type of \xcd"o", \xcd"S", is a subtype of \xcd"C{c}", where the method
    is defined in class \xcd"C" and the guard for \xcd"m" is equivalent to
    \xcd"c".

    Finally, if the declared return type of the method is
    \xcd"D{d}", the
    return type computed for the call is
    \xcdmath"D{a: S; x$_1$: S$_1$; $\dots$; x$_n$: S$_n$; d[a/this]}",
    where \xcd"a" is a new
    variable that does not occur in
    \xcdmath"d, S, S$_1$, $\dots$, S$_n$", and
    \xcdmath"x$_1$, $\dots$, x$_n$" are the formal
    parameters of the method.
\end{staticrule*}
The method body is either an expression, a block of statements,
or a block ending with an expression.

\begin{example}
%%TODO--rewrite this.  I don't know what point it's trying to illustrate.
The following program implements a subset of \xcd`Point`'s behavior.  

%~~gen
%package Classes.Pointlike.For.Fun.And.Profit;
%~~vis
\begin{xten}
final class Pointlike(rank: Int)  {
    public global val coords: ValRail[Int]{self.length == rank};
    public def this(v:ValRail[Int]) {
       property(v.length);
       coords = v as ValRail[Int]{self.length == rank};
    }
    public operator this + (that: Pointlike{self.rank == this.rank})
       : Pointlike{self.rank == this.rank}
       {
         val f : (Int)=>Int = (i:Int) => 
                 (this.coords)(i) + (that.coords)(i);
         val v = ValRail.make[Int](rank, f);
         return new Pointlike(v);
       }
    static def example() {
       val s <: Pointlike{self.rank==3} = new Pointlike([1,2,3]);
       val t <: Pointlike{self.rank==3} = new Pointlike([-1,-1,-1]);
       val u <: Pointlike{self.rank==3} = s + t;
    }
}
\end{xten}
%~~siv
%
%~~neg
\end{example}

\subsection{Property methods}

A method declared with the modifier \xcd"property" may be used
in constraints.  A property method declared in a class must have
a body and must not be \xcd"void".  The body of the method must
consist of only a single \xcd"return" statement or a single
expression.  It is a static error if the expression cannot be
represented in the constraint system. 

The expression may contain invocations of other properties. It is the
responsibility of the programmer to ensure that the evaluation of 
a property terminates at compile-time, otherwise the type-checker
will not terminate and the program will fail to compile.

Property methods in classes are implicitly \xcd"final"; they cannot be
overridden. Property methods are also implicitly \xcd"global".

A nullary property method definition may omit the formal parameters and
the \xcd"def" keyword.  That is, the following are equivalent:


%~~gen
% package classes.not.harpoons.instead.of.python;
% class Waif(rect:Boolean, onePlace:Place, zeroBased:Boolean) {
%~~vis
\begin{xten}
property def rail(): Boolean = rect && onePlace == here && zeroBased;
\end{xten}
%~~siv
%}
%~~neg
and
%~~gen
% package classes.not.muskrats.instead.of.blueberry.cake.with.honey;
% class Waif(rect:Boolean, onePlace:Place, zeroBased:Boolean) {
%~~vis
\begin{xten}
property rail: Boolean = rect && onePlace == here && zeroBased;
\end{xten}
%~~siv
%}
%~~neg

Similarly, nullary property methods can be inspected in constraints without
\xcd`()`.  
%~~longexp~~`~~`
% package classes.not.weasels;
% class Waif(rect:Boolean, onePlace:Place, zeroBased:Boolean) {
%   def this(rect:Boolean, onePlace:Place, zeroBased:Boolean) 
%          :Waif{self.rect==rect, self.onePlace==onePlace, self.zeroBased==zeroBased}
%          = {property(rect, onePlace, zeroBased);}
%   property rail: Boolean = rect && onePlace == here && zeroBased;
%   static def zoink() {
%      val w : Waif{
%~~vis
\xcd`w.rail`, with either definition above, 
% }= new Waif(true, here, true);
% }}
%~~pxegnol
is equivalent to 
%~~longexp~~`~~`
% package classes.not.ferrets;
% class Waif(rect:Boolean, onePlace:Place, zeroBased:Boolean) {
%   def this(rect:Boolean, onePlace:Place, zeroBased:Boolean) 
%          :Waif{self.rect==rect, self.onePlace==onePlace, self.zeroBased==zeroBased}
%          = {property(rect, onePlace, zeroBased);}
%   property rail: Boolean = rect && onePlace == here && zeroBased;
%   static def zoink() {
%      val w : Waif{
%~~vis
\xcd`w.rail()`
% }= new Waif(true, here, true);
% }}
%~~pxegnol



\subsection{Method overloading, overriding, hiding, shadowing and obscuring}
\label{MethodOverload}

The definitions of method overloading, overriding, hiding, shadowing
and obscuring in \Xten{} are the same as in \Java, modulo the following
considerations motivated by type parameters and dependent types.

Two or more methods of a class or interface may have the same
name if they have a different number of type parameters, or
they have formal parameters of different types.  \Eg, the following is legal: 

%~~gen
%
%~~vis
\begin{xten}
class Mful{
   def m() = 1;
   def m[T]() = 2;
   def m(x:Int) = 3;
   def m[T](x:Int) = 4;
}
\end{xten}
%~~siv
%
%~~neg

\XtenCurrVer{} does not permit overloading based on constraints. That is, the
following is {\em not} legal, although either method definition individually
is legal:
\begin{xten}
   def n(x:Int){x==1} = "one";
   def n(x:Int){x!=1} = "not";
\end{xten}


The definition of a method declaration \xcdmath"m$_1$" ``having the same signature
as'' a method declaration \xcdmath"m$_2$" involves identity of types. 

The {\em constraint erasure} of a type \xcdmath"T" is defined as follows.
The constraint erasure of  (a)~a class, interface or struct type \xcdmath"T" is 
\xcdmath"T"; (b)~a type \xcdmath"T{c}" is the constraint erasure of 
\xcdmath"T"; (b)~a type \xcdmath"T[S$_1$,\ldots,S$_n$]" 
is \xcdmath"T'[S$_1$',\ldots,S$_n$']" where each primed type is the erasure of 
the corresponding unprimed type.
 Two methods are said to have {\em the
  same signature} if (a) they have the same number of type parameters,
(b) they have the same number of formal (value) parameters, and (c)
for each formal parameter the constraint erasure of its types are equivalent. It is a
compile-time error for there to be two methods with the same name and
same signature in a class (either defined in that class or in a
superclass).

\begin{staticrule*}
  A class \xcd"C" may not have two declarations for a method named \xcd"m"---either
  defined at \xcd"C" or inherited:
\begin{xtenmath}
def m[X$_1$, $\dots$, X$_m$](v$_1$: T$_1$, $\dots$, v$_n$: T$_n$){tc}: T {...}
def m[X$_1$, $\dots$, X$_m$](v$_1$: S$_1$, $\dots$, v$_n$: S$_n$){sc}: S {...}
\end{xtenmath}
\noindent
if it is the case that the constraint erasures of the types \xcdmath"T$_1$",
\dots, \xcdmath"T$_n$" are
equivalent to the constraint erasures of the types \xcdmath"S$_1$, $\dots$, T$_n$"
respectively.
\end{staticrule*}

In addition, the guard of a overriding method must be 
no stronger than the guard of the overridden method.   This
ensures that any virtual call to the method
satisfies the guard of the callee.

\begin{staticrule*}
  If a class \xcd"C" overrides a method of a class or interface
  \xcd"B", the guard of the method in \xcd"B" must entail
  the guard of the method in \xcd"C".
\end{staticrule*}

A class \xcd"C" inherits from its direct superclass and superinterfaces all
their methods visible according to the access modifiers
of the superclass/superinterfaces that are not hidden or overridden. A method \xcdmath"M$_1$" in a class
\xcd"C" overrides
a method \xcdmath"M$_2$" in a superclass \xcd"D" if
\xcdmath"M$_1$" and \xcdmath"M$_2$" have the same signature.
Methods are overriden on a signature-by-signature basis.

A method invocation \xcdmath"o.m(e$_1$, $\dots$, e$_n$)"
is said to have the {\em static signature}
\xcdmath"<T, T$_1$, $\dots$, T$_n$>" where \xcd"T" is the static type of
\xcd"o", and
\xcdmath"T$_1$",
\dots,
\xcdmath"T$_n$"
are the static types of \xcdmath"e$_1$", \dots, \xcdmath"e$_n$",
respectively.  As in
\Java, it must be the case that the compiler can determine a single
method defined on \xcd"T" with argument type
\xcdmath"T$_1$", \dots \xcdmath"T$_n$"; otherwise, a
compile-time error is declared. However, unlike \Java, the \Xten{} type \xcd"T"
may be a dependent type \xcd"C{c}". Therefore, given a class definition for
\xcd"C" we must determine which methods of \xcd"C" are available at a type
\xcd"C{c}". But the answer to this question is clear: exactly those methods
defined on \xcd"C" are available at the type \xcd"C{c}"
whose guard \xcd"d" is implied by \xcd"c".

\subsection{Method qualifiers}
\label{MethodQualifier}
\index{Qualifier!method}

\subsubsection{\Xcd{atomic} qualifier}
\label{AtomicAnnotation}
\index{atomic}

A method may be declared \xcd"atomic".

\begin{grammar}
  MethodModifier \: \xcd"atomic"  
\end{grammar}

Such a method is treated as if the statement in its body is wrapped 
implicitly in an \xcd"atomic" statement.

\subsubsection{\Xcd{global} qualifier}
\label{LocalAnnotation}
\label{GlobalMethod}
\index{global!method}

A method may be declared \xcd"global".

\begin{grammar}
  MethodModifier \: \xcd"global"  
\end{grammar}

A \xcd"global" method can be invoked on an object \Xcd{o} in any place. The
body of such a method is type-checked without assuming that
\Xcd{here==this.home}. This permits \Xcd{global} fields of \Xcd{o} to
be accessed, but not local fields. The programmer must insert an explicit
\Xcd{at(this)...} to get to the place where the object lives and access
the field.

\Xcd{global} methods can be overridden only by methods also marked \Xcd{global}.

\subsubsection{\Xcd{pinned} qualifier}
\label{PinnedAnnotation}
\label{PinnedMethod}
\index{pinned!method}

A method may be declared \xcd"pinned".

\begin{grammar}
  MethodModifier \: \xcd"pinned"  
\end{grammar}

A \Xcd{pinned} method may not
contain any \Xcd{at} statement or expression whose place argument
is not statically equivalent to \Xcd{here}. It must call only
\Xcd{pinned} methods. That is, a \Xcd{pinned} method does not cause
any communication.

\Xcd{pinned} methods can be overridden only by methods marked \Xcd{pinned}.

\subsubsection{\Xcd{nonblocking} qualifier}
\label{NonblockingAnnotation}
\label{NonblockingMethod}
\index{nonblocking!method}

A method may be declared \xcd"nonblocking".

\begin{grammar}
  MethodModifier \: \xcd"nonblocking"  
\end{grammar}

A \Xcd{nonblocking} method may not
contain any \Xcd{when} statement whose condition
is not statically equivalent to \Xcd{true}. It must call only
\Xcd{nonblocking} methods. That is, a \Xcd{nonblocking} method does not block.

\Xcd{nonblocking} methods can be overridden only by methods marked \Xcd{nonblocking}.

\subsubsection{\Xcd{sequential} qualifier}
\label{SequentialAnnotation}
\label{SequentialMethod}
\index{sequential!method}

A method may be declared \xcd"sequential".

\begin{grammar}
  MethodModifier \: \xcd"sequential"  
\end{grammar}

A \Xcd{sequential} method may not contain any \Xcd{async}
statement. It must call only \Xcd{sequential} methods. That is, a
\Xcd{sequential} method does not spawn any activity.

\Xcd{sequential} methods can be overridden only by methods marked \Xcd{sequential}.

\subsubsection{\Xcd{safe} qualifier}
\label{SafeAnnotation}
\label{SafeMethod}
\index{safe!method}

A method may be declared \xcd"safe".

\begin{grammar}
  MethodModifier \: \xcd"safe"  
\end{grammar}

The \Xcd{safe} annotation is considered shorthand for \Xcd{pinned
  nonblocking sequential}.


\section{Static initialization}
\label{StaticInitialization}
\index{initialization!static}
The \Xten{} runtime implements the following procedure to ensure
reliable initialization of the static state of classes.


Execution commences with a single thread executing the
\emph{initialization} phase of an \Xten{} computation at place \Xcd{0}. This
phase must complete successfully before the body of the \Xcd{main} method is
executed.

The initialization phase must be thought of as if it is implemented in
the following fashion: (The implementation may do something more
efficient as long as it is faithful to this semantics.)

\begin{xten}
Within the scope of a new finish
for every static field f of every class C 
   (with type T and initializer e):
async {
  val l = e; 
  ateach (Dist.makeUnique()) {
     assign l to the static f field of 
         the local C class object;
     mark the f field of the local C 
         class object as initialized;
  }
}
\end{xten}

During this phase, any read of a static field \Xcd{C.f} (where \Xcd{f} is of type \Xcd{T})
is replaced by a call to the method \Xcd{C.read\_f():T} defined on class \Xcd{C}
as follows

\begin{xten}
def read_f():T {
   await (initialized(C.f));
   return C.f;
}
\end{xten}
 

If all these activities terminate normally, all static field have a
legal value (per their type), and the finish terminates normally. If
any activity throws an exception, the finish throws an
exception. Since no user code is executing which can catch exceptions
thrown by the finish, the exceptions are printed on the console, and
computation aborts.

If the activities deadlock, the implementation deadlocks.

In all cases, the main method is executed only once all static fields
have been initialized correctly.

Since static state is immutable and is replicated to all places via 
the initialization phase as described above, it can be accessed from
any place.


\section{User-Defined Operators}

It is often convenient to have methods named by symbols rather than words.
For example, suppose that we wish to define a \xcd`Poly` class of
polynomials -- for the sake of illustration, single-variable polynomials with
\xcd`Int` coefficients.  It would be very nice to be able to manipulate these
polynomials by the usual operations: \xcd`+` to add, \xcd`*` to multiply,
\xcd`-` to subtract, and \xcd`p(x)` to compute the value of the polynomial at
argument \xcd`x`.  We would like to write code thus: 
%~~gen
% package Classes.In.Poly101;
% // Integer-coefficient polynomials of one variable.
% class Poly {
%   public global val coeff : ValRail[Int];
%   public def this(coeff: ValRail[Int]) { this.coeff = coeff;}
%   public global def degree() = coeff.length()-1;
%   public global def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
% 
%   public static safe operator (c : Int) as Poly! = new Poly([c]);
% 
%   public safe def apply(x:Int) {
%     val d = this.degree();
%     var s : Int = this.a(d);
%     for( (i) in 1 .. this.degree() ) {
%        s = x * s + a(d-i);
%     }
%     return s;
%   }
% 
%   public operator this + (p:Poly!) =  new Poly(
%      ValRail.make[Int](
%         Math.max(this.coeff.length(), p.coeff.length()),
%         (i:Int) => this.a(i) + p.a(i)
%      ));
%   public operator this - (p:Poly!) = this + (-1)*p;
% 
%   public operator this * (p:Poly!) = new Poly(
%      ValRail.make[Int](
%        this.degree() + p.degree() + 1,
%        (k:Int) => sumDeg(k, this, p)
%        )
%      );
%   
% 
%   public operator (n : Int) + this = (n as Poly) + this;
%   public operator this + (n : Int) = (n as Poly) + this;
% 
%   public operator (n : Int) - this = (n as Poly) + (-1) * this;
%   public operator this - (n : Int) = ((-n) as Poly) + this;
% 
%   public operator (n : Int) * this = new Poly(
%      ValRail.make[Int](
%        this.degree()+1,
%        (k:Int) => n * this.a(k)
%      ));
%   private static def sumDeg(k:Int, a:Poly, b:Poly) {
%      var s : Int = 0;
%      for ( (i) in 0 .. k ) s += a.a(i) * b.a(k-i);
%        // x10.io.Console.OUT.println("sumdeg(" + k + "," + a + "," + b + ")=" + s);
%      return s;
%      };
%   public global final safe def toString() = {
%      var allZeroSoFar : Boolean = true;
%      var s : String ="";
%      for ( (i) in 0..this.degree() ) {
%        val ai = this.a(i);
%        if (ai == 0) continue;
%        if (allZeroSoFar) {
%           allZeroSoFar = false;
%           s = term(ai, i);
%        }
%        else 
%           s += 
%              (ai > 0 ? " + " : " - ")
%             +term(ai, i);
%      }
%      if (allZeroSoFar) s = "0";
%      return s;
%   }
%   private global final safe def term(ai: Int, n:Int) = {
%      val xpow = (n==0) ? "" : (n==1) ? "x" : "x^" + n ;
%      return (ai == 1) ? xpow : "" + Math.abs(ai) + xpow;
%   }
%   
%   public static def Main(ss:Rail[String]) = main(ss);
% 
%~~vis
\begin{xten}
  public static def main(Rail[String]) {
     val X = new Poly([0,1]);
     val t <: Poly = 7 * X + 6 * X * X * X; 
     val u <: Poly = 3 + 5*X - 7*X*X;
     val v <: Poly = t * u - 1;
     for ( (i) in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X(i) + "	t:" + t(i) 
         + "	u:" + u(i) + "	v:" + v(i)
         );
     }
  }

\end{xten}
%~~siv
%}
%~~neg

Writing the same code with method calls, while possible, is far less elegant: 
%~~gen
%package Classes.In.Poly101;
% // Integer-coefficient polynomials of one variable.
% class UglyPoly {
%   public global val coeff : ValRail[Int];
%   public def this(coeff: ValRail[Int]) { this.coeff = coeff;}
%   public global def degree() = coeff.length()-1;
%   public global def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
% 
%   public static safe operator (c : Int) as UglyPoly! = new UglyPoly([c]);
% 
%   public safe def apply(x:Int) {
%     val d = this.degree();
%     var s : Int = this.a(d);
%     for( (i) in 1 .. this.degree() ) {
%        s = x * s + a(d-i);
%     }
%     return s;
%   }
% 
%   public operator this + (p:UglyPoly!) =  new UglyPoly(
%      ValRail.make[Int](
%         Math.max(this.coeff.length(), p.coeff.length()),
%         (i:Int) => this.a(i) + p.a(i)
%      ));
%   public operator this - (p:UglyPoly!) = this + (-1)*p;
% 
%   public operator this * (p:UglyPoly!) = new UglyPoly(
%      ValRail.make[Int](
%        this.degree() + p.degree() + 1,
%        (k:Int) => sumDeg(k, this, p)
%        )
%      );
%   
% 
%   public operator (n : Int) + this = (n as UglyPoly) + this;
%   public operator this + (n : Int) = (n as UglyPoly) + this;
% 
%   public operator (n : Int) - this = (n as UglyPoly) + (-1) * this;
%   public operator this - (n : Int) = ((-n) as UglyPoly) + this;
% 
%   public operator (n : Int) * this = new UglyPoly(
%      ValRail.make[Int](
%        this.degree()+1,
%        (k:Int) => n * this.a(k)
%      ));
%   private static def sumDeg(k:Int, a:UglyPoly, b:UglyPoly) {
%      var s : Int = 0;
%      for ( (i) in 0 .. k ) s += a.a(i) * b.a(k-i);
%        // x10.io.Console.OUT.println("sumdeg(" + k + "," + a + "," + b + ")=" + s);
%      return s;
%      };
%   public global final safe def toString() = {
%      var allZeroSoFar : Boolean = true;
%      var s : String ="";
%      for ( (i) in 0..this.degree() ) {
%        val ai = this.a(i);
%        if (ai == 0) continue;
%        if (allZeroSoFar) {
%           allZeroSoFar = false;
%           s = term(ai, i);
%        }
%        else 
%           s += 
%              (ai > 0 ? " + " : " - ")
%             +term(ai, i);
%      }
%      if (allZeroSoFar) s = "0";
%      return s;
%   }
%   private global final safe def term(ai: Int, n:Int) = {
%      val xpow = (n==0) ? "" : (n==1) ? "x" : "x^" + n ;
%      return (ai == 1) ? xpow : "" + Math.abs(ai) + xpow;
%   }
%   
%   def mult(p:UglyPoly!) = this * p;
%   def mult(n:Int) = n * this;
%   def plus(p:UglyPoly!) = this + p;
%   def plus(n:Int) = n + this;
%   def minus(p:UglyPoly!) = this - p;
%   def minus(n:Int) = this - n;
%   static def const(n:Int) = n as UglyPoly;
% 
%   public static def Main(x:Rail[String]) = main(x);
%   public static def main(Rail[String]) {
%      val X = new UglyPoly([0,1]);
%      val t <: UglyPoly = 7 * X + 6 * X * X * X; 
% 
%      val u <: UglyPoly = 3 + 5*X - 7*X*X;
%      val v <: UglyPoly = t * u - 1;
%      for ( (i) in -3 .. 3) {
%        x10.io.Console.OUT.println(
%          "" + i + "	X:" + X(i) + "	t:" + t(i) + "	u:" + u(i) + "	v:" + v(i)
%          );
%      }
%      uglymain();
%   }
% 
%~~vis
\begin{xten}
  public static def uglymain() {
     val X = new UglyPoly([0,1]);
     val t <: UglyPoly = X.mult(7).plus(X.mult(X).mult(X).mult(6));  
     val u <: UglyPoly = const(3).plus(X.mult(5)).minus(X.mult(X).mult(7));
     val v <: UglyPoly = t.mult(u).minus(1);
     for ( (i) in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X.apply(i) + "	t:" + t.apply(i) 
          + "	u:" + u.apply(i) + "	v:" + v.apply(i)
         );
     }
  }
\end{xten}
%~~siv
%}
%~~neg

The operator-using code can be written in X10, though a few variations are
necessary to handle such exotic cases as \xcd`1+X`.

\subsection{Binary Operators}

Defining the sum \xcd`P+Q` of two polynomials looks much like a method
definition.  It uses the \xcd`operator` keyword instead of \xcd`def`, and
\xcd`this` appears in the definition in the place that a \xcd`Poly` would
appear in a use of the operator.  So, 
\xcd`operator this + (p:Poly!)` explains how to add \xcd`this` to a
\xcd`Poly!` value.
%~~gen
% package Classes.In.Poly102;
%~~vis
\begin{xten}
class Poly {
  public global val coeff : ValRail[Int];
  public def this(coeff: ValRail[Int]) { this.coeff = coeff;}
  public global def degree() = coeff.length()-1;
  public global def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);

  public operator this + (p:Poly!) =  new Poly(
     ValRail.make[Int](
        Math.max(this.coeff.length(), p.coeff.length()),
        (i:Int) => this.a(i) + p.a(i)
     )); 
  // ... 
\end{xten}
%~~siv
%   public operator (n : Int) + this = new Poly([n]) + this;
%   public operator this + (n : Int) = new Poly([n]) + this;
% 
%   def makeSureItWorks() {
%      val x = new Poly([0,1]);
%      val p <: Poly = x+x+x;
%      val q <: Poly = 1+x;
%      val r <: Poly = x+1;
%   }
%     
% }
%~~neg


The sum of a polynomial and an integer, \xcd`P+3`, looks like
an overloaded method definition.  
%~~gen
% package Classes.In.Poly103;
% class Poly {
%   public global val coeff : ValRail[Int];
%   public def this(coeff: ValRail[Int]) { this.coeff = coeff;}
%   public global def degree() = coeff.length()-1;
%   public global def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
% 
%   public operator this + (p:Poly!) =  new Poly(
%      ValRail.make[Int](
%         Math.max(this.coeff.length(), p.coeff.length()),
%         (i:Int) => this.a(i) + p.a(i)
%      ));
%~~vis
\begin{xten}
   public operator (n : Int) + this = new Poly([n]) + this;
\end{xten}
%~~siv

%   public operator this + (n : Int) = new Poly([n]) + this;
% 
%   def makeSureItWorks() {
%      val x = new Poly([0,1]);
%      val p <: Poly = x+x+x;
%      val q <: Poly = 1+x;
%      val r <: Poly = x+1;
%   }
%     
% }
%~~neg


However, we want to allow the sum of an integer and a polynomial as well:
\xcd`3+P`.  It would be quite inconvenient to have to define this as a method
on \xcd`Int`; changing \xcd`Int` is far outside of normal coding.  So, we
allow it as a method on \xcd`Poly` as well.


%~~gen
% package Classes.In.Poly104o;
% class Poly {
%   public global val coeff : ValRail[Int];
%   public def this(coeff: ValRail[Int]) { this.coeff = coeff;}
%   public global def degree() = coeff.length()-1;
%   public global def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
% 
%   public operator this + (p:Poly!) =  new Poly(
%      ValRail.make[Int](
%         Math.max(this.coeff.length(), p.coeff.length()),
%         (i:Int) => this.a(i) + p.a(i)
%      ));
%    public operator (n : Int) + this = new Poly([n]) + this;
%~~vis
\begin{xten}
   public operator this + (n : Int) = new Poly([n]) + this;
\end{xten}
%~~siv
% 
%   def makeSureItWorks() {
%      val x = new Poly([0,1]);
%      val p <: Poly = x+x+x;
%      val q <: Poly = 1+x;
%      val r <: Poly = x+1;
%   }
%     
% }
%~~neg

Furthermore, it is sometimes convenient to express a binary operation as a
static method on a class. 
The definition for the sum of two
\xcd`Poly`s could have been written:
%~~gen
% package Classes.In.Poly105;
% class Poly {
%   public global val coeff : ValRail[Int];
%   public def this(coeff: ValRail[Int]) { this.coeff = coeff;}
%   public global def degree() = coeff.length()-1;
%   public global def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
%~~vis
\begin{xten}
  public static operator (p:Poly!) + (q:Poly!) =  new Poly(
     ValRail.make[Int](
        Math.max(q.coeff.length(), p.coeff.length()),
        (i:Int) => q.a(i) + p.a(i)
     ));
\end{xten}
%~~siv
%
%   public operator (n : Int) + this = new Poly([n]) + this;
%   public operator this + (n : Int) = new Poly([n]) + this;
% 
%   def makeSureItWorks() {
%      val x = new Poly([0,1]);
%      val p <: Poly = x+x+x;
%      val q <: Poly = 1+x;
%      val r <: Poly = x+1;
%   }
%     
% }
%~~neg


This requires the following syntax:\\ 
\begin{grammar}
MethodHeader \:
  \xcd`operator` TypeParameterList\opt \xcd`this` BinOp \xcd`(`  FormalParameter \xcd")" \\
  && Guard\opt ReturnType\opt  Throws\opt \\
MethodHeader \:
  \xcd`operator` TypeParameterList\opt \xcd`(`  FormalParameter \xcd")" BinOp \xcd`this`  \\
  && Guard\opt ReturnType\opt  Throws\opt \\
MethodHeader \:
  \xcd`operator` TypeParameterList\opt \xcd`(`  FormalParameter \xcd")" BinOp  \xcd`(`  FormalParameter \xcd")"  \\
  && Guard\opt ReturnType\opt  Throws\opt \\
\end{grammar}

When X10 attempts to typecheck a binary operator expression like \xcd`P+Q`, it
first typechecks \xcd`P` and \xcd`Q`. Then, it looks for operator declarations
for \xcd`+` in the types of \xcd`P` and \xcd`Q`. If there are none, it is a
static error. If there is precisely one, that one will be used. If there are
several, X10 looks for a {\em best-matching} operation, \viz{} one which does
not require the operands to be converted to another type. For example,
\xcd`operator this + (n:Long)` and \xcd`operator this + (n:Int)` both apply to
\xcd`p+1`, because \xcd`1` can be converted from an \xcd`Int` to a \xcd`Long`.
However, the \xcd`Int` version will be chosen because it does not require a
conversion. If even the best-matching operation is not uniquely determined,
the compiler will report a static error.

The main difference between expressing a binary operation as an instance
method (with a \xcd`this` in the definition) and a static one (no \xcd`this`)
is that instance methods don't apply any conversions, while static methods
attempt to convert both arguments. 
\bard{give an example}

\bard{List the operators which this works for, in precedence order}

\subsection{Unary Operators}

Unary operators are defined in a similar way, with \xcd`this` appearing in the
\xcd`operator` definition where an actual value would occur in a unary
expression.  The operator to negate a polynomial is: 

%~~gen
% package Classes.In.Poly106;
% class Poly {
%   public global val coeff : ValRail[Int];
%   public def this(coeff: ValRail[Int]) { this.coeff = coeff;}
%   public global def degree() = coeff.length()-1;
%   public global def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
%~~vis
\begin{xten}
  public operator - this = new Poly(
    ValRail.make[Int](coeff.length(), (i:Int) => -coeff(i))
    );
\end{xten}
%~~siv
%   def makeSureItWorks() {
%      val x = new Poly([0,1]);
%      val p <: Poly = -x;
%   }
% }
%~~neg

The syntax for unary operators is:

\begin{grammar}
MethodHeader \:
  \xcd`operator` PrefixOp \xcd`this`    Guard\opt ReturnType\opt  Throws\opt 
\end{grammar}

The rules for typechecking a unary operation are the same as for methods; the
complexities of binary operations are not needed.

\bard{List the operators which this works for, in precedence order}


\subsection{Type Conversions}

Explicit type conversions, \xcd`e as T{c}`, can be defined as operators on
class \xcd`T`.

%~~gen
% package Classes.And.Type.Conversions.For.Sea.Urchins;
%~~vis
\begin{xten}
class Poly {
  public global val coeff : ValRail[Int];
  public def this(coeff: ValRail[Int]) { this.coeff = coeff;}
  public static operator (a:Int) as Poly! = new Poly([a]);
  public static def main(Rail[String]) {
     val three : Poly! = 3 as Poly!;
  }
}
\end{xten}
%~~siv
%
%~~neg



You may define a type conversion to a constrained type, like \xcd`Poly!` in
the previous example.   If you convert to a more specific constraint, X10 will use
the conversion, but insert a dynamic check to make sure that you have
satisfied the more specific constraint.  For example: 
%~~gen
%package Classes.And.Type.Conversions.For.Street.Urchins;
%~~vis
\begin{xten}
class Uni(n:Int) {
  public def this(n:Int) : Uni{self.n==n} = {property(n);}
  static operator (String) as Uni{self.n != 9} = new Uni(3);
  public static def main(Rail[String]) {
    val u = "" as Uni{self.n != 9 && self.n != 3};
  }
}
\end{xten}
%~~siv
%
%~~neg
The string \xcd`""` is converted to \xcd`Uni{self.n != 9}` via the defined
conversion operator, and that value is checked against the remaining
constraints \xcd`{self.n != 3}` at runtime.  (In this case it will fail.)

There may be many conversions from different types to \xcd`T`, but there may
be at most one conversion from any given type to \xcd`T`. 

\bard{Syntax}

\subsection{Implicit Type Coercions}

You may also define {\em implicit} type coercions to \xcd`T{c}` as static
operators in class \xcd`T`.  The syntax for this is
\xcd`static operator (x:U) : T{c} = e`.
Implicit coercions are used automatically by the compiler.  
\bard{How does this work?  One coercion, or a chain, and how about ambiguity?}

For example, we can define an implicit coercion from \xcd`Int` to \xcd`Poly!`,
and avoid having to define the sum of an integer and a polynomial
as many special cases.  In the following example, we only define \xcd`+` on
two polynomials (using a \xcd`static` operator, so that implicit coercions
will be used -- they would not be for an instance method operator).  The
calculation \xcd`1+x` coerces \xcd`1` to a polynomial and uses polynomial
addition to add it to \xcd`x`.

%~~gen
% package Classes.And.Implicit.Coercions;
% class Poly {
%   public global val coeff : ValRail[Int];
%   public def this(coeff: ValRail[Int]) { this.coeff = coeff;}
%   public global def degree() = coeff.length()-1;
%   public global def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
%   public global final safe def toString() = {
%      var allZeroSoFar : Boolean = true;
%      var s : String ="";
%      for ( (i) in 0..this.degree() ) {
%        val ai = this.a(i);
%        if (ai == 0) continue;
%        if (allZeroSoFar) {
%           allZeroSoFar = false;
%           s = term(ai, i);
%        }
%        else 
%           s += 
%              (ai > 0 ? " + " : " - ")
%             +term(ai, i);
%      }
%      if (allZeroSoFar) s = "0";
%      return s;
%   }
%   private global final safe def term(ai: Int, n:Int) = {
%      val xpow = (n==0) ? "" : (n==1) ? "x" : "x^" + n ;
%      return (ai == 1) ? xpow : "" + Math.abs(ai) + xpow;
%   }

%~~vis
\begin{xten}
  public static safe operator (c : Int) : Poly! = new Poly([c]);

  public static operator (p:Poly!) + (q:Poly!) = new Poly(
      ValRail.make[Int](
        Math.max(p.coeff.length(), q.coeff.length()),
        (i:Int) => p.a(i) + q.a(i)
     ));

  public static def main(ValRail[String]) {
     val x = new Poly([0,1]);
     x10.io.Console.OUT.println("1+x=" + (1+x));
  }
\end{xten}
%~~siv
%}
%~~neg

\bard{Syntax}

\subsection{\xcd`set` and \xcd`apply`}

X10 allows types to implement the subscripting / function application
operator, and indexed assignment.  The \xcd`Array`-like classes take advantage
of both of these in \xcd`a(i) = a(i) + 1`.  Unlike unary and binary operators,
subscripting and indexed assignment are done by methods, \xcd`apply` and
\xcd`set` respectively.

\xcd`a(b,c,d)` is short for the method call \xcd`a.apply(b,c,d)`.  Since it is
possible to overload methods, the application syntax can be overloaded.  For
example, an ordered dictionary structure could allow subscripting by numbers
with \xcd`def apply(i:Int)`, and by string-valued keys with 
\xcd`def apply(s:String)`.  

\xcd`a(i)=b` is short for the method call \xcd`a.set(b,i)`, with one or more
indices \xcd`i`. (This has a
possibly surprising consequence for the order of evaluation: in \xcd`a(i)=b`,
as in \xcd`a.set(b,i)`, \xcd`a` is evaluated first, then \xcd`b`, and finally
\xcd`i`.)  Again, it is possible to overload \xcd`set` to provide a variety of
subscripting operations.

The \xcd`Oddvec` class of somewhat peculiar vectors illustrates this.
\xcd`a()` returns a string representation of the oddvec, which probably should
be done by \xcd`toString()` instead.  \xcd`a(i)` picks out one of the three
coordinates of \xcd`a`, which is sensible.  \xcd`a(i)=b` assigns to one of the
coordinates.  \xcd`a(i,j)=b` assigns different values to \xcd`a(i)` and
\xcd`a(j)`, purely for the sake of the example.

%~~gen
% package Classes.Assignments.Are.Not.From.Any.Course.Of.Study;
%~~vis
\begin{xten}
class Oddvec {
  var v : Rail[Int]! = Rail.make[Int](3, (Int)=>0);
  public def apply() = "(" + v(0) + "," + v(1) + "," + v(2) + ")";
  public def apply(i:Int) = v(i);
  public def set(newval:Int, i:Int) = {v(i) = newval;}
  public def set(newval:Int, i:Int, j:Int) = {
       v(i) = newval; v(j) = newval+1;} 
  // ... 
\end{xten}
%~~siv
%  public static def main(argv:Rail[String]!) {
%     val a = new Oddvec();
%     x10.io.Console.OUT.println(a() + " ... " + a(0));
%     a(1) = 20;
%     x10.io.Console.OUT.println(a());
%     a(0) = 30;
%     x10.io.Console.OUT.println(a());
%     a(0,1) = 100;
%     x10.io.Console.OUT.println(a());
%   }
% }
%~~neg


