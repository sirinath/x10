%\documentclass[nocopyrightspace,10pt]{sigplanconf}
\documentclass{llncs}

\newif\iflncs
\lncstrue

\usepackage{times-lite}
\usepackage{mathptm}
\usepackage{txtt}
\usepackage{stmaryrd}
\usepackage{code}
\usepackage{bcprules}
%\usepackage{ttquot}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{afterpage}
\usepackage{balance}
\usepackage{floatflt}
\usepackage{defs}
\usepackage{utils}
\usepackage[pdftex]{graphicx}
\usepackage{xspace}
\usepackage{ifpdf}
\newif\iflstworks
\lstworkstrue
\iflstworks
\usepackage{listings}
\fi

\newif\ifhas
\hastrue

\hfuzz=1pt

\iflstworks
\lstdefinelanguage{X10}%
  {morekeywords={abstract,break,case,catch,class,%
      const,continue,default,do,else,extends,false,final,%
      finally,for,goto,if,implements,import,instanceof,%
      interface,label,native,new,null,package,private,protected,%
      public,return,static,super,switch,synchronized,this,throw,%
      throws,transient,true,try,void,volatile,while,%
      async,atomic,when,foreach,ateach,finish,clock,clocked,%
      type,here,%
      self,property,nullable,future},%
   sensitive,%
   morecomment=[l]//,%
   morecomment=[s]{/*}{*/},%
   morestring=[b]",%
   morestring=[b]',%
  }
\fi

\newcommand\codestyle\tt

\iflstworks
\lstnewenvironment{displayxtenmath}
  {\lstset{language=X10,basicstyle=\codestyle,tabsize=4,columns=fullflexible,captionpos=b,xleftmargin=1em,xrightmargin=1em,mathescape=true,keepspaces=true,keywordstyle=}}
  {}
\lstnewenvironment{displayxten}
  {\lstset{language=X10,basicstyle=\codestyle,tabsize=4,columns=fullflexible,captionpos=b,xleftmargin=1em,xrightmargin=1em,mathescape=false,keepspaces=true,keywordstyle=}}
  {}
\newcommand\inputxten[1]{\begin{minipage}{\textwidth}\lstinputlisting[language=X10,basicstyle=\codestyle\footnotesize,columns=fullflexible,tabsize=4,captionpos=b,keepspaces,keywordstyle=,numbers=left,numberstyle=\tiny,xleftmargin=15pt]{#1}\end{minipage}}

\newcommand{\xcd}[1]{{\lstinline[language=X10,basicstyle=\codestyle,mathescape=false,columns=flexible,breaklines,keywordstyle=]{#1}}}
\newcommand{\xcdmath}[1]{{\lstinline[language=X10,basicstyle=\codestyle,mathescape=true,columns=flexible,breaklines,keywordstyle=]{#1}}}
\newcommand{\tcd}[1]{{\codestyle{#1}}}

\else
\newcommand{\xcd}[1]{{\tt #1}}
\newcommand{\tcd}[1]{{\tt #1}}
\fi

\pagestyle{plain}


\ifpdf
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}
\fi


% \input{../../../../vj/res/pagesizes}
% \input{../../../../vj/res/vijay-macros}
\newcommand\alt{\bnf}

\newcommand\Implies{\Rightarrow}

\iflncs
\else
\newtheorem{example}{Example}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newenvironment{proof}{
\trivlist
\item[\hskip \labelsep \textsc{Proof.}]
\selectfont
\ignorespaces}{$\Box$}

%\newtheorem{proof}[theorem]{Proof}
\fi

\begin{document}

\title{Genericity through Dependent Types}

\iflncs

\author{Nathaniel Nystom\inst{1} \and Vijay Saraswat\inst{1}}

\institute{IBM T.~J. Watson Research~Center, P.O.~Box~704, Yorktown~Heights NY 10598 USA,
\email{\{nystrom,vsaraswa\}@us.ibm.com}}

\else

\authorinfo{Nathaniel Nystrom\titlenote{IBM T.~J. Watson Research
Center, P.O. Box 704, Yorktown Heights NY 10598 USA}}{}
  {nystrom@us.ibm.com}
\authorinfo{Vijay Saraswat$^{\;*}$}{}
  {vsaraswa@us.ibm.com}

% \conferenceinfo{POPL'08}{XXX}
% \copyrightyear{2008}
% \copyrightdata{[to be supplied]}

\fi

\maketitle

\begin{abstract}
We describe a design for generic types in the programming language X10.
\end{abstract}

\section{Introduction}

X10 is a modern statically typed object-oriented language 
designed for high performance computing.
The language extends a class-based sequential core
with constructs for distribution and find-grained
concurrency.  The syntax is based on Scala's; the sequential semantics are 
based on Java's.

X10 provides \emph{constrained types} to rule out large classes
of errors by design.
Constrained types are a form of dependent type
defined on predicates over the immutable state of
objects~\cite{x10,constrained-types}.
%
The immutable state of an object is captured by its
\emph{properties}: public final fields of the object. 
For instance, the following class declares a two-dimensional
point with \tcd{float} properties \tcd{x} and \tcd{y}:
\begin{displayxten}
class Point(x: float, y: float) { }
\end{displayxten}
A constrained type is a type \xcd{C\{e\}}, where \tcd{C} is a
class and \tcd{e} is a boolean predicate on the properties of
\tcd{C} and the final variables in scope at the type.
For example, given the above class definition,
the type \xcd{Point\{x*x+y*y<1\}} is the type of all
points within the unit circle.
%
Constraints on properties induce a natural subtyping relationship:
\xcd{C\{c\}} is a subtype of
\xcd{D\{d\}} if \tcd{C} is a subclass of \tcd{D} and
\tcd{c} entails \tcd{d}.  See \cite{constrained-types}
for more details.

In this paper, we generalize these types to allow \emph{type
properties} and constraints on these properties.
Like a value property, a type property is an instance member.
The type properties of an object are bound to concrete types
when the object is
created.
Types may be defined by constraining the type properties as
well as the value properties of a class.

The following code declares a class \tcd{Cell} with a type property \xcd{T}.
\begin{displayxten}
class Cell[T] {
    var x: T;
    def this[T](x: T) { property[T](); this.x = x; }
    def get(): T = x;
    def set(val x: T) = { this.x = x: }
}
\end{displayxten}
The class has a mutable field \xcd{x}, a constructor that
initializes \xcd{x}, a getter method, and a setter method.

Type properties are types in their own right: 
they may be used in any context a type may be used,
including in \tcd{instanceof} and cast expressions.
Since type properties are instance members, for an expression
\tcd{e} of type \tcd{Cell}, \xcd{e.T} is a type.  To ensure
soundness, \tcd{e} is restricted to final access paths.
Within the body of a class, a property name \tcd{T} resolves
to \xcd{this.T} (or to \xcd{C.this.T} if \xcd{T} is a property of
an enclosing class \xcd{C}), just as value properties are
resolved.

\section{Constrained types}

\begin{figure}
\begin{center}
\begin{tabular}{rcl}
\emph{Constraint}     & ::=  & \emph{Expression} \\
                      & \bnf & \emph{Type}~\xcd{==} \emph{Type} \\
                      & \bnf & \emph{Type}~\xcd{<=} \emph{Type} \\
                      & \bnf & \emph{Type}~\xcd{>=} \emph{Type} \\
\ifhas
                      & \bnf & \emph{Type}~\xcd{has}~\emph{Signature} \\
\fi
                      & \bnf & \emph{Constraint}~\xcd{,}~\emph{Constraint} \\
                      & \bnf & \xcd{true} \\
\ifhas
\emph{Signature}      & ::=  & \emph{MethodSignature} \\
                      & \bnf & \emph{ConstructorSignature} \\
                      & \bnf & \emph{PropertySignature} \\
\emph{MethodSignature}& ::=  &
                [\xcd{static}]~\xcd{def}~\emph{Identifier}~\xcd{(}~[\emph{TypesOrFormals}]~\xcd{)} \xcd{:}~\emph{Type} \\
\emph{ConstructorSignature}& ::=  &
                \xcd{def}~\xcd{this}~\xcd{(}~[\emph{TypesOrFormals}]~\xcd{)} \xcd{:}~\emph{Type} \\
\emph{PropertySignature}& ::=  &
                [\xcd{val}]~\emph{Identifier}\xcd{:}~\emph{Type} \\
\emph{TypesOrFormals} & ::=  & \emph{TypeOrFormal} \\
                      & \bnf & \emph{TypeOrFormals}~\xcd{,}~\emph{TypeOrFormal} \\
\emph{TypesOrFormal}  & ::=  & \emph{Type} \\
                      & \bnf & \emph{Formal} \\
\fi
\end{tabular}
\end{center}
\caption{Constraint grammar}
\label{fig:constraints}
\end{figure}

In general, the syntax of a constrained type is
\xcd{C\{c\}}, where \xcd{C} is a base class and
\xcd{c} is a predicate on the properties of \xcd{C}.
Type constraints are type equality and subtyping predicates.
For (slight) brevity, the constraint
\xcd{c1}~\xcd{&&}~\xcd{c2} can be written
\xcd{c1,}~\xcd{c2}.  The grammar for constraints is shown in
Figure~\ref{fig:constraints}.
%
The following are legal types:
\begin{itemize}
\item \xcd{Cell}.  This type has no constraints on \tcd{T}.
Any type that constraints \tcd{T}, including the three below,
is a subtype of \tcd{Cell}.  The type \xcd{Cell} is equivalent to
\xcd{Cell\{true\}}.
%
For a \xcd{Cell} \xcd{c}, the return type of the \xcd{get} method 
is \xcd{c.T}.  
Since the property \xcd{T} is unconstrained,  
the caller can only assign the return value of \xcd{get}
to a variable of type \xcd{c.T} or of type \xcd{Object}.
In the following code, \xcd{y} cannot be passed to the \xcd{set} method
because it is not known if \xcd{Object} is a subtype of \xcd{c.T}.
\begin{displayxten}
val x: c.T = c.get();
val y: Object = c.get();
c.set(x); // legal
c.set(y); // illegal
\end{displayxten}

\item \xcd{Cell\{T==float\}}.
The type property \tcd{T} is bound to \tcd{float}.
Assuming \tcd{c} has this type, the following code is legal:
\begin{displayxten}
val x: float = c.get();
c.set(1.0);
\end{displayxten}
The type of \xcd{c.get()} is \xcd{c.T}, which is equivalent to
\xcd{float}.
Similarly, the \tcd{set} method takes a \xcd{float} as argument.

\item \xcd{Cell\{T<=int\}}.
This type constrains \xcd{T} to be a subtype of \xcd{int}.
All instances of this type must bind \xcd{T} to a subtype of \tcd{int}.
The following expressions have this type:
\begin{displayxten}
new Cell[int](1);
new Cell[int{self==3}](3);
\end{displayxten}
The cell in the first expression may contain any \tcd{int}.
The cell in the second expression may contain only \tcd{3}.
%
If \tcd{c} has the type \xcd{Cell\{T<=int\}},
then \xcd{c.get()} has type \xcd{c.T}, which is an unknown but
fixed subtype of \tcd{int}.  The \xcd{set} method of \tcd{c} can
only be called with an object of type \xcd{c.T}.

\item \xcd{Cell\{T>=String\}}.  This type bounds the type property
\tcd{T}
from below.  The \xcd{set} method may be called with any
supertype of \tcd{String}; the return type of the \xcd{get}
method is known to be a
supertype of \tcd{String} (and implicitly a subtype of \tcd{Object}).

\ifhas
\item \xcd{Cell\{T has equals(T):boolean\}}.  Instances of this type can
only be instantiated on types with an \tcd{equals} method.
See Section~\ref{sec:structural} for more details on structural
constraints.
\fi
\end{itemize}

For brevity, the constraint may be omitted and
interpreted as \tcd{true}.
The syntax 
\xcd{C[T1,...,Tm](e1,...,en)} is sugar for
\xcd{C\{X1==T1,...,Xm==Tm,x1==e1,...,xn==en\}}
where \xcd{Xi} are the type properties and \xcd{xi} are the
value properties of \xcd{C}.  
If either list of properties is empty, it may be omitted.

In this shortened syntax, a type \tcd{T} used may also be annotated
with
a \emph{use-site variance tag}, either \tcd{+} or \tcd{-}:
if \xcd{X} is a type property, then
the syntax \xcd{C[+T]} is sugar \xcd{C\{X<=T\}} and
\xcd{C[-T]} is sugar \xcd{C\{X>=T\}}; of course,
\xcd{C[T]} is sugar \xcd{C\{X==T\}}.

\if 0
\section{Typing}

As stated above, if \xcd{p} is a final access path of a
type with property \xcd{T}, then \xcd{p.T} is a legal type.
Given an expression context \xcd{E}$[\cdot]$, if
the expression \xcd{E}$[{\tt x}]$ has type \xcd{x.T},
then the expression \xcd{E}$[{\tt e}]$ has type \xcd{z.T},
where ${\tt z} = {\tt e}$ if \xcd{e} is a final access path
or else \xcd{z} is a fresh variable.
\fi

\section{Class definitions}

Classes may be declared with any number of type properties and
value properties.  These properties can be constrained with a
\emph{class invariant}, specified by a \xcd{where} clause,
a predicate on the properties of any instance of the class.
%
The general form of a class definition is:
\begin{displayxtenmath}
class C[X$_1$, $\dots$, X$_p$](x$_1$: T$_1$, $\dots$, x$_k$: T$_k$)
      where c
      extends B{c$_0$}
      implements I$_1${c$_1$}, $\dots$, I$_n${c$_n$} {$\dots$}
\end{displayxtenmath}

\subsection{Definition-site variance}

In a class definition, 
a type property may be declared with a \emph{definition-site variance tag}, either \xcd{+} or
\xcd{-}.  A \xcd{+} tag indicates that the class is covariant on
the property; that is, given a definition
\xcd{Cell[+T]},
if \xcd{A} $\subtype$ \xcd{B}, then
\xcd{Cell[A]} $\subtype$ \xcd{Cell[B]}.
Similarly,
\xcd{Cell[-T]} indicates that \xcd{T} is contravariant in \xcd{Cell};
that is, if \xcd{A} $\subtype$ \xcd{B}, then
\xcd{Cell[B]} $\subtype$ \xcd{Cell[A]}.

A definition-site variance tag changes the meaning of the
syntactic sugar for the type \xcd{Cell[A]}.
If the property is covariant (\xcd{+T}), \xcd{Cell[A]}
is sugar for \xcd{Cell\{T<=A\}}.
If the property is contravariant (\xcd{-T}), \xcd{Cell[A]}
is sugar for \xcd{Cell\{T>=A\}}.
Otherwise, the property is invariant and \xcd{Cell[A]}
is sugar for \xcd{Cell\{T==A\}}.

The compiler should issue a warning if 
a covariant property is used in a negative position
in its class definition,
or if a contravariant property is used in a positive position.
Without these restrictions, methods or fields with types
dependent on the property would be safe, but not be accessible 
using the default instantiation (e.g., \xcd{Cell[int]}).

\if 0
More formally, a type property cannot be used in a position
where its actual variance differs from its declared variance.

\infrule{
\vdash_{+} T
\vdash_{-} T
}{
var x : T = e
}

\infrule{
\vdash_{+} T
}{
val x : T = e
}

\infrule{
\vdash_{-} T1
\vdash_{+} T2
\vdash_{-} c
}{
def f(x: T1) : T2 where c = e
}

\infrule{
\vdash_{+}
}{}
\fi

%
A type appears in a negative position if:
\begin{itemize}
\item it is the type of a mutable or immutable field; or,
\item it is the type of a method formal parameter; or,
\item it appears in a constraint on a type that is in a negative position 
and the constraint bounds it from above; or,
\item it appears in a constraint on a type that is in a positive position 
and the constraint bounds it from below.
\end{itemize}
%
A type appears in a positive position if:
\begin{itemize}
\item it is the type of a immutable field; or,
\item it is a method return type; or,
\item it appears in a constraint on a type that is in a negative position 
and the constraint bounds it from below; or,
\item it appears in a constraint on a type that is in a positive position 
and the constraint bounds it from above.
\end{itemize}

\section{Method parameters}

Methods and constructors may have type parameters.
For instance, the following class defines a \xcd{map}
function for a list that maps each element of the list
to a value of another type, constructing a new list.
\begin{displayxten}
class List[T] {
    val array: Array[T];
    def map[S](f: T => S): List[S] {
        val newArray = new Array[S](array.length);
        for (i in [0:array.length-1]) {
            newArray(i) = f(array(i));
        }
        return new List(newArray);
    }
}
\end{displayxten}


A parameterized method may is invoked by giving type arguments before the 
expression arguments.  For example:
\begin{displayxten}
xs: List[String] = ...;
ys: List[int] = xs.map[int]((x: String) => x.length());
\end{displayxten}

Method parameters and properties of the enclosing class
can be constrained with a where clause on the method.
This feature is similar to the generlized constraints proposed for
C\#~\cite{emir06}.
%
In the following code, the \xcd{T} parameter is covariant
and so the \xcd{append} methods below are illegal:
\begin{displayxten}
class List[+T] {
   def append(other: T): List[T] = { ... }        // illegal
   def append(other: List[T]): List[T] = { ... }  // illegal
}
\end{displayxten}
%
However, one can introduce a method parameter and then constrain
the parameter from below by the class's parameter:
For example, in the following code,
\begin{displayxten}
class List[+T] {
   def append[U](other: U): List[U] where T <= U = { ... }
   def append[U](other: List[U]): List[U] where T <= U = { ... }
}
\end{displayxten}

The constraints must be satisfied by the callers of \xcd{append}.
For example, in the following code:
\begin{displayxten}
xs: List[Number];
ys: List[Integer];
xs = ys; // ok
xs.append(1.0); // legal
ys.append(1.0); // illegal
\end{displayxten}
the call to \xcd{xs.append} is allowed and the result type is \xcd{List[Number]}, but
the call to \xcd{ys.append} is not allowed because the caller cannot show that
${\tt Number} \subtype {\tt Double}$.

\section{Constructor definitions}

A constructor is defined with the following syntax:

\medskip

\begin{tabular}{rcl}
\emph{ConstructorDef}& ::=  &
                \xcd{def}~\xcd{this}~\xcd{(}~[\emph{Formals}]~\xcd{)}
                [\xcd{:}~\emph{Type}] \\
                & & \quad \xcd{where}~\emph{Constraint}~\xcd{=}~\emph{ConstructorBlockOrExpression} \\
\end{tabular}

\medskip

Constructors must ensure that the class invariants of the given
class and its superclasses and superinterfaces hold.
For instance, the
constructor for \xcd{Cell} ensures that the type property
\xcd{T} is bound.
\begin{displayxten}
    def this[T](x: T) { property[T](); this.x = x; }
\end{displayxten}
The \xcd{property} statement is used to set all the properties
of the new object simultaneously; the syntax is similar to a \xcd{super}
constructor call.  

If the \xcd{property} statement is omitted, the compiler implicitly
initailizes the properties from the formal type and value parameters
of the constructor.  The property statement for \xcd{Cell}'s constructor,
for example, could have been omitted.

Constructors have ``return
types'' that can specify an invariant satisfied by the object being
constructed.  The compiler verifies that the
constructor return type and the class invariant are implied by the
\xcd{property} statement and any \xcd{super}
or \xcd{this} calls in the constructor body.

Classes that do not declare a constructor 
have a default constructor with a type parameter for each
type property and a value parameter for each value property.


\section{Type inference}

X10 performs type inference of local variable
types and of type arguments for method and constructor calls.%
\footnote{We describe here the results that the type
inference algorithm should produce, but not the algorithm itself since
we have not derived it yet.}

The algorithm infers a type for a local variable by
type-checking the variable initializer and assigning
that type to the variable.
When checking calls with omitted type arguments,
the algorithm attempts to find an instantiation of the type
parameters for which the call will type check.

Consider the following method from \cite{adding-wildcards}:
\begin{displayxten}
def choose[T](a: T, b: T): T { ... }
\end{displayxten}
%
In the following snippet, we should infer the type
\xcd{Collection} for \xcd{x}.
\begin{displayxten}
intSet: Set[int];
stringList: List[String];
val x = choose(intSet, stringList);
\end{displayxten}
%
And in this snippet, we should infer the type
\xcd{Collection[int]} for \xcd{y}.
\begin{displayxten}
intSet: Set[int];
intList: List[int];
val y = choose(intSet, intList);
\end{displayxten}
%
Finally, in this snippet, we should infer the type
\xcd{Collection\{T <= Number\}} for \xcd{z}.
\begin{displayxten}
intSet: Set[int];
numList: List{T <= Number};
val z = choose(intSet, numList);
\end{displayxten}

The inference algorithm for Java 5 produces analogous results.
Another possible algorithm on which to base our inference algorithm
is the one
for C\# described by Bierman et al.~\cite{csharp3}.
A key difference is that X10 supports where clauses that
constrain the method type and value arguments.

Now, consider the following example:
\begin{displayxten}
def union[T](a: Set[T], b: Set[T]) : Set[T];
\end{displayxten}
The union method cannot be called with just arguments of type \xcd{Set}.
\begin{displayxten}
set1: Set;
set2: Set;
val a = union(set1, set2);
\end{displayxten}
This is illegal because the type system cannot demonstrate that
\xcd{set1.T} and \xcd{set2.T} are equal.
The following, however, is acceptable:
\begin{displayxten}
set1: Set;
set2: Set[set1.T];
val a = union(set1, set2);
\end{displayxten}

As another example from \cite{adding-wildcards}, consider
the following method signature:
\begin{displayxten}
def unmodifiableSet[T](set: Set[T]): Set[T];
\end{displayxten}

In Java, this method could be called with an argument of
type \xcd{Set<?>}.
This instantiates the method on \xcd{?}; that is, the
wildcard is captured by the call, since any element type will be
safe.  A type variable can capture only one wildcard.

In X10, the method can be called with just a \xcd{Set} because there
are no constraints on \xcd{T}.  Using desugared syntax, the method is
equivalent to: 
\begin{displayxten}
def unmodifiableSet[T](set: Set{self.T==T}): Set{self.T==T};
\end{displayxten}
Any \xcd{Set} can be passed in: for an argument \xcd{e}, the method
is instantiated on \xcd{e.T}.
%
Note that if this method were defined as:
\begin{displayxten}
def unmodifiableSet(set: Set): Set;
\end{displayxten}
then the connection between the element types of the
argument and of the return types would be broken.
However, in X10, one could write use the following signature to keep the
connection:
\begin{displayxten}
def unmodifiableSet(set: Set): Set[set.T];
\end{displayxten}

\section{Discussion}

\subsection{Type properties versus type parameters}

Type properties are similar, but not identical to type parameters.  The
differences may potentially confuse programmers used to Java generics or C++
templates.  The key difference is that type properties are instance members and
are thus accessible through access paths: \xcd{e.T} is a legal type.

Type properties, unlike type parameters, are inherited.
For example, in the following code, \xcd{T} is defined in \xcd{List}
and inherited into \xcd{Cons}.  The property need not be
declared by the \xcd{Cons} class.
\begin{displayxten}
class List[T] { }
class Cons extends List {
    def head(): T = { ... }
    def tail(): List[T] = { ... }
}
\end{displayxten}
The analogous code for \xcd{Cons} using type parameters would be:
\begin{displayxten}
class Cons[T] extends List[T] {
    def head(): T = { ... }
    def tail(): List[T] = { ... }
}
\end{displayxten}
% This code is perfectly acceptable in X10 as well, but introduces a redundant
% type property \xcd{T} equal to the \xcd{T} inherited from \xcd{List}.

We can make the type system behave as if type properties were
type parameters very simply.  We need only make the syntax \xcd{e.T}
illegal and permit type properties to be accessible only
from within the body of their class definition via the implicit \xcd{this}
qualifier.

\subsection{Wildcards}

Wildcards in Java~\cite{Java3,adding-wildcards} were motivated
by the following example (rewritten in X10 syntax)
from \cite{adding-wildcards}.
Sometimes a class needs a field or method
that is a list, but we don't care what the element type is.
For methods, one can give the method a type parameter:
\begin{displayxten}
def aMethod[T](list: List[T]) = { ... }
\end{displayxten}
This method can then be called on any \xcd{List} object.
However, there is no way to do this for fields since they
cannot be parameterized.
Java introduced wildcards to allow such fields to be 
typed:
\begin{displayxten}
List<?> list;
\end{displayxten}
In X10, a similar effect is achieved by not constraining the
type property of \xcd{List}.
One can write the following:
\begin{displayxten}
list: List;
\end{displayxten}
Similarly, the method can be written without type parameters by
not constraining \xcd{List}:
\begin{displayxten}
def aMethod(list: List) = { ... }
\end{displayxten}

In X10, \xcd{List}
is a supertype of
\xcd{List[T]} for any \xcd{T},
just as in Java
\xcd{List<?>} is a supertype of
\xcd{List<T>} for any \xcd{T}.
This follows directly from the definition of the type \xcd{List}
as \xcd{List\{true\}}, and the type \xcd{List[T]}
as \xcd{List\{X==T\}}, and the definition of subtyping.

Wildcards in Java can also be bounded.
We achieve the same
effect in X10 by using type constraints.
For instance, the following Java declarations:
\begin{displayxten}
void aMethod(List<? extends Number> list) { ... }
<T extends Number> void aParameterizedMethod(List<T> list) { ... }
\end{displayxten}
may be written as follows in X10:
\begin{displayxten}
def aMethod(list: List{T <= Number}) = { ... }
def aParameterizedMethod[T{self <= Number}](list: List[T]) = { ... }
\end{displayxten}

Wildcard bounds may be covariant, as in the following example:
\begin{displayxten}
List<? extends Number> list = new ArrayList<Integer>();
Number num = list.get(0);     // legal 
list.set(0, new Double(0.0)); // illegal
list.set(0, list.get(1));     // illegal
\end{displayxten}
This can also be written in X10, but with an important 
difference:
\begin{displayxten}
list: List{T <= Number} = new ArrayList[Integer]();
num: Number = list.get(0);    // legal 
list.set(0, new Double(0.0)); // illegal
list.set(0, list.get(1));     // legal! (when list is final)
\end{displayxten}
Note because \xcd{list.get} has return type \xcd{list.T}, the
last call in above is well-typed in X10; the analogous call in
Java is not well-typed.

Finally,
one can also specify lower bounds on types.  These are useful for
comparators:
\begin{displayxten}
class TreeSet[T] {
    def this[T](cmp: Comparator{T >= this.T}) { ... }
}
\end{displayxten}
Here, the comparator for any supertype of \xcd{T} can be used as
to compare \xcd{TreeSet} elements.

Another use of lower bounds is for list operations.
The \xcd{map} method below takes a function that maps a supertype
of the class parameter \xcd{T} to the method type parameter \xcd{S}:
\begin{displayxten}
class List[T] {
    def map[S](fun: Object{self >= T} => S) : List[S] = { ... }
}
\end{displayxten}

\subsection{Proper abstraction}

Consider the following example adapted from \cite{adding-wildcards}:
\begin{displayxten}
def shuffle[T](list: List[T]) = {
    for (i: int in [0..list.size()-1]) {
        val xi: T = list(i);
        val j: int = Math.random(list.size());
        list(i) = list(j);
        list(j) = xi;
    }
}
\end{displayxten}
The method is parameterized on \xcd{T} because the method body needs
the element type to declare the variable \xcd{xi}.

However, the method parameter can be omitted by using the type \xcd{list.T}
for \xcd{xi}.  Thus, the method can be declared with the signature:
\begin{displayxten}
def shuffle(list: List) { ... }
\end{displayxten}
This is called \emph{proper abstraction}.

This example illustrates a key difference between type properties
and type parameters:
A type property is a member of its class, whereas a type parameter is
not.  The names of type properties are visible outside the body of
their class declaration.

\if 0
Type properties can be used as the basis of a parameterized type
system.  This is done simply by making type properties private.
Using the syntactic sugar described above,
the resulting system behaves identically to a system with type
parameters.
\fi

In Java,
Wildcard
capture allows the parameterized method to be called with any \xcd{List},
regardless of its parameter type.
However,
the method parameter cannot be omitted: declaring a parameterless version
of shuffle requires delegating to a private parameterized version that 
``opens up'' the parameter.

\subsection{Virtual types}

Type properties share many similarities with virtual types~\cite{mp89-virtual-classes,beta}, particularly 
with sound formulations of virtual types using path-dependent types,
as found in gbeta~\cite{ernst99-gbeta}, Scala~\cite{scala}, 
and J\&~\cite{nqm06}.
%
Constrained types are more expressive than virtual
types since they can be constrained at the use-site,
can be refined on a per-object basis without explicit subclassing,
and can be refined contravariantly
as well as covariantly.

Thorup~\cite{thorup97}
proposed adding genericity to Java using virtual types.  For example,
a generic \xcd{List} class can be written as follows:
\begin{displayxten}
abstract class List {
    abstract typedef T;
    void add(T element) { ... }
    T get(int i) { ... }
}
\end{displayxten}
This class can be refined by bounding the virtual type \xcd{T} above:
\begin{displayxten}
abstract class NumberList extends List {
    abstract typedef T as Number;
}
\end{displayxten}
And this abstract class can be further refined to \emph{final bind}
\xcd{T} to a particular type:
\begin{displayxten}
class IntList extends NumberList {
    final typedef T as Integer;
}
\end{displayxten}
These classes are related by subtyping:
${\tt IntList} \subtype {\tt NumberList} \subtype {\tt List}$.
Only classes where \xcd{T} is final bound can be non-abstract.

In X10, an analogous \xcd{List} class would be written as follows:
\begin{displayxten}
class List[T] {
    def add(element: T) = { ... }
    def get(i: int): T = { ... }
}
\end{displayxten}

\xcd{NumberList} and \xcd{IntList} can be written as follows:
\begin{displayxten}
class NumberList extends List{T<=Number} { }
class IntList extends NumberList{T==Integer} { }
\end{displayxten}

However, note that X10's \xcd{List} is not abstract.
Instances of \xcd{List}
can instantiate \xcd{T} with a particular type and there is no need to declared classes for \xcd{NumberList} and \xcd{IntList}.  Instead, one can use the types
\xcd{List[+Number]} and \xcd{List[Integer]}.

Unlike virtual types, type properties can be refined contravariantly.
For instance, one can write the type \xcd{List[-Integer]},
and even \xcd{List\{Integer<=T, T<=Number\}}.


\if 0
\subsection{Definition-site variance}

\begin{displayxten}
class List[+T] {
    def head(): T { ... }
    def tail(): List[T] { ... }
}
\end{displayxten}

Disadvantage is that \xcd{T} cannot appear in negative positions.
Cannot write:

\begin{displayxten}
    def prepend(x: T): List[T] { return new List[T](x, this); }
\end{displayxten}

But we can have this:
\begin{displayxten}
    def prepend[S: S==T](x: S): List[T] { return new List[T](x, this); }
\end{displayxten}

Then:
\begin{displayxten}
xs: List[Number];   // same as List[:T<=Number]
ys: List[Integer];  // same as List[:T<=Integer]
xs = ys;            // ok since List[:T<=Number] >= List[:T<=Integer]
xs = xs.prepend(1); // not ok; can't prove int <= xs.T
\end{displayxten}

We should probably disallow \xcd{prepend[S: S==T]} also.
And disallow \xcd{prepend[S: S<=T]}.
But allow \xcd{prepend[S: S>=T]}.

When checking if a constraint is satisfiable, need to tag
variance into account.

So: 
\begin{verbatim}
T covariant, S==T |- S covariant
\end{verbatim}

Can we fold variance into the constraints?

        If T is on the left of <= constraint, it's positive
        and so should be restricted

\begin{verbatim}
T covariant means: Gamma = this : U, U <= List[T]
T invariant means: Gamma = this : List[T]
\end{verbatim}

Can have covariant fields, too:

\begin{displayxten}
class C[+T] {
    x: T;
}

a: C[Number] 
b: C[Integer] 
c: C[:T==Integer];
a = b = c;
a.x = 1; // fails!
a.x;     // ok, with type Number
c.x:     // ok, with type Integer
c.x = 1: // ok!
\end{displayxten}

Now:

\xcd{C[+T]} simply means that \xcd{C[X]} is sugar for \xcd{C[:T<=X]}.
And we restrict the negative occurrences of the parameter; but
this is redundant, since the methods cannot be invoked.

\begin{displayxten}
class C[T] {
    T get();
    set(T);
    foo[U](U : T <= U);
}

C[T<=Number] a;
C[T<=Integer] b;
a = b; // ok since T<=Integer ==> T<=Number
a.get(); // ok: type is Number
a.set(1); // fail: T <= Number, 1 : Integer =/=> 1: T
a.foo(1); // ok: foo[Number], T <= Number
\end{displayxten}
\fi


\if 0
\section{Introspection}

\xcd{Cell[Cell[T<=A]]}

If not invariant, need run-time constraint solving.
\fi

\section{Structural constraints}
\label{sec:structural}

The language PolyJ~\cite{polyj} allows type parameters to be bounded using
structural where clauses.
For example, a sorted list class in PolyJ can be written as follows:
\begin{displayxten}
class SortedList[T] where T { int compare(T) } {
    void add(T x) { ... x.compare(y) ... }
}
\end{displayxten}
The where clause states that the type parameter \xcd{T} must have a
method \xcd{compare} with the given signatures.

To support this, X10 provides structural constraints on types.
The analogous X10 code for \xcd{SortedList} is:
\begin{displayxten}
class SortedList[T] where T has compare(T): int {
    def add(x: T) = { ... x.compare(y) ... }
}
\end{displayxten}

A structural constraint is of the form \emph{Type}~\xcd{has}~\emph{Signature}.
A constraint is satisfied if the type has a member of the appropriate name
and with a compatible type.  
The constraint \xcd{X has f(T1): T2}
is satisfied by a type \xcd{T} if it has a method \xcd{f}
whose type is a subtype of \xcd{(T1 => T2)}$[{\tt T}/{\tt X}]$.
As an example,
the constraint \xcd{X has equals(X): boolean}
is satisfied by all three of the following classes:
\begin{displayxten}
class C { def equals(x: C): boolean; }
class D extends C { }
class E { def equals(x: Object): boolean; }
\end{displayxten}

By using function types and where clauses on constructors,
X10 can go further than PolyJ.
Unlike in PolyJ, where the \xcd{compare} method must be provided by \xcd{T},
in X10 the \xcd{compare} function can be external to \xcd{T}.
This is achieved as follows:
\begin{displayxten}
class SortedList[T] {
    val compare: (T,T) => int;
    def this(cmp: (T,T) => int) = { compare = cmp; }
    def add(x: T) = { ... compare(x,y) ... }
}
\end{displayxten}

This permits 
\xcd{SortedList} to be instantiated using different compare functions:
\begin{displayxten}
val unixFiles    = new SortedList[String]
                        (String.compareTo.(String));
val windowsFiles = new SortedList[String]
                        (String.compareToIgnoreCase.(String));
\end{displayxten}

But, a problem with this approach is that the compare function must be
provided to the constructor at each instantiation of \xcd{SortedList}.
The problem can be resolved by using constructors with different
structural constraints:
\begin{displayxten}
class SortedList[T] {
    val compare: (T,T) => int;
    def this[T]() where T has compareTo(T): int = {
        this[T](T.compareTo.(S));
    }
    def this[T](cmp: (T,T) => int) = { compare = cmp; }
    def add(x: T) = { ... compare(x,y) ... }
}
\end{displayxten}
Now, \xcd{SortedList} can be instantiated with any type that has
a \xcd{compareTo}
method without expliclty specifying the method at each constructor call.

\section{Type definitions}

X10 supports type definitions with the following syntax:

\medskip

\begin{tabular}{rcl}
\emph{TypeDef}     & ::=  &
        \xcd{type}
        \emph{Identifier}
        \xcd{[}
        \emph{TypeParameters}
        \xcd{]}
        \xcd{(}
        \emph{FormalParameters}
        \xcd{)}
        \xcd{=}
        \emph{Type}
        \xcd{;}
\\
\end{tabular}

\medskip

A type definition can be thought of as a type-valued function.
Type definitions may be parameterized on types and on values.
%
The following examples are legal type definitions:
\begin{displayxten}
type Variable = int;
type int(x: int) = int{self==3};
type int(lo: int, hi: int) = int{lo <= self, self <= hi};
type StringSet = Set[String];
type ListMap[K,V] = Map[K,List[V]];
\end{displayxten}

Type definitions may appear as class members or in the body of a method, constructor, or initializer.
Type definitions that are members of a class are \xcd{static}; type properties
can be used for non-static type definitions.

Type definitions are applicative, not generative; that is, they
are define aliases for types and do not introduce new types.
Thus, the following code is legal:
\begin{displayxten}
type A = int;
type B = String;
type C = String;
a: A = 3;
b: B = new C("Hi");
c: C = b + ", Mom!";
\end{displayxten}
A type defined by a type definition 
has the same constructors as its defining type.

\subsection{(Pseudo) generative type definitions}

Annotations~\cite{ns07-x10anno} may be used to make type definitions
generative (upto annotation erasure).  In the following, \xcd{@tag}
annotation restricts how the annotated type can be used: types
with distinct tags are incomparable.
Thus,
\begin{displayxten}
type Variable = int@tag("Variable");
a: Variable = (Variable) 4; // legal
b: Variable = 3; // illegal
c: int = a; // illegal
\end{displayxten}
We could introduces variations on \xcd{@tag} that
indicate that the tagged type is a subtype or supertype of the
untagged type, thus allowing the assignments to \xcd{c}
and to \xcd{b} respectively.

\section{Semantics}

\input{semantics}

\section{Implementation}

This section describes a possible implementation approach that
performs
run-time instantiation of classes, similar to the implementation
of parameterized classes in NextGen~\cite{allen03,allen04}.
We describe only the translation to Java; an obvious
translation strategy for the C++ backend would use templates.
Another possible translation, 
based on the implementation of PolyJ~\cite{polyj},
uses \emph{adapter objects} to allow generic code to invoke
methods of instances of the its type properties.

Consider the following code:
\begin{displayxten}
class C[T] {
    var x: T;
    def this[T](x: T) { property[T](); this.x = x; }
    def set(x: T) { this.x = x; }
    def get(): T { return this.x; }
    def map[S](f: T => S): S { return f(this.x); }
    def d() { return new D[T](); }
    def t() { return new T(); }
    def isa(y: Object): boolean { return y instanceof T; }
    static def isa2[S](y: Object): boolean { return y instanceof S; }
}

val x : C = new C[String]();
val y : C[int] = new C[int]();
val z : C[T <= Object] = new C[Array[int]]();
x.map[int](f);
C.isa2[int](3);
new C[int{self==3}]() instanceof C[int{self<4}];
\end{displayxten}

\subsection{Eliminating method type parameters}

The first step in translation is to remove method parameters by
introducing generic inner class for each generic method.
Constructor type parameters are not changed.
In addition, function type \xcd{T => S} is translated to \xcd{Fun1[T,S]}.
This step produces the following code:
\begin{displayxten}
class C[T] where T has T() {
    var x: T;

    def this[T](x: T) { property[T](); this.x = x; }

    def set(x: T) { this.x = x; }
    def get(): T { return this.x; }

    def d() { return new D[T](); }
    def t() { return new T(); }

    def isa(y: Object): boolean { return y instanceof T; }

    // Translation of map to an inner class
    class map$[T,S] {
        def apply(c: C[T], f: Fun1[T,S]) { return f(c.x); }
    }

    // Translation of isa2 to an inner class
    static class isa2$[S] {
        def apply(y: Object): boolean { return y instanceof S; }
    }
}

val x : C = new C[String]();
val y : C[int] = new C[int]();
val z : C[T <= Object] = new C[Array[int]]();
new map$[x.T,int]().apply(x,f);
new C.isa2$[int]().apply(y);
new C[int{self==3}]() instanceof C[int{self<4}];
\end{displayxten}
At this point, the code consists only of generic classes.
The remaining translation introduces a run-time representation
for the type properties of these classes.

\subsection{Run-time instantiation}

In this translation the type properties are represented as
instances of a \xcd{Type} class, analogous to \xcd{java.lang.Class}. 
Each generic class has a \xcd{Type}-typed field for each of
its type properties initialized by the class's constructor.
The \xcd{Type} objects
are used to implement {\tt instanceof} and cast operations.
\begin{displayxten}
interface Type {
    boolean instanceof$(Object x);
    <T> T cast$(Object x);
}
\end{displayxten}

In this translation, which is partially based on the
NextGen~\cite{allen03,allen04} translation,
a generic class is translated into a \emph{base interface} and
a \emph{template class} that implements the base interface.
At runtime, the first time a generic class is instantiated
a class loader loads \emph{template class}, rewriting the
bytecode to instantiate the type properties as appropriate.

For example, the 
code for class {\tt C} above is translated into the following template class.
When instantiating the template, the string ``{\tt \{0\}}'' is
substituted with the name of the actual type
property.\footnote{In a real implementation, the names would be
mangled as appropriate.}
Since methods of {\tt C} can be called in a context where the
property instantiation is not known, 
each method in the template class has to be implemented twice:
once with an Object interface and once with an instantiated
interface.

\begin{displayxten}
class C$Type implements Type {
    static Type it = new C$Type();
    boolean instanceof$(Object x) { return x instanceof C; }

    static Map<Type,Type> instantiations;

    static Type instantiate$(Type T) {
        instantiations.get(T);
    }
}

class C{0}$Type implements Type {
    static Type it = new C{0}$Type();
    boolean instanceof$(Object x) { return x instanceof C{0}; }
}

interface C {
    void set$(Object x);
    Object get$();
    D d$();
    Object t$();
    boolean isa$(Object y);
}

class C{0} implements C {
    final Type T = {0}$Type.it;
    {0} x;
    C{0}({0} x) { this.x = x; }

    void set$(Object x) { set(({0}) x); }
    void set({0} x) { this.x = x; }

    Object get$() { return ({0}) get(); }
    {0} get() { return this.x; }

    D d$() { return d(); }
    D{0} d() { return new D{0}(); }

    Object t$() { return t(); }
    {0} t() { return new {0}(); }

    boolean isa(Object y) { return T.instanceof$(y); }

    static class map$Type extends Type {
        ...
        static map$Type instantiate$(Type T, Type S) { ... }
    }

    static class map$Type{0}{1} extends Map$Type {
        map$ new$() { return new map${0}{1}(); }
    }
    
    interface map$ {
        Object apply$(C c, Fun1 f);
    }

    class map${0}{1} implements map$ {
        final Type T = {0}$Type.it;
        final Type S = {1}$Type.it;
        Object apply$(C c, Fun1 f) { return apply((C{0}) c, (Fun1{0}{1}) f); }
        {1} apply(C{0} c, Fun1{0}{1} f) { return f(c.x); }
    }

    static interface isa2$ {
        boolean apply$(Object y);
    }

    static class isa2${0} implements isa2$ {
        final java.lang.Class S = {0}$Type.it;
        boolean apply$(Object y) { return apply(y); }
        boolean apply(Object y) { return S.instanceof$(y); }
    }
}

C x = new C$String();
C$int y = new C$int();
C z = new C$Array$int();
C.map$Type.instantiate$(x.T, int$Type.it).new$().apply$(x,f);
C.isa2$int.apply(y);
C$int$self$lt$4.instanceof$(new C$int$self$eqeq$3());
\end{displayxten}

We translate \xcd{instanceof} and cast operations to calls to
methods of a \xcd{Type} because the actual implementation of
the operation may require run-time constraint solving or other
complex code that cannot be easily substituted in when rewriting
the bytecode during instantiation.




\if 0
They support the following interface:

In this translation the type properties are represented as
instances of \xcd{Type} objects analogous to \xcd{java.lang.Class}.
They support the following interface:

\begin{displayxten}
interface Type {
    boolean subtype(Type t);
    boolean equals(Type t);
    boolean instanceof$(Object o);
}
\end{displayxten}
The methods of this interface are needed to
implement \xcd{instanceof} and cast operations.

Each concrete type has a class that implements the \xcd{Type}
interface.  These instances are passed into methods and
constructors with type parameters and are assigned to the type
properties of objects during construction.

For example, the \xcd{Type} for \xcd{String} is:

\begin{displayxten}
class String$Type implements Type {
    public boolean subtype(Type t) {
        return 
    }
    public boolean equals(Type t) {
        return this == t; // assuming we intern
    }
    public boolean instanceof$(Object o) {
        return o instanceof String;
    }
}
\end{displayxten}
The methods of this interface are needed to

\fi

\if 0

The \emph{adapter object} for a given instance
of a generic class
is responsible for allocating new
objects whose type depends on the type property of the generic
instance.  For instance, the adapter is responsible for
allocating the \xcd{D[T]} in method \xcd{d} above and for
allocating the \xcd{T} in method \xcd{t}.
%
Depending on the translation scheme, the adapter can also 
implement run-time introspection 
and dispatching for structural constraints.

\subsection{Run-time instantiation}

In this translation, the adapter for a given instantiation of a
property is simply a factory for the type.

For example, the adapter for \xcd{String}

\begin{verbatim}
need a run-time factory:

        new D[T]() --> D$type.it.new$(T);

class type {
    abstract boolean instanceof$(Object x);
}

class int$type extends type {
    boolean instanceof$(Object x) { return x instanceof Integer; }
    int cast$(Object x) { return (Integer) x; }
}

class String$type extends type {
    String new$() { return new String(); }
    boolean instanceof$(Object x) { return x instanceof String; }
    String cast$(Object x) { return (String) x; }
}

class D$type extends type {
    D new$(type T) { return new D${T}(T); }
}
\end{verbatim}

\subsection{Adapter object translation}

Type properties are represented as \emph{adapter objects}.
When an object is instantiated, an adapter is created for
each type passed to the constructor.  Adapters can usually be
implemented as singleton objects or cached in a hashtable to
reduce space or allocation time.
Adapters are also used to represent type parameters of methods.

The adapter is an instance of an adapter class. 
An abstract adapter class is created for each type property
for a given class declaration based on the class's type
constraints.  Each instantiation of \xcd{C[T]}
creates a subclass of the adapter class for \xcd{C}.


Adapter translation output:
\begin{displayxten}
class where$C$T {
    type T();
    boolean instanceof$(Object x);
    static where$C$T adapt(type T) {
        return new where$C${0}();
    }
}
class where$C$int extends where$C$T {
    type T() { return inttype; }
    static where$C$int it = new where$C$int();
    boolean instanceof$(Object x) { return T().instanceof$(x); }
}
class where$C$map$S {
    boolean instanceof$(Object x);
}
class C(where$C$T T) {
    Object x;
    C(where$C$T T, Object x) { property(T); this.x = x; }
    void set(Object x) { this.x = x; }
    Object get() { return this.x; }
    Object map(where$C$map$S S, f: Fun1) { return f(this.x); }
    D d() { return new D(where$D$T.adapt(T)); }
    T t() { return where$C$T.new$(); }
    boolean isa(Object y) { return T.instanceof$(y); }
    static boolean isa(where$C$isa$S S, Object y) { return S.instanceof$(y); }
}
new C(where$C$String.it);
new C(where$C$int.it);
new C(where$C$Array$int.it);
\end{displayxten}

Run-time instantiation translation output:
\begin{displayxten}
class where$C$T {
    boolean instanceof$(Object x);
}
class where$C$int extends where$C$T {
    static where$C$int it = new where$C$int();
    boolean instanceof$(Object x) { return x instanceof Integer; }
}
interface Fun1${0}${1}(where$Fun1$Domain D, where$Fun1$Range R) {
    abstract {1} apply({0} x);
}
class Fun1$T${1}(where$Fun1$Range R) {
    abstract {1} apply(Object x);
}
interface Fun1${0}$T(where$Fun1$Domain D, where$Fun1$Range R) {
    abstract {1} apply({0} x);
}
// Template class:
class C${0} {
    {0} x;
    C({0} x) { this.x = x; }
    void set({0} x) { this.x = x; }
    {0} get() { return this.x; }
    Object map(where$C$map$S S, f: Fun1$S${0}) { return f(this.x); }
    boolean isa(Object y) { return T.instanceof$(y); }
    static boolean isa(where$C$isa$S S, Object y) { return S.instanceof$(y); }
}
new C(where$C$String.it);
new C(where$C$int.it);
new C(where$C$Array$int.it);
\end{displayxten}


Need to widen permissions from package/protected to public in translation
to allow cross-package calls.

\fi



\nocite{unifying-genericity}
\nocite{adding-wildcards}
\nocite{emir06}
\nocite{myers94}
\nocite{polyj}
\nocite{allen04}
\nocite{allen03}
\nocite{beta}
\nocite{mp89-virtual-classes}
\nocite{thorup97}


\bibliographystyle{plain}
\bibliography{master}

% \appendix
% \onecolumn

% \section{An extended example}
% \input{longex}

\end{document}
