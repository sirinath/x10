%III. Applied constrained calculii. (3 pages)
%
%For each example below, formal static and dynamic semantics rules for
%new constructs extension over the core CFJ. Subject-reduction and
%type-soundness theorems. Proofs to be found in fuller version of
%paper.
%
%(a) arrays, region, distributions -- type safe implies no arrayoutofbounds
%exceptions, only ClassCastExceptions (when dynamic checks fail).
%
%Use Satish's conditional constraints example.
%-- emphasize what is new over DML. 
%
%(b) places, concurrency -- place types.
%
%(c) ownership types, alias control.
%

Specific constraint systems used when developing specific
examples.

In the following we will use the shorthand $\tt C(\bar{t}:c)$ for the
type $\tt C(:\bar{f}=\bar{t},c)$ where the declaration of the class
{\tt C} is $\tt \class\ C(\bar{\tt T}\ \bar{\tt f}:c)\ldots$.  Also,
we abbreviate $\tt C(\bar{t}:\true)$ as $\tt C(\bar{t})$.  Finally, we
will also have need to use the shorthand ${\tt C}_1(\bar{t}_:{\tt
c}_1)\& \ldots {\tt C}_k(\bar{\tt t}_k:{\tt c}_k)$ for the type
${\tt C}_1(:\bar{\tt f}_1=\bar{\tt t}_1, \ldots, \bar{\tt
f}_k=\bar{\tt t}_k,{\tt c}_1,\ldots,{\tt c}_k$ 
provided that the ${\tt C}_i$ form a subtype chain
and the declared fields of ${\tt C}_i$ are ${\tt f}_i$.

Constraints naturally allow for partial specification
(e.g. inequalities) or incomplete specification (no constraint on a
variable) with the same simple syntax. In the example below,
the type of {\tt a} does not place any constraint on the second
dimension of {\tt a}, but this dimension can be used in other
types (e.g.{} the return type).

{\footnotesize
\begin{verbatim}
class Matrix(int m, int n) {
  Matrix(m,a.n) mul(Matrix(:m=this.n) a) {...}
  ...
}
\end{verbatim}}

Constraints naturally permit the expression of existential types:

{\footnotesize
\begin{verbatim}
 class List(int length) { 
 List(:self.length < length) filter(Comparator k) { ...} 
 ...
 }
\end{verbatim}}


\subsection{Binary methods}

The binary method problem \cite{bruce-binary}.
{\footnotesize
\begin{verbatim}
interface Set {
    Set(:class == this.class)
        union(Set(:class == this.class) s);
    boolean superSetOf(Set(:class == this.class) s);
}

class IntSet implements Set {
    long bits;

    Set(:class == this.class)
        union(Set(:class == this.class) s) {

        Set(:class == this.class) r = new IntSet();
        // need to be able to conclud that r : IntSet
        r.bits = this.bits | s.bits;
        return r;
    }
    boolean superSetOf(Set(:self.class == this.class) s) {
        return (s.bits & ~bits) == 0;
    }
}
\end{verbatim}}

\subsection{AVL trees}

{\footnotesize
\begin{verbatim}
class AVLList(int(:self >= 0) height) {...}
class Leaf(Object key) extends AVLList(0) {...}
class Node(Object key, AVLList l, AVLList r
           : int d=l.height-r.height; -1 <= d, d <= 1) 
    extends AVLList(max(l.height,r.height)+1){..}
\end{verbatim}}

\subsection{Red--black trees}
Red/black trees may be modeled similarly. Such trees have the
invariant that (a) all leaves are black, (b) each non-leaf node has
the same number of black nodes on every path to a leaf (the black
height), (c) the immediate children of every red node are black.
{\footnotesize
\begin{verbatim}
class Tree(int blackHeight) {...}
class Leaf extends Tree(0) { int value; ...}
class Node(boolean isBlack, 
    Tree(:this.isBlack || isBlack) l, 
    Tree(:this.isBlack || isBlack, 
          blackHeight=l.blackHeight) r 
) extends Tree(l.blackHeight+1) { 
   int value; ...}
\end{verbatim}}

\subsection{Bounds checks}

{\footnotesize
\begin{verbatim}
class Array {
 Object[] a;
 Object get(int(:0 <= self && self < a.length) i) { 
   return a[i]; 
 }
 void set(int(:0 <= self && self < a.length) i, T v) {
    a[i] = v; 
 }
}
\end{verbatim}}

\subsection{Nullable types}

Nullable types (T(:self != null))


\subsection{A distributed binary tree}
This example is due to Satish Chandra. We wish to specify a balanced
distributed tree with the property that its right child is always at
the same place as its parent, and once the left child is at the same
place then the entire subtree is at that place:

{\footnotesize
\begin{verbatim}
class Tree(boolean localLeft,
  Tree(: this.localLeft => (loc=here,self.localLeft)) left, 
  Tree(: loc=here) right) extends Object { ...}
\end{verbatim}}

\subsection{Places}

% \begin{figure}
% \input{place}
% \end{figure}

\subsection{$k$-dimensional regions}

% \begin{figure}
% \input{region}
% \end{figure}

\subsection{Point}


% \begin{figure}
% \input{point}
% \end{figure}

\subsection{Distribution}


% \begin{figure}
% \input{dist}
% \end{figure}

\subsection{Arrays}

\cite{gps06-arrays}

Finally we can now define arrays. An array is built over a
distribution and a base type.

%\begin{figure}
%\input{array}
%\end{figure}

\subsection{Clocks}

Clock types

\subsection{Capabilities}

Capablities (from Radha and Vijay's paper on neighborhoods)

\subsection{Ownership types}

Figure~\ref{fig:ownership} demonstrates how ownership
types~\cite{ownership-types} can be encoded in CFJ.
The example is from XXX~\cite{???} and shows the code for a
simple map implemented using a list of key--value pairs.

Cyclic: this.nodes.o == this

\begin{figure*}
\input{Ownership}
\caption{Ownership types}
\label{fig:ownership}
\end{figure*}

\subsection{Discussion}

Dependent types are of use in annotations~\cite{ns07-x10anno}.
