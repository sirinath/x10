%III. Applied constrained calculii. (3 pages)
%
%For each example below, formal static and dynamic semantics rules for
%new constructs extension over the core CFJ. Subject-reduction and
%type-soundness theorems. Proofs to be found in fuller version of
%paper.
%
%(a) arrays, region, distributions -- type safe implies no arrayoutofbounds
%exceptions, only ClassCastExceptions (when dynamic checks fail).
%
%Use Satish's conditional constraints example.
%-- emphasize what is new over DML. 
%
%(b) places, concurrency -- place types.
%
%(c) ownership types, alias control.
%

Specific constraint systems used when developing specific
examples.

In the following we will use the shorthand $\tt C(\bar{t}:c)$ for the
type $\tt C(:\bar{f}=\bar{t},c)$ where the declaration of the class
{\tt C} is $\tt \class\ C(\bar{\tt T}\ \bar{\tt f}:c)\ldots$.  Also,
we abbreviate $\tt C(\bar{t}:\true)$ as $\tt C(\bar{t})$.  Finally, we
will also have need to use the shorthand ${\tt C}_1(\bar{t}_:{\tt
c}_1)\& \ldots {\tt C}_k(\bar{\tt t}_k:{\tt c}_k)$ for the type
${\tt C}_1(:\bar{\tt f}_1=\bar{\tt t}_1, \ldots, \bar{\tt
f}_k=\bar{\tt t}_k,{\tt c}_1,\ldots,{\tt c}_k$ 
provided that the ${\tt C}_i$ form a subtype chain
and the declared fields of ${\tt C}_i$ are ${\tt f}_i$.

Constraints naturally allow for partial specification
(e.g. inequalities) or incomplete specification (no constraint on a
variable) with the same simple syntax. In the example below,
the type of {\tt a} does not place any constraint on the second
dimension of {\tt a}, but this dimension can be used in other
types (e.g.{} the return type).

{\footnotesize
\begin{verbatim}
class Matrix(int m, int n) {
  Matrix(m,a.n) mul(Matrix(:m=this.n) a) {...}
  ...
}
\end{verbatim}}

Constraints naturally permit the expression of existential types:

{\footnotesize
\begin{verbatim}
 class List(int length) { 
 List(:self.length < length) filter(Comparator k) { ...} 
 ...
 }
\end{verbatim}}


\subsection{Binary methods}

The binary method problem \cite{bruce}.

Bruce and Cardelli and Castagna and Leavens and Pierce,
On Binary Methods, TAPOS 1(3): 221--242, Fall 1995.

{\footnotesize
\begin{verbatim}
interface Set {
    Set(:class == this.class)
        union(Set(:class == this.class) s);
    boolean superSetOf(Set(:class == this.class) s);
}

class IntSet implements Set {
    long bits;

    Set(:class == this.class)
        union(Set(:class == this.class) s) {

        Set(:class == this.class) r = new IntSet();
        // need to be able to conclud that r : IntSet
        r.bits = this.bits | s.bits;
        return r;
    }
    boolean superSetOf(Set(:self.class == this.class) s) {
        return (s.bits & ~bits) == 0;
    }
}
\end{verbatim}}

\subsection{Cayenne examples}


\subsection{DML examples}

{\footnotesize
\begin{verbatim}
class AVLList(int(:self >= 0) height) {...}
class Leaf(Object key) extends AVLList(0) {...}
class Node(Object key, AVLList l, AVLList r
           : int d=l.height-r.height; -1 <= d, d <= 1) 
    extends AVLList(max(l.height,r.height)+1){..}
\end{verbatim}}


Red/black tree invariant.

Invariant:
1. all leaves black
2. for each node n, there are the same number of black nodes on
every path from n to a leaf (the black height)
3. the immediate children of every red node are black

\begin{verbatim}
class Tree(boolean isBlack, int blackHeight, Tree left, Tree right
  : ( left == null && right == null ||   // leaf or interior
      left != null && right != null
    )
    &&
    ( left == null || left.value < right.value )   // ordered
    &&
    ( left != null || isBlack )   // leaves are black
    &&
    ( left != null || blackHeight == 0 ) // leaves have height 0
    &&
    ( left == null || blackHeight == left.blackHeight + 1 )
    &&
    ( right == null || blackHeight == right.blackHeight + 1 )
    &&
    ( isBlack || ( left.isBlack && right.isBlack ) )
  )
{
    int value;

    // empty
    Tree(: isBlack && blackHeight == 0 && left == null && right == null)
        () {
        property(isBlack, 0, null, null);
    }

    // black
    Tree(: isBlack && blackHeight == l.blackHeight+1 && left == l && right == r)
        (Tree l, Tree r, int v : l.blackHeight == r.blackHeight) {
        property(true, l.blackHeight+1, l, r);
        this.value = v;
    }
       
    // red: use a dummy argument to overload
    Tree(: !isBlack && blackHeight == l.blackHeight && left == l && right == r)
        (Tree l, Tree r, int v, Object _ : l.blackHeight == r.blackHeight) {
        property(false, l.blackHeight, l, r);
        this.value = v;
    }

    // need to show add, remove preserve the invariant
}
\end{verbatim}

Bounds checks.

\begin{code}
class Array \{
    T[] a;
    T get(int(:0 <= self \&\& self < a.length) i) \{ return a[i]; \}
    void set(int(:0 <= self \&\& self < a.length) i, T v) \{ a[i] = v; \}
\}
\end{code}

\subsection{Nullable types}

Nullable types (T(:self != null))

\subsection{Arrays}

Array/region/distribution types (examples from X10)

\cite{gps06-arrays}

\subsection{Places}

Place types (examples from X10)

\subsection{Clocks}

Clock types

\subsection{Capabilities}

Capablities (from Radha and Vijay's paper on neighborhoods)

\subsection{Ownership types}

Ownership types~\cite{ownership-types}

\subsection{Discussion}

Dependent types are of use in annotations~\cite{ns07-x10anno}.
