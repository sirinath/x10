Constraint-based type systems enjoy a long history.
Mitchell~\cite{mitchell84} and Reynolds~\cite{reynolds85}
developed the use of constraints for type inference and subtyping.
%
Trifonov and Smith~\cite{trifonov96}
proposed a type system where types are refined by subtyping
constraints.  Dependent types are not supported.
%
Pottier~\cite{pottier96simplifying,pottier01b}
presents a constraint-based type system for an ML-like language with
subtyping.

HM(X)~\cite{sulzmann97type,pottier01a,pottier-remy-attapl}
is a constraint-based framework
for Hindley--Milner style type systems.
The framework is parameterized on the specific constraint system
X; instantiating X yields extensions of the HM type system.
Constraints in HM(X) are over types, not values.
%
XXX HM(X) introduced {\em term constraint systems}; constraints in
CFJ are term constraints?

% Cardelli~\cite{cardelli86}, type checking dependent types and
% subtypes.

% Russell
% \cite{fuh88}
% \cite{curtis90}
% \cite{aiken93}

% Aiken, Wimmers, and Lakshman proposed {\em conditional
% types}~\cite{conditional-types}, which have the ability to
% encode control-flow analysis of {\tt case} expressions.
% Conditional types are not dependent.

% \cite{smith94}



% \cite{palsberg95}
% constraint-based inference algorithm for object calculus, 

% Henglein (TAPOS) set constraints for OO language type-inference.

% Bane~\cite{fahndrich99}

% Pottier

% CLP(X) framework in constraint logic programming (JM94)
% HM(X)

Several systems have been proposed that refine types in a base
type system through constraints.
%
{\em Refinement types}~\cite{refinement-types} extend the 
Hindley--Milner type system with intersection, union, and
constructor types, enabling specification and inference of
more precise type information.
%
{\em Conditional
types}~\cite{conditional-types} extend refinement types to
encode control-flow information in the types.
%
Jones introduced {\em qualified types}, which permit
types to be constrained by a finite set of
predicates~\cite{jones94}.
%
{\em Sized types}~\cite{sized-types}
annotate types with the sizes of recursive data structures.
Sizes are linear functions of size variables.
Size inference is performed using a constraint solver for
Presburger arithmetic~\cite{omega}.
% contraints on types, support primitive recursion only

% Indexed types~\cite{indexed-types}

Xi and Pfenning~\cite{xi99dependent} describe an extension of ML
with dependent types, DML($C$), in which types are indexed by
constraints from a domain $C$ that is a parameter to the type
system.  Types in DML are refinement types; they do no affect
the operational semantics and erasing the
constraints yields an ML program.
CFJ permits casts and run-time tests of constraints.
Like CFJ, DML supports existenial dependent types.
% Index objects must be pure.
% Singleton types int(n).
% ML$^{\Pi}_0$:
% Refinement of the ML type system: does not affect the
% operational semantics.  Can erase to ML$_0$.

% Jay and Sekanina 1996: array bounds checking based on shape
% types.

With hybrid type-checking~\cite{flanagan-popl06,flanagan-fool06},
types can be constrained by arbitrary boolean expressions.
While typing is undecidable, dynamic checks are inserted into
where the type-checker cannot accept or reject a program.

% Ada dependent types.
% Ada has constrained array definitions.  A constraint
% \cite{ada-ref-man}.  Not clear if they're dependent.  Are
% there other dependent types?  Generics are dependent?

Singleton types~\cite{aspinall-singletons,stone00} are dependent
types containing only one value.  
In Stone's formulation~\cite{stone00},
$S(e : \tau)$
is the type of all values of type $\tau$ that are equal to $e$.
Term equivalence is
constructed so that type-checking is decidable.
The singleton $S(e: \tau)$ can be encoded in CFJ as
$\tau(:{\tt self} {\tt =} \lfloor e \rfloor)$, where 
$\lfloor e \rfloor$ lifts $e$ to a constraint term.

        % Used for array bounds by Morrisett et al (I think--need
        % to find paper)

% Singleton types~\cite{aspinall-singletons}.

Several languages---gbeta~\cite{ernst99-gbeta},
Scala~\cite{scala-overview,scala-oopsla05}, J\&~\cite{nqm06} and
others~\cite{oz01,ocrz-ecoop03}---provide {\em dependent path
types}.  For a final access path {\tt p}, {\tt p.type}
in Scala is the singleton type containing the object {\tt p}.
In J\& {\tt p.class} is a type containing all objects
whose run-time class is the same as {\tt p}'s.
Scala's {\tt p.type} can be encoded in CFJ using an equality
constraint {\tt C(:self == p)}, where {\tt C} is a supertype of
{\tt p}'s static type.
\eat{
These types can be encoded in CFJ by introducing a
{\tt type} property.
\rn{T-constr}, as
described in Section~\ref{sec:examples}.
}

% Where clauses for F-bounded polymorphism~\cite{where-clauses}
% Bounded quantification: Cardelli and Wegner.  Bound T with T'
% In F-bounded polymorphism~\cite{f-bounds}, type variables are bounded by a function of 
% the type variable. 
% Not dependent types.

\eat{
conditional types:

type of an expression can be constrained using information about
the results of run-time tests in the context surrounding the
expression.

e.g., can express that e2 is evaluated only if e1 is true

\begin{verbatim}
\y. case y of true => e1 | false => e2 :
        'a -> (true ? ('a ^ typeof(e1)) U (false ? ('a ^ typeof(e2))
\end{verbatim}

Types include type constructors applied to types.

\begin{verbatim}
        so,  true      : true
        but, (\x . x)  : 'a -> 'a
             node(l,r) : node('a tree, 'a tree)
\end{verbatim}


when checking a case branch, type of the expression being
matched refined to the include the type constructor for that
branch

captures some control flow analysis in the types

types
\begin{verbatim}
        t ::= t1 -> t2
                | c(..ti..) <-- type constructor
                | alpha
                | t1 U t2
                | t1 ^ t2
                | t1 ? t2
                | 0
                | 1

        sigma ::= t | \forall ..alpha.. t where ..ti <= tj..
\end{verbatim}
}


Cayenne~\cite{cayenne} is a Haskell-like langauge with fully dependent types.
There is no distinction between static and dynamic types.
Type-checking is undecidable.
There is no notion of datatype refinement as in DML.

Epigram~\cite{epigram}
is a dependently typed functional programming language.

\eat{
$\lambda^{\sf Con}$ is a lambda calculus with assertions.
Findler, Felleisen, Contracts for higher-order functions (ICFP02)

  example: int[> 9]

contracts are either simple predicates or function contracts.
defined by (define/contract ...)

enforced at run-time.
}

% Jif~\cite{jif,jflow} is an extension of Java in which
% types are labeled with security policies enforced by the
% compiler.

ESCJava~\cite{esc-java}
and Spec$\sharp$~\cite{specsharp}
allow programmers to write invariants to be enforced statically
by the compiler.

JSR 308, Javari

% Holt, Cordy, the Turing programming language

% Ou, Tan, Mandelbaum, Walker, Dynamic typing with dependent types
% Separate dependent and simple parts of the program.
% Statically type the dependent parts.
% Dynamic checks when passing values into dependent part.

