%IV. Implementation (0.5 page)
%
%Specify what has been implemented and how. What is interesting about
%the implementation.

The dependent type system is implemented in the \Xten{}
compiler~\cite{X10}, which is implemented as an extension of
Java using the Polyglot compiler framework~\cite{ncm03}.

Polyglot implements a source-to-source base Java compiler 
that is extended to translate \Xten{} to Java.  In describing the
implementation, we ignore the additional statement and expression types
introduced in \Xten{} and treat the language simply as Java
extended with constrained types.

Constraints in \Xten{} are conjunctions of equalities over immutable
side-effect-free expressions.  Expressions used in constrained
types are type-checked as normal non-dependent \Xten{} expressions;
no constraint solving is performed.
A second compiler pass generates and solves constraints via an
ask--tell interface~\cite{my-thesis-book}.
If constraints cannot be solved, an error is reported.

After constraint-checking, the \Xten{} code is translated to Java.
The basic idea behind the translation is simple. Each dependent class
is translated into a single class of the same name without dependent
types. The explicit properties of the dependent class are translated
into {\tt public final} (instance) fields of the target class.
A {\tt property} statement in a constructor is translated to a
sequence of assignments to initialize the property fields.

For each property, a getter method is also generated in the
target Java class.
Properties declared in interfaces are translated into getter
method signatures.  Subclasses implementing these interfaces
thus provide the required properties by implementing the
generated interfaces.

Usually, constrained types are simply translated to
non-constrained types by erasure; constraints are checked
statically and need no run-time representation.
However, dependent types may be used in casts
and {\tt instanceof} expressions.  Because the constraint syntax
in \Xten{} is a subset of the \Xten{} expression syntax, run-time tests
of constrained types are translated to Java
in straightforward manner by evaluating the constraint with
{\tt self} bound to the expression being tested.
For examples, casts are translated as:
\eat{
\begin{code}
  $\Lb$e instanceof C(:c)$\Rb$ = 
    new Object() \{
      boolean check(Object o) \{
        if (o instanceof C) \{
          C self = (C) o;
          return $\Lb$c$\Rb$;
        \}
        return false;
      \}
    \}.check($\Lb$e$\Rb$)
\end{code}
}
\begin{code}
  $\Lb$(C(:c) e$\Rb$ = 
    new Object() \{
      C cast(C self) \{
        if ($\Lb$c$\Rb$) return self;
        throw new ClassCastException(); \}
    \}.cast((C) $\Lb$e$\Rb$)
\end{code}
\noindent Wrapping the evaluation of {\tt c} in an anonymous class
ensures the expression {\tt e} is evaluated only once.

