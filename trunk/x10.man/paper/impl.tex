%IV. Implementation (0.5 page)
%
%Specify what has been implemented and how. What is interesting about
%the implementation.

Constrained types are implemented in the \Xten{}
language.
Constraints in \Xten{} are conjunctions of equalities over immutable
side-effect-free expressions.


The \Xten{} compiler is implemented as an extension of
Java using the Polyglot compiler framework~\cite{ncm03}.
Expressions used in constrained
types are type-checked as normal non-dependent \Xten{} expressions;
no constraint solving is performed.
A separate compiler pass generates and solves constraints via an
ask--tell interface~\cite{my-thesis-book}.
If constraints cannot be solved, an error is reported.

After constraint-checking, the \Xten{} code is translated to
Java in a straightforward manner.  Each dependent class
is translated into a single class of the same name without dependent
types. The explicit properties of the dependent class are translated
into {\tt public final} (instance) fields of the target class.
A {\tt property} statement in a constructor is translated to a
sequence of assignments to initialize the property fields.

For each property, a getter method is also generated in the
target Java class.
Properties declared in interfaces are translated into getter
method signatures.  Subclasses implementing these interfaces
thus provide the required properties by implementing the
generated interfaces.

Usually, constrained types are simply translated to
non-constrained types by erasure; constraints are checked
statically and need no run-time representation.
However, dependent types may be used in casts
and {\tt instanceof} expressions.  Because the constraint syntax
in \Xten{} is a subset of the \Xten{} expression syntax, run-time tests
of constrained types are translated to Java
by evaluating the constraint with
{\tt self} bound to the expression being tested.
For examples, casts are translated as:
\eat{
\begin{code}
  $\Lb$e instanceof C(:c)$\Rb$ = 
    new Object() \{
      boolean check(Object o) \{
        if (o instanceof C) \{
          C self = (C) o;
          return $\Lb$c$\Rb$;
        \}
        return false;
      \}
    \}.check($\Lb$e$\Rb$)
\end{code}
}
\begin{code}
  $\Lb$(C(:c) e$\Rb$ = 
    new Object() \{
      C cast(C self) \{
        if ($\Lb$c$\Rb$) return self;
        throw new ClassCastException(); \}
    \}.cast((C) $\Lb$e$\Rb$)
\end{code}
\noindent Wrapping the evaluation of {\tt c} in an anonymous class
ensures the expression {\tt e} is evaluated only once.

