%IV. Implementation (0.5 page)
%
%Specify what has been implemented and how. What is interesting about
%the implementation.

The \Xten{} compiler provides a framework for writing and
checking constrained types.  The \Xten{} 
language, 
constraints in \Xten{} are conjunctions of equalities over immutable
side-effect-free expressions.  Compiler plugins may be installed
that support other constraint languages, Presburger
constraints (linear inequalities)~\cite{??}.

The \Xten{} compiler is implemented as an extension of
Java using the Polyglot compiler framework~\cite{ncm03}.
Expressions used in constrained
types are type-checked as normal non-dependent \Xten{} expressions;
no constraint solving is performed on these expressions.
During type-checking, constraints are generated and solved using
the built-in constraint solver or using solvers provided by
plugins.  The system allows types to constrained by conjunctions
of constraints in different constraint languages.
If constraints cannot be solved, an error is reported.

\subsection{Constraint checking}

After type-checking a constraint as a boolean expression {\tt e},
the abstract syntax tree for
the boolean expression is transformed into a list of conjuncts.
{\tt e1 \&\& ... \&\& ek}.  Each conjunct {\tt ei} is given to 
the installed constraint system plugins, which symbolically
evaluate the expression to create an internal representation of
the conjunct.  If no
constraint system can handle the conjunct, an error is reported.

To interoperate, the constraint solvers must share a common
vocabulary: constraint terms {\tt t} range over the properties of the
base type, the final variables in scope at the type (including
{\tt this}), the special variable {\tt self} representing
the a value of the type, and field selections {\tt t.f}.
All
constraint systems are required to support the trivial
constraint
\true, conjunction, existential quantification and equality on
constraint terms.


In this form, the constraint is represented as a 
conjunction of constraints from different theories.  Constraints
are checked for satisfiability using a Nelson--Oppen
procedure~\cite{nelson-oppen}.
After constructing a constraint-system specific 
representation of a conjunct, each plugin computes the set of
term equalities entailed by the conjunct.  These equalities are
propagated to the other conjuncts, which are again checked for
satisfiability and any new equalities generated are propagated.
If a conjunct is found to be unsatisfiable, an error is
reported. 

\if 0
Individual constraint systems may interpret a conjunct as a
formula containing constraint-system-specific atomic functions
{\tt g} and predicates {\tt p}.  

For example, given the constrained type
{\tt Node(:self.x >= 0 \&\& reachable(self).contains(y))},
Presburger constraint system interprets the formula as:

a Presburger constraint {\tt self.x >= 0}
and
an uninterpreted constraint {\tt `reachable/contains'(self,y)}.

A reachability constraint system interprets the formula with the
inequality uninterpreted and the reachability constraint
interpreted.

The base system sees {\tt '>='(self, 0) \&\& 'reachable-contains'(self,y)} 

Neet to propagate implied bindings between terms.  For instance:

{\tt int(:self >= x \&\& self <= x)}
should be equivalent to the type
{\tt int(:self == x)}.

By ensuring constraint systems share the same vocabulary and all
support equality on constraint terms, we can propagate
equalities between constraint systems.
cf. Nelson-Oppen.

Constraint systems must not have conflicting or overlaping
constraints ..XXX

Above, ``,'' binds tighter than ``;''. We use the syntax {\tt
{\tt T\;x};\;c} for the constraint obtained by existentially
quantifying the
variable {\tt x} of type {\tt T} in {\tt c}. {\tt p} ranges over
the collection of predicates supplied by the underlying
constraint
system, and {\tt g} over the collection of functions.




After this translation step, constraints are represented as
lists of constraint-system-specific conjuncts.

The constraints are checked for consistency as follows.
\ref{TODO}
\fi

During type-checking, the type checker needs to determine if the
type
{\tt C(:c)} is a subtype of {\tt D(:d)}.  This is true if 
the base type {\tt C} is a subtype of {\tt D} and if the
constraint {\tt c} entails {\tt d}.

To check entailment, each constraint solver is asked if
a given conjunct of {\tt d} is entailed by {\tt c}.
If any report false, the entailment does not hold and the
subtyping check fails.

% what if a conjunct of d that makes c unsat is ignored?

% propagation of bindings.



\subsection{Translation}

After constraint-checking, the \Xten{} code is translated to
Java in a straightforward manner.  Each dependent class
is translated into a single class of the same name without dependent
types. The explicit properties of the dependent class are translated
into {\tt public final} (instance) fields of the target class.
A {\tt property} statement in a constructor is translated to a
sequence of assignments to initialize the property fields.

For each property, a getter method is also generated in the
target Java class.
Properties declared in interfaces are translated into getter
method signatures.  Subclasses implementing these interfaces
thus provide the required properties by implementing the
generated interfaces.

Usually, constrained types are simply translated to
non-constrained types by erasure; constraints are checked
statically and need no run-time representation.
However, dependent types may be used in casts
and {\tt instanceof} expressions.  Because the constraint syntax
in \Xten{} is a subset of the \Xten{} expression syntax, run-time tests
of constrained types are translated to Java
by evaluating the constraint with
{\tt self} bound to the expression being tested.
For examples, casts are translated as:
\eat{
\begin{code}
  $\Lb$e instanceof C(:c)$\Rb$ = 
    new Object() \{
      boolean check(Object o) \{
        if (o instanceof C) \{
          C self = (C) o;
          return $\Lb$c$\Rb$;
        \}
        return false;
      \}
    \}.check($\Lb$e$\Rb$)
\end{code}
}
\begin{code}
  $\Lb$(C(:c) e$\Rb$ = 
    {\bf new} Object() \{
      C cast(C self) \{
        if ($\Lb$c$\Rb$) return self;
        throw new ClassCastException(); \}
    \}.cast((C) $\Lb$e$\Rb$)
\end{code}
\noindent Wrapping the evaluation of {\tt c} in an anonymous class
ensures the expression {\tt e} is evaluated only once.

