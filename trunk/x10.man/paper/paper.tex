\documentclass[nocopyrightspace,preprint,9pt]{sigplanconf}

\usepackage{times-lite}
\usepackage{mathptm}
\usepackage{txtt}
\usepackage{stmaryrd}
\usepackage{code}
%\usepackage{ttquot}
\usepackage{bcprules}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{afterpage}
\usepackage{balance}
\usepackage{defs}
\usepackage{pldefs}
\usepackage{utils}
\usepackage[pdftex]{graphicx}
\usepackage{ifpdf}

\ifpdf
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}
\fi


% \input{../../../../vj/res/pagesizes}
% \input{../../../../vj/res/vijay-macros}
\newcommand\alt{\bnf}

\newcommand\Implies{\Rightarrow}

\newtheorem{example}{Example}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

\newcommand\Xten{{X10}}
\newcommand\java{{Java}}
\newcommand\Java{{\java}}
\newcommand\csharp{{C$\sharp$}}
\newcommand\FXten{{FX10}}

\begin{document}
\title{Constrained Types for Object-Oriented Languages}
\authorinfo{Vijay Saraswat}
  {IBM T.~J. Watson Research Center \\
   P.O. Box 704 \\
   Yorktown Heights, NY 10598}
  {vsaraswa@us.ibm.com}
\authorinfo{Nathaniel Nystrom}
  {IBM T.~J. Watson Research Center \\
   P.O. Box 704 \\
   Yorktown Heights, NY 10598}
  {nystrom@us.ibm.com}
\authorinfo{Radha Jagadeesan}
  {Depaul University}
  {rjagadeesan@cs.depaul.edu}
\authorinfo{Jens Palsberg}
  {University of California--Los Angeles}
  {palsberg@cs.ucla.edu}
\authorinfo{Christian Grothoff}
  {University of Denver}
  {christian@grothoff.org}

\maketitle

% \conferenceinfo{POPL'08}{XXX}
% \copyrightyear{2008}
% \copyrightdata{[to be supplied]}

\begin{abstract}
We formalize the basic ideas of dependent-types for Java-like
languages, in the context of \FXten, a Featherweight version of \Xten{}.
\end{abstract}

\section{Introduction}

%
%I. Introduction and overview (3 pages)

%Design of X10, concurrency, high productivity, high performance,
%practical language.
%
%Dependent types arise naturally. arrays, regions, distributions, place
%types.
%
%Indeed you can look around and recognize many OO type systems proposed
%in the last decade or so as specific kinds of applied dependent type
%systems.
%
%Our goal is to develop a general framework for dependent types for
%statically typed OO languages ("Java-like languages"). 

\Xten{} is a modern statically typed object-oriented (OO) language
designed for high productivity in the high performance computing (HPC)
domain~\cite{X10}. \Xten{}, like most OO languages is designed around the notion
of objects, as instances of {\em classes}. However, \Xten{} places
equal emphasis on {\em arrays}, a central data-structure in high
performance computing. In particular, \Xten{} supports dense,
distributed multi-dimensional arrays of value and reference types,
built over index sets known as {\em regions}, and mappings from index
sets to places, known as {\em distributions}.  \Xten{} supports a rich
algebra of operations over regions, distributions and arrays.

In designing a static type system for \Xten{} a central problem
arises. It becomes necessary to permit types, such as {\tt region(2)},
the type of all two-dimensional regions, {\tt int[5]}, the type of
all arrays of {\tt int} of length {\tt 5}, and {\tt int[region(2)]},
the type of all {\tt int} arrays over two dimensional regions.
The underlying
general idea is that of {\em dependent types}: types
parametrized by {\em values} \cite{xi99dependent}.

XXX emph pluggable nature of the constraint system.

%, just as generic
%types are types paramterized by other types \cite{genericjava}.

In this paper we develop a general syntactic and semantic framework
for {\em constrained types}, user-defined dependent types
in the context of modern class-based
OO languages such as \java{}, \csharp{} and \Xten{}. Our central
insight is that a rich, user-extensible type system can be developed
on top of predicates over the {\em immutable} state of objects. Such
types statically capture many common invariants naturally arising in
code. Given a single dependently typed class or interface {\tt C}, a
user may construct a potentially infinite family of types {\tt C(:c)}
where {\tt c} is a predicate on the immutable state.

%Criteria:
%
%-- easy to use for practicing programmers
%
%-- must be flexible, it must permit the development of concrete,
%   specific type systems tailored to the application area at hand
%   (pluggable types), therefore must be parametric in the kinds of
%   expressions used in the type system.
%
%-- the implementation must be modular, the rules for type-checking
%   must be specified once in a way that is independent of the
%   particular vocabulary of operations used in the dependent type
%   system.
%
%-- must work smoothly with nominal type systems found in Java-like
%   languages, must permit separate compilation.
%
%-- must permit mostly static type-checking. 

In designing this framework, we had the following criteria:
\begin{itemize}
\item 
{\bf Ease of use.}
The framework must be 
easy to use for practicing programmers.

\item
{\bf Flexibility.}
The framework
must permit the development of concrete,
specific type systems tailored to the application area at
hand, enabling a kind of pluggable type system~\cite{bracha04-pluggable}.
Hence, the framework must be parametric in the kinds of
expressions used in the type system.

\item
{\bf Modularity.}
The rules for type-checking
must be specified once in a way that is independent of the
particular vocabulary of operations used in the dependent type
system.

\item
{\bf Integration with OO languages.}
The framework must
work smoothly with nominal type systems found in Java-like
languages, and must permit separate compilation.

\item
{\bf Static checking.}
The framework must permit mostly static type-checking. 
\end{itemize}


XXX Overview of our design.

XXX Claims of this paper.

%
%Related work
%

As in staged languages~\cite{nielson-multistage,ts97-multistage},
the design distinguishes between
compile-time and run-time evaluation. Constrained types are
checked (mostly) at compile-time.
The compiler uses a
constraint solver to perform universal reasoning (``for all possible
values of method parameters'') for dependent type-checking.  There is
no run-time constraint-solving.  However,
run-time casts to dependent types are
permitted; these casts involve arithmetic, not
algebra---the values of all parameters are known.

We outline the design for a compiler that can use an extensible
constraint-solver for type-checking.
This design is implemented in the \Xten{} compiler.
No extension of an
underlying virtual machine is necessary, except as may be useful in
improving efficiency (for example, eliminating array bounds checks).
The compiler translates source
programs into target programs without dependent types
but with {\tt assume} and {\tt assert} statements.
A general
constraint propagator that depends only on the operational semantics
of the language and is parametric on the underlying constraint solver
may be run on the program in order to eliminate branches and {\tt
asserts} forced by the assumptions. If all {\tt assert}s cannot be
eliminated at compile-time, some residual constraint-checking
({\em not} solving) may need to be performed at runtime.
%
XXX contrast with hybrid type checking.

\paragraph{Rest of this paper.}

The next section reviews related work.
Section~\ref{sec:lang} fleshes out the syntactic and semantic details of the
proposal.
Formal semantics
and a soundness theorem
are presented in Section~\ref{sec:semantics}.
Section~\ref{sec:examples} works through a number of
examples using a variety of constraint systems.
Sections~\ref{sec:future}
and \ref{sec:conclusions} conclude the paper with a discussion of
future work.

\section{Constrained types}

XXX move first part up into intro.  Move details into Section~\ref{sec:lang}

Our basic approach to introducing dependent types into
class-based statically typed OO languages is to
follow the spirit of generic types, but use values instead of
types.

We permit the definition of a class {\tt C} to specify
a list of typed parameters, or {\em properties},
{\tt (T1 x1, \ldots, Tk xk)} similar in syntactic structure to
a method argument list. Each
property in this list is treated as a {\tt public final} instance
field of the class.
We also permit the
specification of a {\em class invariant}, a
{\em where clause}~\cite{where-clauses}
in the class definition. A where
clause is a boolean expression on the parameters separated from the
parameter list with a ``{\tt :}''.  The compiler ensures that all
instances of the class created at runtime satisfy the where clause
associated with the class.
Thus, for instance, we may specify a class {\tt List} with an
{\tt int length} property as follows:
\begin{code}
  class List(int length: length >= 0) \{...\}
\end{code}

Given such a definition for a class {\tt C},
types can be constructed by {\em constraining} the properties of
{\tt C}.
In principle, {\em any} boolean expression over the
properties specifies a type: the type of all instances of the
class which satisfy the boolean expression. Thus,
{\tt List(:length == 3)} is a permissible type, as are
{\tt List(:length <= 41)} and even
{\tt List(:length * f() >= g())}.
If {\tt C} has no properties, the only type that can be
constructed is the type {\tt C}.

Accordingly, a {\em parametric type} is of the form {\tt C(:e)}, the name of
a class or interface {\tt C}, called the {\em base class}, followed by a
where clause {\tt e}, called the {\em condition}, a boolean expression
on the properties of the base class. 
The denotation, or
semantic interpretation, of such a type is the set of all instances
of subclasses of the base class whose properties satisfy the
condition.
Clearly, for the denotation of a parametric type $t$ to be
non-empty the condition of $t$ must be consistent with the class
invariant, if any, of the base class of $t$.  The compiler is required to
ensure that the type of any variable declaration is non-empty.

For brevity, we write {\tt C} as a type as well; it
corresponds to the (vacuously) parametric type {\tt C(:true)}.
We also permit the syntax {\tt C(t1,\ldots, tk)} for
the type {\tt C (:x1 == t1 \&\& \ldots \&\& xk == tk)} (assuming that
the property list for {\tt C} specifies the {\tt k} properties {\tt
x1,\ldots, xk}, and each term {\tt ti} is of the correct
type). Thus, using the definition above, {\tt List(n)} is the type of
all lists of length {\tt n}.

Parametric types naturally come equipped with a {\em subtyping
structure}: type $t_1$ is a subtype of $t_2$ if the denotation of
$t_1$ is a subset of $t_2$. This definition satisfies
Liskov's Substitution Principle~\cite{liskov-behaviors}),
and implies that
{\tt C(:e1)} is a subtype of {\tt C(:e2)} if {\tt e1} implies {\tt e2}.
In particular, for all conditions {\tt e},
{\tt C(:e)} is a subtype of {\tt C}.
{\tt C(:e)} is empty exactly
when {\tt e} conjoined with {\tt C}'s class invariant is inconsistent.

Two parametric types {\tt C1(:e1)} and {\tt C2(:e2)} are considered equivalent
if {\tt C1} and {\tt C2} are the same base type and {\tt e1} and
{\tt e2} are equivalent when considered as logical expressions.

\subsection{Method and constructor preconditions}

Methods and constructors may specify preconditions
on their parameters as where clauses.
For an invocation of a method (or
constructor) to be type-correct, the
associated where clause must be statically known to be satisfied. The
return type of a method may also contain expressions involving the
arguments to the method. However, we will require
that any argument used in this way must be declared {\tt final},
ensuring it is not mutated by the method body.
For instance:
\begin{verbatim}
  List(arg.length-1)
    tail(final List arg : arg.length > 0) {...}
\end{verbatim}
\noindent will be a valid method declaration. It says that
{\tt tail} must be passed a non-empty list, and it returns a list
whose length is one less than its argument.

\subsubsection{Constructors for dependent classes}

Like a method definition,
a constructor may
specify preconditions on its arguments
and a postcondition on the value produced by the constructor.

Postconditions may be specified in a constructor declaration between
the name of the class and the argument list of the constructor using a
where clause. The where clause can reference only the properties of
the class.

For instance, the
nullary constructor for {\tt List} ensures that the property
{\tt length} has the value {\tt 0}:
{\footnotesize
\begin{verbatim}
    /** Returns the empty list. */
    public List(:length==0)() {
      property(0);
    }
\end{verbatim}}
The {\tt property} statement is used to set all the properties
of the new object simultaneously.  Capturing this assignment in
a single statement simplifies checking that the constructor
postcondition and class invariant are established.  In a class
has properties, every path through the constructor must contain
exactly one {\tt property} statement.

%% Cannot throw an exception.

%% Figure out the real condition. Not sure this is important.

\subsection{Constraints}

In this framework, types may be constrained by any boolean
expression over the properties.  For practical reasons,
restrictions need to be imposed to ensure constraint checking is
decidable.

The condition of a parametric type must be a pure
function only of the properties of the base class.
Because properties are
{\tt final} instance fields of the object,
this requirement
ensures that whether or not an object belongs to a parametric type does
not depend on the {\em mutable} state of the object.
That is, the status of the
predicate ``this object belongs to this type'' does not
change over the lifetime of the object.  Second, by insisting that each
property be a {\em field} of the object, the question of
whether an object is of a given type can be
determined merely by examining the state of the object and evaluating
a boolean expression. Of course, an implementation is free to not {\em
explicitly} allocate memory in the object for such fields. For
instance, it may use some scheme of colored pointers to implicitly
encode the values of these fields~\cite{???}.

Further, by requiring that the programmer distinguish certain {\tt
final} fields of a class as properties, we ensure that the programmer
consciously controls {\em which} {\tt final} fields should be available for
constructing parametric types. A field that is ``accidentally'' {\tt
final} may not be used in the construction of a parametric type. It must be
declared as a property.

\java{}-like languages permit constructors to throw exceptions. This
is necessary to deal with the situation in which the arguments to a
constructor for a class {\tt C} are such that no object can be
constructed which satisfies the invariants for {\tt C}. Dependent
types make it possible to perform some of these checks at
compile-time. The class invariant of a class explicitly captures
conditions on the properties of the class that must be satisfied by
any instance of the class.  Constructor preconditions capture
conditions on the constructor arguments.
The compiler's static check for
non-emptiness of the type of any variable captures these invariant
violations at compile-time.




\subsection{Extending dependent classes}

A class may extend a parametric class.

{\em MetaNote: This should be standard. A class definition may extend
a dependent super class, e.g. class Foo(int i) extends Fum(i*i) \{
\ldots \}. The expressions in the actual parameter list for the super
class may involve only the parameters of the class being defined. The
intuition is that these parameters are analogous to explicit arguments
that must be passed in every super-constructor invocation.}

\subsection{An example}

\begin{figure*}
{\footnotesize
\begin{verbatim}
public value class List(int length : length >= 0) {
  Object head = null;
  List(length-1) tail = null;

  /** Returns the empty list. */
  public List(:length==0)() {
    property(0);
  }

  /** Returns a singleton list. */
  public List(:length==1)(Object head) {
    this(head, new List());
  }
  /** Returns the cons of head and tail. */
  public List(:length==tail.length+1)(Object head, final List tail) {
    property(tail.length+1);
    this.head = head;
    this.tail = tail;
  }
  public List(length+arg.length) append(final List arg) {
    return (length == 0)
          ? arg
          : new List(head, tail.append(arg));
  }
  public List(length) rev() {
    return rev(new List());
  }
  public List(length+acc.length) rev(final List acc) {
    return (length == 0)
          ? acc
          : tail.rev(new List(head, acc));
  }
  /** Return a list of compile-time unknown length, obtained by filtering
      this with f. */
  public List(:self.length <= this.length) filter(Predicate f) {
    if (length==0) return this;
    if (f.isTrue(head)) {
      List<Object> l = tail.filter(f);
      return new List(l+1)(head, l);
    } else {
      return tail.filter(f);
    }
  }
}
\end{verbatim}}
%% Aha a design choice here!!
%% Have parameter(..) or not.
\caption{List example}
\label{fig:list-example}
\end{figure*}

Figure~\ref{fig:list-example} shows a {\tt List} class.
Intuitively, this definition states that a {\tt List} has a {\tt int}
property {\tt length}, which must be non-negative.  The
class has two fields that hold the head and tail of the list.

The first constructor {\tt List()} has a postcondition that
signifies that it returns a list of length 0.
The constructor body contains a {\tt property} statement
that initializes the {\tt length} property to {\tt 0}.
The compiler verifies that
the constructor postcondition and the class invariant
are implied by the {\tt property} statement
and any {\tt super} calls in the constructor body imply

The 
second constructor returns a singleton list of length {\tt
1}. The third constructor returns a list of length {\tt m+1}, where
{\tt m} is the length of the second argument. 
If an argument appears in the return type then the argument must be
declared {\tt final}. Thus the argument will point to the same object
throughout the evaluation of the constructor body.

Functions that append one list to another or that reverse a list can
be defined quite naturally. In both cases the size of the list
returned is known statically (as a function of the size of the list
and the argument to the method).  The example also illustrates a
method {\tt filter} which returns a list whose length cannot be known
statically since it depends on the argument predicate {\tt f};
the list length can be bounded, however.

\eat{
XXX
Finally, the example illustrates a dependent method. This example is
discussed more below.
}


\eat{
\subsubsection{Implicit parameters}
A dependent class may also specify additional parameters in the body
of the class. Such parameters are called {\em implicit} parameters.
Syntactically, an implicit parameter is specified using instance field
declaration syntax and prefixing the field declaration with the
keyword {\tt parameter}. The declaration of parameters must include an
initializer which may depend only on parameters defined in the
parameter list for the class or on previously defined parameters in
the class body.

In what follows by the {\em parameters} of a (dependent) class we will
mean either the explicit parameters enumerated in the parameter list,
or the implicit parameters defined using a {\tt parameter} declaration
in the body of the class. Parameters may be used  in an
expression specifying the value of some other parameter (in a
constructor or method call).

\begin{example}
The class {\tt List} may be extended to define an implicit {\tt
boolean} parameter {\tt isEven} which records whether the length of
the list is even.
{\footnotesize
\begin{verbatim}
  public value class List(int length : length >= 0) {
    parameter boolean isEven = (length % 2 == 0);
    ...
  }
\end{verbatim}}
\end{example}

The parameters of a class may be used in any type expression in the
body of the class at which they are visible. Parameters have the
status of final instance fields, hence they are not visible in static
fields, initializers or methods, or when they are overridden.
}


\eat{
\subsubsection{Dependent methods}
Instance method declarations may specify parameters after the
qualifiers and before the return type of the method, through a
parameter list (called the {\em parameter list} of the
method\footnote{We shall use the term ``arguments'' or ``argument
list'' for the usual arguments passed to a method.}).  The parameter
list may be followed by a where expression on the parameters of the
method and/or the parameters of the class. (Recall that a where
expression is a boolean expression following a ``{\tt :}''.)

The parameter list of the method is visible in the declaration of the
method and the body of the method. Each parameter is treated as a {\tt
final} local variable in the body of the method.  The types of
arguments to the method, and the return type of the method, may be
built from type expressions referencing these parameters.

A method invocation must specify the parameters in an actual parameter
list after the name of the method and before the arguments to the
method.  For each such method invocation, the compiler must determine the
corresponding method definition and statically check that its where
clause (if any) is satisfied by the invocation.

{\em MetaNote Need to determine rules for overriding for generic
methods and compare with the rule above.}

Dependent methods are useful in particular when a parameter in the
type of the result is not functionally determined by parameters of
arguments. For instance, suppose we want to write a method to return
the list of all numbers upto $n$. This method cannot take $n$ as an
argument because then it would not be able to assert that the return
type of the method is {\tt List(n)} (all variables that can be
referenced in the return type of a method must be parameters visible
to the method). Thus instead of writing
{\footnotesize
\begin{verbatim}
    public static List<nat> gen(nat m) {
       // returns the list of numbers from 0 to m.
    }
\end{verbatim}}
\noindent one may write:
{\footnotesize
\begin{verbatim}
    public static (nat m) List(m)<nat> gen() {
       // returns the list of numbers from 0 to m.
    }
\end{verbatim}}

Such a method may be invoked as:
{\footnotesize
\begin{verbatim}
    List(32)<nat> l = C.gen(32)();
\end{verbatim}}

%% TODO vj: Hmm... can the argument be a runtime computed value?
%% For usefulness we may need to allow that. But then how do we compile-time check
%% List(m)<nat> l = C.gen(arb())
%% where m is a number already specified and arb() is some random computation
%% on non-parameters?
}

\subsection{Dependent interfaces}

\java{} does not allow interfaces to specify instance fields. Rather all
fields in an interface are final static fields (constants).

X10 supports rich user-definable extensions to the type system by
allowing the user of a type to construct new parametric types: new
types that are predicates on the immutable state of the base type.
For interfaces to support this extension, they must support
user-definable properties, so that parametric types can be
built over interfaces.

As with classes, an interface definition may specify properties
in a 
list after the name of the interface. Similarly, an interface
definition may specify a where clause in its property list. Methods
in the body of an interface may have where clauses
as well.

All classes implementing an interface must have a property
with the same name and
type (either declared in the class or inherited from the superclass)
for each property in the interface. If a class implements
multiple interfaces and more than one of them specify a property
with the same name, then they must all agree on the type of the
property. The class must have a single property with the given name
and type.

The general form of a class declaration is now:
\begin{verbatim}
  class C(T1 x1, ..., Tk xk)
        extends B(:e)
        implements I1(:e1), ..., In(:en) {...}
\end{verbatim}
\noindent
For such a
declaration to type-check, it must be that the class invariant
implies {\tt inv(I) \&\& e}, where {\tt inv(I)} is the invariant associated with
interface {\tt I}.  Again, a parameteric class or interface {\tt I} is taken as
shorthand for {\tt I(:true)}.  Further, every method specified in the
interface must have a corresponding method in the class with the same
signature whose precondition, if any, is implied by the precondition
of the method in the interface.



%%% Come back to this.

\section{Related work}
\label{sec:related}

Constraint-based type systems:

\cite{mitchell84}

\cite{fuh88}

\cite{curtis90}

\cite{aiken93}

\cite{jones94}

\cite{smith94}

\cite{palsberg95}

\cite{trifonov96}

        Types of the form $T\backslash C$, where $C$ is
        a set of subtyping constraints.

        Not dependent.

\cite{fahndrich99}

% Pottier

Pottier~\cite{pottier96simplifying,pottier01b}
presents a constraint-based type system for an ML-like language with
subtyping.

% HM(X)

HM(X)~\cite{sulzmann97type,pottier01a,pottier-remy-attapl}
is a constraint-based framework
for Hindley--Milner style type systems.
The framework is parameterized on the specific constraint system
X; instantiating X yields extensions of the HM type system.



\begin{itemize}
\item Pottier
\item HM(X)
\item Xi and Pfenning (POPL99)

Dependent types in practical programming.
Dependent ML.  DML(C). Objects drawn from constraint domain C.

Index objects must be pure.
Singleton types int(n).

ML$^{\Pi}_0$:
Refinement of the ML type system: does not affect the
operational semantics.  Can erase to ML$_0$.



\item Ada dependent types

Ada has constrained array definitions.  A constraint
\cite{ada-ref-man}.  Not clear if their dependent.  Are there other dependent
types?

\item singleton kinds (Chris Stone)

\item Nested types, vObj, Scala, gbeta, J\&

Nested types: witness types, p
vObj, Scala: p.type.
J\&: p.class
gbeta: p.C

\item Where clauses for F-bounded polymorphism (Theta and PolyJ)

Bounded quantification: Cardelli and Wegner.  Bound T with T'
F-bounds: Canning, Cook, Hill, Olthoff, Mitchell.  Bound T with F(T).

Not dependent types.

\item Hybrid type checking (Flanagan, POPL06)


Refinement types.  Types can be arbitrary predicates:

        { z : Int | z >= 0 }
        equivalent to the X10 type:
        Int(:self >= 0)

Subtyping is undecidable.  Type-checker can report ``yes'',
``no'',
or ``don't know''.  If the latter, dynamic checks inserted where
subsumption occurs.

Also Hybrid Types, Invariants and Refinements for Imperative
Objects (Flanagan, Freund, Tomb, FOOL06).

    Constraints must be pure.  Update is not pure.
    Calls must have pure actuals + receiver.
    What about alising?


\item Soft typing with conditional types (Aiken, POPL94)

Aiken, Wimmers, and T.K. Lakshman.

\item Cayenne (Augustsson, ICFP98)

Result type of function can depend on argument value.
Any expression is a type.
Haskell-like.
Undecidable type checking.

\item Cardelli, type checking dependent types and subtypes

\item Esterel

\item Findler, Felleisen, Contracts for higher-order functions (ICFP02)

example: int[> 9]

contracts are either simple predicates or function contracts.
defined by (define/contract ...)

enforced at run-time.

\item Jif (final access paths in security labels)
\item FX-90
\item ESCJava \cite{esc-java}, Spec\#
\item JSR 308, Javari
\item Freeman, Pfenning, Refinement types for ML (PLDI91)
\item Holt, Cordy, the Turing programming language
\item Mandelbaum, Walker, Harper, effective thy of type refinements
\item Ou, Tan, Mandelbaum, Walker, Dynamic typing with dependent types

Separate dependent and simple parts of the program.
Statically type the dependent parts.
Dynamic checks when passing values into dependent part.

\item Dependently typed data structurse (Xi)
\item Dead code elimination through dependent types (Xi)
\end{itemize}

\section{Constrained FJ}
\label{sec:lang}

%II. Language design and rules (CFJ) (3.5 pages)

CFJ with field assignments.

Discussion of language design issues

-- how should method resolution be done in the presence of constrained
   types?

-- conditional fields.
-- recursive definitions of predicates in the constraint language
   through the use of CLP.

Constraint system (generic presentation).
Design is constraint-system agnostic.

Principal clause

\section{Semantics}
\label{sec:semantics}

\newcommand{\starderives}{\derives^*}
\def\from#1\infer#2{{{\textstyle #1}\over{\textstyle #2}}}
\def\axname#1\axiom#2{{\textstyle #2}{\ \textstyle(\mbox{#1)}}}
\def\rname#1\from#2\infer#3{{{\textstyle #2}\over{\textstyle #3}}{\ \textstyle(\mbox{#1)}}}
\def\derives{\longrightarrow}
\def\subtype{\sqsubseteq}

\def\super{\mbox{\tt super}}
\def\class{\mbox{\tt class}}
\def\extends{\mbox{\tt extends}}
\def\return{\mbox{\tt return}}
\def\new{\mbox{\tt new}}
\def\this{\mbox{\tt this}}
\def\self{\mbox{\tt self}}

\begin{figure*}

\paragraph{Syntax.} 
The syntax for the language is specified as follows. We assume a fixed
constraint system, $\cal C$, with inference relation $\vdash_{\cal
C}$. However, we require all constraint systems to support conjunction
and existential quantification.

\begin{tabular}{rrcl}
&&&\\
(Class) & L &{::=}& $\class \ T\  \extends\ T\ \{\bar{T} \bar{f};\ K\ \bar{M}\}$ \\
(Ctor) & K &{::=}& $T(\bar{T} \bar{x})\{\super(\bar{x});\bar{f}=\bar{x}\}$\\
(Method)& M &{::=}& $T\ m(\bar{T}\ \bar{x})\{\return\ e;\}$\\
(Expr)& e &{::=}& $x \alt e.f \alt e.m(\bar{e})\alt \new\ C(\bar{e})\alt (T)e$\\\quad\\
(C Terms) & t&{::=}& x\alt \self \alt t.f\\
(Constraint) & c,d&{::=}&$a\alt t=t\alt c,c\alt T\,x;c$\\
(Type)& S,T,U&{::=}& $C(:d)$\\
&&&\\
\end{tabular}

\paragraph{Subtyping Judgements.}
We let $\Gamma$ stand for multisets of type assertions, of the form
$T\,x$, and constraints. We define $\sigma(\Gamma)$ to be the set of
constraints obtained from $\Gamma$ by replacing each type assertion
${\tt C(:d)\ x}$ with ${\tt d}[{\tt x}/\self]$. 

$$
\begin{array}{ll}
\Gamma\vdash {\tt T} \subtype {\tt T}
&
\from{\class\ {\tt C(:c)}\, \extends\, {\tt D(:d)}\{\ldots\}}
\infer{\vdash {\tt C(:c) \subtype D(:d)}}
\\ & \\
\from{\Gamma \vdash {\tt C \subtype D} \ \ \ \sigma(\Gamma),{\tt c} \vdash_{\cal C} {\tt d}}
\infer{\Gamma \vdash {\tt C(:c) \subtype D(:d)}}
&
\from{\Gamma \vdash {\tt S \subtype T} \ \ \ \Gamma \vdash {\tt T \subtype U}}
\infer{\Gamma \vdash {\tt S \subtype U}}
\end{array}
$$

\paragraph{Type Judgements.}

$$
\begin{array}{ll}
\axname{T-VAR}
\axiom{\Gamma, {\tt T}\ {\tt x} \vdash {\tt T}\ {\tt x}}
&  
\rname{CONSTR}
\from{\Gamma \vdash {\tt C(:c)\ x} \ \ \ \sigma(\Gamma) \vdash_{\cal C}{\tt d[x/\self]}}
\infer{\Gamma \vdash {\tt C(:c,d)\ x}} 
\\ \quad \\
\rname{T-Field}
\from{\Gamma \vdash {\tt T}_0\ {\tt e} \ \ \ fields({\tt T}_0)= \bar{\tt U}(:\bar{\tt d}) \bar{\tt f}}
\infer{\Gamma \vdash {\tt U}_i(:{\tt T}_0\ \this;\this.{\tt f}=\self,{\tt d}_i)\, {\tt e.f}_i} \\
& \\
\rname{T-UCast}
\from{\Gamma \vdash {\tt S\ e}\ \ \Gamma \vdash {\tt S} \subtype {\tt T}}
\infer{\Gamma \vdash {\tt T\ (T) e}} & 
\rname{T-DCast}
\from{\Gamma \vdash {\tt S\ e}\ \ \Gamma \vdash {\tt T} \subtype {\tt S}}
\infer{\Gamma \vdash {\tt T\ (T) e}} \\
& \\
\rname{T-SCast}
\from{\Gamma \vdash {\tt S\ e}\ \ \Gamma \not\vdash {\tt T \subtype S} \ \ 
\Gamma \not\vdash {\tt S \subtype T} \ \ }
\infer{\Gamma \vdash {\tt T\ (T) e}} \\
& \\
\rname{T-INVK}
\from{\begin{array}{l}
\Gamma \vdash {\tt T}_{0:n} {\tt e}_{0:n} \\
{\tt T}_0 \rhd {\tt S(:d) m(Z}_{1:n}\, {\tt z}_{1:n}) \\
\Gamma, {\tt T}_0\ \this, {\tt T}_{1:i-1}\ {\tt z}_{1:i-1} \vdash {\tt T}_i \subtype {\tt Z}_i\ \ (i\in 1:n)
\end{array}}
\infer{\Gamma \vdash {\tt S(:T}_0\ \this;{\tt T}_{1:n}\ {\tt z}_{1:n};{\tt d})\ {\tt e}_0.{\tt m(e}_{1:n}{\tt)}} &
\rname{T-NEW}
\from{
  \begin{array}{l}
    \Gamma \vdash {\tt T}_{1:n}\ {\tt e}_{1:n} \\
    {\tt C} \rhd {\tt C(:d)(Z}_{1:n}\ {\tt f}_{1:n}{\tt )} \\
    \Gamma, {\tt T}_{1:(i-1)}\ {\tt f}_{1:(i-1)} \vdash {\tt T}_i \subtype {\tt Z}_i \ \ (i\in 1:n)\\
    \Gamma,  {\tt T}_{1:n}\ {\tt f}_{1:n} \vdash {\tt d}\\
  \end{array}
}
\infer{\Gamma \vdash {\tt C(:T}_{1:n}\ {\tt f}_{1:n}{\tt ;\self.f}_{1:n}={\tt f}_{1:n}{\tt ,d)}\ \new\ {\tt C(e}_{1:n}{\tt )}} \\
\end{array}
$$
\paragraph{Method and Class Typing.}
$$
\begin{array}{ll}
\from{
  \begin{array}{l}
    \bar{T}\ \bar{x}, C\ \this \vdash S\ e   \\
    \bar{T}\ \bar{x}, C\ \this \vdash S \subtype T   \\
  \end{array}}
\infer{T\,m(\bar{T}\,\bar{x})\{\return\ e;\}\ \mbox{OK in}\ C} &
\from{
  \begin{array}{l}
    K=C(\bar{S}\,\bar{g},\bar{T}\,\bar{f})\{\super(\bar{g});\this.\bar{f}=\bar{f};\}\\
    D \rhd \bar{S}\ \bar{g}\ \\ 
    \bar{M}\ \mbox{OK in}\ C\\
  \end{array}}
\infer{\class\ C\ \extends\ D\ \{\bar{T}\bar{f};K\,\bar{M}\}\ \mbox{OK}} 
\end{array}
$$

\caption{Constrained FJ}\label{FJ-Table}
\end{figure*}

\begin{figure*}
\paragraph{Computation:}

$$
\begin{array}{c}
\rname{{\sc R-FIELD}}
\from{fields(C)=\bar{C}\ \bar{f}}
\infer{(\new\ {\tt C}(\bar{\tt e})).{\tt f}_i \derives {\tt e}_i} \\ \quad\\
\rname{{\sc R-INVK}}
\from{mbody({\tt m},{\tt C})=\bar{x}. \bar{e}_0}
\infer{(\new\ {\tt C}(\bar{\tt e})).{\tt m}(\bar{\tt d}) \derives 
[\bar{d}/\bar{x},\new\ C(\bar{e})/\this]{\tt e}_0} \\ \quad\\
\rname{{\sc R-CAST}}
\from{\vdash C \subtype D[\new\ C(\bar{\tt d})/\self]}
\infer{{\tt (D)(\new\ C(\bar{\tt d}))} \derives \new\ C(\bar{\tt d})}
\end{array}
$$
\paragraph{Congruence:}
$$
\begin{array}{c}
\rname{{\sc RC-FIELD}}
\from{{\tt e}_0 \derives {{\tt e}_0}'}
\infer{{\tt e}_0.{\tt f} \derives {{\tt e}_0}'.{\tt f}} \\ \quad\\
\rname{{\sc RC-INVK-RECV}}
\from{{\tt e}_0 \derives {{\tt e}_0}'}
\infer{{\tt e}.{\tt m}(\bar{\tt e}) \derives {{\tt e}_0}'.{\tt m}(\bar{\tt e})} \\ \quad\\
\rname{{\sc RC-INVK-ARG}}
\from{{\tt e}_i \derives {{\tt e}_i}'}
\infer{{\tt e}.{\tt m}(\ldots,{\tt e}_i,\ldots) \derives {{\tt e}_0}.{\tt m}(\ldots,{\tt e}_i',\ldots)}\\ \quad\\
\rname{{\sc RC-NEW-ARG}}
\from{{\tt e}_i \derives {{\tt e}_i}'}
\infer{\new\ {\tt C}(\ldots,{\tt e}_i,\ldots) \derives \new\ {\tt C}(\ldots,{\tt e}_i',\ldots)} \\ \quad\\
\rname{{\sc RC-CAST}}
\from{{\tt e}_0 \derives {{\tt e}_0}'}
\infer{{\tt (C) e}_0 \derives {{\tt (C) e}_0}'}
\end{array}
$$

\caption{Reduction rules for Constrained FJ}\label{CFJ-red-rules}
\end{figure*}

\begin{theorem}[Subject Reduction] 

If $\Gamma \vdash T\ e$ and $e \derives e'$ then for some type $S$,
$\Gamma \vdash S\ e'$ and $\Gamma \vdash S \subtype T$.

\end{theorem}

Let the normal form of expressions be given by {\em values},
i.e. expressions 

\begin{tabular}{rrcl}
&&&\\
(Values) & {\tt v} &{::=}& $\new\ {\tt C(\bar{\tt v})}$
\end{tabular}

\begin{theorem}[Type Soundness] 

If $\vdash T\ e$ and $e \starderives e' \not\derives$ then $e'$ is
either (1)~a value {\tt } with $\vdash {\tt S\ v}$ and $\vdash {\tt S
\subtype T}$, for some type {\tt S}, or, (2)~ an expression containing
a subexpression ${\tt (T)\new\ C(\bar{\tt v})}$ where 
$\not\vdash \tt C\subtype T[\new\ C(\bar{\tt v})/\self]$.

\end{theorem}


\section{Examples}
\label{sec:examples}

%III. Applied constrained calculii. (3 pages)
%
%For each example below, formal static and dynamic semantics rules for
%new constructs extension over the core CFJ. Subject-reduction and
%type-soundness theorems. Proofs to be found in fuller version of
%paper.
%
%(a) arrays, region, distributions -- type safe implies no arrayoutofbounds
%exceptions, only ClassCastExceptions (when dynamic checks fail).
%
%Use Satish's conditional constraints example.
%-- emphasize what is new over DML. 
%
%(b) places, concurrency -- place types.
%
%(c) ownership types, alias control.
%

Specific constraint systems used when developing specific
examples.

\subsection{Binary methods}

The binary method problem \cite{bruce}.

Bruce and Cardelli and Castagna and Leavens and Pierce,
On Binary Methods, TAPOS 1(3): 221--242, Fall 1995.

\begin{verbatim}
interface Set {
    Set(:self.class == this.class)
        union(Set(:self.class == this.class) s);
    boolean superSetOf(Set(:self.class == this.class) s);
}

class IntSet implements Set {
    long bits;

    Set(:self.class == this.class)
        union(Set(:self.class == this.class) s) {

        Set(:self.class == this.class) r = new IntSet();
        // need to be able to conclud that r : IntSet
        r.bits = this.bits | s.bits;
        return r;
    }

    boolean superSetOf(Set(:self.class == this.class) s) {
        return (s.bits & ~bits) == 0;
    }
}
\end{verbatim}

\subsection{Cayenne examples}





\subsection{DML examples}

Red/black tree invariant.

Invariant:
1. all leaves black
2. for each node n, there are the same number of black nodes on
every path from n to a leaf (the black height)
3. the immediate children of every red node are black

\begin{verbatim}
class Tree(boolean isBlack, int blackHeight, Tree left, Tree right
  : ( left == null && right == null ||   // leaf or interior
      left != null && right != null
    )
    &&
    ( left == null || left.value < right.value )   // ordered
    &&
    ( left != null || isBlack )   // leaves are black
    &&
    ( left != null || blackHeight == 0 ) // leaves have height 0
    &&
    ( left == null || blackHeight == left.blackHeight + 1 )
    &&
    ( right == null || blackHeight == right.blackHeight + 1 )
    &&
    ( isBlack || ( left.isBlack && right.isBlack ) )
  )
{
    int value;

    // empty
    Tree(: isBlack && blackHeight == 0 && left == null && right == null)
        () {
        property(isBlack, 0, null, null);
    }

    // black
    Tree(: isBlack && blackHeight == l.blackHeight+1 && left == l && right == r)
        (Tree l, Tree r, int v : l.blackHeight == r.blackHeight) {
        property(true, l.blackHeight+1, l, r);
        this.value = v;
    }
       
    // red: use a dummy argument to overload
    Tree(: !isBlack && blackHeight == l.blackHeight && left == l && right == r)
        (Tree l, Tree r, int v, Object _ : l.blackHeight == r.blackHeight) {
        property(false, l.blackHeight, l, r);
        this.value = v;
    }

    // need to show add, remove preserve the invariant
}
\end{verbatim}

Bounds checks.

\begin{code}
class Array \{
    T[] a;
    T get(int(:0 <= self \&\& self < a.length) i) \{ return a[i]; \}
    void set(int(:0 <= self \&\& self < a.length) i, T v) \{ a[i] = v; \}
\}
\end{code}

\subsection{Nullable types}

Nullable types (T(:self != null))

\subsection{Arrays}

Array/region/distribution types (examples from X10)

\cite{gps06-arrays}

\subsection{Places}

Place types (examples from X10)

\subsection{Clocks}

Clock types

\subsection{Capabilities}

Capablities (from Radha and Vijay's paper on neighborhoods)

\subsection{Ownership types}

Ownership types~\cite{ownership-types}

\subsection{Discussion}

Dependent types are of use in annotations~\cite{ns07-x10anno}.

\section{Implementation}
\label{sec:implementation}

%IV. Implementation (0.5 page)
%
%Specify what has been implemented and how. What is interesting about
%the implementation.

The dependent type system is implemented in the X10
compiler~\cite{X10}, which is implemented as an extension of
Java using the Polyglot compiler framework~\cite{ncm03}.

Polyglot implements a source-to-source base Java compiler 
that is extended to translate X10 to Java.  For purposes of this
paper, we ignore the additional statement and expression types
introduced in X10 and treat the language as simply Java
extended with constrained types.

Type-checking is implemented as two passes.  The first pass
performs type-checking using the base compiler implementation
augmented with additional code for new statement and expression
types introduced in X10. In this pass, expressions used in
dependent types are type-checked using the non-dependent type
system, however, no constraint solving is performed.
The second pass generates and solves constraints via an
ask--tell interface~\cite{my-thesis-book}.
If constraints cannot be solved, an error is reported.

After constraint checking, the X10 code is translated to Java.
The basic idea behind the translation is simple. Each dependent class
is translated into a single class of the same name without dependent
types). The explicit properties of the dependent class are translated
into {\tt public final} (instance) fields of the target class.
A {\tt property} statement in a constructor is translated to a
sequence of assignments to initialize the property fields.

For each property, there is also a getter method in the class.
Properties declared in interfaces are translated into getter
method signatures.  Subclasses implementing these interfaces
thus provide the required properties by implementing the
generated interfaces.

For the most part, constraints are simply erased from the
generated code.
However, dependent types may be used in casts
and {\tt instanceof} expressions.  These are translated to Java
in straightforward manner by evaluating the constraint with
{\tt self} bound to the expression being tested.

\begin{code}
  $\Lb$e instanceof C(:c)$\Rb$ = 
    new Object() \{
      boolean check(Object o) \{
        if (o instanceof C) \{
          C self = (C) o;
          return $\Lb$c$\Rb$;
        \}
        return false;
      \}
    \}.check($\Lb$e$\Rb$)
\end{code}

\begin{code}
  $\Lb$(C(:c) e$\Rb$ = 
    new Object() \{
      C cast(C self) \{
        if ($\Lb$c$\Rb$)
          return self;
        throw new ClassCastException();
      \}
    \}.cast((C) $\Lb$e$\Rb$)
\end{code}




\section{Future work}
\label{sec:future}

%V. Conclusion and future work. (0.5 page)
%
%state-dependent constrained types.
%
%use of dependent types for optimization. 
%
%type-inference.
%
%Bibliography (1.5 page)

State-dependent constrained types

Use of dependent types for optimization

Constraints on control-flow

Type inference

\section{Conclusions}
\label{sec:conclusions}

We have presented a simple design for dependent types in \java-like
languages. The design considerably enriches the space of (mostly)
statically checkable types expressible in the language. This is
particularly important for data-structurs such as lists and arrays. We
have shown a simple translation scheme for dependent types into an
underlying language with {\tt assert} and {\tt assume} statements.
The assert and assume statements generated by this translation have
the important property of state invariance. This enables a very simple
notion of simplification for such programs. A general constraint
propagator can simplify programs by using ask and tell operations on
the underlying constraint system. Assert statements are removed if they
are entailed by the conjunction of {\tt assume}s on each path to the
statement.

Our treatment is parametric in that the underlying constraint system
can vary. Indeed the constraint system is not required to be complete;
any incompleteness results merely in certain asserts being relegated
to runtime. Some of these asserts may throw runtime exceptions if they
are violated.

In future work we plan to investigate optimizations (such as array
bounds check elimination) enabled by dependent types. We also plan to
pursue much richer constraint systems, e.g., those necessary to deal
with regions, cyclic and block-cyclic distributions etc.

\section*{Acknowledgments}

Igor Peshansky,
Lex Spoon,
Vincent Cave.


\bibliographystyle{plain}
\bibliography{master}
\balance
\appendix
\onecolumn

\section{An extended example}
{\footnotesize
\begin{verbatim}
/**
   A distributed binary tree.
   @author Satish Chandra 4/6/2006
   @author vj
 */
//                             ____P0
//                            |     |
//                            |     |
//                          _P2  __P0
//                         |  | |   |
//                         |  | |   |
//                        P3 P2 P1 P0
//                         *  *  *  *
// Right child is always on the same place as its parent;
// left child is at a different place at the top few levels of the tree,
// but at the same place as its parent at the lower levels.

class Tree(localLeft: boolean,
           left: nullable Tree(& localLeft => loc=here),
           right: nullable Tree(& loc=here),
           next: nullable Tree) extends Object {
    def postOrder:Tree = {
        val result:Tree = this;
        if (right != null) {
            val result:Tree = right.postOrder();
            right.next = this;
            if (left != null) return left.postOrder(tt);
        } else if (left != null) return left.postOrder(tt);
        this
    }
    def postOrder(rest: Tree):Tree = {
        this.next = rest;
        postOrder
    }
    def sum:int = size + (right==null => 0 : right.sum()) + (left==null => 0 : left.sum)
}
value TreeMaker {
    // Create a binary tree on span places.
    def build(count:int, span:int): nullable Tree(& localLeft==(span/2==0)) = {
        if (count == 0) return null;
        {val ll:boolean = (span/2==0);
         new Tree(ll,  eval(ll => here : place.places(here.id+span/2)){build(count/2, span/2)},
           build(count/2, span/2),count)}
    }
}
\end{verbatim}}

\subsection{Places}
{\footnotesize
\begin{verbatim}
/**

 * This class implements the notion of places in X10. The maximum
 * number of places is determined by a configuration parameter
 * (MAX_PLACES). Each place is indexed by a nat, from 0 to MAX_PLACES;
 * thus there are MAX_PLACES+1 places. This ensures that there is
 * always at least 1 place, the 0'th place.

 * We use a dependent parameter to ensure that the compiler can track
 * indices for places.
 *
 * Note that place(i), for i <= MAX_PLACES, can now be used as a non-empty type.
 * Thus it is possible to run an async at another place, without using arays---
 * just use async(place(i)) {...} for an appropriate i.

 * @author Christoph von Praun
 * @author vj
 */

package x10.lang;

import x10.util.List;
import x10.util.Set;

public value class place (nat i : i <= MAX_PLACES){

    /** The number of places in this run of the system. Set on
     * initialization, through the command line/init parameters file.
     */
    config nat MAX_PLACES;

    // Create this array at the very beginning.
    private constant place value [] myPlaces = new place[MAX_PLACES+1] fun place (int i) {
	return new place( i )(); };

    /** The last place in this program execution.
     */
    public static final place LAST_PLACE = myPlaces[MAX_PLACES];

    /** The first place in this program execution.
     */
    public static final place FIRST_PLACE = myPlaces[0];
    public static final Set<place> places = makeSet( MAX_PLACES );

    /** Returns the set of places from first place to last place.
     */
    public static Set<place> makeSet( nat lastPlace ) {
	Set<place> result = new Set<place>();
	for ( int i : 0 .. lastPlace ) {
	    result.add( myPlaces[i] );
	}
	return result;
    }

    /**  Return the current place for this activity.
     */
    public static place here() {
	return activity.currentActivity().place();
    }

    /** Returns the next place, using modular arithmetic. Thus the
     * next place for the last place is the first place.
     */
    public place(i+1 % MAX_PLACES) next()  { return next( 1 ); }

    /** Returns the previous place, using modular arithmetic. Thus the
     * previous place for the first place is the last place.
     */
    public place(i-1 % MAX_PLACES) prev()  { return next( -1 ); }

    /** Returns the k'th next place, using modular arithmetic. k may
     * be negative.
     */
    public place(i+k % MAX_PLACES) next( int k ) {
	return places[ (i + k) % MAX_PLACES];
    }

    /**  Is this the first place?
     */
    public boolean isFirst() { return i==0; }

    /** Is this the last place?
     */
    public boolean isLast() { return i==MAX_PLACES; }
}
\end{verbatim}}
\subsection{$k$-dimensional regions}
{\footnotesize
\begin{verbatim}
package x10.lang;

/** A region represents a k-dimensional space of points. A region is a
 * dependent class, with the value parameter specifying the dimension
 * of the region.
 * @author vj
 * @date 12/24/2004
 */

public final value class region( int dimension : dimension >= 0 )  {

    /** Construct a 1-dimensional region, if low <= high. Otherwise
     * through a MalformedRegionException.
     */
    extern public region (: dimension==1) (int low, int high)
        throws MalformedRegionException;

    /** Construct a region, using the list of region(1)'s passed as
     * arguments to the constructor.
     */
    extern public region( List(dimension)<region(1)> regions );

    /** Throws IndexOutOfBoundException if i > dimension. Returns the
        region(1) associated with the i'th dimension of this otherwise.
     */
    extern public region(1) dimension( int i )
        throws IndexOutOfBoundException;


    /** Returns true iff the region contains every point between two
     * points in the region.
     */
    extern public boolean isConvex();

    /** Return the low bound for a 1-dimensional region.
     */
    extern public (:dimension=1) int low();

    /** Return the high bound for a 1-dimensional region.
     */
    extern public (:dimension=1) int high();

    /** Return the next element for a 1-dimensional region, if any.
     */
    extern public (:dimension=1) int next( int current )
        throws IndexOutOfBoundException;

    extern public region(dimension) union( region(dimension) r);
    extern public region(dimension) intersection( region(dimension) r);
    extern public region(dimension) difference( region(dimension) r);
    extern public region(dimension) convexHull();

    /**
       Returns true iff this is a superset of r.
     */
    extern public boolean contains( region(dimension) r);
    /**
       Returns true iff this is disjoint from r.
     */
    extern public boolean disjoint( region(dimension) r);

    /** Returns true iff the set of points in r and this are equal.
     */
    public boolean equal( region(dimension) r) {
        return this.contains(r) && r.contains(this);
    }

    // Static methods follow.

    public static region(2) upperTriangular(int size) {
        return upperTriangular(2)( size );
    }
    public static region(2) lowerTriangular(int size) {
        return lowerTriangular(2)( size );
    }
    public static region(2) banded(int size, int width) {
        return banded(2)( size );
    }

    /** Return an \code{upperTriangular} region for a dim-dimensional
     * space of size \code{size} in each dimension.
     */
    extern public static (int dim) region(dim) upperTriangular(int size);

    /** Return a lowerTriangular region for a dim-dimensional space of
     * size \code{size} in each dimension.
     */
    extern public static (int dim) region(dim) lowerTriangular(int size);

    /** Return a banded region of width {\code width} for a
     * dim-dimensional space of size {\code size} in each dimension.
     */
    extern public static (int dim) region(dim) banded(int size, int width);


}

\end{verbatim}}

\subsection{Point}
{\footnotesize
\begin{verbatim}
package x10.lang;

public final class point( region region ) {
    parameter int dimension = region.dimension;
    // an array of the given size.
    int[dimension] val;

    /** Create a point with the given values in each dimension.
     */
    public point( int[dimension] val ) {
        this.val = val;
    }

    /** Return the value of this point on the i'th dimension.
     */
    public int valAt( int i) throws IndexOutOfBoundException {
        if (i < 1 || i > dimension) throw new IndexOutOfBoundException();
        return val[i];
    }

    /** Return the next point in the given region on this given
     * dimension, if any.
     */
    public void inc( int i )
        throws IndexOutOfBoundException, MalformedRegionException {
        int val = valAt(i);
        val[i] = region.dimension(i).next( val );
    }

    /** Return true iff the point is on the upper boundary of the i'th
     * dimension.
     */
    public boolean onUpperBoundary(int i)
        throws IndexOutOfBoundException {
        int val = valAt(i);
        return val == region.dimension(i).high();
    }

    /** Return true iff the point is on the lower boundary of the i'th
     * dimension.
     */
    public boolean onLowerBoundary(int i)
        throws IndexOutOfBoundException {
        int val = valAt(i);
        return val == region.dimension(i).low();
    }
}
\end{verbatim}}

\subsection{Distribution}
{\footnotesize
\begin{verbatim}
package x10.lang;

/** A distribution is a mapping from a given region to a set of
 * places. It takes as parameter the region over which the mapping is
 * defined. The dimensionality of the distribution is the same as the
 * dimensionality of the underlying region.

   @author vj
   @date 12/24/2004
 */

public final value class distribution( region region ) {
    /** The parameter dimension may be used in constructing types derived
     * from the class distribution. For instance,
     * distribution(dimension=k) is the type of all k-dimensional
     * distributions.
     */
    parameter int dimension = region.dimension;

    /** places is the range of the distribution. Guranteed that if a
     * place P is in this set then for some point p in region,
     * this.valueAt(p)==P.
     */
    public final Set<place> places; // consider making this a parameter?

    /** Returns the place to which the point p in region is mapped.
     */
    extern public place valueAt(point(region) p);

    /** Returns the region mapped by this distribution to the place P.
        The value returned is a subset of this.region.
     */
    extern public region(dimension) restriction( place P );

    /** Returns the distribution obtained by range-restricting this to Ps.
        The region of the distribution returned is contained in this.region.
     */
    extern public distribution(:this.region.contains(region))
        restriction( Set<place> Ps );

    /** Returns a new distribution obtained by restricting this to the
     * domain region.intersection(R), where parameter R is a region
     * with the same dimension.
     */
    extern public (region(dimension) R) distribution(region.intersection(R))
        restriction();

    /** Returns the restriction of this to the domain region.difference(R),
        where parameter R is a region with the same dimension.
     */
    extern public (region(dimension) R) distribution(region.difference(R))
        difference();

    /** Takes as parameter a distribution D defined over a region
        disjoint from this. Returns a distribution defined over a
        region which is the union of this.region and D.region.
        This distribution must assume the value of D over D.region
        and this over this.region.

        @seealso distribution.asymmetricUnion.
     */
    extern public (distribution(:region.disjoint(this.region) &&
                                dimension=this.dimension) D)
        distribution(region.union(D.region)) union();

    /** Returns a distribution defined on region.union(R): it takes on
        this.valueAt(p) for all points p in region, and D.valueAt(p) for all
        points in R.difference(region).
     */
    extern public (region(dimension) R) distribution(region.union(R))
        asymmetricUnion( distribution(R) D);

    /** Return a distribution on region.setMinus(R) which takes on the
     * same value at each point in its domain as this. R is passed as
     * a parameter; this allows the type of the return value to be
     * parametric in R.
     */
    extern public (region(dimension) R) distribution(region.setMinus(R))
        setMinus();

    /** Return true iff the given distribution D, which must be over a
     * region of the same dimension as this, is defined over a subset
     * of this.region and agrees with it at each point.
     */
    extern public (region(dimension) r)
        boolean subDistribution( distribution(r) D);

    /** Returns true iff this and d map each point in their common
     * domain to the same place.
     */
    public boolean equal( distribution( region ) d ) {
        return this.subDistribution(region)(d)
            && d.subDistribution(region)(this);
    }

    /** Returns the unique 1-dimensional distribution U over the region 1..k,
     * (where k is the cardinality of Q) which maps the point [i] to the
     * i'th element in Q in canonical place-order.
     */
    extern public static distribution(:dimension=1) unique( Set<place> Q );

    /** Returns the constant distribution which maps every point in its
        region to the given place P.
    */
    extern public static (region R) distribution(R) constant( place P );

    /** Returns the block distribution over the given region, and over
     * place.MAX_PLACES places.
     */
    public static (region R) distribution(R) block() {
        return this.block(R)(place.places);
    }

    /** Returns the block distribution over the given region and the
     * given set of places. Chunks of the region are distributed over
     * s, in canonical order.
     */
    extern public static (region R) distribution(R) block( Set<place> s);


    /** Returns the cyclic distribution over the given region, and over
     * all places.
     */
    public static (region R) distribution(R) cyclic() {
        return this.cyclic(R)(place.places);
    }

    extern public static (region R) distribution(R) cyclic( Set<place> s);

    /** Returns the block-cyclic distribution over the given region, and over
     * place.MAX_PLACES places. Exception thrown if blockSize < 1.
     */
    extern public static (region R)
        distribution(R) blockCyclic( int blockSize)
        throws MalformedRegionException;

    /** Returns a distribution which assigns a random place in the
     * given set of places to each point in the region.
     */
    extern public static (region R) distribution(R) random();

    /** Returns a distribution which assigns some arbitrary place in
     * the given set of places to each point in the region. There are
     * no guarantees on this assignment, e.g. all points may be
     * assigned to the same place.
     */
    extern public static (region R) distribution(R) arbitrary();

}
\end{verbatim}}

\subsection{Arrays}
Finally we can now define arrays. An array is built over a
distribution and a base type.

{\footnotesize
\begin{verbatim}
package x10.lang;

/** The class of all  multidimensional, distributed arrays in X10.

    <p> I dont yet know how to handle B@current base type for the
    array.

 * @author vj 12/24/2004
 */

public final value class array ( distribution dist )<B@P> {
    parameter int dimension = dist.dimension;
    parameter region(dimension) region = dist.region;

    /** Return an array initialized with the given function which
        maps each point in region to a value in B.
     */
    extern public array( Fun<point(region),B@P> init);

    /** Return the value of the array at the given point in the
     * region.
     */
    extern public B@P valueAt(point(region) p);

    /** Return the value obtained by reducing the given array with the
        function fun, which is assumed to be associative and
        commutative. unit should satisfy fun(unit,x)=x=fun(x,unit).
     */
    extern public B reduce(Fun<B@?,Fun<B@?,B@?>> fun, B@? unit);


    /** Return an array of B with the same distribution as this, by
        scanning this with the function fun, and unit unit.
     */
    extern public array(dist)<B> scan(Fun<B@?,Fun<B@?,B@?>> fun, B@? unit);

    /** Return an array of B@P defined on the intersection of the
        region underlying the array and the parameter region R.
     */
    extern public (region(dimension) R)
        array(dist.restriction(R)())<B@P>  restriction();

    /** Return an array of B@P defined on the intersection of
        the region underlying this and the parametric distribution.
     */
    public  (distribution(:dimension=this.dimension) D)
        array(dist.restriction(D.region)())<B@P> restriction();

    /** Take as parameter a distribution D of the same dimension as *
     * this, and defined over a disjoint region. Take as argument an *
     * array other over D. Return an array whose distribution is the
     * union of this and D and which takes on the value
     * this.atValue(p) for p in this.region and other.atValue(p) for p
     * in other.region.
     */
    extern public (distribution(:region.disjoint(this.region) &&
                                dimension=this.dimension) D)
        array(dist.union(D))<B@P> compose( array(D)<B@P> other);

    /** Return the array obtained by overlaying this array on top of
        other. The method takes as parameter a distribution D over the
        same dimension. It returns an array over the distribution
        dist.asymmetricUnion(D).
     */
    extern public (distribution(:dimension=this.dimension) D)
        array(dist.asymmetricUnion(D))<B@P> overlay( array(D)<B@P> other);

    extern public array<B> overlay(array<B> other);

    /** Assume given an array a over distribution dist, but with
     * basetype C@P. Assume given a function f: B@P -> C@P -> D@P.
     * Return an array with distribution dist over the type D@P
     * containing fun(this.atValue(p),a.atValue(p)) for each p in
     * dist.region.
     */
    extern public <C@P, D>
        array(dist)<D@P> lift(Fun<B@P, Fun<C@P, D@P>> fun, array(dist)<C@P> a);

    /**  Return an array of B with distribution d initialized
         with the value b at every point in d.
     */
    extern public static (distribution D) <B@P> array(D)<B@P> constant(B@? b);

}
\end{verbatim}}


\begin{example}
 The code for {\tt List} translates as given in Table~\ref{List-translation}.
\end{example}

\begin{figure*}
{\footnotesize
\begin{verbatim}
  public value class List <Node> {
    public final nat n;   // is a parameter
    nullable Node node = null;
    nullable List<Node> rest = null;  // All assignments must check n = this.n-1.

    /** Returns the empty list. Defined only when the parameter n
        has the value 0. Invocation: new List(0)<Node>().
     */
    public List ( final nat n ) {
      assume n==0;
      this.n = n;
    }

    /** Returns a list of length 1 containing the given node.
        Invocation: new List(1)<Node>( node ).
     */
    public List ( final nat n, Node node ) {
      assume n==1;                         // From the constructor precondition.
      assert 0==0 : "DependentTypeError"; // For the constructor call.
      assert n>=1 : "DependentTypeError"; // For the this call.
      this(n, node, new List<Node>(0));
    }

    public List ( final nat n, Node node, List<Node> rest ) {
      assume n>=1;                               // From the constructor precondition
      assume rest.n==n-1 : "DependentTypeError"; // From the argument type.
      this.n = n;
      this.node = node;
      assert rest.n==n-1 : "DependentTypeError"; // For the field assignment.
      this.rest = rest;
    }

    public  List<Node> append( List<Node> arg ) {
      if (n == 0) {
          final List<Node> result = arg;
          assert n+arg.n == result.n : "DependentTypeError"; // For the return value
          return result;
      } else {
          assume rest.n == n-1;
          final List<Node> argval = rest.append(arg);
          assume argval.n == rest.n+arg.n;
          assert n+arg.n-1== argval.n : "DependentTypeError"; // For the constructor call.
          final List<Node> result = new List<Node>(n+arg.n, node, argval);
          assume result.n == n+arg.n;
          assert n+arg.n == result.n : "DependentTypeError"; // For the return value
          return result;
      }
    }

\end{verbatim}}
\caption{Translation of {\tt List} (contd in Table~\ref{List-translation-2}).}\label{List-translation}
\end{figure*}
\begin{figure*}
{\footnotesize
\begin{verbatim}
    public  List<Node> rev() {
      final List<Node> arg = new List<Node>(0);
      assume arg.n = 0;                           // From the constructor call.
      final List<Node> result = rev( arg );
      assume result.n == n+arg.n;                  // From the method signature
      assert n == result.n : "DependentTypeError"; // For the return value.
      return result;
    }

    public  List(n+arg.n)<Node> rev( final List<Node> arg) {
      if (n==0) {
         assert n+arg.n == arg.n : "DependentTypeError"; // For the return value.
         return arg;
      } else {
        assert 1+arg.n-1=arg.n : "DependentTypeError"; // For the argument to the constructor
        final List<Node> arg2 = new List<Node>(1+arg.n,node, arg));
        assume arg2.n==1+arg.n;                      // From the constructor invocation
        final List<Node> restval = rest;             // Read from a mutable field of parametric type
        assume restval.n == n-1;                     // From the field read.
        final List(restval.n+arg2.n)<Node> result = restval.rev( arg2 );
        assume result.n=restval.n+arg2.n
        assert n+arg.n == result.n                   // For the return value
        return result;
    }

    /** Return a list of compile-time unknown length, obtained by filtering
        this with f. */
    public List<Node> filter(fun<Node, boolean> f) {
         if (n==0) return this;
         if (f(node)) {
           final List<Node> l = rest.filter(f);
           assert l.n+1-1==l.n : "DependentTypeError"; // For the constructor call
           return new List<Node>(l.n+1,node, l);
         } else {
           return rest.filter(f);
         }
    }

    /** Return a list of m numbers from o..m-1. */
    public static  List<nat> gen( final nat m ) {
         assert 0 <= m : "DependentTypeError";        // Precondition for method call.
         final List<nat> result = gen(0,m);
         assume result.n=m-0 : "DependentTypeError";  // From the method signature
         assert m == result.n : "DependentTypeError"; // For the return value
         return result;
    }

    /** Return a list of (m-i) elements, from i to m-1. */
    public static List<nat> gen(final nat i, final nat m) {
      assume i <= m;                                   // Method precondition.
      if (i==m) {
        assert m-i == 0 : "DependentTypeError";        // For the constructor call
        final List result = new List<nat>(m-i);
        assume result.n == 0;                          // From the constructor call.
        assert m-i == result.n : "DependentTypeError"; // For the return value.
        return result;
      } else {
        assert i+1 <= m : "DependentTypeError";        // For the method call.
        final List<nat> arg = gen(i+1,m);
        assume arg.n = m-(i+1);                        // From the method call.
        assert m-i-1 = arg.n;                          // For the constructor invocation.
        final List result = new List<nat>(m-i, i, arg);
        assume result.n = m-i;                         // From the constructor invocation.
        assert m-i == result.n : "DependentTypeError"; // For the return value
        return result;
    }
  }
\end{verbatim}}
\caption{Translation of {\tt List} (continued).}\label{List-translation-2}
\end{figure*}

\section{Type-checking dependent classes}

Each programming language---such as \Xten{}---will specify the base
underlying classes (and the operations on them) which can occur as
types in parameter lists. For instance, in the code for {\tt List}
above, the only type that appears in parameter lists is {\tt int}, and
the only operations on {\tt int} are addition, subtraction, {\tt >=},
{\tt ==}, and the only constants are {\tt 0} and {\tt 1}.  (This
language falls within Presburger arithmetic, a decidable fragment of
arithmetic.)  The compiler must come equipped with a constraint solver
(decision procedure) that can answer questions of the form: does one
constraint entail another?  Constraints are atomic formulas built up
from these operations, using variables. For instance, the compiler
must answer each one of:
{\footnotesize
\begin{verbatim}
  n >= 2 |- n-1 >= 0
  n >= 0, m >= 0 |- m+n >= 0
\end{verbatim}}

Ultimately, the only variables that will occur in constraints are
those that correspond to {\tt config} parameters and those that are
defined by implicit parameter definitions. We need to establish that
the verification of any class will generate only a finite number of
constraints, hence only a finite constraint problem for the constraint
solver.

Second, it should be possible for instances of user-defined classes
(and operations on them) to occur as type parameters. For the compiler
to check conditions involving such values, it is necessary that the
underlying constraint solver be extended.

There are two general ways in which the constraint solver may be
extended.  Both require that the programmer single out some classes
and methods on those classes as {\em pure}. (We shall think of
constants as corresponding to zero-ary methods.) Only instances of
pure classes and expressions involving pure methods on these instances
are allowed in parameter expressions.

How shall constraints be generated for such pure methods? First, the
programmer may explicitly supply with each pure method {\tt T m(T1 x1,
..., Tn xn)} a constraint on {\tt n+2} variables in the constraint
system of the underlying solver that is entailed by {\tt y =
o.m(x1,..., xn)}. Whenever the compiler has to perform reasoning on an
expression involving this method invocation, it uses the constraint
supplied by the programmer. A second more ambitious possibility is
that a symbolic evaluator of the language may be run on the body of
the method to automatically generate the corresponding constraint.

Finally an additional possibility is that the constraint solver itself
be made extensible. In this case, when a user writes a class which is
intended to be used in specifying parameters, he also supplies an
additional program which is used to extend the underlying constraint
solver used by the compiler. This program adds more primitive
constraints and knows how to perform reasoning using these
constraints. This is how I expect we will initially implement the
\Xten{} language. As language designers and implementers we will
provide constraint solvers for finite functions and {\tt Herbrand}
terms on top of arithmetic.



\end{document}
