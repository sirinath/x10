
Generic constrained types generalize virtual types and 
have a connection to parametric types with use-site variance
annotations, such as Java's wildcards.  

\subsection{Virtual types}

Type properties share many similarities with virtual
types~\cite{mp89-virtual-classes,beta,ernst99-gbeta,ernst06-virtual,cdnw07-tribe}
and similar constructs built on path-dependent types found in
languages such as Scala~\cite{scala}, and J\&~\cite{nqm06}.
Indeed, one of the first proposals for adding genericity to Java
was via virtual types~\cite{thorup97}, and Java
wildcards (i.e., parameters with use-site variance)
were developed from a line of work beginning with virtual
types~\cite{unifying-genericity,variant-parametric-types,adding-wildcards}.

Constrained types are more expressive than virtual
types in that they can be constrained at the use-site,
can be refined on a per-object basis without explicit subclassing,
and can be refined contravariantly
as well as covariantly. 

Thorup~\cite{thorup97}
proposed adding genericity to Java using virtual types.  For example,
a generic \xcd"List" class can be written as follows:
{\footnotesize
\begin{xten}
abstract class List {
  abstract typedef T;
  void add(T element) { ... }
  T get(int i) { ... }
}
\end{xten}}
This class can be refined by bounding the virtual type \xcd"T" above:
{\footnotesize
\begin{xten}
abstract class NumberList extends List {
  abstract typedef T as Number;
}
\end{xten}}
This abstract class can be further refined to \emph{final bind}
\xcd"T" to a particular type:
{\footnotesize
\begin{xten}
class IntList extends NumberList {
  final typedef T as Integer;
}
\end{xten}}
These classes are related by subtyping:
{\tt IntList} \subtype {\tt NumberList} \subtype {\tt List}.
Only classes where \xcd"T" is final bound can be non-abstract.
%
The analogous definition of 
\xcd"List" using type properties follows:
{\footnotesize
\begin{xten}
class List[T] {
  def this[T]() = { ... }
  def add(element: T) = { ... }
  def get(i: int): T = { ... }
}
\end{xten}}

\noindent
\xcd"NumberList" and \xcd"IntList" can be written as follows:
{\footnotesize
\begin{xten}
class NumberList extends List{T<:Number} { }
class IntList extends NumberList{T==Integer} { }
\end{xten}}

However, note that our version of \xcd"List" is not abstract;
\xcd"T" need not be instantiated by a subclass because it can be
instantiated on a per-object basis in the constructor.
There is no
need to declared classes for \xcd"NumberList" and \xcd"IntList".
Instead, one can simply use the types
\xcd"List{T<:Number}" and \xcd"List{T==Integer}".

In addition,
unlike virtual types, type properties can be refined contravariantly.
For instance, one can write the type \xcd"List{T:>Integer}",
and even \xcd"List{Integer<:T, T<:Number}".

\subsection{Type parameters and wildcards}
\label{sec:parameters-vs-fields}

Type properties are also similar, but not identical to, type
parameters.  The key difference is that type properties are
instance members bound during object construction.  Type
properties are thus accessible through expressions: \xcd"e.T" is
a legal type.

We can make the type system behave as if type properties were
type parameters very simply.  We need only make the syntax \xcd"e.T"
illegal and permit type properties to be accessible only
from within the body of their class definition via the implicit \xcd"this"
qualifier.

Wildcards in Java~\cite{Java3,adding-wildcards} can be motivated
by the following example.
Consider a \xcd"Set" class and a variable \xcd"EMPTY" containing
the empty set.  What should be the type of \xcd"EMPTY"?
In Java, one can use a wildcard, and 
assign the type \xcd"Set<?>"; that is the type of all \xcd"Set"
instantiated on {\em some} parameter.  Clients of this
type do not know what parameter the actual instance of \xcd"Set"
is bound to, which restricts the methods that can be invoked on
the object.

Wildcards can
also be bounded above and below with
{\tt ?} {\tt extends} {\tt T} and {\tt ?} {\tt super} {\tt T} respectively.
%
In \Xten{}, a similar effect to wildcards is achieved by leaving the
element type property of \xcd"Set" unconstrained.
%
We can thus define the following straightforward translation
from Java wildcards to \Xten{}.
Type parameters are translated to type properties whose name
encodes their position in the parameter list.
Types are translated as follows:
{\footnotesize
\begin{align*}
\SB{ \Xcd{X} } &= \Xcd{_}i ~~~~\mbox{where \xcd{X} is the $i$th type parameter} \\
\SB{ \Xcdmath{C<?, $\dots$>} } &= \Xcdmath{C\{$\dots$\}} \\
\SB{ \Xcdmath{C<? extends T, $\dots$>} } &= \Xcdmath{C\{_1 <: $\ \SB{\tt{T}}$, $\dots$\}} \\
\SB{ \Xcdmath{C<? super T, $\dots$>} } &= \Xcdmath{C\{_1 :> $\ \SB{\tt{T}}$, $\dots$\}} \\
\SB{ \Xcdmath{C<T, $\dots$>} } &= \Xcdmath{C\{_1 == $\ \SB{\tt{T}}$, $\dots$\}}
\end{align*}}
Through such a translation, the \FXG calculus in
Section~\ref{sec:semantics} can capture the essence of Java's
wildcards, but extended with support for run-time type
introspection.

\eat{
Finally,
one can also specify lower bounds on types.  These are useful for
comparators:
{\footnotesize
\begin{xten}
class TreeSet[T] {
  def this[T](cmp: Comparator{T :> this.T}) { ... }
}
\end{xten}}
Here, the comparator for any supertype of \xcd"T" can be used as
to compare \xcd"TreeSet" elements.

Another use of lower bounds is for list operations.
The \xcd"map" method below takes a function that maps a supertype
of the class parameter \xcd"T" to the method type parameter \xcd"S":
{\footnotesize
\begin{xten}
class List[T] {
  def map[S](fun: Object{self :> T} => S) : List[S] = { ... }
}
\end{xten}}
}

Constrained types also support
\emph{proper abstraction}~\cite{adding-wildcards}.  To illustrate, a
\xcd"reverse"
operation can operate on \xcd"List" of any type:
{\footnotesize
\begin{xten}
def reverse(list: List) = {
  for (i: int in [0..list.length-1]) {
    val tmp: list.T = list(i);
    list(i) = list(list.length-1-i);
    list(list.length-1-i) = tmp;
  }
}
\end{xten}}

The client of \xcd"reverse" need not provide the concrete type
on which the list is instantiated; the \xcd"list" itself
provides the element type---it is stored in the \xcd"list"
to implement run-time type introspection.

In Java, this method would be written with a type parameter on
the method.
Wildcard
capture allows the parametrized method to be called with any \xcd"List",
regardless of its parameter type.
However,
the method parameter cannot be omitted: declaring a parameterless version
of \xcd"reverse" requires delegating to a private parametrized version that
``opens up'' the parameter.


\subsection{Self types}

Type properties can also be used to support a form of self
types~\cite{bruce-binary,bsg95}.
%
Self types can be implemented by introducing a
type property \Xcd{class} to the root of the class hierarchy, \Xcd{Object}:
{\footnotesize
\begin{xtenmath}
class Object[class] { $\dots$ }
\end{xtenmath}}

\noindent
Scala's path-dependent types~\cite{scala} and J\&'s
dependent classes~\cite{nqm06}
take a similar approach.

Self types are achieved by
implicitly constraining types so that if an path expression \Xcd{p}
has type \Xcd{C}, then
$\Xcd{p}.\Xcd{class} \subtype \Xcd{C}$.  In particular,
$\Xcd{this}.\Xcd{class}$ is guaranteed to be a subtype
of the lexically enclosing class; the type
$\Xcd{this}.\Xcd{class}$ represents all instances of the fixed,
but statically unknown, run-time class referred to by the \Xcd{this}
parameter.

Self types address the binary method problem~\cite{bruce-binary}.
In the following
example, the class \xcd"BitSet" can be written with a
\xcd"union" method that takes a self type as argument.

{\footnotesize
\begin{xtenmath}
interface Set {
  def union(s: this.class): void;
}

class BitSet implements Set {
  int bits;
  def union(s: this.class): void {
    this.bits |= s.bits;
  }
}
\end{xtenmath}}

\noindent
Since \xcd"s" has type this \Xcd{this}.\Xcd{class}, and the class
invariant of \xcd"BitSet" implies
$\Xcd{this}.\Xcd{class} \subtype \Xcd{BitSet}$,
the implementation of the method is free to access the
\xcd"bits" field of \xcd"s".

Callers of \xcd"BitSet".\xcd"union()" must call the method with
an argument that has the same run-time class as the
receiver.  For a receiver \xcd"p", the
type of the actual argument of the call must have a constraint
that entails \xcd"self".\xcd"class==p".\xcd"class".


\eat{
\subsection{Ownership types}

Consider the following example of generic ownership
derived from Potanin et al.~\cite{ogj-oopsla06}.

\begin{xten}
class Object(owner: Object) { }

// Map inherits Object.owner
// No need to add explicit vOwner and kOwner properties for Key, Value
class Map[Key, Value]{Key <: Comparable, Value <: Object}
{
    private nodes: Vector[Node[Key, Value](this)](this);

    public def put(key: Key, value: Value): Void = {
        nodes.add(new Node[Key, Value](key, value, this)());
    }

    public def get(key: Key): Value = {
        for (mn: Node[Key, Value](this) in nodes) {
            if (mn.key.equals(key))
                return mn.value;
        }
        return null;
    }

    // OGJ will prevent this from being called, since caller
    // can only assign the result to a supertype of Vector(this),
    // which would be only Vector(this) or Object(this)
    // BUT: we have Vector :> Vector(this)
    // Need to require that all class types have an equality constraint
    // on the owner property
    public def exposeVector(): Vector(this) { return nodes; }
}

class Node[Key, Value]
    {Key <: Comparable, Value <: Object}
{
    val key: Key;
    val value: Value;

    public def this[K, V](k: Key, v: Value, o: Object): Node[K, V](o) {
        super(o);               // set the owner
        property[K, V];         // set the type properties
        this.key = k;
        this.value = v;
    }
}
\end{xten}

Restrictions:
\begin{itemize}
\item owner property must be constrained (define this!)
\item owner is always equal to or inside the owner of all other type properties
\item types with an actual owner == this, can only be accessed via this
\end{itemize}

}

\subsection{Structural constraints}
\label{sec:structural}
\label{sec:structural-typing}

Type constraints need not be limited to subtyping constraints.
By introducing structural constraints on types, one can
instantiate
type properties on any type with a given set
of methods and fields.
A structural constraint is satisfied if the type has a member of
the appropriate name and with a compatible type.
This feature is useful for reusing code
in separate libraries since it does not require
code of one library to implement an interface to satisfy a
constraint of another library.

In this section, we consider an extension of the \Xten{} type system
to support structural type constraints.  Formally, the extension
is straightforward; indeed the \FX{} family already supports structural constraints
via the rules {\sc Has-F},
{\sc Method-B},
{\sc Method-I},
and
{\sc Method-C,E} in Figure~\ref{fig:O}.
The constraint system need change only to add 
structural
constraints of the form ``{\tt T} {\tt has} {\tt I}''
trivially derived from the existing constraints.

Structural constraints on types are found in many languages.
Haskell supports type
classes~\cite{haskell,haskell-type-classes}.
%ML's module system allows modules to be constrained by
%structural signatures~\cite{ml}.
In Modula-3, type equivalence and subtyping are structural
rather than nominal as in object-oriented languages of the C
family such as C++, Java, Scala, and \Xten{}.
%
The language PolyJ~\cite{java-popl97} allows type parameters to be
bounded using
structural \emph{where clauses}~\cite{where-clauses}.
For example, the sorted list class from Figure~\ref{fig:sorted}
could be
be written as follows in PolyJ:
{\footnotesize
\begin{xten}
class SortedList[T] where T {int compareTo(T)} {
    void add(T x) { ... x.compareTo(y) ... }
    ...
}
\end{xten}}
The where clause states that the type parameter \xcd"T" must have a
method \xcd"compareTo" with the given signature.

The analogous code for \xcd"SortedList" in the structural
extension of \Xten{} would be:
\begin{xten}
class SortedList[T]{T has def compareTo(T): int} {
    def add(x: T) = { ... x.compareTo(y) ... }
    ...
}
\end{xten}

\eat{
A structural constraint is satisfied if the type has a member of
the appropriate name and with a compatible type.
The constraint
\xcdmath"Z has def m[$\tbar{X}$]($\tbar{x}\ty\tbar{T}$): U"
is satisfied by a type \xcd"T" if it has a method \xcd"m"
with signature
\xcdmath"def m[$\tbar{Y}$]($\tbar{y}\ty\tbar{S}$): V"
and where
(\xcdmath"[$\tbar{Y}$]($\tbar{y}\ty\tbar{S}$) => V")$[\Xcd{T}/\Xcd{Z}]$
is a subtype of
(\xcdmath"[$\tbar{X}$]($\tbar{x}\ty\tbar{T}$) => U")$[\Xcd{T}/\Xcd{Z}]$.
As an example,
the constraint \xcd"X has def compareTo(X): int"
is satisfied by both of the following classes:
{\footnotesize
\begin{xten}
class C { def compareTo(x: C): int = ...; }
class D { def compareTo(x: Object): int = ...; }
\end{xten}}
}

Structural method constraints permit the introduction of
CLU-style optional methods~\cite{clu}.  Consider the following
\xcd"Array" class:
{\footnotesize
\begin{xten}
class Array[T] {
  def add(a: Array[S])
    {T has add(S): U}: Array[U] = { ... }
  ...
}
\end{xten}}

\noindent
The \xcd"Array" class defines an \xcd"add" method that takes 
an array of \xcd"S", adds each element of the array to the
corresponding element of \xcd"this", and returns an array of the
results.  The method constraint specifies that the method may
only be invoked if \xcd"T" has an \xcd"add" method of the
appropriate type.  Thus, for example, an \xcd"Array[int]"
can be added to an \xcd"Array[double]" because \xcd"int"
has a method \xcd"add" (corresponding to the \xcd"+" operation)
that adds an \xcd"int" and a \xcd"double", retuning a
\xcd"double".  However, \xcd"Array[Rabbit]", for example, does not support
the \xcd"add" operation because \xcd"Rabbit" does not have an
\xcd"add" method.

\eat{
\subsection{Definition-site variance}

\subsection{Conditional methods and generalized constraints}

For type parameters, method constraints are 
similar to generalized constraints proposed for
\csharp~\cite{emir06}.
%
In the following code, the \xcd"T" parameter is covariant
and so the \xcd"append" methods below are illegal:
{\footnotesize
\begin{xten}
class List[+T] {
  def append(other: T): List[T] = { ... }
      // illegal
  def append(other: List[T]): List[T] = { ... }
      // illegal
}
\end{xten}}
%
However, one can introduce a method parameter and then constrain
the parameter from below by the class's parameter:
For example, in the following code,
{\footnotesize
\begin{xten}
class List[+T] {
  def append[U](other: U)
      {T <: U}: List[U] = { ... }
  def append[U](other: List[U])
      {T <: U}: List[U] = { ... }
}
\end{xten}}

The constraints must be satisfied by the callers of \xcd"append".
For example, in the following code:
{\footnotesize
\begin{xten}
xs: List[Number];
ys: List[Integer];
xs = ys; // ok
xs.append(1.0); // legal
ys.append(1.0); // illegal
\end{xten}}
the call to \xcd"xs.append" is allowed and the result type is \xcd"List[Number]", but
the call to \xcd"ys.append" is not allowed because the caller cannot show that
${\tt Number} \subtype {\tt Double}$.

}
