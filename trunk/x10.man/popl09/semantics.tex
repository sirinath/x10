\subsection{
Grammar}

\begin{tabular}{lrcl}
environment & $\Gamma$ & ::=  & $\epsilon$ \\
            &          & \bnf & $\Gamma$, \xcd"c" \\
            &          & \bnf & $\Gamma$, \xcd"x": \xcd"T" \\
\end{tabular}


\subsection{
    Well-typedness rules
}

Now we come to a reformulation of the rules.

First, for a type environment $\Gamma$,
we define the \emph{constraint projection},
   $\sigma(\Gamma)$ thus:

\begin{align*}
\sigma(\epsilon) &= {\tt true} \\
\sigma(\Gamma, {\tt c}) &= \sigma(\Gamma), {\tt c} \\
\sigma(\Gamma, {\tt x}: \Xcd{C\{c\}}) &= \sigma(\Gamma), 
        ({\tt self}: {\tt C};\ \Xcd{x==self}, {\tt c}) \\
 \\
\end{align*}

Discussion: Why is this different from the paper? I am trying to avoid
explicit use of substitutions, in favor of just conjunction and
existential quantification. (Thus: (self:C; x==self, c) vs c[x/self].)

In general, existential quantification is more general than
substitution, and since we have to use it anyway, we may as well avoid
using substitutions.

\subsection{
        Judgements
}


The following judgements will be defined:

\begin{itemize}
\item
     The type {\tt T} is well-formed, given the assumptions $\Gamma$:

    $\Gamma \vdash {\tt T}: {\tt type}$

\item
     The type {\tt S} is a subtype of {\tt T}, under the assumption $\Gamma$:

      $\Gamma \vdash {\tt S} \subtype {\tt T}$

    \item The expression {\tt e} is of type {\tt T}, given the assumptions $\Gamma$:

      $\Gamma \vdash {\tt e}: {\tt T}$

    \item The method {\tt M} is well-defined for the class {\tt C}
given assumptions $\Gamma$:

      $\Gamma \vdash {\tt M}~\mbox{OK in}~{\tt C}$

    \item The field {\tt f: T} is well defined for the class {\tt C} given assumptions $\Gamma$:

      $\Gamma \vdash {\tt f: T}~\mbox{OK in}~C$

    \item The class definition Cl is well defined given assumptions $\Gamma$:

      $\Gamma \vdash {\tt L}~\mbox{OK}$

\end{itemize}


In what follows we will sometimes think of the family of five judgements
as a single judgement $\Gamma \vdash \phi$ where $\phi$ ranges over the
formulas 
    ${\tt T}: {\tt type}$,
      ${\tt S} \subtype {\tt T}$,
      ${\tt e}: {\tt T}$,
      ${\tt M}~\mbox{OK in}~{\tt C}$,
      ${\tt f: T}~\mbox{OK in}~C$, and
      ${\tt L}~\mbox{OK}$.


Now, these judgements need to satisfy certain properties:

\begin{enumerate}

\item
    $\Gamma \vdash {\tt T}: {\tt type}$
whenever 
      $\Gamma \vdash {\tt e}: {\tt T}$; that is,
if we can conclude that {\tt e}
      has type {\tt T} (under certain assumptions), then under those
      assumptions we must be able to conclude that {\tt T} is well-defined.

\item
    $\Gamma \vdash {\tt S}: {\tt type}$ and
    $\Gamma \vdash {\tt T}: {\tt type}$ whenever
      $\Gamma \vdash {\tt S} \subtype {\tt T}$.

\item
If 
      $\Gamma \vdash {\tt e}: {\tt T}$ and if {\tt x}
is a variable occurring free in ${\tt e}: {\tt T}$, then for some
      type {\tt U},
      $\Gamma \vdash {\tt x}: {\tt U}$.
That is, all free variables on the right-hand
      side of the judgement are actually defined on the left-hand side.
\end{enumerate}


Keeping in mind these requirements, the rules are as follows. Below,
whenever we use the assertion ``{\tt x} free'' in the antecedent of
a rule we mean
that {\tt x} is not free in the consequent of the rule.


\subsection{
      Structural and Logical Rules
}


First, we present the structural rules for $\vdash$. The judgement
$\Gamma\vdash {\tt e}: {\tt T}$ is
intuitionistic. That is, $\Gamma$ is considered a multiset of assertions, and
the judgement possesses the inference rules:

\infrule{
\Gamma \vdash {\tt e}: {\tt T}
\andalso
\Gamma \vdash {\tt S}: {\tt type}
\andalso
    \mbox{{\tt x} not in $\mathit{var}(\Gamma)$}
}{
\Gamma, {\tt x}: {\tt S} \vdash {\tt e}: {\tt T}
}



\infrule{
\Gamma \vdash {\tt e}: {\tt T}
\andalso
\Gamma \vdash {\tt c}: {\tt o} ~~XXX
}{
\Gamma, {\tt c} \vdash {\tt e}: {\tt T}
}


We also assume the following rule for conjunctions on the left and right:

\infrule{
\Gamma, \phi_1 , \phi_2 \vdash \phi
}{
\Gamma, (\phi_1 , \phi_2 ) \vdash \phi
}


\infrule{
\Gamma \vdash \phi_1 
\andalso
     \Gamma \vdash \phi_2  
}{
\Gamma \vdash (\phi_1 , \phi_2 )
}



Existential quantification is governed by the following standard rules,
specialized for the particular kinds of formulas we are dealing with:


\infrule{
\Gamma \vdash {\tt e}: {\tt T}[{\tt t}/{\tt x}]
\andalso
\Gamma \vdash {\tt t}: {\tt S}
}{
\Gamma \vdash {\tt e}: ({\tt x}: {\tt S};~{\tt T})
}


\infrule[exists L-const]{
\Gamma, {\tt x}: {\tt S}, {\tt c} \vdash {\tt e}: {\tt T}
\andalso
\mbox{{\tt x} fresh}
}{
\Gamma, ({\tt x}: {\tt S};~{\tt c}) \vdash {\tt e}: {\tt T}
}


\infrule[exists L-const]{
\Gamma, {\tt x}: {\tt S}, {\tt y}: \Xcd{C\{c\}} \vdash {\tt e}: {\tt T}
\andalso
\mbox{{\tt x} fresh}
}{
\Gamma, {\tt y}: \Xcd{C\{x: S; c\}} \vdash {\tt e}: {\tt T}
}





\subsection{
      Type inference rules
}


\subsubsection{
        Expression typing judgement
}

Question: why bake in subsumption here

\infrule[T-var]{
\sigma(\Gamma), {\tt self}: {\tt C}, {\tt c} \vdash_{\cal C} {\tt d}
\\
\Gamma \vdash \Xcd{C\{c\}}: {\tt type}
\andalso
\Gamma \vdash \Xcd{C\{d\}}: {\tt type}
}{
\Gamma, {\tt x}: \Xcd{C\{c\}} \vdash {\tt x}: \Xcd{C\{d\}}
}


This rule is different from the rule in the paper in that we explicitly
require that \Xcd{C\{c\}} and \Xcd{C\{d\}} be well-formed types.


\infrule[T-cast]{
\Gamma \vdash {\tt e}: {\tt U}
\andalso
\Gamma \vdash {\tt T}: {\tt type}
}{
\Gamma \vdash {\tt e~as~T}: {\tt T}
}



This rule differs from the rule in the paper in that there is no need to
substitute a fresh variable for the receiver. Note that {\tt this} may be free
in {\tt S}---that would be a reference to the current object in the code in
which {\tt e.f} occurs, not a reference to the receiver of the {\tt e.f} field
selection (i.e., the object obtained by evaluating {\tt e}).

\infrule[T-field]{
\Gamma \vdash {\tt e}: {\tt S}
\andalso
\mathit{fields}({\tt S}) = \bar{\tt f}: \bar{\tt U}
}{
\Gamma \vdash {\tt e.f_i}: ({\tt this}: {\tt S};~{\tt U_i})
}


TODO: type parameters!

Now we consider the rule for method invocation. Assume that in a type
environment $\Gamma$ the expressions ${\tt e_0}, \dots, {\tt e_n}$
have the types ${\tt T_0}, \dots, {\tt T_n}$.
Since the
actual values of these expressions are not known, we shall assume that
they take on some fixed but unknown values
                                     ${\tt z_0}, \dots, {\tt z_n}$
of types ${\tt T_0}, \dots, {\tt T_n}$.
Now, for ${\tt z_0}$ as receiver, let us assume that the type
${\tt T_0}$ has a method named ${\tt m}$
with signature
$[\bar{\tt Z}](\bar{\tt z}: \bar{\tt S})\Xcd{\{c\}} \to {\tt U}$
(Let ${\tt T_0} = \Xcd{C\{d\}}$.
 If there is no
method named {\tt m} for the class {\tt C} then this method invocation cannot be
type-checked. Without loss of generality, we may assume that the
type parameters of this method are named
                                     ${\tt Z_1}, \dots, {\tt Z_k}$, and
the value parameters are named
                                     ${\tt z_1}, \dots, {\tt z_n}$
since we are free to choose
variable names as we wish.)
Now, for the method to be invocable,
it must be the case that the types
    ${\tt T_1}, \dots, {\tt T_n}$
are subtypes of
    ${\tt S_1}, \dots, {\tt S_n}$.
(Note
that there may be no occurrences of {\tt this} in
    ${\tt S_1}, \dots, {\tt S_n}$---they have been
replaced by ${\tt z_0}$.)
Further, it must be the case that for these parameter
values, the constraint {\tt c} is entailed. Given all these assumptions it
must be the case that the return type is {\tt U}, with all the parameters
    ${\tt z_0}, \dots, {\tt z_n}$
existentially quantified.

\infrule[T-invk]{
\Gamma \vdash {\tt e_0}: {\tt T_0}
\andalso
\Gamma \vdash \bar{\tt e}: \bar{\tt T}
\\
\mathit{mtype}({\tt T_0}, {\tt m}, {\tt z_0}) =
[\bar{\tt Z}](\bar{\tt z}: \bar{\tt S})\Xcd{\{c\}} \to {\tt U}
\\
    {\tt z_0}, \bar{\tt z}, \bar{\tt Z}~\mbox{fresh}
\\
\Gamma' = \Gamma, \bar{Z}: {\tt type}, {\tt z_0}: {\tt T_0}, \bar{\tt z}: \bar{\tt T}
\\
\sigma(\Gamma') \vdash_{\cal C} ({\tt c}, \bar{\tt V}\Xcd{==}\bar{\tt Z}, \bar{\tt T} \subtype \bar{\tt S})
}{
\Gamma \vdash {\tt e_0}.{\tt m}[\bar{\tt V}](\bar{\tt e}): (\bar{\tt Z}: {\tt type};~{\tt z_0}: {\tt T_0};~\bar{\tt z}: \bar{\tt T};~{\tt U})
}

\infrule[T-invk-inferred]{
\bar{\tt Y}~\mbox{fresh}
\\
\Gamma, \bar{\tt Y}: {\tt type}
\vdash {\tt e_0}.{\tt m}[\bar{\tt Y}](\bar{\tt e}): (\bar{\tt Z}: {\tt type};~{\tt z_0}: {\tt T_0};~\bar{\tt z}: \bar{\tt T};~{\tt U})
}{
\Gamma \vdash {\tt e_0}.{\tt m}(\bar{\tt e}): (\bar{\tt Z}: {\tt type};~{\tt z_0}: {\tt T_0};~\bar{\tt z}: \bar{\tt T};~{\tt U})
}

\infrule[T-new]{
\Gamma \vdash \bar{\tt e}: \bar{\tt T}
\\
\mathit{fields}({\tt C}, {\tt z_0}) = \bar{\tt f}: \bar{\tt S}
\\
    {\tt z_0}, \bar{\tt z}, \bar{\tt Z}~\mbox{fresh}
\\
\Gamma' = \Gamma, \bar{Z}: {\tt type}, {\tt z_0}: {\tt C}, \bar{\tt z}: \bar{\tt T},
{\tt z_0}.\bar{\tt f}\Xcd{==}\bar{\tt z}
\\
\sigma(\Gamma') \vdash_{\cal C} ( \mathit{inv}({\tt C},{\tt z_0}),
\bar{\tt V}\Xcd{==}\bar{\tt Z}, \bar{\tt T} \subtype \bar{\tt S})
\\
\sigma(\Delta) \vdash_{\cal C}
}{
\Gamma \vdash
{\tt new}~{\tt C}[\bar{\tt V}](\bar{\tt e}): \Xcd{C\{}
{\tt z_0}: {\tt C};~
\bar{\tt z}: \bar{\tt T};~
{\tt z_0}.\bar{\tt f}\Xcd{==}\bar{\tt z},
{\tt self}\Xcd{==}{\tt z_0}\Xcd{\}}
}


\subsubsection{
        Class OK judgement
}

The following rule is modified from what we had in the paper to ensure
that all the types are well-formed (under the assumption {\tt this}: {\tt C}).
Note
that the variables $\bar{\tt x}$ are permitted to occur in the types ${\tt T_0}, \bar{\tt T}$,
hence their typing assertions must be added to $\Gamma$.

\infrule[Method OK]{
\Gamma = {\tt this}: {\tt C}, \bar{\tt x}: \bar{\tt T}
\\
\Gamma, {\tt c} \vdash {\tt e}: {\tt U}
\\
\Gamma, {\tt c} \vdash {\tt U} \subtype {\tt T}
}{
{\tt def~m}[\bar{\tt X}](\bar{\tt x}: \bar{\tt T})\Xcd{\{c\}}: {\tt T}~\Xcd{=}~{\tt e}~\mbox{OK in}~{\tt C}
}


This rule did not exist in our submission. This is necessary to ensure
that the types of fields are well-formed.

\infrule[Field OK]{
{\tt this}: {\tt C} \vdash {\tt T}: {\tt type}
}{
{\tt var~f}\Xcd{\{c\}}: {\tt T}~\mbox{OK in}~{\tt C}
}


This rule is now modified to ensure that all the types and methods in
the body of the class are well-formed.

\infrule[Class OK]{
\bar{\tt K}~\mbox{OK in}~{\tt C}
\\
\bar{\tt M}~\mbox{OK in}~{\tt C}
\\
\bar{\tt F}~\mbox{OK in}~{\tt C}
\\
{\tt this}: {\tt C} \vdash {\tt T}: {\tt type}
}{
\mbox{\Xcdmath{class C[$\bar{\tt X}$]($\bar{\tt x}$: $\bar{\tt T}$)\{c\} extends T \{\ $\bar{\tt K}$\ $\bar{\tt M}$\ $\bar{\tt F}$\ \}}}~\mbox{OK}
}


\subsubsection{
        Subtype judgement
}

\infrule{
\sigma(\Gamma) \vdash_{\cal C} {\tt T_1} \subtype {\tt T_2}
}{
\Gamma \vdash {\tt T_1} \subtype {\tt T_2}
}

