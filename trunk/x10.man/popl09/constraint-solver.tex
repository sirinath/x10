\section{Constraint solver}
\label{sec:solver}

The goal of the constraint solver is 
to check an assertion $\xbar{c} \vdashC \Xcd{d}$.

\eat{
Inference

The first step is to normalize constraints
into a set of constraint judgments
$\xbar{c} \vdashC \Xcd{c}$ where $\Xcd{c}$ contains no conjunctions.


Once in normalized form, the inference proceeds as follows:
Select a constraint $\xbar{c} \vdashC \Xcd{c}$.
If not consistent, fail.
If valid, ok.
If not valid, generate assignment of variables that makes it
true, adding the assignment to the assumptions for all
constraints.

The inference algorithm must specify the criteria for:
\begin{itemize}
\item selecting the next constraint to solve
\item generating the variable assignment consistent with all
other constraints (to avoid backtracking)
\end{itemize}

Pick an unassigned variable, find weakest assignment that makes just
this clause true.  Does the weakest assignment exist?

Question: can we ensure each clause involves only one or two
unknowns?
}

We add the following rules to allow type arguments to calls to
be omitted.

\infrule[T-invk-inferred]{
\xbar{Y}~\mbox{fresh}
\\
\Gamma, \xbar{Y} \ty {\tt type}
\vdash
\Xcd{e}_0.\Xcd{m[}\xbar{Y}\Xcd{](}\xbar{e}\Xcd{)} \ty
\Xcd{T}
}{
\Gamma \vdash
\Xcd{e}_0.\Xcd{m(}\xbar{e}\Xcd{)} \ty
\Xcd{T}
}

\infrule[T-new-inferred]{
\xbar{Y}~\mbox{fresh}
\\
\Gamma, \xbar{Y} \ty {\tt type}
\vdash
\Xcd{new}~\Xcd{C[}\xbar{Y}\Xcd{](}\xbar{e}\Xcd{)} \ty
\Xcd{T}
}{
\Gamma \vdash
\Xcd{new}~\Xcd{C(}\xbar{e}\Xcd{)} \ty
\Xcd{T}
}

\subsection{Constraint representation}

%\newcommand\eqedge{\rightleftharpoons}
\newcommand\eqedge{\sim}
\newcommand\flowedge{\to}
\newcommand\treeedge[1]{\mapsto_{#1}}
\newcommand\typeedge{\mapsto_{\tt type}}

Represent a constraint as a graph $G$.
Each node represents a constraint term for a value or a type.
The node for a path $p$ is written $v_p$;
the node for a type $T$ is written $V_T$.
There are four kinds of edges:
\begin{enumerate}
\item undirected equivalence edges,
        $v_p \eqedge v_q$ and $V_S \eqedge V_T$,
\item type edges, $v_p \typeedge V_T$,
\item tree edges, $v_p \treeedge{f} v_{p.f}$
              and $v_p \treeedge{X} V_{p.X}$, and
\item flow edges, $V_S \flowedge V_T$.
\end{enumerate}

First, each constraint term is mapped to a node in the graph as
follows.
Associate each term $t$ with a node
$v_t$.  For each access path {\tt p.x}, add a tree edge
$v_{{\tt p}} \treeedge{{\tt x}} v_{{\tt p.x}}$.
For each path type {\tt p.X}, add a tree edge
$v_{{\tt p}} \treeedge{{\tt X}} V_{{\tt p.X}}$.
For each atomic formula ${\tt f}(\xbar{t})$, add the tree edge
$v_{{\tt f}(\xbar{t})} \treeedge{i} v_{t_i}$ for all $i$.
If term $t$ has type $T$, add $v_t \typeedge V_{t{\tt .type}}$
and
add $V_T \eqedge V_{t{\tt .type}}$ to $G$.

Type nodes are sets of classes.

Next, constraints are incorporated into the graph:

\begin{itemize}
\item
For constraint {\tt p==q}, add $v_{\tt p} \eqedge v_{\tt q}$ to $G$.

\item
For constraint {\tt S==T}, add $V_{\tt S} \eqedge V_{\tt T}$ to $G$.

\item
For constraint {\tt S<:T},
add $V_{\tt S} \flowedge V_{\tt T}$
to $G$.

\end{itemize}

\subsection{Solving}

A flow-path is a path that follows flow and equivalence edges
only.
A type-path is a path that follows type and equivalence edges
only.

Now, we saturate: 
If there is a type-path $v_t \typeedge^* V_{\tt C\{c\}}$,
add $c[t/\Xcd{self}]$ to the worklist.

        Can saturate lazily when doing a lookup.
        EXCEPT: a type may have an arbitrary constraint
                \xcd"C{self.x==3 && y > 7}", so affect is non-local
        EXCEPT: c is x.f==...
                with x: C{c}
                need to avoid infinite loop

To check:

\begin{itemize}
\item To check
constraint {\tt p==q}, check if $v_{\tt p} \eqedge^* v_{\tt q}$.
\item To check
constraint {\tt S<:T}, check if there is a flow-path from $V_{\tt S}$ to
$V_{\tt T}$.  This requires checking entailment of the type constraints and
adding more edges to the graph.  (XXX details!)
Add the flow edge to memoize.
\end{itemize}


