% Problem statement
% X10 ... new language design
% OO, imperative, concurrent
% catch errors -> types
% dependent types, generics
% practical, pluggable

Large-scale systems present a number of challenges for modern
object-oriented programming languages.  Concurrency,
distribution, and heterogeneous hardware and software
environments require programming languages to support a rich set
of features to be able to catch programmer errors at
compile-time, to permit great expressiveness, and to enable code
reuse.

\Xten{} is a modern statically typed object-oriented language
designed for high-performance concurrent and distributed
programming~\cite{X10}.  A key data structure in \Xten{} programs
is the array: \Xten{} supports
dense,
distributed, multi-dimensional arrays of objects,
defined over sets of indices known as {\em regions}.
%
To define arrays---and other data structures---in the
\Xten{} standard library, \Xten{} supports both dependent types and
generic types. 

Generic
types~\cite{clu,ada,GJ,java-popl97,thorup97,Java3,csharp-generics}
enable more precise static type checking and allow programmers
to reuse code in a variety of contexts.  Generic types are vital
for implementing libraries, especially collections classes.

Dependent type
systems~\cite{dependent-types,xi99dependent,ocrz-ecoop03,aspinall-attapl,cayenne,epigram-matter,calc-constructions}
allow programmers to enforce run-time program invariants at
compile-time.
Dependent types in \Xten{} are used to
ensure the safety of array accesses.
In addition,
\Xten{} uses dependent types to enforce \Xten{}'s
distribution model by ensuring remote data is
not accessed as if it were local, and to enforce
restrictions on concurrent accesses to prevent deadlock and data
races.

The key idea is to define \emph{constrained types}, a form of
dependent type defined on predicates over types and over the
immutable state of the program.

In \Xten{}, objects may have both value members (fields)
and type members.
The immutable state of an object is captured by its
\emph{value properties}: public final fields of the object.
For instance, the following class declares a two-dimensional
point with properties \xcd"x" and \xcd"y" of type \xcd"int":
\begin{xten}
class Point2(x: int, y: int) { }
\end{xten}

A constrained type in \Xten{} is a type \xcd"C{e}", where \xcd"C" is a
class---called the \emph{base class}---and \xcd"e" is a
\emph{constraint}, or list of constraints, on the properties of
\xcd"C" and the final variables in scope at the type.
For example, given the above class definition,
the type \xcd"Point2{x==y}" is the type of all
points on the diagonal.

% For brevity, a constraint can be written as
% a comma-separated list of conjuncts; that is, the constraint
% \xcd"c1"~\xcd"&&"~\xcd"c2" can be written
% \xcd"c1,"~\xcd"c2".

Constraints on properties induce a natural subtyping relationship:
\xcd"C{c}" is a subtype of
\xcd"D{d}" if \xcd"C" is a subclass of \xcd"D" and
\xcd"c" entails \xcd"d".  Thus, \xcd"Point2{x==1,y==1}"
is a subtype of \xcd"Point2{x>0}", which in turn is a subtype of
\xcd"Point2{true}"---written simply as \xcd"Point2".

In previous
work~\cite{X10,constrained-types}, we considered
only value properties.
In this paper,
to support genericity these types are generalized
to allow \emph{type properties}, type-valued instance
members of an object.
Types may be defined by constraining the type properties as
well as the value properties of a class.

The following code declares a class \xcd"Array" with a type
property named \xcd"T".
The \xcd"Array" class maps points defined in a given region
to values of type \xcd"T".
\begin{xten}
class Array[T] {
  def get(p: Point): T = ...;
  def set(p: Point, v: T) = ...;
  ...
}
\end{xten}

% class Region(rank: int) {
%   invariant point_rank(p: Point) = ! (p in this) || rank==this.rank;
%   def contains(p: Point{rank==this.rank}): boolean{p in this};
% }

Type properties are in many ways similar to
type parameters as provided in object-oriented languages such as
Java~\cite{Java3} and Scala~\cite{scala} and in functional
languages such as ML~\cite{ml} and
Haskell~\cite{haskell}.
%
As the \xcd"Array" example illustrates,
type properties are types in their own right:
they may be used in any context a type may be used,
including in \xcd"instanceof" and cast expressions.

However, the key distinction between type properties
and type parameters is that type properties are instance
members.
Thus, for an expression \xcd"a" of type \xcd"Array", \xcd"a.T" is
a type, equivalent to the concrete type to which \xcd"T" was
initialized when the object \xcd"a" was instantiated.
To ensure
soundness, \xcd"a" is restricted to final access paths.
Within the body of a class, the unqualified property name \xcd"T" resolves
to \xcd"this.T".

All properties of an object, both type and value, must be bound at object
instantiation and are immutable once bound.  Thus, the type
property \xcd"T" of a given \xcd"Array" instance must be bound
by the constructor
to a concrete type such as \xcd"String" or \xcd"Point2{x>=0}".

As with value properties, type properties may be constrained
by predicates to produce \emph{constrained types}.
Many features of modern object-oriented type systems fall out
naturally from this type system.

\Xten{} supports
equality constraints, written \xcdmath"T$_1$==T$_2$", and
subtyping constraints, written \xcdmath"T$_1$<:T$_2$", on types.
For instance,
the type \xcd"Array{T==float}" is the type of all \xcd"Array"s
containing a \xcd"float".  For an instance \xcd"a" of this type,
the types \xcd"a.T" and \xcd"float" are equivalent.
%Thus, the
%following code is legal.
%\begin{xten}
%val x: float = a.get(p);
%a.set(p, 1.0);
%\end{xten}

Subtyping constraints enable
\emph{use-site variance}~\cite{variant-parametric-types}.
The type \xcd"Array{T<:Collection}"
constrains \xcd"T" such that all instances of the type must bind
\xcd"T" to a subtype of \xcd"Collection".  Variables of this
type may contain \xcd"Array"s of \xcd"Collection", \xcd"Array"
of \xcd"List", or \xcd"Array" of \xcd"Set", etc.
% Subtyping constraints provide similar expressive power as Java
% wildcards.  We describe an encoding of wildcards in
% Section~\ref{sec:wildcards}. 

Constraints on value properties may be used to ensure array
bounds are not violated.
Arrays in \Xten{} are distributed 
over a number of abstract {\em places} (which the language runtime
maps to physical nodes in a distributed system).  The property
\xcd"dist" defines a mapping from a point \xcd"p" to the place
where the storage for the array element at \xcd"p" is located. 
The index points given to the \xcd"get" and \xcd"set" methods
have constrained types that ensure the array is accessed only
using points in the region on which the array is defined.

The following code declares a version of \xcd"Array" with a type
property named \xcd"T" and value properties \xcd"dist" of type
\xcd"Dist" and \xcd"region" of type \xcd"Region".
The region
of the array is constrained to be the same as 
the region of the distribution.
\begin{xten}
class Array[T]
  (dist: Dist,
   region: Region{self==dist.region})
{ ...
  def get(p: Point{self in region}): T = ...
  def set(p: Point{self in region}, v: T) = ...
}
\end{xten}

Our previous work~\cite{constrained-types}
was a first step toward defining a dependent type system 
for an object-oriented language as a constraint system.
%
In this paper,
we present a constraint-based framework for formalizing
object-oriented type systems.
The type system is parametrized on a constraint system.
By augmenting the default constraint system,
the type system can serve as a core calculus 
for formalization of extensions of a core object-oriented language. 

The same framework can be extended to support generic types with
structural rather than nominal 
bounds~\cite{java-popl97,haskell-type-classes},
to model other features of object-oriented languages
such as virtual types~\cite{mp89-virtual-classes,beta,ernst06-virtual}
and self types~\cite{bruce-binary,bsg95}.

\eat{
\begin{xten}
class SortedList[T]{tail == null || head < tail.head} {
  head: T;
  tail: SortedList[T];

  def this[T](hd: T, tl: SortedList[T]) {
    property[T]();
    this.head = hd; this.tail = tl;
  }

  def insert(x: T): SortedList[T]{head == min(this.head, x)} = {
    if (x < head)
      return new SortedList[T](x, this);
    else
      return new SortedList[T](hd, tl.insert(x));
  }
}
\end{xten}
}

\paragraph{Contributions.}

We present a constraint-based framework \FX{}
for formalizing
object-oriented type systems.
The framework is based on
Featherweight Java~\cite{FJ} and
is parametrized on a constraint system over types and values.
By augmenting the default constraint system,
the type system can serve as a core calculus 
for formalization of extensions of a core object-oriented
language:
\begin{itemize}
\item \FXG{}
supports generic types,
\item \FXD{}
supports dependent types,
\item \FXGD{}
supports both generics and dependent types.
\end{itemize}
The formal system has been proved sound.

The constraint-based framework forms the basis for a practical,
implementable language.
We describe the implementation of an extension of \Xten{} that
provides both generic and dependent types.  The implementation
supports run-time type introspection and instantiation of
generic types on primitive types.
The performance of primitive arrays, especially, is
critical for the high-performance applications for which
\Xten{} is intended.
Our design does not require primitive values be boxed.

\paragraph{Outline.}

The rest of the paper is organized as follows.
%
An informal overview of generic constrained types in \Xten{}
is presented in
Section~\ref{sec:lang}.  
%
Section~\ref{sec:semantics} presents a formal semantics and a
proof of soundness.
%
We discuss extensions of the type system, including for
virtual types and self types, in
Section~\ref{sec:discussion}.
%
The implementation of generics in \Xten{} by translation to Java is described in 
Section~\ref{sec:translation}.
%
Section~\ref{sec:related} discusses related work.
%
Finally, Section~\ref{sec:conclusions} concludes.

