\documentclass[preprint,nocopyrightspace,9pt]{sigplanconf}
%\documentclass{llncs}

\newif\iflncs
\lncsfalse

\usepackage{times-lite}
\usepackage{mathptm}
\usepackage{txtt}
\usepackage{stmaryrd}
\usepackage{code}
\usepackage{bcprules}
%\usepackage{ttquot}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{afterpage}
\usepackage{balance}
\usepackage{floatflt}
\usepackage{defs}
\usepackage{utils}
\usepackage[pdftex]{graphicx}
\usepackage{xspace}
\usepackage{ifpdf}
\usepackage{listings}
\usepackage{x10}

\newif\ifsemantics
%\semanticsfalse
\semanticstrue

\hfuzz=1pt

\pagestyle{plain}


\ifpdf
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}
\fi

\newcommand\gxx{GFX\xspace}

\newcommand\xbar[1]{\ensuremath{\bar{\Xcd{#1}}}}
\newcommand\tbar[1]{\ensuremath{\bar{\tt {#1}}}}
\newcommand\exc[2]{\ensuremath{\exists}#1.~#2}
\newcommand\exty[3]{\ensuremath{\exists}#1\ty#2.~#3}
\newcommand\extyty[5]{\ensuremath{\exists}#1\ty#2,#3\ty#4.~#5}
\newcommand\extytyty[7]{\ensuremath{\exists}#1\ty#2,#3\ty#4,#5\ty#6.~#7}


% \input{../../../../vj/res/pagesizes}
% \input{../../../../vj/res/vijay-macros}
\newcommand\alt{\bnf}

\newcommand\Implies{\Rightarrow}

\iflncs
\else
\newtheorem{example}{Example}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newenvironment{proof}{
\trivlist
\item[\hskip \labelsep \textsc{Proof.}]
\selectfont
\ignorespaces}{$\Box$}

%\newtheorem{proof}[theorem]{Proof}
\fi

\begin{document}

\title{Genericity through Dependently Constrained Types}

\iflncs

\author{
Nathaniel Nystrom\inst{1}
\and
Igor Peshansky\inst{1}
\and
Vijay Saraswat\inst{1}
}

\institute{IBM T.~J. Watson Research~Center,
P.O.~Box~704, Yorktown~Heights NY 10598 USA,
\email{\{nystrom,igorp,vsaraswa\}@us.ibm.com}}

\else

\authorinfo{Nathaniel Nystrom\titlenote{IBM T.~J. Watson Research
Center, P.O. Box 704, Yorktown Heights NY 10598 USA}}{}
  {nystrom@us.ibm.com}
\authorinfo{Igor Peshansky$^{\;*}$}{}
  {igorp@us.ibm.com}
\authorinfo{Vijay Saraswat$^{\;*}$}{}
  {vsaraswa@us.ibm.com}

% \conferenceinfo{POPL'08}{XXX}
% \copyrightyear{2008}
% \copyrightdata{[to be supplied]}

\fi

\maketitle

\begin{abstract}
We present a general framework for \emph{generic constrained types}
that captures the notion of value-dependent and
type-dependent (generic) type systems for object-oriented
languages.  Constraint systems formalize systems of partial
information.  Constrained types are formulas \Xcd{C\{c\}} where
\Xcd{C} is the name of a class or an interface and \Xcd{c} is a
constraint on the immutable state of an instance of \Xcd{C} (the
{\em properties}).

The basic idea is to formalize the essence of nominal
object-oriented types as a constraint system, and to permit both
value and type properties and parameters.  Type-generic
dependence is now expressed through constraints on these
properties and parameters.  Type-valued properties are required
to have a run-time representation---the run-time semantics is
not defined through erasure.

Many type systems for object-oriented languages developed over
the last decade can be thought of as constrained type systems in
this formulation.  This framework is parametrized by an
arbitrary constraint system $\cal C$ of interest.  It permits
the development of languages with pluggable type systems, and
supports dynamic code generation to check casts at run-time.

The paper makes the following contributions: (1) We show how to
accommodate generic object-oriented types within the framework of
constrained types. (1) We illustrate the type system with the
development of a formal calculus \gxx and establish type
soundness. (3) We discuss the design and implementation of the
type system for X10, a modern object-oriented language, based on
constrained types.  The type system integrates and extends the
features of nominal types, virtual types, and
Scala's path-dependent types, as well as representing generic
types.
\end{abstract}

\section{Introduction}
\label{sec:intro}

\todo{Awkward, repetitive}

\todo{More positioning, relative to: DML, HM(X), constrained
types (Trifonov, Smith) and subtyping constraints, Java
generics, GJ, PolyJ, C\# generics, virtual types, liquid types}

\todo{Possible claim: first type system
that combines genericity and dep types in some vague general way.}

\todo{Incorporate some text from OOPSLA paper on deptypes.}

\todo{Cite liquid types and whatever it cites}

Modern object-oriented type systems provide 
many features to improve productivity by 
allowing programmers to express strong program
invariants as types that are
checked by the compiler, without sacrificing the ability to
reuse code.

Examples include generics, self types, 
dependent types. 
We present a dependent type system
that extends a class-based language with
statically-enforced constraints on
types and values.
This type system 
supports several features of modern object-oriented 
language through natural extensions of the core dependent type
system: generic types, virtual types, and self types
among them.

We have formalized the type system in an extension of
Featherweight Java~\cite{FJ}
and provide proof of soundness.
The type system is parametrized on the constraint system.
By augmenting the default constraint system,
the type system can serve as a core calculus 
for formalizing extensions of a core object-oriented language. 

The key idea is to define
\emph{constrained types},
a form of dependent type
defined on predicates over types and over the immutable state of
the program.

This work is done in the context of the X10
programming language~\cite{X10}.
In X10, objects may have both value members (fields)
and type members.
The immutable state of an object is captured by its
\emph{value properties}: public final fields of the object.
For instance, the following class declares a two-dimensional
point with properties \xcd"x" and \xcd"y" of type \xcd"float":
\begin{xten}
class Point(x: float, y: float) { }
\end{xten}

A constrained type is a type \xcd"C{e}", where \xcd"C" is a
class---called the \emph{base class}---and \xcd"e" is a
\emph{constraint}, or list of constraints, on the properties of
\xcd"C" and the final variables in scope at the type.
For example, given the above class definition,
the type \xcd"Point{x*x+y*y<1}" is the type of all
points within the unit circle.

% For brevity, a constraint can be written as
% a comma-separated list of conjuncts; that is, the constraint
% \xcd"c1"~\xcd"&&"~\xcd"c2" can be written
% \xcd"c1,"~\xcd"c2".

Constraints on properties induce a natural subtyping relationship:
\xcd"C{c}" is a subtype of
\xcd"D{d}" if \xcd"C" is a subclass of \xcd"D" and
\xcd"c" entails \xcd"d".  Thus, \xcd"Point{x==1,y==1}"
is a subtype of \xcd"Point{x>0}", which in turn is a subtype of
\xcd"Point{true}"---written simply as \xcd"Point".

In previous
work~\cite{X10,constrained-types}, we considered
only value properties.
In this paper,
to support genericity these types are generalized
to allow \emph{type properties}, type-valued instance
members of an object.
Types may be defined by constraining the type properties as
well as the value properties of a class.

The following code declares a class \xcd"Cell" with a type
property named \xcd"T".
\begin{xten}
class Cell[T] {
    var value: T;
    def get(): T = value;
    def set(v: T) = { value = v; }
}
\end{xten}
The class has a mutable field \xcd"value" of type \xcd"T",
and has \xcd"get" and \xcd"set" methods for accessing the field.

This example shows that type properties are in many ways similar to
type parameters as provided in object-oriented languages such as
Java~\cite{Java3} and Scala~\cite{scala} and in functional
languages such as ML~\cite{ml} and
Haskell~\cite{haskell}.

As the example illustrates,
type properties are types in their own right:
they may be used in any context a type may be used,
including in \xcd"instanceof" and cast expressions.
%
However, the key distinction between type properties
and type parameters is that type properties are instance
members.
Thus, for an expression \xcd"e" of type \xcd"Cell", \xcd"e.T" is
a type, equivalent to the concrete type to which \xcd"T" was
initialized when the object \xcd"e" was instantiated.
To ensure
soundness, \xcd"e" is restricted to final access paths.
Within the body of a class, the unqualified property name \xcd"T" resolves
to \xcd"this.T".

All properties of an object, both type and value, must be bound at object
instantiation and are immutable once bound.  Thus, the type
property \xcd"T" of a given \xcd"Cell" instance must be bound
by the constructor
to a concrete type such as \xcd"String" or \xcd"Point{x>=0}".

As with value properties, type properties may be constrained
by predicates to produce \emph{constrained types}.
Many features of modern object-oriented type systems fall out
naturally from this type system.

\paragraph{Generic types.}
The \xcd"Cell" defined class above is a generic class.
X10 supports
equality constraints, written \xcdmath"T$_1$==T$_2$", and
subtyping constraints, written \xcdmath"T$_1$<:T$_2$", on types.
For instance,
the type \xcd"Cell{T==float}" is the type of all \xcd"Cell"s
containing a \xcd"float".  For an instance \xcd"c" of this type,
the types \xcd"c.T" and \xcd"float" are equivalent.  Thus, the
following code is legal.
\begin{xten}
val x: float = c.get();
c.set(1.0);
\end{xten}

Subtyping constraints enable \emph{use-site variance}~\cite{variance}.
The type \xcd"Cell{T<:Collection}"
constrains \xcd"T" to be a subtype of \xcd"Collection".
All instances with this type must bind \xcd"T" to a subtype of
\xcd"Collection".
Variables of this type may contain \xcd"Cell"s of
\xcd"Collection", \xcd"Cell" of \xcd"List",
or \xcd"Cell" of \xcd"Set", etc.

Subtyping constraints provide similar expressive power as Java
wildcards.  We describe an encoding of wildcards in
Section~\ref{sec:wildcards}. 

\paragraph{Self types.}
Type properties can also be used to support a form of self
types~\cite{bruce-binary,bsg95}.
%
Self types can be implemented by introducing a
type property \Xcd{class} to the root of the class hierarchy, \Xcd{Object}:
\begin{xtenmath}
class Object[class] { $\dots$ }
\end{xtenmath}
Scala's path-dependent types~\cite{scala} and J\&'s
dependent classes~\cite{nqm06}
take a similar approach.

Self types are achieved by
implicitly constraining types so that if an path expression \Xcd{p}
has type \Xcd{C}, then
$\Xcd{p}.\Xcd{class} \subtype \Xcd{C}$.  In particular,
$\Xcd{this}.\Xcd{class}$ is guaranteed to be a subtype
of the lexically enclosing class; the type
$\Xcd{this}.\Xcd{class}$ represents all instances of the fixed,
but statically unknown, run-time class referred to by the \Xcd{this}
parameter.

\paragraph{Virtual types.}

Type properties share many similarities with virtual
types~\cite{mp89-virtual-classes,beta,ernst99-gbeta,ernst06-virtual,cdnw07-tribe}
and similar constructs built on path-dependent types found in
languages such as Scala~\cite{scala}, and J\&~\cite{nqm06}.
%
Constrained types are more expressive than virtual
types since they can be constrained at the use-site,
can be refined on a per-object basis without explicit subclassing,
and can be refined contravariantly
as well as covariantly.  We explore this connection in
Section~\ref{sec:virtual}.

\subsection{Contributions}

\todo{We need some!}

\subsection{Implementation}

Type properties are a powerful mechanism
for providing genericity in X10.
Unlike existing 
existing proposals for generic types in
Java-like
languages~\cite{Java3,adding-wildcards,GJ,Pizza,polyj,thorup97,allen03,allen04,csharp,emir06,scala},
which 
are implemented via type erasure,
our design supports run-time introspection of generic types.

Another problem with many of these proposals is inadequate support
for primitive types, especially arrays. The performance of primitive arrays is
critical for the high-performance applications for which
X10 is intended. These proposals introduce unnecessary boxing
and unboxing of primitives.
Our design does not require primitives be boxed.

\paragraph{Structural constraints.}

Type constraints need not be limited to subtyping constraints.
By introducing structural constraints on types, \gxx allows
type properties to be instantiated on any type with a given set
of methods and fields. This feature is useful for reusing code
in separate libraries since it does not require 
code of one library to implement an interface to satisfy a
constraint of another library.

\paragraph{Outline.}
The rest of the paper is organized as follows.
%
Section~\ref{sec:related} discusses related work.
%
An informal overview of generic constrained types in X10
is presented in
Section~\ref{sec:lang}.  
%
Section~\ref{sec:semantics} presents a formal semantics and a
proof of soundness.
%
The implementation of generics in X10 by translation to Java is described in 
Section~\ref{sec:translation}.
%
Finally, Section~\ref{sec:conclusions} concludes.

\todo{Fix this}

\section{Related work}
\label{sec:related}

\input{related}

\section{X10 language overview}
\label{sec:lang}

This section presents an informal description of the 
generic constrained types in X10.  The type system is formalized
in a simplified version of X10, \gxx (Generic Featherweight X10), in
Section~\ref{sec:semantics}.

X10 is a class-based object-oriented language.
The language has a sequential core similar to Java or Scala, but 
constructs
for concurrency and distribution, as well as constrained types,
described here.
Like Java, the language provides single class inheritance and
multiple interface inheritance.

\subsection{Classes}

Classes in X10 may be declared with any number of type properties and
value properties.  These properties can be constrained with a
\emph{class invariant},
a predicate on the properties of any instance of the class.
%
The general form of a class declaration is:
\begin{xtenmath}
class C[$\tbar{X}$]($\tbar{x} \ty \tbar{T}$){c} extends D{d}
      implements $\tbar{I}${$\tbar{c}$} { $\dots$ }
\end{xtenmath}
This declaration defines a class \xcd"C" with zero or more type properties
          \xbar{X}, zero of more value properties \xbar{x} of
          types \xbar{T}, and a class invariant \xcd"c".
          The class \xcd"C" is a subclass of \xcd"D"
          (constrained by \xcd"d")
          and implements the constrained
          interfaces \xbar{I}\xcd"{"\xbar{c}\xcd"}".

Both classes and interfaces may define properties. Value
properties may be considered to be public final instance fields.
Whereas
Java supports only static fields in interfaces, X10
allows interfaces to define value properties. Any class implementing
an interface must declare or inherit from a superclass 
the properties inherited from the interface.  All properties of
a class,
both type and value, must be initialized by the class's
constructors.

Classes may define fields, methods, and constructors.
Consider the example in Figure~\ref{fig:list}.
The
declaration syntax
is similar to Scala's.  Fields may be
declared either \xcd"val" or \xcd"var".  A \xcd"val" field is
\emph{final} and must be assigned exactly once by the
constructor.  Methods are
declared with a \xcd"def" keyword.
Methods in classes and interfaces may be declared \xcd"static".
Mutable static fields 
are not permitted.
Constructor syntax is
similar to method syntax; X10 adopts Scala's syntax,
using the name \xcd"this" for constructors.
In X10, constructors have a return type, which constrains
the properties of the new object.

\begin{figure}
\begin{xtennoindent}
class List[T](length: int){length >= 0} {
    var head: T;
    var tail: List[T];

    def this[S](): List[S](0) = property[S](0);
    def this[S](hd: S): List[S](1) = {
        property[S](1); head = hd;
    }
    def this[S](hd: S, tl: List[S])
        : List[S](tl.length+1) = {
        property[S](tl.length+1);
        head = hd; tail = tl;
    }

    def map[S](f: (T)=>S): List[S] = ...;

    // XXX
    def get(i: int){0 <= i, i < length} = {
        if (i == 0) return head;
        if (tail != null) return tail.get(i-1);
        throw new IndexOutOfBoundsException();
    }
}
\end{xtennoindent}
\caption{List example}
\label{fig:list}
\end{figure}

\subsection{Constrained types}

A constrained type is written \xcd"C{e}", where \xcd"C" is the
name of a class and \xcd"e" is a constraint on the
properties of \xcd"C" and the final variables in scope at the
type.  

For brevity, the constraint may be omitted and
interpreted as \xcd"true".
The syntax
\xcdmath"C[T$_1$,$\dots$,T$_m$](e$_1$,$\dots$,e$_n$)" is sugar for
\xcdmath"C{X$_1$==T$_1$,$\dots$,X$_m$==T$_m$,x$_1$==e$_1$,$\dots$,x$_n$==e$_n$}"
where \xcd"X$_i$" are the type properties and \xcd"x$_i$" are the
value properties of \xcd"C".
If either list of properties is empty, it may be omitted.

In this shortened syntax, a type argument \xcd"T" used may also
be annotated
with
a \emph{use-site variance tag}, either \xcd"+" or \xcd"-":
if \xcd"X" is a type property, then
the syntax \xcd"C[+T]" is sugar \xcd"C{X<:T}" and
\xcd"C[-T]" is sugar \xcd"C{X:>T}"; of course,
\xcd"C[T]" is sugar \xcd"C{X==T}".
Use-site variance is discussed in more detail in
Section~\ref{sec:variance}

The compiler checks that constraints are expressions
of type \xcd"boolean" and that they can be statically checked by
the compiler's constraint solver.  X10 supports conjunctions of equality and
subtyping consraints.  Compiler plugins may be installed to
handle richer constraint systems such as Presburger arithmetic
or set constraints.

\subsection{Generics}

Type properties and subtyping constraints are used in X10 to 
provide genericity.

Unlike existing 
existing proposals for generic types in
Java-like
languages~\cite{Java3,adding-wildcards,GJ,Pizza,polyj,thorup97,allen03,allen04,csharp,emir06,scala},
which 
are implemented via type erasure,
our design supports run-time introspection of generic types.

Another problem with many of these proposals is inadequate support
for primitive types, especially arrays. The performance of primitive arrays is
critical for the high-performance applications for which
X10 is intended. These proposals introduce unnecessary boxing
and unboxing of primitives.
Our design does not require primitives be boxed.

\subsection{Type constraints and variance}
\label{sec:variance}

Type properties and subtyping constraints are used in X10 to 
provide genericity.

The \xcd"List" class in Figure~\ref{fig:list}.
Consider the following subtypes  of \xcd"List".
\begin{itemize}
\item \xcd"List".  This type has no constraints on the type
property \xcd"T".
Any type that constrains \xcd"T",
is a subtype of \xcd"List".  The type \xcd"List" is equivalent to
\xcd"List{true}".
%
For a \xcd"List" \xcd"l", the return type of the \xcd"get" method
is \xcd"l.T".
Since the property \xcd"T" is unconstrained,
the caller can only assign the return value of \xcd"get"
to a variable of type \xcd"l.T" or of type \xcd"Object".
In the following code, \xcd"y" cannot be passed to the \xcd"set" method
because it is not known if \xcd"Object" is a subtype of \xcd"c.T".
\begin{xten}
val x: l.T = l.get(0);
val y: Object = l.get(1);
l.set(x); // legal
l.set(y); // illegal
\end{xten}

\item \xcd"List{T==float}".
The type property \xcd"T" is bound to \xcd"float".
Assuming \xcd"l" has this type, then following code is legal:
\begin{xten}
val x: float = l.get();
l.set(1.0);
\end{xten}
The type of \xcd"l.get()" is \xcd"l.T", which is equivalent to
\xcd"float".

\item \xcd"List{T<:Collection}".
This type constrains \xcd"T" to be a subtype of \xcd"Collection".
All instances of this type must bind \xcd"T" to a subtype of
\xcd"Collection"; for example \xcd"List[Set]" (i.e.,
\xcd"List{T==Set}" is a subtype of
\xcd"List{T<:Collection}" because \xcd"T==Set" entails
\xcd"T<:Collection".
%
If \xcd"l" has the type \xcd"List{T<:Collection}",
then \xcd"l.get(0)" has type \xcd"l.T", which is an unknown but
fixed subtype of \xcd"Collection"; the return value can be
assigned into a variable of type \xcd"Collection".

\item \xcd"List{T:>String}".  This type bounds the type property
\xcd"T"
from below.  The \xcd"set" method may be called with any
supertype of \xcd"String"; the return type of the \xcd"get"
method is known to be a
supertype of \xcd"String" (and implicitly a subtype of \xcd"Object").
\end{itemize}

\subsection{Type properties}

Type properties may be declared invariant, covariant, or
contravariant.
If a property \xcd"X" of a class \xcd"C" is covariant,
then if \xcd"S" is a subtype of
\xcd"T", the type \xcd"C{X==S}" is a subtype of \xcd"C{X==T}".
Similarly, if \xcd"X" is contravariant, 
                  \xcd"C{X==T}" is a subtype of \xcd"C{X==S}".
It is illegal for a covariant property to occur in a negative
position in its class declaration and for a contravariant
property to occur in a positive position.  A position is
negative if it is a formal parameter type, or occurs in a method
where clause.  A position is positive if it is a return type or
occurs in a method where clause.

\subsection{Constructors}

Objects in X10 are initialized with constructors. 
Constructors are defined using the syntax \xcd"def this",
illustrated with the three \xcd"List"
constructors in Figure~\ref{fig:list}.

Constructors must ensure that all properties of the new object
are initialized and that the class invariants of the object's
class and its superclasses and superinterfaces hold.

Constructors can take zero or more type parameters and zero or
more value parameters.

Properties are initialized with a \xcd"property" statement.
The \xcd"property" statement is used to set all the properties
of the new object simultaneously; the syntax is similar to a \xcd"super"
constructor call.
The first constructor takes zero arguments and initializes the
type property \xcd"T" to the type parameter \xcd"S"
length to \xcd"0".  The second constructor initializes the
length to \xcd"1", the third to one plus the length of the tail.

Constructors have ``return
types'' that can specify an invariant satisfied by the object being
constructed.  This type 
is used as the type of the \xcd"new" expression that
invoked the constructor.
The compiler verifies that the
constructor return type and the class invariant are implied by the
\xcd"property" statement and any \xcd"super"
or \xcd"this" calls in the constructor body.

Classes that do not declare a constructor
have a default constructor with a type parameter for each
type property and a value parameter for each value property.

\subsection{Methods}

Methods in X10 are declared with the \xcd"def" keyword.
The \xcd"List" class in Figure~\ref{fig:list} declares methods
\xcd"get" and \xcd"map".

Like Java, X10 supports both instance and static methods.
Since a type property is an instance member, a static method may
not refer to a type property of the class.

Interfaces are also permitted to have static methods.  Classes
implementing the interface must provide an implementation of the
static methods of the interface.
This feature is
useful when a type property \xcd"T" is constrained to implement
an interface \xcd"I"; static methods of \xcd"I" can be invoked
through \xcd"T".

Methods may have both type and value parameters.  
For instance, the \xcd"map" method in Figure~\ref{fig:list} 
has a type parameter \xcd"S" and a value parameter that is a
function from \xcd"T" to \xcd"S".

A parametrized method can is invoked by giving type arguments before the
expression arguments.  The following code takes a
list of \xcd"String"s and returns a list of string lengths of
type \xcd"int"
\begin{xten}
xs: List[String] = ...;
ys: List[int] = xs.map[int](
        (x: String) => x.length());
\end{xten}

\paragraph{Conditional methods.}

Methods and constructor may also have \emph{where clauses},
constraints on how
the method may be invoked.  The where clause is written after
the
method parameters and before the return type.  The \xcd"get" method in
Figure~\ref{fig:list} requires that the argument \xcd"i" is
within the list bounds.  A method with a where clause
is called a \emph{conditional method}.

For type parameters, method where clauses are 
similar to generalized constraints proposed for
C\#~\cite{emir06}.
%
In the following code, the \xcd"T" parameter is covariant
and so the \xcd"append" methods below are illegal:
\begin{xten}
class List[+T] {
   def append(other: T): List[T] = { ... }
        // illegal
   def append(other: List[T]): List[T] = { ... }
        // illegal
}
\end{xten}
%
However, one can introduce a method parameter and then constrain
the parameter from below by the class's parameter:
For example, in the following code,
\begin{xten}
class List[+T] {
   def append[U](other: U)
        {T <: U}: List[U] = { ... }
   def append[U](other: List[U])
        {T <: U}: List[U] = { ... }
}
\end{xten}

The constraints must be satisfied by the callers of \xcd"append".
For example, in the following code:
\begin{xten}
xs: List[Number];
ys: List[Integer];
xs = ys; // ok
xs.append(1.0); // legal
ys.append(1.0); // illegal
\end{xten}
the call to \xcd"xs.append" is allowed and the result type is \xcd"List[Number]", but
the call to \xcd"ys.append" is not allowed because the caller cannot show that
${\tt Number} \subtype {\tt Double}$.

\paragraph{Method overriding.}

Method overriding is similar to Java: a method of a subclass
with the same name and parameter types overrides a method of the
superclass.  An overridden method may have a return type that is
a subtype of the superclass method's return type.
A method where clause may be weakened by an overriding
method; that is, the where clause of the superclass must entail the  
where clause of the subclass.

\eat{
\subsection{Interfaces}

optional interfaces
value properties in interfaces
static methods in interfaces

\subsubsection{Optional methods and interfaces}

Method where clauses also provide support for optional methods.

\begin{xten}
class List[T] {
    ...
    def print(){T <: Printable} = {
        for (x: T in this)
            x.print();
    }
}
\end{xten}

\xcd"List.print" may only be called on lists instantiated on
subtypes of the \xcd"Printable" interface.

Optional methods generalize to optional interfaces.

\begin{xten}
interface Printable { def print(); }

class List[T] implements Printable if {T <: Printable} {
    ...
    def print(){T <: Printable} = {
        for (x: T in this)
            x.print();
    }
}
\end{xten}

In this case \xcd"List" implements the \xcd"Printable" interface
only if \xcd"List.T" implements \xcd"Printable".
Thus \xcd"List{T==String}"
and \xcd"List{T==List[String]}"
are subtypes of \xcd"Printable", but
\xcd"List{T" \xcd"==DirtyWord}" is not.


Without optional interfaces, \xcd"List" cannot be a subtype
of \xcd"Printable".  The constraint \xcd"{T <: Printable}" on
the \xcd"print" method is more restrictive than the 
constraint (i.e., \xcd"true") on 
\xcd"Printable.print".
}

\subsection{Function-typed properties}

\begin{figure}

\begin{xtenmathnoindent}
class SortedList(compare: (T,T)=>int) extends List {
    def this[T](hd: T, tl: List[T],
                compare: (T,T)=>int)
        : SortedList[T](compare) = {
        super[T](hd, tl);
        property(compare);
    }

    def this[T](hd: T, tl: List[T]){T <: Comparable}
        : SortedList[T](T.compare.(Object)) = {
        this[T](hd, tl, T.compareTo.(Object));
    }

    def add(x: T) = {
        $\dots$ compare(x, y) $\dots$
    }
}
\end{xtenmathnoindent}

\caption{A \Xcd{SortedList} class with function-typed value properties}
\label{fig:sorted}
\end{figure}


X10 supports first-class functions.
Function-typed properties are a useful feature for generic
collection classes.  Consider the definition of the
\xcd"SortedList" class in Figure~\ref{fig:sorted}.
The class has a property \xcd"compare" of type
\xcd"(T,T)=>int"---a function that takes two \xcd"T"s and
returns an \xcd"int".  The class declares two constructors,
one that takes a function to bind to the \xcd"compare"
property, and another that binds \xcd"T"'s \xcd"compare" method to
the property.  The \xcd"compare" method uses the \xcd"equals"
function to compare elements. 

Using this definition, one can create lists with distinct types
of, for example, case-sensitive and case-insensitive strings:
\begin{xten}
val unixFiles
  = new SortedList[String]
        (String.compareTo.(String));
val windowsFiles
  = new SortedList[String]
        (String.compareToIgnoreCase.(String));
\end{xten}

\noindent
The lists \xcd"unixFiles" and \xcd"windowsFiles" are constrained
by different comparison functions.  This allows the programmer
to write code, for instance, in which it is illegal to pass a list of UNIX
files into a function that expects a list of Windows files, and
vice versa.

\section{Structural constraints}
\label{sec:structural}


\begin{figure}[tp]
\begin{center}
\begin{tabular}{lrcl}
constraints & {\tt c} & ::= & \dots \\
            &        & \bnf & \xcd"T has Sig" \\
signatures  & {\tt Sig} & ::= &
\xcdmath"def this[$\tbar{X}$]($\tbar{x}$: $\tbar{T}$){c}: T" \\
            &        & \bnf &
\xcdmath"def m[$\tbar{X}$]($\tbar{x}$: $\tbar{T}$){c}: T" \\
            &        & \bnf &
\xcdmath"val x{c}: T" \\
            %&  & \bnf & \xcdmath"var x{c}: T" \\
\end{tabular}
\end{center}
\caption{Grammar for structural constraints}
\label{fig:structural}
\end{figure}

In this section, we consider an extension of the X10 type system
to support structural type constraints.
The type
system need not change except by extending the constraint
system.  The syntax for structural constraints is shown in
Figure~\ref{fig:structural}.  A structural constraint of the
form \xcd"T has Sig" can specify that the type \xcd"T" have a
constructor, method, or field of the given signature.

Structural constraints on types are found in many languages.
Haskell supports type
classes~\cite{haskell,haskell-type-classes}.
%ML's module system allows modules to be constrained by
%structural signatures~\cite{ml}.
In Modula-3, type equivalence and subtyping are structural
rather than nominal as in object-oriented languages of the C
family such as C++, Java, Scala, and X10.
%
The language PolyJ~\cite{polyj} allows type parameters to be bounded using
structural where clauses.
For example, the sorted list class from Figure~\ref{fig:sorted}
could be
be written as follows in PolyJ:
\begin{xten}
class SortedList[T] where T { int compareTo(T) } {
    void add(T x) { ... x.compareTo(y) ... }
    ...
}
\end{xten}
The where clause states that the type parameter \xcd"T" must have a
method \xcd"compareTo" with the given signature.

The analogous code for \xcd"SortedList" in the structural
extension of X10 is:
\begin{xten}
class SortedList[T]{T has def compareTo(T): int} {
    def add(x: T) = { ... x.compareTo(y) ... }
    ...
}
\end{xten}

A structural constraint is satisfied if the type has a member of
the appropriate name and with a compatible type.  The constraint
\xcdmath"Z has def m[$\tbar{X}$]($\tbar{x}\ty\tbar{T}$): U"
is satisfied by a type \xcd"T" if it has a method \xcd"m"
with signature
\xcdmath"def m[$\tbar{Y}$]($\tbar{y}\ty\tbar{S}$): V"
and where
(\xcdmath"[$\tbar{Y}$]($\tbar{y}\ty\tbar{S}$) => V")$[\Xcd{T}/\Xcd{Z}]$
is a subtype of
(\xcdmath"[$\tbar{X}$]($\tbar{x}\ty\tbar{T}$) => U")$[\Xcd{T}/\Xcd{Z}]$.
As an example,
the constraint \xcd"X has def compareTo(X): int"
is satisfied by both of the following classes:
\begin{xten}
class C { def compareTo(x: C): int = ...; }
class D { def compareTo(x: Object): int = ...; }
\end{xten}

\todo{The important bit about all this is... don't have to
      change the type system, just the constraints}

\section{Self types}
\label{sec:self}

X10 itself does not support self 
types~\cite{bruce-binary,bsg95}
directly, but type properties can
be used to encode them.

%
We introduce a 
type property \Xcd{class} to the root of the class hierarchy, \Xcd{Object}:
\begin{xtenmath}
class Object[class] { $\dots$ }
\end{xtenmath}
Scala's path-dependent types~\cite{scala} and J\&'s
dependent classes~\cite{nqm06}
take a similar approach.

\noindent
Self types are achieved by
implicitly constraining types so that if a path expression \Xcd{p}
has type \Xcd{C}, then
$\Xcd{p}.\Xcd{class} \subtype \Xcd{C}$.  In particular,
$\Xcd{this}.\Xcd{class}$ is guaranteed to be a subtype
of the lexically enclosing class; the type
$\Xcd{this}.\Xcd{class}$ represents all instances of the fixed,
but statically unknown, run-time class referred to by the \Xcd{this}
parameter.

Self types address the binary method problem~\cite{bruce-binary}.
In the following
example, the class \xcd"BitSet" can be written with a
\xcd"union" method that takes a self type as argument.

\begin{xtenmath}
interface Set {
    def union(s: this.class): void;
}

class BitSet implements Set {
    int bits;
    def union(s: this.class): void {
        this.bits |= s.bits;
    }
}
\end{xtenmath}

\noindent
The implementation of the method is free to access the
\xcd"bits" field of the argument since the constraint
$\Xcd{this}.\Xcd{class} \subtype \Xcd{BitSet}$ ensures the field is
accessible.



\section{Formal semantics}
\label{sec:semantics}

We present a core calculus, \gxx, for X10 with generics.
\gxx is based on Constrained Featherweight
Java~\cite{constrained-types}.

\todo{
Add method overriding rules: covariant return, contravariant
args, weaker constraints
}

The grammar for \gxx is shown in 
Figure~\ref{fig:grammar}.  The calculus elides features of the
full X10 language not relevant to this paper.

\begin{figure}[tp]
\begin{center}
\begin{tabular}{lrcl}
program & {\tt P} & ::= & \xbar{L} \\
classes & {\tt L} & ::= &
\xcdmath"class C[$\tbar{X}$]($\tbar{x} \ty \tbar{T}$){c}" \\
& & & \xcdmath"  extends T { $\tbar{M}$ }" \\
base types & {\tt R} \\
\quad classes & & ::= & \xcd"C" \\
\quad type variables  & & \bnf & \xcd"X" \\
\quad type members    & & \bnf & \xcd"e.X" \\
\quad type type       & & \bnf & \xcd"type" \\
types & {\tt T} & ::= & \xcd"R{c}" \\
methods     & {\tt M} & ::= &
\xcdmath"def m[$\tbar{X}$]($\tbar{x}$: $\tbar{T}$){c}: T = e" \\
expressions & {\tt e} & \\
\quad literals        &         & ::=  & \xcd"true" \bnf \xcd"false" \bnf \xcd"null" \bnf $n$ \\
\quad variables       &         & \bnf & \xcd"x" \\
\quad field access    &         & \bnf & \xcdmath"e.x" \\
\quad call            &         & \bnf & \xcdmath"e$_0$.m[$\tbar{T}$]($\tbar{e}$)" \\
%\quad                 &         & \bnf & \xcdmath"e$_0$.m($\tbar{e}$)" \\
\quad new             &         & \bnf & \xcdmath"new C[$\tbar{T}$]($\tbar{e}$)" \\
%\quad                 &         & \bnf & \xcdmath"new C($\tbar{e}$)" \\
\quad cast            &         & \bnf & \xcdmath"e as T" \\
constraint terms & {\tt t} &     & \\
\quad self            &         & ::=  & \xcd"self" \\
\quad variables       &         & \bnf & \xcd"x" \\
\quad properties      &         & \bnf & \xcd"t".\xcd"x" \\
\quad atoms           &         & \bnf & \xcdmath"g(t$_1$,$\dots$,t$_n$)" \\
\quad new             &         & \bnf & \xcdmath"new C(t$_1$,$\dots$,t$_n$)" \\
constraint & {\tt c} &      & \\
\quad true            &  & ::=  & \Xcd{true} \\
\quad equality        &  & \bnf & $\Xcd{t}_1 \equals \Xcd{t}_2$ \\
\quad existentials    &  & \bnf & $\exc{\Xcd{x}}{\Xcd{c}}$ \\
\quad conjunction     &  & \bnf & $\xbar{c}$ \\
\quad predicates      &  & \bnf & \xcdmath"p(t$_1$,$\dots$,t$_n$)" \\
environments & $\Gamma$ & ::=  & $\epsilon$ \\
            &          & \bnf & $\Gamma$, $\Xcd{c}$ \\
            &          & \bnf & $\Gamma$, $\Xcd{x} \ty \Xcd{T}$ \\
            &          & \bnf & $\Gamma$, $\Xcd{X} \ty \Xcd{type}$ \\
\end{tabular}
\end{center}
\caption{\gxx grammar}
\label{fig:grammar}
\end{figure}

Figure~\ref{fig:grammar2} extends the grammar with syntactic
sugar for subtyping constraints and existential types.
The subtyping constraint
                  $\Xcd{t}_1 \subtype \Xcd{t}_2$ 
                  is atomic formula.
The existential type 
$\exty{\Xcd{x}}{\Xcd{T}}{\Xcd{R\{c\}}}$
is sugar for
$\Xcd{R\{}\exc{\Xcd{x}}{\sigma(\Xcd{x}\ty\Xcd{T}),\Xcd{c}}\Xcd{\}}$.

\begin{figure}[tp]
\begin{center}
\begin{tabular}{lrcl}
types & {\tt T} & ::= & \dots \\
            & & \bnf & $\exty{\Xcd{x}}{\Xcd{T}_0}{\Xcd{T}}$ \\
            & & \bnf & $\exty{\Xcd{X}}{\Xcd{type}}{\Xcd{T}}$ \\
constraint terms & {\tt t} & ::= & \dots \\
\quad literals        &         &      & \xcd"true" \bnf $n$ \bnf \xcd"C" \\
\quad type variables       &         & \bnf & \xcd"X" \\
\quad type properties      &         & \bnf & \xcd"t".\xcd"X" \\
constraint & {\tt c} & ::=  & \dots \\
                  &  & \bnf & $\Xcd{t}_1 \subtype \Xcd{t}_2$ \\
                  &  & \bnf & \Xcd{cons(T,z)} \\
\end{tabular}
\end{center}
\caption{\gxx grammar with subtyping constraints}
\label{fig:grammar2}
\end{figure}

We assume a fixed but unknown constraint system ${\cal D}$.
A program \Xcd{P} is written using constraints from ${\cal D}$,
We assume classes defined in \Xcd{P} do not have a cyclic
inheritance structure.

\infrule[Program OK]{
\Xcd{extends}^+~\mbox{acyclic}
}{
\vdash \xbar{L}~\mbox{ok}
}

\subsection{
The object constraint system, ${\cal O}$
}

From \Xcd{P} and ${\cal D}$
we generate an \emph{object constraint system} ${\cal O}$, shown
in Figure~\ref{fig:object-constraints},
as follows.  Let \Xcd{C} and \Xcd{D} range over names of classes
in \Xcd{P}, \Xcd{f} over field names, \Xcd{m} over method names,
\Xcd{T} over types, and \Xcd{c} over constraints in the
underlying data constraint system ${\cal D}$.

\begin{figure}[tp]
\begin{center}
\begin{tabular}{lrcl}
constraint & {\tt c} 
                    & ::=  & \Xcd{class(C)} \\
                  & & \bnf & \Xcd{C}~\Xcd{extends}~\Xcd{D} \\
                  & & \bnf & $\Xcd{fields(x,}\xbar{f}\ty\xbar{T}\Xcd{)}$ \\
                  & & \bnf & $\Xcd{mtype(x,m,[}\xbar{X}\Xcd{(}\xbar{x}\ty\xbar{T}\Xcd{)\{c\}}$ \\
\end{tabular}

\infrule{
\Xcdmath{class C[$\tbar{X}$]($\tbar{f} \ty \tbar{T}$)\{c\} extends D\{d\} \{ $\tbar{M}$\}} \in \Xcd{P}
}{
\vdashO \Xcd{class(C)} \\
\vdashO \Xcd{C}~\Xcd{extends}~\Xcd{C} \\
\vdashO \Xcd{C}~\Xcd{extends}~\Xcd{D}
}

\infrule[Fields]{
\Xcdmath{class C[$\tbar{X}$]($\tbar{f} \ty \tbar{T}$)\{c\} extends Object \{ $\tbar{M}$\}} \in \Xcd{P}
}{
\Gamma, \Xcd{z}\ty \Xcd{C}\{d\} \vdashO \Xcdmath{fields(z,$\tbar{f}\ty\tbar{T}$)}
}

\infrule[Fields-extends]{
\vdashO \Xcd{C}~\Xcd{extends}~\Xcd{D}
\\
\Xcdmath{class C[$\tbar{X}$]($\tbar{f} \ty \tbar{T}$)\{c\} extends D\{d\} \{ $\tbar{M}$\}} \in \Xcd{P}
\\
\Gamma, \Xcd{z}\ty \Xcd{D\{d\}} \vdashO
\Xcdmath{fields(z,$\tbar{f}_0\ty\tbar{T}_0$)}
}{
\Gamma, \Xcd{z}\ty \Xcd{D\{d\}} \vdashO
\Xcdmath{fields(z,$\tbar{f}_0\ty\tbar{T}_0$, $\tbar{f}\ty\tbar{T}$)}
}

\infrule[Mtype]{
\Xcdmath{class C[$\tbar{X}$]($\tbar{f} \ty \tbar{T}$)\{c\} extends Object \{$\tbar{M}$\}} \in \Xcd{P}
\\
\Xcd{M}_i = 
\Xcdmath{def m$_i$[$\tbar{X}$]($\tbar{x}\ty\tbar{T}$)\{c\}: T = e}
}{
\Gamma, \Xcd{z}\ty \Xcd{C\{d\}} \vdashO
\Xcdmath{mtype(z,m$_i$,[$\tbar{X}$]($\tbar{x}\ty\tbar{T}$)\{c\} $\to$T)}
}

\end{center}
\caption{The constraint system ${\cal O}$}
\label{fig:object-constraints}
\end{figure}

In the method signature
                $\Xcd{[}\xbar{X}\Xcd{(}\xbar{x}\ty\xbar{T}\Xcd{)\{c\}}$,
                the type variables \xbar{X} and data variables
                \xbar{x} are considered bound; formulas with
                bound variables are considered equivalent up to
                $\alpha$-renaming.

The constraint system satisfies the axioms and
inference rules in Figure~\ref{fig:object-constraints}.
The \Xcd{class}, \Xcd{extends}, \Xcd{fields}, and \Xcd{mtype}
constraints are given directly from the program \Xcd{P}.

The constraint system ${\cal C}$ is the disjoint conjunction
${\cal D}$, ${\cal O}$
of
the constraint systems
${\cal D}$ and ${\cal O}$.
(This requires the assumption that 
${\cal D}$ does not have any constraints in common with ${\cal O}$.

\eat{
The X10 compiler permits the constraint system to be extended
with compiler plugins.  The base compiler supports equality
constraints over literals and final variables and subtyping
and equality
constraints over types.
The core constraint system is presented here.  We assume a
constraint solver ${\cal X}$ implementing the plugged-in
constraint systems.

The constraint system does not distinguish between values and
types.  Logical variables \xcd"x" may represent program variables
or type variables.  Path terms \Xcd{p.x} may represent field
accesses or member type references.

The constraint system is shown in Figure~\ref{fig:constraints}.
$\xbar{c}$ is a set of constraints.  The constraint system
satisfies the given structural rules, and supports equality and
subtyping constraints over terms.
}


\subsection{Structural and logical rules}

All judgments are intuitionistic.  In particular, this means
that all constraint systems satisfy the rules and axioms
in Figure~\ref{fig:logic}.

\begin{figure}

\infax[Id]{ \Gamma, \Xcd{c} \vdash \Xcd{c} }

\infrule[Cut]{
\Gamma \vdash \Xcd{c}
\andalso
\Gamma, \Xcd{c} \vdash \Xcd{d}
}{
\Gamma \vdash \Xcd{d}
}

% \infrule[Contraction]{ \xbar{c}, \Xcd{c}, \Xcd{c} \vdashC \Xcd{d} }
                     % { \xbar{c}, \Xcd{c} \vdashC \Xcd{d} }
% \infrule[Permutation]{ \xbar{c}, \Xcd{c}, \Xcd{d} \vdashC \Xcd{e} }
                     % { \xbar{c}, \Xcd{d}, \Xcd{c} \vdashC \Xcd{e} }
% \infrule[Extension]{ \xbar{c}, \vdashC \Xcd{c} }
                     % { \xbar{c}, \xbar{c}' \vdashC \Xcd{c} }

\infrule[Weak-1]{
\Gamma \vdash \phi
\andalso
\Gamma \vdash \Xcd{T} \ty \Xcd{type}
\andalso
\Xcd{x} \not\in \mathit{var}(\Gamma)
}{
\Gamma, \Xcd{x} \ty \Xcd{T} \vdash \phi
}

\infrule[Weak-2]{
\Gamma \vdash \phi
\andalso
\Gamma \vdash \Xcd{c} \ty \Xcd{o}
}{
\Gamma, \Xcd{c} \ty \phi
}

\infrule[And-L]{
\Gamma, \psi_0, \psi_1 \vdash \phi
}{
\Gamma, (\psi_0, \psi_1) \vdash \phi
}

\infrule[And-R]{
\Gamma \vdash \psi_0
\andalso
\Gamma \vdash \psi_1
}{
\Gamma \vdash (\psi_0, \psi_1)
}

\infrule[Exists-R]{
\Gamma \vdash \phi[\Xcd{t}/\Xcd{x}]
}{
\Gamma \vdashC \exc{\Xcd{x}}{\phi}
}

\infrule[Exists-L]{
\Gamma, \Xcd{x} \ty \Xcd{T}, \psi \vdash \phi
\andalso
\Xcd{x}~\mbox{fresh}
}{
\Gamma, \exc{\Xcd{x}\ty\Xcd{T}}{\psi} \vdash \phi
}

\caption{Logical rules}
\label{fig:logic}
\end{figure}


\subsection{Well-formedness rules}

We use the judgment for well-typedness for expressions to
represent well-typedness for constraints.  That is, we posit
a special type \Xcd{o} (traditionally the type of propositions),
and regard constraints as expressions of type \Xcd{o}.

Further, we change the formulation slightly so that there are no
constraints of the form \Xcdmath{p(t$_1$,$\dots$,t$_n$)}; rather
instance method invocation syntax is used to express invocation
of
pre-defined constraints.  This logically leads to the step of
simply marking certain classes as ``predicate'' classes---all
the (instance) methods of these classes whose return type is
\Xcd{o} then correspond to ``primitive constraints''.
Syntactically, we continue to use the symmetric syntax
\Xcdmath{p(t$_1$,$\dots$,t$_n$)} rather than
\Xcdmath{t$_1$.p(t$_2$,$\dots$,t$_n$)}.
The alternative is tor introduce static methods and static
method invocations in the expression language.  This is not
difficult, but is annoying to have to repeat most of the
formulation of instance methods.

This means that the only cases left to handle are all the simple
ones, expression the availability of certain constraints and
operations of type \Xcd{o}.


\begin{figure}
\infax[True]{\Gamma \vdash \Xcd{true} \ty \Xcd{o}}

\infrule[Equals]{
\Gamma \vdash \Xcd{t}_0 \ty \Xcd{T}_0
\andalso
\Gamma \vdash \Xcd{t}_1 \ty \Xcd{T}_1
\andalso
(
\Gamma \vdash \Xcd{T}_0 \subtype \Xcd{T}_1
\vee
\Gamma \vdash \Xcd{T}_1 \subtype \Xcd{T}_2
)
}{
\Gamma \vdash \Xcd{t}_0 \equals \Xcd{t}_1 \ty \Xcd{o}
}

\infrule[And]{
\Gamma \vdash \Xcd{c}_0 \ty \Xcd{o}
\andalso
\Gamma \vdash \Xcd{c}_1 \ty \Xcd{o}
}{
\Gamma \vdash (\Xcd{c}_0, \Xcd{c}_1) \ty \Xcd{o}
}

\infrule[Some]{
\Gamma \vdash \Xcd{t} \ty \Xcd{T}
\andalso
\Gamma \vdash \Xcd{c}[\Xcd{t}/\Xcd{x}] \ty \Xcd{o}
}{
\Gamma \vdash \exc{\Xcd{x}\ty\Xcd{T}}{\Xcd{c}} \ty \Xcd{o}
}

\infrule[Type]{
\Gamma \vdash \Xcd{class(C)}
\andalso
\Gamma, \Xcd{self} \ty \Xcd{C} \vdash \Xcd{c} \ty \Xcd{o}
}{
\Gamma \vdash \Xcd{C\{c\}} \ty \Xcd{type}
}

\caption{Well-formedness rules}
\label{fig:wf}
\end{figure}


\subsection{Subtyping constraints}


\begin{figure}

\infrule[Cons-eq]{
\xbar{c} \vdashC \Xcd{T}_1 \equals \Xcd{T}_2
}{
\xbar{c} \vdashC
\Xcd{cons(}\Xcd{T}_1\Xcd{,z)} \equals 
\Xcd{cons(}\Xcd{T}_2\Xcd{,z)} 
}

\infrule[Cons-sub]{
\xbar{c} \vdashC \Xcd{T}_1 \subtype \Xcd{T}_2
}{
\xbar{c},
\Xcd{cons(}\Xcd{T}_1\Xcd{,z)} \vdashC 
\Xcd{cons(}\Xcd{T}_2\Xcd{,z)} 
}

\infax[Cons]{
\vdashC \Xcd{cons(C,z)}
}

\infrule[Eq-atom]
{ \xbar{c} \vdashC \xbar{s} \equals \xbar{t} }
{ \xbar{c} \vdashC \Xcd{f(}\xbar{s}\Xcd{)} \equals \Xcd{f(}\xbar{t}\Xcd{)} }

% \infrule[Eq-field]{ \xbar{c} \vdashC \Xcd{t}_1 \equals \Xcd{t}_2 }
                  % { \xbar{c} \vdashC \Xcd{t}_1.\Xcd{f} \equals \Xcd{t}_2.\Xcd{f} }
% \infrule[Eq-type]{ \xbar{c} \vdashC \Xcd{t}_1 \equals \Xcd{t}_2 }
                  % { \xbar{c} \vdashC \Xcd{t}_1.\Xcd{X} \equals \Xcd{t}_2.\Xcd{X} }

\infax[Eq-refl]{ \xbar{c} \vdashC \Xcd{t} \equals \Xcd{t} }

\infrule[Eq-trans]{
        \xbar{c} \vdashC \Xcd{t}_1 \equals \Xcd{t}_2
        \andalso
        \xbar{c} \vdashC \Xcd{t}_2 \equals \Xcd{t}_3
        }
        { \xbar{c} \vdashC \Xcd{t}_1 \equals \Xcd{t}_3 }

\infrule[Eq-sym]{
        \xbar{c} \vdashC \Xcd{t}_1 \equals \Xcd{t}_2
        }
        { \xbar{c} \vdashC \Xcd{t}_2 \equals \Xcd{t}_1 }

\infrule[Eq-sub]{
\xbar{c} \vdashC \Xcd{T}_1 \subtype \Xcd{T}_2 \\
\xbar{c} \vdashC \Xcd{T}_2 \subtype \Xcd{T}_1
}{
\xbar{c} \vdashC \Xcd{T}_1 \equals \Xcd{T}_2
}

\infrule[Sub-cons]{
\xbar{c} \vdashC \Xcd{C\{c\}} \ty \Xcd{type}
\andalso
\xbar{c}, \Xcd{c} \vdashC \Xcd{d}
}{
\xbar{c} \vdashC \Xcd{C\{c\}} \subtype \Xcd{C\{d\}}
}

\infrule[Sub-super]{
\mbox{\Xcdmath{C[$\tbar{X}$]($\tbar{x}$: $\tbar{T}$)\{c\} ext T \{\ K\ $\tbar{M}$\ $\tbar{F}$\ \}}}
}{
\vdashC \Xcd{C} \subtype \Xcd{T} \\
}

\infax[Sub-object]{
\vdashC \Xcd{T} \subtype \Xcd{Object}
}

\infrule[Sub-eq]{
\xbar{c} \vdashC \Xcd{T}_1 \equals \Xcd{T}_2
}{
\xbar{c} \vdashC \Xcd{T}_1 \subtype \Xcd{T}_2
}

\infrule[Sub-trans]{
\xbar{c} \vdashC \Xcd{T}_1 \subtype \Xcd{T}_2
\andalso
\xbar{c} \vdashC \Xcd{T}_2 \subtype \Xcd{T}_3
}{
\xbar{c} \vdashC \Xcd{T}_1 \subtype \Xcd{T}_3
}

\caption{Equality and subtyping rules}
\label{fig:subtyping}
\end{figure}



\subsection{
Constraint projection
}

First, for a type environment $\Gamma$,
we define the \emph{constraint projection},
$\sigma(\Gamma)$ thus:

\begin{align*}
\sigma(\epsilon) &= \Xcd{true} \\
\sigma(\Gamma, \Xcd{x} \ty \Xcd{T}) &=
        \sigma(\Gamma),
        \cons{\Xcd{T}}{\Xcd{x}}
\\
\sigma(\Gamma, \Xcd{c}) &= \sigma(\Gamma), \Xcd{c} \\
\end{align*}

The auxiliary function $\mathit{cons}$
specifies the constraint for a type \Xcd{T} with \Xcd{self}
bounds to \Xcd{x}.
The constraint projection uses an atomic formula \Xcd{cons},
which is equated to the constraint of \Xcd{T} if \Xcd{T} is not
a type variable.

\begin{align*}
\cons{\Xcd{C}}{\Xcd{z}} &=
    \Xcd{cons(C,z)} \\
\cons{\Xcd{C\{c\}}}{\Xcd{z}} &=
    \Xcd{c}[\Xcd{z}/\Xcd{self}], \Xcd{cons(C\{c\},z)==c}[\Xcd{z}/\Xcd{self}] \\
\cons{\Xcd{p.X}}{\Xcd{z}} &=
    \Xcd{cons(p.X,z)} \\
\cons{\Xcd{X}}{\Xcd{z}} &=
    \Xcd{cons(X,z)} \\
\end{align*}

\noindent
Thus, for example, the constraint projection of the environment:
\begin{quote}
\xcdmath"b: D, a: C{self.X==D{d},self.Y<:b.Z}"
\end{quote}
\noindent is:
\begin{quote}
\xcdmath"a.X==D{d}, a.Y<:b.Z" \\
\end{quote}

\eat{
\subsection{
        Judgments
}

The following judgments will be defined:

\begin{itemize}
\item
     The type {\tt T} is well-formed, given the assumptions $\Gamma$:

    $\Gamma \vdash {\tt T} \ty {\tt type}$

\item
     The type {\tt S} is a subtype of {\tt T}, under the assumption $\Gamma$:

      $\Gamma \vdash {\tt S} \subtype {\tt T}$

    \item The expression {\tt e} is of type {\tt T}, given the assumptions $\Gamma$:

      $\Gamma \vdash {\tt e} \ty {\tt T}$

    \item The method {\tt M} is well-defined for the class {\tt C}
given assumptions $\Gamma$:

      $\Gamma \vdash {\tt M}~\mbox{OK in}~{\tt C}$

    \item The field {\tt f: T} is well defined for the class {\tt C} given assumptions $\Gamma$:

      $\Gamma \vdash {\tt f: T}~\mbox{OK in}~C$

    \item The class definition {\tt L} is well defined given assumptions $\Gamma$:

      $\Gamma \vdash {\tt L}~\mbox{OK}$

\end{itemize}


In what follows we will sometimes think of the family of five
judgments
as a single judgment $\Gamma \vdash \phi$ where $\phi$ ranges over the
formulas 
    ${\tt T} \ty {\tt type}$,
      ${\tt S} \subtype {\tt T}$,
      ${\tt e} \ty {\tt T}$,
      ${\tt M}~\mbox{OK in}~{\tt C}$,
      ${\tt f: T}~\mbox{OK in}~C$, and
      ${\tt L}~\mbox{OK}$.


Now, these judgments need to satisfy certain properties:

\begin{enumerate}

\item
    $\Gamma \vdash {\tt T} \ty {\tt type}$
whenever 
      $\Gamma \vdash {\tt e} \ty {\tt T}$; that is,
if we can conclude that {\tt e}
      has type {\tt T} (under certain assumptions), then under those
      assumptions we must be able to conclude that {\tt T} is well-defined.

\item
    $\Gamma \vdash {\tt S} \ty {\tt type}$ and
    $\Gamma \vdash {\tt T} \ty {\tt type}$ whenever
      $\Gamma \vdash {\tt S} \subtype {\tt T}$.

\item
If 
      $\Gamma \vdash {\tt e} \ty {\tt T}$ and if {\tt x}
is a variable occurring free in ${\tt e} \ty {\tt T}$, then for some
      type {\tt U},
      $\Gamma \vdash {\tt x} \ty {\tt U}$.
That is, all free variables on the right-hand
      side of the judgment are actually defined on the left-hand side.
\end{enumerate}


Keeping in mind these requirements, the rules are as follows. Below,
whenever we use the assertion ``{\tt x} free'' in the antecedent of
a rule we mean
that {\tt x} is not free in the consequent of the rule.


\subsection{
      Structural and Logical Rules
}


First, we present the structural rules for $\vdash$. The
judgment
$\Gamma\vdash {\tt e} \ty {\tt T}$ is
intuitionistic. That is, $\Gamma$ is considered a multiset of assertions, and
the judgment possesses the inference rules:

\infrule{
\Gamma \vdash {\tt e} \ty {\tt T}
\andalso
\Gamma \vdash {\tt S} \ty {\tt type}
\andalso
    \mbox{{\tt x} not in $\mathit{var}(\Gamma)$}
}{
\Gamma, {\tt x} \ty {\tt S} \vdash {\tt e} \ty {\tt T}
}



\infrule{
\Gamma \vdash {\tt e} \ty {\tt T}
\andalso
\Gamma \vdash {\tt c} \ty {\tt boolean}
}{
\Gamma, {\tt c} \vdash {\tt e} \ty {\tt T}
}


We also assume the following rule for conjunctions on the left and right:

\infrule{
\Gamma, \phi_1 , \phi_2 \vdash \phi
}{
\Gamma, (\phi_1 , \phi_2 ) \vdash \phi
}


\infrule{
\Gamma \vdash \phi_1 
\andalso
     \Gamma \vdash \phi_2  
}{
\Gamma \vdash (\phi_1 , \phi_2 )
}



Existential quantification is governed by the following standard rules,
specialized for the particular kinds of formulas we are dealing with:


\infrule{
\Gamma \vdash {\tt e} \ty {\tt T}[{\tt t}/{\tt x}]
\andalso
\Gamma \vdash {\tt t} \ty {\tt S}
}{
\Gamma \vdash {\tt e} \ty ({\tt x} \ty {\tt S};~{\tt T})
}


\infrule{
\Gamma, {\tt x} \ty {\tt S}, {\tt c} \vdash {\tt e} \ty {\tt T}
\andalso
\mbox{{\tt x} fresh}
}{
\Gamma, ({\tt x} \ty {\tt S};~{\tt c}) \vdash {\tt e} \ty {\tt T}
}


\infrule{
\Gamma, {\tt x} \ty {\tt S}, {\tt y} \ty \Xcd{C\{c\}} \vdash {\tt e} \ty {\tt T}
\andalso
\mbox{{\tt x} fresh}
}{
\Gamma, {\tt y} \ty \Xcd{C\{x:S; c\}} \vdash {\tt e} \ty {\tt T}
}

}

\subsection{
Type well-formedness
}

\begin{figure}

\infrule{
\mbox{\Xcdmath{C[$\tbar{X}$]($\tbar{x}$: $\tbar{T}$)\{c\} ext T \{\ $\tbar{M}$\ $\tbar{F}$\ \}}}
}{
\vdash \Xcd{C} \ty \Xcd{type}
}

\infrule{
\Gamma \vdash \Xcd{T} \ty \Xcd{type}
\andalso
\Gamma, \Xcd{self} \ty \Xcd{T} \vdash \Xcd{c} \ty \Xcd{Boolean}
\andalso
\sigma(\Gamma) \vdashC \Xcd{c}~\mbox{OK}
}{
\Gamma \vdash \Xcd{T\{c\}} \ty \Xcd{type}
}

\infrule{
\Gamma \vdash \Xcd{p} \ty \Xcd{T}
\andalso
\Gamma \vdash \Xcd{T}~\Xcd{has}~\Xcd{X}
}{
\Gamma \vdash \Xcd{p.X} \ty \Xcd{type}
}

\infax{
\Gamma, \Xcd{X} \ty \Xcd{type} \vdash \Xcd{X} \ty \Xcd{type}
}

\caption{Type well-formedness}
\label{fig:type-wf}
\end{figure}

\subsection{
      Type inference rules
}

\subsubsection{Constraint rules}

\begin{figure}

\infrule[Has-class]{
\mbox{\Xcdmath{C[$\tbar{X}$]($\tbar{x}$: $\tbar{T}$)\{c\} ext T \{\ K\ $\tbar{M}$\ $\tbar{F}$\ \}}}
}{
\vdash {\tt C}~{\tt has}~{\tt K} \\
\vdash {\tt C}~{\tt has}~{\tt X}_i \\
\vdash {\tt C}~{\tt has}~{\tt x}_i \ty {\tt T}_i \\
\vdash {\tt C}~{\tt has}~{\tt M}_i \\
\vdash {\tt C}~{\tt has}~{\tt F}_i
}

\infrule[Has-sub]{
{\tt Z} \not= {\tt K}
\andalso
\Gamma \vdash {\tt T}_1~{\tt has}~{\tt Z}
\andalso
\sigma(\Gamma) \vdash {\tt T}_2 \subtype {\tt T}_1
}{
\Gamma \vdash {\tt T}_2~{\tt has}~{\tt Z}
}

\caption{Structural constraints}
\label{fig:structural}
\end{figure}

\subsubsection{
        Expression typing judgment
}

\eat{
We define \Xcd{T\{c\}} as follows:

\begin{align*}
\Xcd{D\{c\}} &= \Xcd{D\{c\}} \\
\Xcd{D\{d\}\{c\}} &= \Xcd{D\{d,c\}} \\
\Xcd{X\{c\}} &= \Xcd{X\{c\}} \\
\Xcd{p.X\{c\}} &= \Xcd{p.X\{c\}} \\
\end{align*}

\begin{align*}
\exists\Xcd{x}\ty \Xcd{S}.~\Xcd{C} &= \Xcd{C} \\
\exists\Xcd{x}\ty \Xcd{S}.~\Xcd{C\{c\}} &=
        \Xcd{C\{}\exists\Xcd{x}.~\sigma(\Xcd{x}\ty \Xcd{S})\Xcd{,c\}} \\
\exists\Xcd{x}\ty \Xcd{S}.~\Xcd{p.X} &=
        \Xcd{p.X\{}\exists\Xcd{x}.~\sigma(\Xcd{x}\ty \Xcd{S})\Xcd{,c\}} \\
\exists\Xcd{x}\ty \Xcd{S}.~\Xcd{X} &=
        \Xcd{X\{}\exists\Xcd{x}.~\sigma(\Xcd{x}\ty \Xcd{S})\Xcd{,c\}} \\
\end{align*}
}

\begin{figure}

\infrule[T-sub]{
\Gamma \vdash \Xcd{e} \ty \Xcd{S}
\andalso
\sigma(\Gamma) \vdashC \Xcd{S} \subtype \Xcd{T}
\andalso
\Gamma \vdash \Xcd{T} \ty \Xcd{type}
}{
\Gamma \vdash \Xcd{e} \ty \Xcd{T}
}

\infax[T-bool]{
\vdash \Xcd{true} \ty \Xcd{Boolean\{self==true\}} \\
\vdash \Xcd{false} \ty \Xcd{Boolean\{self==false\}}
}

\infax[T-int]{
\vdash n \ty \Xcd{Int\{self==}n\Xcd{\}}
}

\infrule[T-eq]{
\Gamma \vdash \Xcd{e}_1 \ty \Xcd{T}_1
\andalso
\Gamma \vdash \Xcd{e}_2 \ty \Xcd{T}_2
}{
\Gamma \vdash \Xcd{e}_1 \equals \Xcd{e}_2 \ty
        \extyty{\Xcd{z}_1}{\Xcd{T}_1}{\Xcd{z}_2}{\Xcd{T}_2}
        {\Xcd{Boolean\{self==(}{\Xcd{z}_1}\equals{\Xcd{z}_2}\Xcd{)\}}}
}

\infrule[T-teq]{
\Gamma \vdash \Xcd{T}_1 \ty \Xcd{type}
\andalso
\Gamma \vdash \Xcd{T}_2 \ty \Xcd{type}
}{
\Gamma \vdash \Xcd{T}_1 \equals \Xcd{T}_2 \ty \Xcd{Boolean}
}

\infrule[T-tsub]{
\Gamma \vdash \Xcd{T}_1 \ty \Xcd{type}
\andalso
\Gamma \vdash \Xcd{T}_2 \ty \Xcd{type}
}{
\Gamma \vdash \Xcd{T}_1 \subtype \Xcd{T}_2 \ty \Xcd{Boolean}
}

\infax[T-var]{
\Gamma, \Xcd{x} \ty \Xcd{T} \vdash \Xcd{x} \ty \Xcd{T}
}

\infrule[T-cast]{
\Gamma \vdash \Xcd{e} \ty \Xcd{S}
\andalso
\Gamma \vdash \Xcd{T} \ty \Xcd{type}
}{
\Gamma \vdash \Xcd{e}~\Xcd{as}~\Xcd{T} \ty \Xcd{T}
}

\infrule[T-field]{
\Gamma \vdash \Xcd{e} \ty \Xcd{T}
%\\
%\Xcd{T} = \exty{\Xcd{z}}{\Xcd{S}}{\Xcd{S\{self==z\}}}
\\
\Xcd{T}~\Xcd{has}~\Xcd{f}\Xcd{\{c\}} \ty \Xcd{U}
\\
\sigma(\Gamma, \Xcd{this} \ty \Xcd{T}) \vdashC \Xcd{c}
}{
\Gamma \vdash \Xcd{e}.\Xcd{f} \ty \exty{\Xcd{this}}{\Xcd{T}}{\Xcd{U\{self==this.f\}}}
}

\infrule[T-invk]{
\Gamma \vdash \Xcd{e}_0 \ty \Xcd{T}_0
\andalso
\Gamma \vdash \xbar{e} \ty \xbar{T}
\\
\Xcd{T}_0~\Xcd{has}~\Xcd{def}~\Xcd{m[}\xbar{X}\Xcd{](}\xbar{x} \ty \xbar{S}\Xcd{)\{c\}} \ty {\tt U}~\Xcd{=}~\Xcd{e}
\\
\Gamma' = \Gamma, \xbar{X} \ty \Xcd{type},
        \Xcd{this} \ty \Xcd{T}_0,
        \xbar{x} \ty \xbar{T},
        \xbar{X} \equals \xbar{V}
\\
\sigma(\Gamma') \vdashC \Xcd{c}
\\
\sigma(\Gamma') \vdashC \xbar{T} \subtype \xbar{S}
}{
\Gamma \vdash
\Xcd{e}_0.\Xcd{m[}\xbar{V}\Xcd{](}\xbar{e}\Xcd{)} \ty
\extytyty{\xbar{X}}{\Xcd{type}}{\Xcd{this}}{\Xcd{T}_0}{\xbar{x}}{\xbar{T}}{\Xcd{U}}
}

\infrule[T-new]{
\Gamma \vdash \xbar{e} \ty \xbar{T}
\\
\Xcd{C}~\Xcd{has}~\Xcd{def}~\Xcd{this[}\xbar{X}\Xcd{](}\xbar{x} \ty \xbar{S}\Xcd{)\{c\}} \ty {\tt U}~\Xcd{=}~\dots
\\
\Gamma' = \Gamma, \xbar{X} \ty \Xcd{type}, \Xcd{this} \ty \Xcd{C}, \xbar{x} \ty \xbar{T}, \xbar{V} \equals \xbar{X}
\\
\Gamma'' = \Gamma, \xbar{X} \ty \Xcd{type}, \Xcd{this} \ty \Xcd{U}, \xbar{x} \ty \xbar{T}, \xbar{V} \equals \xbar{X}
\\
\sigma(\Gamma') \vdashC \Xcd{c}
\\
\sigma(\Gamma') \vdashC \xbar{T} \subtype \xbar{S}
\\
\sigma(\Gamma'') \vdashC \mathit{inv}(\Xcd{C}),
}{
\Gamma \vdash
\Xcd{new}~\Xcd{C[}\xbar{V}\Xcd{](}\xbar{e}\Xcd{)} \ty
\extytyty{\xbar{X}}{\Xcd{type}}{\Xcd{this}}{\Xcd{C}}{\xbar{x}}{\xbar{T}}{\Xcd{U}}
}

\caption{Typing rules}
\label{fig:typing}
\end{figure}

The cast rule
\rn{T-cast}
requires that the cast type be well-formed. 

The field access rule \rn{T-field}
differs from the rule in the paper in that there is no need to
substitute a fresh variable for the receiver. Note that {\tt this} may be free
in {\tt S}---that would be a reference to the current object in the code in
which {\tt e.f} occurs, not a reference to the receiver of the {\tt e.f} field
selection (i.e., the object obtained by evaluating {\tt e}).

\noindent
if we allow adding constraints to arbitrary types---do we?

TODO: type parameters!

Now we consider the rule for method invocation. Assume that in a type
environment $\Gamma$ the expressions ${\tt e_0}, \dots, {\tt e_n}$
have the types ${\tt T_0}, \dots, {\tt T_n}$.
Since the
actual values of these expressions are not known, we shall assume that
they take on some fixed but unknown values
                                     ${\tt z_0}, \dots, {\tt z_n}$
of types ${\tt T_0}, \dots, {\tt T_n}$.
Now, for ${\tt z_0}$ as receiver, let us assume that the type
${\tt T_0}$ has a method named ${\tt m}$
with signature
$[\xbar{Z}](\xbar{z} \ty \xbar{S})\Xcd{\{c\}} \to {\tt U}$
(Let ${\tt T_0} = \Xcd{C\{d\}}$.
 If there is no
method named {\tt m} for the class {\tt C} then this method invocation cannot be
type-checked. Without loss of generality, we may assume that the
type parameters of this method are named
                                     ${\tt Z_1}, \dots, {\tt Z_k}$, and
the value parameters are named
                                     ${\tt z_1}, \dots, {\tt z_n}$
since we are free to choose
variable names as we wish.)
Now, for the method to be invokable,
it must be the case that the types
    ${\tt T_1}, \dots, {\tt T_n}$
are subtypes of
    ${\tt S_1}, \dots, {\tt S_n}$.
(Note
that there may be no occurrences of {\tt this} in
    ${\tt S_1}, \dots, {\tt S_n}$---they have been
replaced by ${\tt z_0}$.)
Further, it must be the case that for these parameter
values, the constraint {\tt c} is entailed. Given all these assumptions it
must be the case that the return type is {\tt U}, with all the parameters
    ${\tt z_0}, \dots, {\tt z_n}$
existentially quantified.


\subsubsection{
        Class OK judgment
}

The following rule is modified from what we had in the paper to ensure
that all the types are well-formed (under the assumption {\tt this} \ty {\tt C}).
Note
that the variables $\xbar{x}$ are permitted to occur in the types $\Xcd{T}_0, \xbar{T}$,
hence their typing assertions must be added to $\Gamma$.

\infrule[Method OK]{
\Gamma = \Xcd{this} \ty \Xcd{C\{self==this},\mathit{inv}(\Xcd{C})\Xcd{\}},
        \xbar{x} \ty \xbar{T}\Xcd{\{self==\}}\xbar{x}\Xcd{\}},
        \Xcd{c}
\\
\Gamma \vdash \Xcd{e} \ty \Xcd{U}
\\
\sigma(\Gamma) \vdashC \Xcd{U} \subtype \Xcd{T}
}{
\Xcd{def}~\Xcd{m[}\xbar{X}\Xcd{](}\xbar{x} \ty
\xbar{T}\Xcd{)\{c\}} \ty \Xcd{T}~\Xcd{=}~\Xcd{e}~\mbox{OK in}~\Xcd{C}
}


This rule did not exist in our submission. This is necessary to ensure
that the types of fields are well-formed.

\infrule[Field OK]{
\Xcd{this} \ty \Xcd{C}, \Xcd{c} \vdash \Xcd{T} \ty \Xcd{type}
}{
\Xcd{val}~\Xcd{f}\Xcd{\{c\}} \ty \Xcd{T}~\mbox{OK in}~\Xcd{C}
}


This rule is now modified to ensure that all the types and methods in
the body of the class are well-formed.

\infrule[Class OK]{
K~\mbox{OK in}~{\tt C}
\\
\xbar{M}~\mbox{OK in}~{\tt C}
\\
\xbar{F}~\mbox{OK in}~{\tt C}
\\
{\tt this} \ty {\tt C} \vdash {\tt T} \ty {\tt type}
}{
\mbox{\Xcdmath{C[$\tbar{X}$]($\tbar{x}$: $\tbar{T}$)\{c\} ext T \{\ K\ $\tbar{M}$\ $\tbar{F}$\ \}}}~\mbox{OK}
}

TODO: method overriding


\subsubsection{
        Subtype judgment
}

\infrule{
\sigma(\Gamma) \vdash_{\cal C} {\tt T_1} \subtype {\tt T_2}
}{
\Gamma \vdash {\tt T_1} \subtype {\tt T_2}
}



\section{Constraint solver}
\label{sec:solver}

The goal of the constraint solver is 
to check an assertion $\xbar{c} \vdashC \Xcd{d}$.

\eat{
Inference

The first step is to normalize constraints
into a set of constraint judgments
$\xbar{c} \vdashC \Xcd{c}$ where $\Xcd{c}$ contains no conjunctions.


Once in normalized form, the inference proceeds as follows:
Select a constraint $\xbar{c} \vdashC \Xcd{c}$.
If not consistent, fail.
If valid, ok.
If not valid, generate assignment of variables that makes it
true, adding the assignment to the assumptions for all
constraints.

The inference algorithm must specify the criteria for:
\begin{itemize}
\item selecting the next constraint to solve
\item generating the variable assignment consistent with all
other constraints (to avoid backtracking)
\end{itemize}

Pick an unassigned variable, find weakest assignment that makes just
this clause true.  Does the weakest assignment exist?

Question: can we ensure each clause involves only one or two
unknowns?
}

We add the following rules to allow type arguments to calls to
be omitted.

\infrule[T-invk-inferred]{
\xbar{Y}~\mbox{fresh}
\\
\Gamma, \xbar{Y} \ty {\tt type}
\vdash
\Xcd{e}_0.\Xcd{m[}\xbar{Y}\Xcd{](}\xbar{e}\Xcd{)} \ty
\Xcd{T}
}{
\Gamma \vdash
\Xcd{e}_0.\Xcd{m(}\xbar{e}\Xcd{)} \ty
\Xcd{T}
}

\infrule[T-new-inferred]{
\xbar{Y}~\mbox{fresh}
\\
\Gamma, \xbar{Y} \ty {\tt type}
\vdash
\Xcd{new}~\Xcd{C[}\xbar{Y}\Xcd{](}\xbar{e}\Xcd{)} \ty
\Xcd{T}
}{
\Gamma \vdash
\Xcd{new}~\Xcd{C(}\xbar{e}\Xcd{)} \ty
\Xcd{T}
}

\subsection{Constraint representation}

%\newcommand\eqedge{\rightleftharpoons}
\newcommand\eqedge{\sim}
\newcommand\flowedge{\to}
\newcommand\treeedge[1]{\mapsto_{#1}}
\newcommand\typeedge{\mapsto_{\tt type}}

Represent a constraint as a graph $G$.
Each node represents a constraint term for a value or a type.
The node for a path $p$ is written $v_p$;
the node for a type $T$ is written $V_T$.
There are four kinds of edges:
\begin{enumerate}
\item undirected equivalence edges,
        $v_p \eqedge v_q$ and $V_S \eqedge V_T$,
\item type edges, $v_p \typeedge V_T$,
\item tree edges, $v_p \treeedge{f} v_{p.f}$
              and $v_p \treeedge{X} V_{p.X}$, and
\item flow edges, $V_S \flowedge V_T$.
\end{enumerate}

First, each constraint term is mapped to a node in the graph as
follows.
Associate each term $t$ with a node
$v_t$.  For each access path {\tt p.x}, add a tree edge
$v_{{\tt p}} \treeedge{{\tt x}} v_{{\tt p.x}}$.
For each path type {\tt p.X}, add a tree edge
$v_{{\tt p}} \treeedge{{\tt X}} V_{{\tt p.X}}$.
For each atomic formula ${\tt f}(\xbar{t})$, add the tree edge
$v_{{\tt f}(\xbar{t})} \treeedge{i} v_{t_i}$ for all $i$.
If term $t$ has type $T$, add $v_t \typeedge V_{t{\tt .type}}$
and
add $V_T \eqedge V_{t{\tt .type}}$ to $G$.

Type nodes are sets of classes.

Next, constraints are incorporated into the graph:

\begin{itemize}
\item
For constraint {\tt p==q}, add $v_{\tt p} \eqedge v_{\tt q}$ to $G$.

\item
For constraint {\tt S==T}, add $V_{\tt S} \eqedge V_{\tt T}$ to $G$.

\item
For constraint {\tt S<:T},
add $V_{\tt S} \flowedge V_{\tt T}$
to $G$.

\end{itemize}

\subsection{Solving}

A flow-path is a path that follows flow and equivalence edges
only.
A type-path is a path that follows type and equivalence edges
only.

Now, we saturate: 
If there is a type-path $v_t \typeedge^* V_{\tt C\{c\}}$,
add $c[t/\Xcd{self}]$ to the worklist.

        Can saturate lazily when doing a lookup.
        EXCEPT: a type may have an arbitrary constraint
                \xcd"C{self.x==3 && y > 7}", so affect is non-local
        EXCEPT: c is x.f==...
                with x: C{c}
                need to avoid infinite loop

To check:

\begin{itemize}
\item To check
constraint {\tt p==q}, check if $v_{\tt p} \eqedge^* v_{\tt q}$.
\item To check
constraint {\tt S<:T}, check if there is a flow-path from $V_{\tt S}$ to
$V_{\tt T}$.  This requires checking entailment of the type constraints and
adding more edges to the graph.  (XXX details!)
Add the flow edge to memoize.
\end{itemize}

\section{Translation}
\label{sec:translation}

This section describes an implementation approach for
generic constrained types on a Java virtual machine.
We describe the implementation as a translation to Java.

The design
is a hybrid design based on the implementation of parametrized classes in
NextGen~\cite{allen03,allen04} and the implementation of
PolyJ~\cite{polyj}.
Generic classes are translated into template classes
that are instantiated on demand at run time by binding the type properties
to concrete types.  To implement run-time type checking (e.g.,
casts), type properties are represented at run time
using \emph{adapter objects}.

This design, extended to handle language features
not described in this paper, has been implemented in the X10
compiler.  The X10 compiler is built on the Polyglot framework
and translates X10 source to Java source\footnote{There is also
a translation from X10 to C++ source, not described here.}

\subsection{Classes}

Each class is translated into a \emph{template class}.
The template class is compiled by a Java compiler (e.g., javac)
to produce a class file.
At run time, when a constrained type \xcd"C{c}" is first referenced, a
class loader loads the template class for \xcd"C" and then transforms the
template class bytecode, specializing it to the constraint
\xcd"c".

For example, consider the following classes.
\begin{xten}
class A[T] {
    var a: T;
}
class C {
    val x: A[Int] = new A[Int]();
    val y: Int = x.a;
}
\end{xten}

The compiler generates the following code:
\begin{xten}
class A {
    // Dummy class needed to type-check uses of T.
    @TypeProperty(1) static class T { }

    T a;

    // Dummy getter and setter; will be eliminated
    // at run time and replaced with actual gets
    // and sets of the field a.
    @Getter("a") <S> S get$a() { return null; }
    @Setter("a") <S> S set$a(S v) { return null; }
}

class C {
    @ActualType("A$Int")
    final A x = Runtime.<A>alloc("A$Int");
    final int y = x.<Integer>get$a();
}
\end{xten}

The member class \xcd"A.T" is used in place of the
type property \xcd"T". 
The \xcd"Runtime.alloc" method is used
used in place of a constructor call.
This code is compiled to Java bytecode.


Then, at run time, suppose the expression \xcd"new C()" is
evaluated.  This causes \xcd"C" to be loaded.
The class loader transforms the bytecode as if it had
been written as follows:

\begin{xten}
class C {
    final A$Int x = new A$Int();
    final int y = x.a;
}
\end{xten}

The \xcd"ActualType" annotation is used to change the
type of the field \xcd"x" from \xcd"A" to \xcd"A$Int".
The call to \xcd"Runtime.alloc" is replaced with a
constructor call.  The call to \xcd"x.get$a()" is
replaced with a field access.

The implementation cannot generate this code directly because
the class \xcd"A$Int" does not yet exist; the Java source compiler
would fail to compile \xcd"C".

Next, as the \xcd"C" object is being constructed, the expression
\xcd"new A$Int()" is evaluated, causing the class \xcd"A$Int" to
be loaded.  The class loader intercepts
this, demangles the name, and loads the bytecode for the
template class \xcd"A".

The bytecode is transformed, replacing the type property \xcd"T"
with the concrete type \xcd"int", the translation of \xcd"Int".

\begin{xten}
class A {
    x10.runtime.Type T;
}

class A$Int extends A {
    int x;
}
\end{xten}

Type properties are mapped to the Java primitive types and to
Object.  Only nine possible instantiations per parameter.
Instantiations used for representation.
Adapter objects used for run time type information.

Could do instantiation eagerly, but quickly gets out of hand without
whole-program analysis to limit the number of instantiations: 9
instantiations for one type property, 81 for two type
properties, 729 for three.

Value constraints are erased from type references.

Constructors are translated to static methods of their enclosing
class.
Constructor calls
are translated to calls to static methods.


Consider the code in Figure~\ref{fig:translation1}.  It contains most of the
features of generics that have to be translated.
\begin{figure*}[tp]
\begin{xten}
class C[T] {
    var x: T;
    def this[T](x: T) { this.x = x; }
    def set(x: T) { this.x = x; }
    def get(): T { return this.x; }
    def map[S](f: T => S): S { return f(this.x); }
    def d() { return new D[T](); }
    def t() { return new T(); }
    def isa(y: Object): boolean { return y instanceof T; }
}

val x : C = new C[String]();
val y : C[int] = new C[int]();
val z : C{T <: Array} = new C[Array[int]]();
x.map[int](f);
new C[int{self==3}]() instanceof C[int{self<4}];
\end{xten}
\caption{Code to translate}
\label{fig:translation1}
\end{figure*}

\subsection{Eliminating method type parameters}

\subsection{Translation to Java}

\subsection{Run-time instantiation}

We translate \xcd"instanceof" and cast operations to calls to
methods of a \xcd"Type" because the actual implementation of
the operation may require run-time constraint solving or other
complex code that cannot be easily substituted in when rewriting
the bytecode during instantiation.

\section{Discussion}
\label{sec:discussion}

\todo{Move some of this to Section~\ref{sec:related}}

\subsection{Type properties versus type parameters}


Type properties are similar, but not identical to type parameters.  The
differences may potentially confuse programmers used to Java generics or C++
templates.  The key difference is that type properties are instance members and
are thus accessible through access paths: \xcd"e.T" is a legal type.

Type properties, unlike type parameters, are inherited.
For example, in the following code, \xcd"T" is defined in \xcd"List"
and inherited into \xcd"Cons".  The property need not be
declared by the \xcd"Cons" class.
\begin{xten}
class List[T] { }
class Cons extends List {
    def head(): T = { ... }
    def tail(): List[T] = { ... }
}
\end{xten}
The analogous code for \xcd"Cons" using type parameters would be:
\begin{xten}
class Cons[T] extends List[T] {
    def head(): T = { ... }
    def tail(): List[T] = { ... }
}
\end{xten}
% This code is perfectly acceptable in X10 as well, but introduces a redundant
% type property \xcd"T" equal to the \xcd"T" inherited from \xcd"List".

We can make the type system behave as if type properties were
type parameters very simply.  We need only make the syntax \xcd"e.T"
illegal and permit type properties to be accessible only
from within the body of their class definition via the implicit \xcd"this"
qualifier.

\subsection{Wildcards}

Wildcards in Java~\cite{Java3,adding-wildcards} were motivated
by the following example (rewritten in X10 syntax)
from \cite{adding-wildcards}.
Sometimes a class needs a field or method
that is a list, but we don't care what the element type is.
For methods, one can give the method a type parameter:
\begin{xten}
def aMethod[T](list: List[T]) = { ... }
\end{xten}
This method can then be called on any \xcd"List" object.
However, there is no way to do this for fields since they
cannot be parametrized.
Java introduced wildcards to allow such fields to be
typed:
\begin{xten}
List<?> list;
\end{xten}
In X10, a similar effect is achieved by not constraining the
type property of \xcd"List".
One can write the following:
\begin{xten}
list: List;
\end{xten}
Similarly, the method can be written without type parameters by
not constraining \xcd"List":
\begin{xten}
def aMethod(list: List) = { ... }
\end{xten}

In X10, \xcd"List"
is a supertype of
\xcd"List[T]" for any \xcd"T",
just as in Java
\xcd"List<?>" is a supertype of
\xcd"List<T>" for any \xcd"T".
This follows directly from the definition of the type \xcd"List"
as \xcd"List{true}", and the type \xcd"List[T]"
as \xcd"List{X==T}", and the definition of subtyping.

Wildcards in Java can also be bounded.
We achieve the same
effect in X10 by using type constraints.
For instance, the following Java declarations:
\begin{xten}
void aMethod(List<? extends Number> list) { ... }
<T extends Number> void aParameterizedMethod(List<T> list) { ... }
\end{xten}
may be written as follows in X10:
\begin{xten}
def aMethod(list: List{T <: Number}) = { ... }
def aParameterizedMethod[T{self <: Number}](list: List[T]) = { ... }
\end{xten}

Wildcard bounds may be covariant, as in the following example:
\begin{xten}
List<? extends Number> list = new ArrayList<Integer>();
Number num = list.get(0);     // legal
list.set(0, new Double(0.0)); // illegal
list.set(0, list.get(1));     // illegal
\end{xten}
This can also be written in X10, but with an important
difference:
\begin{xten}
list: List{T <: Number} = new ArrayList[Integer]();
num: Number = list.get(0);    // legal
list.set(0, new Double(0.0)); // illegal
list.set(0, list.get(1));     // legal! (when list is final)
\end{xten}
Note because \xcd"list.get" has return type \xcd"list.T", the
last call in above is well-typed in X10; the analogous call in
Java is not well-typed.

Finally,
one can also specify lower bounds on types.  These are useful for
comparators:
\begin{xten}
class TreeSet[T] {
    def this[T](cmp: Comparator{T :> this.T}) { ... }
}
\end{xten}
Here, the comparator for any supertype of \xcd"T" can be used as
to compare \xcd"TreeSet" elements.

Another use of lower bounds is for list operations.
The \xcd"map" method below takes a function that maps a supertype
of the class parameter \xcd"T" to the method type parameter \xcd"S":
\begin{xten}
class List[T] {
    def map[S](fun: Object{self :> T} => S) : List[S] = { ... }
}
\end{xten}

\subsection{Proper abstraction}

Consider the following example adapted from \cite{adding-wildcards}:
\begin{xten}
def shuffle[T](list: List[T]) = {
    for (i: int in [0..list.size()-1]) {
        val xi: T = list(i);
        val j: int = Math.random(list.size());
        list(i) = list(j);
        list(j) = xi;
    }
}
\end{xten}
The method is parametrized on \xcd"T" because the method body needs
the element type to declare the variable \xcd"xi".

However, the method parameter can be omitted by using the type \xcd"list.T"
for \xcd"xi".  Thus, the method can be declared with the signature:
\begin{xten}
def shuffle(list: List) { ... }
\end{xten}
This is called \emph{proper abstraction}.

This example illustrates a key difference between type properties
and type parameters:
A type property is a member of its class, whereas a type parameter is
not.  The names of type properties are visible outside the body of
their class declaration.

\if 0
Type properties can be used as the basis of a parametrized type
system.  This is done simply by making type properties private.
Using the syntactic sugar described above,
the resulting system behaves identically to a system with type
parameters.
\fi

In Java,
Wildcard
capture allows the parametrized method to be called with any \xcd"List",
regardless of its parameter type.
However,
the method parameter cannot be omitted: declaring a parameterless version
of shuffle requires delegating to a private parametrized version that
``opens up'' the parameter.

\eat{
\section{Extensions}
\label{sec:extensions}

\subsection{Self type}

\subsection{Structural constraints}


\subsection{Ownership}

Consider the following example of generic ownership
derived from Potanin et al.~\cite{ogj-oopsla06}.

\begin{xten}
class Object(owner: Object) { }

// Map inherits Object.owner
// No need to add explicit vOwner and kOwner properties for Key, Value
class Map[Key, Value]{Key <: Comparable, Value <: Object}
{
    private nodes: Vector[Node[Key, Value](this)](this);

    public def put(key: Key, value: Value): Void = {
        nodes.add(new Node[Key, Value](key, value, this)());
    }

    public def get(key: Key): Value = {
        for (mn: Node[Key, Value](this) in nodes) {
            if (mn.key.equals(key))
                return mn.value;
        }
        return null;
    }

    // OGJ will prevent this from being called, since caller
    // can only assign the result to a supertype of Vector(this),
    // which would be only Vector(this) or Object(this)
    // BUT: we have Vector :> Vector(this)
    // Need to require that all class types have an equality constraint
    // on the owner property
    public def exposeVector(): Vector(this) { return nodes; }
}

class Node[Key, Value]
    {Key <: Comparable, Value <: Object}
{
    val key: Key;
    val value: Value;

    public def this[K, V](k: Key, v: Value, o: Object): Node[K, V](o) {
        super(o);               // set the owner
        property[K, V];         // set the type properties
        this.key = k;
        this.value = v;
    }
}
\end{xten}

Restrictions:
\begin{itemize}
\item owner property must be constrained (define this!)
\item owner is always equal to or inside the owner of all other type properties
\item types with an actual owner == this, can only be accessed via this
\end{itemize}

}

                        

\section{Conclusions}
\label{sec:conclusions}

We have presented a preliminary design for supporting genericity
in X10 using type properties.  This type system generalizes the
existing X10 type system.  The use of constraints on type
properties allows
the design to capture many features of generics in languages
like Java 5 and C\# and then to extend these features with new
more expressive power.
We expect that the design admits an efficient
implementation and intend to implement the design shortly.

\section*{Acknowledgments} 

The authors thank Bob Blainey, 
Doug Lea, Jens Palsberg, Lex Spoon, and Olivier Tardieu
for valuable feedback on versions of the language.
We thank 
Andrew Myers and
Michael Clarkson for providing us with their implementation of
PolyJ, on which our implementation was based, and for many
discussions over the years about parametrized types in Java.

\bibliographystyle{plain}
\bibliography{master}

% \appendix
% \onecolumn

% \section{An extended example}
% \input{longex}

\end{document}
