\Xten{} is a class-based object-oriented language.
that provides both dependent and generic types.
The language has a sequential core similar to Java or Scala, but
also
constructs for concurrency and distribution.
Like Java, the language provides single class
inheritance and multiple interface inheritance.
%\footnote{We plan
%to support traits in a future version of the language.}

A constrained type in \Xten{} is written \xcd"C{c}", where \xcd"C" is the
name of a class and \xcd"c" is a constraint on the properties
of \xcd"C" and the immutable state in scope at the type.  The
constraint \xcd"c" may refer to the value being constrained through
the special variable \xcd"self", which has type \xcd"C" in the
constraint.  Constraints are drawn from a constraint language that,
syntactically, is a subset of the boolean expressions of \Xten{}.  For
brevity, the constraint may be omitted and interpreted as \xcd"true".

Constraints may also be used as \emph{class invariants}, 
which are constraints on the class's members and type parameters 
that must be established by the class's
constructor and that subsequently hold for all instances of the class.
Methods and constructors may also be guarded by constraints on
their formal parameters---including type parameters. The
caller of a guarded method must ensure the constraint is
satisfied.

To illustrate the features of dependent types in \Xten{}, we
develop a \xcd"List"
class.  We will present several versions of \xcd"List" as we
introduce new features.
A \xcd"List" class with a type parameter \xcd"T" and an \xcd"int"
property \xcd"len" is declared as in Figure~\ref{fig:list0}.
Classes in \Xten{} may be declared with any number of type
parameters and properties.

\begin{figure}
{
\begin{xtennoindent}
      class List[T](len: int) {
        var head: T;
        val tail: List[T];
        def get(i: int): T {
          if (i == 0) return head;
          else return tail.get(i-1);
        }
        def this(hd: T, tl: List[T]):
            List[T]{len==tl.len+1} {
          super();
          property(tl.len+1);
          head = hd; tail = tl;
        }
      }
\end{xtennoindent}
}
\caption{List example, simplified}
\label{fig:list0}
\end{figure}

As in Scala, fields are declared using the keywords \xcd"var"
or \xcd"val".  The \xcd"List" class has a mutable \xcd"head"
field with type \xcd"T" (which resolves to \xcd"this.T"), and an
immutable (final) \xcd"tail" field with type \xcd"List[T]".
Note that \xcd"this" occurring
in the constraint refers to the instance of the enclosing
\xcd"List" class,
and \xcd"self" refers to the value being
constrained---\xcd"this.tail" in this case.

Methods are declared with the \xcd"def" keyword.
The method \xcd"get" takes an integer \xcd"i" argument
and returns the element at that position.

Objects in \Xten{} are initialized with constructors, which
must ensure that all properties of the new object
are initialized and that the class invariants of the object's
class and its superclasses and superinterfaces hold.
\Xten{} uses method syntax with the name
\xcd"this" for constructors.
In \Xten{}, constructors have a ``return type'', which constrains
the properties of the new object.  The constructor in
Figure~\ref{fig:list0} takes a type argument \xcd"T"
and two value arguments \xcd"hd" and \xcd"tl".  The constructor
return type specifies that the constructor initializes the
object to have type \xcd"List[T]{len==tl.len+1}".
The formal parameter types and return types of both methods and
constructors may refer to final parameters of the same
declaration.

The body of the constructor
begins with a \xcd"super" call that invokes the superclass
constructor.  In the case of \xcd"List", the superclass is
\xcd"Object" and its constructor takes no arguments.
Nullary \xcd"super" calls can be elided from the X10 programs.
A \xcd"property" statement that initializes the
properties of the new instance.  All properties are initialized
simultaneously and it is required that the property assignment
entails the constraint in the constructor return type.
The remainder of the constructor assigns the fields of the
instance with the constructor arguments.

We next illustrate more advanced features of \Xten by
presenting a new version of \xcd"List", shown
in Figure~\ref{fig:list}.

\begin{figure}
{\footnotesize
\begin{xtenmathnoindent}
class List[T](len: int){len >= 0) {
  var head: T;
  val tail: List[T]{self.len==this.len-1};

  def map[S](f: T => S): List[S]{self.len==this.len} {
    return new List[S](f(head), tail.map[S](f));
  }

  def get(i: int{0 <= self, self < len}){len > 0}: T {
    if (i == 0)
      return head;
    val tl = tail as List{len>0};
    val i1 = i-1 as int{0 <= self,self < tail.len};
    return tl.get(i1);
  }

  def this(hd: T, tl: List[T]):
      List[T]{len==tl.len+1} {
    super();
    property(tl.len+1);
    head = hd; tail = tl;
  }

  def print(){T $\extends$ Printable} {
    head.print();
    println(", ");
    tail.print();
  }
}
\end{xtenmathnoindent}}
\caption{List example, extended}
\label{fig:list}
\end{figure}

\subsection{Class invariants}

Properties of a class may be constrained with 
a \emph{class invariant}.
\xcd"List"'s class invariant in
Figure~\ref{fig:list} specifies that the length of
the list be non-negative.
The class invariant must be established by all constructors of
the class and subsequently can be assumed for all instances of the class.

For generic types, the invariant is used to provide 
bounds on the type parameters.
For example, in the following code,
\xcd"SortedList" 
specifies that the element type \xcd"T"
be a subtype of \xcd"Comparable[T]":
\begin{xtenmath}
class SortedList[T] {T$\extends$Comparable[T]} {
  def sort() { ... x.compare(y) ... }
}
\end{xtenmath}
Constraints can specify either subtype (\xcd"<="), supertype (\xcd">="),
or equality bounds (\xcd"==").

\subsection{Methods}

Methods in \Xten may have type parameters.  
For instance, the \xcd"map" method in Figure~\ref{fig:list} 
has a type parameter \xcd"S" and a value parameter that is a
function from \xcd"T" to \xcd"S".
A parametrized method is invoked by giving type arguments before the
expression arguments (see the recursive call to
\xcd"map").\footnote{In \Xten, actual type arguments can be
inferred from the types of the value arguments.  However, type
inference is out of the scope of this paper.}

Method declarations in \Xten
may also have additional
constraints, or \emph{guards}, on the method parameters.  A
method guard must be satisfied by the caller of the method, and
the guard holds throughout the method body.
The guard may constrain both the value and type parameters of
the method; it may also constrain other types in
scope at the declaration, including the enclosing class's type parameters.

The method \xcd"get" in Figure~\ref{fig:list}
has a constraint on the type of \xcd"i" that requires
that it be within the list bounds.
The method also has a guard that
requires that the actual
receiver's
\xcd"len" property must be positive---calls to \xcd"get" on empty
lists are not permitted.
A method with a guard is called a \emph{conditional method}.
The constraint on \xcd"get" ensures that the guard on 
\xcd"tail" is satisfied in the method body.
In the method body, the \xcd"head" of the list is returned for
position \xcd"0"; otherwise, the call recurses on \xcd"tail".
For this example to type-check, the constraint system
must establish
the guard on the recursive call to \xcd"get".
This is done explicitly by performing run-time casts using the
\xcd"as" operator.\footnote{Support for flow-sensitive constraints
would obviate the need for
run-time casts in this context.}
\eat{
The constraint solver must prove
{\footnotesize
$$
\begin{array}[t]{l}
\tt len > 0, tail.len=len-1, 0 \leq i, i < len, i \not= 0 \\
\tt \quad\vdash tail.len > 0, 0 \leq i-1,i-1 < tail.len 
\end{array}
$$}
}

Method guards can also constrain type parameters.
For instance, the \xcd"print" method can be invoked only if
\xcd"T" is instantiated on a type that implements
\xcd"Printable".  Since the guard holds in the body of the
method, the \xcd"print" method can be invoked on \xcd"head"---it
is guaranteed to implement \xcd"Printable".
This feature is similar to optional methods in CLU~\cite{clu}.
Using structural constraints on \xcd"T" would give more
expressive power; optional methods are discussed further in
Section~\ref{sec:discussion}.
Constructors in \Xten may also have guards.

Method overriding is similar to Java: a method of a subclass
with the same name and parameter types overrides a method of the
superclass.  An overridden method may have a return type that is
a subtype of the superclass method's return type.
A method guard may be weakened by an overriding
method; that is, the guard in the superclass must entail the  
guard in the subclass.

Method overloading in \Xten is not constraint-sensitive.  It is
illegal for a class to contain two methods with the same name
and the same parameter types when constraints are erased from the 
types.  Constraints are also not evaluated during method
dispatch, as in predicate dispatch~\cite{jpred}.

\eat{
\xcd"List" also defines three constructors: the first
constructor takes no value arguments and initializes
the length to \xcd"0".  Note that \xcd"head" and \xcd"tail" are
not assigned since they are inaccessible.
The second constructor takes an argument for the head of the
list; the third takes both a head and tail.
}

\subsection{Type constraints and variance}
\label{sec:variance-overview}

\Xten supports definition-site variance annotations.
Parameters may be declared invariant, covariant, or
contravariant.
If a parameter \xcd"X" of a class \xcd"C" is covariant,
then if \xcd"S" is a subtype of
\xcd"T", the type \xcd"C[S]" is a subtype of \xcd"C[T]".
Similarly, if \xcd"X" is contravariant, 
\xcd"C[T]" is a subtype of \xcd"C[S]".
Invariant parameters are the default; a covariant parameter is
declared by prepending ``\xcd"+"'' to the parameter name in the
class header; a contravariant parameter is declared by
prepending ``\xcd"-"''.

It is illegal for a covariant parameter to occur in a negative
position in its class declaration and for a contravariant
parameter to occur in a positive position.  A position is
negative if it is a formal parameter type, or occurs in a method
where clause.  A position is positive if it is a return type or
occurs in a method constraint.

\todo{
Variant type parameters used in method guards and in other
constraints in method signatures must also be
restricted.  
}

\eat{
\subsection{Methods}

Methods in \Xten{} are declared with the \xcd"def" keyword.
The \xcd"List" class in Figure~\ref{fig:list} declares methods
\xcd"get" and \xcd"map".

Like Java, \Xten{} supports both instance and static methods.
Since a type property is an instance member, a static method may
not refer to a type property of the class.

Interfaces are also permitted to have static methods.  Classes
implementing the interface must provide an implementation of the
static methods of the interface.
This feature is
useful when a type property \xcd"T" is constrained to implement
an interface \xcd"I"; static methods of \xcd"I" can be invoked
through \xcd"T".
}

\eat{
\subsection{Interfaces}

optional interfaces
value properties in interfaces
static methods in interfaces

\subsubsection{Optional methods and interfaces}

Method constraints also provide support for optional methods.

{
\begin{xtenmath}
class List[T] {
  ...
  def print(){T $\extends$ Printable} {
    for (x: T in this)
      x.print();
}
}
\end{xtenmath}}

\xcd"List.print" may only be called on lists instantiated on
subtypes of the \xcd"Printable" interface.

Optional methods generalize to optional interfaces.

{\footnotesize
\begin{xtenmath}
interface Printable { def print(); }

class List[T] implements Printable if {T $\extends$ Printable} {
  ...
  def print(){T $\extends$ Printable} {
    for (x: T in this)
      x.print();
  }
}
\end{xtenmath}}

In this case \xcd"List" implements the \xcd"Printable" interface
only if \xcd"List.T" implements \xcd"Printable".
Thus \xcd"List{T==String}"
and \xcd"List{T==List[String]}"
are subtypes of \xcd"Printable", but
\xcd"List{T" \xcd"==FourLetterWord}" is not.


Without optional interfaces, \xcd"List" cannot be a subtype
of \xcd"Printable".  The constraint \xcdmath"{T $\extends$ Printable}" on
the \xcd"print" method is more restrictive than the 
constraint (i.e., \xcd"true") on 
\xcd"Printable.print".
}

