\newcommand{\constraint}{{\tt constraint}}
\newcommand\cj[2]{{#1} \vdash {#2}~\constraint}
\newcommand\cjj[3]{{#1} \vdash {#2}~\constraint, {#3}~\constraint}
\newcommand\wj[2]{{#1} \vdash {#2}~\type}
\newcommand\tj[3]{{#1} \vdash {#2} \ty {#3}}
\newcommand\stj[3]{{#1} \vdash {#2} \subtype {#3}}

We now describe the semantics of languages in the \FX{} family.
For uniformity we declare type-valued parameters and properties
to be of ``type'' \type, instead of using square brackets to demarcate
them.


\subsection{\FXZ}

The grammar for \FXZ{} is shown in Figure~\ref{fig:fx-grammar}.
The syntax is essentially that of \FJ{}.
Following the convention for \FJ{}, we use $\bar{x}$ to denote a
list $x_1, \dots, x_n$.  We use $\bullet$ to denote the empty
list.

A program {\tt P} is a set of class declarations \tbar{L}.
Class names {\tt C} in {\tt P} range over the declared classes in {\tt P} 
and {\tt Object}.
Classes have
properties (i.e., immutable fields) \tbar{f} and methods \tbar{M}.  We omit constructors
and require that the \new{} expression provide initializers
for all fields (including inherited fields). 
Methods are introduced with the {\tt def} keyword.

Both classes and methods may have constraint clauses
{\tt c}.  In the case of classes, {\tt c} is to be thought of as an
{\em invariant} satisfied by all instances of the class; in the case of
methods, {\tt c} is an additional condition, or {\em guard},
that must be satisfied by
{\tt this} and the actual arguments of the method in order for the method to
be applicable.

Expressions {\tt e} are either parameters {\tt x} (including the implicit
method parameter {\tt this}), field accesses, method invocations, \new{}
expressions, or casts (written {\tt e}~\as~{\tt T}).

The set of types includes classes {\tt C} and is closed under
constrained types ($\tt T\{c\}$) and existential
quantification ($\exists \tt x:T.~U$).
An object {\tt o} is of type {\tt C} if it is an instance of class {\tt C}; it is of type $\tt
T\{c\}$ if it is of type {\tt T} and it satisfies the constraint $\tt
c[o/self]$\footnote{Thus the constraint {\tt c} in a type {\tt T\{c\}}
should be thought of as a unary predicate $\lambda\self.{\tt c}$, an
object is of this type if it is of type {\tt T} and satisfies this
predicate.}; it is of type $\exists \tt x:T.~U$
if there is some object {\tt q}
of type {\tt T} such that {\tt o} is of type
$\tt U[q/x]$.

The syntax for constraints in \FXZ{} is specified in
Figure~\ref{fig:fx-grammar}. Neither casts nor method
invocations are permitted in constraints.

We distinguish a subset of these constraints as
{\em user constraints}---these are permitted to occur in
programs. For \FXZ{} the only user constraint permitted is the vacuous
{\tt true}. Thus the types occurring in user programs are isomorphic
to class types, and class and method definitions specialize to the
standard class and method definitions of \FJ{}. 

The constraints permitted by the syntax in
Figure~\ref{fig:fx-grammar} that
are not user constraints are equality constraints and
conjunctions of constraints. These additional
constraints as well as constrained and existential types
are not necessary to the definition of \FXZ.
But they enable us to present the static and dynamic
semantics once for the entire family of \FX{} languages,
distinguishing different members of the family by varying the
constraint system over which they are defined.


\paragraph{Operational semantics.}

The operational semantics, shown in Figure~\ref{fig:sos},
is straightforward and essentially identical
to \FJ \cite{FJ}. It is described in terms of a non-deterministic
reduction relation on expressions. The only novelty is the use of the
subtyping relation to check that the cast is satisfied. In \FXZ, this
test simply involves checking that the class of which the object is an
instance is a subclass of the class specified in the given type; in
richer languages with richer notions of type this operation may
involve run-time constraint solving using the fields of the object.


\subsection{Judgments}

In the following, the context $\Gamma$ is always a
(finite, possibly empty) sequence of formulas $\tt x:T$ and constraints $\tt c$ satisfying:
\begin{enumerate}
  \item for any formula $\phi=\tt x:T$ or constraint $\phi=\tt c$ in the sequence all free variables $\tt y$
  occurring in $\tt T$ or $\tt c$ are declared by a formula $\tt
  y:U$ in $\Gamma$.

  \item for any variable $\tt x$, there is at most one
  formula $\tt x:T$ in $\Gamma$.
\end{enumerate}

The judgments of interest are as follows.
\begin{enumerate}
	\item Well-formedness:\\
	  $\cj{\Gamma}{\tt c}$ \hfill constraint {\tt c} is well formed\\
	  $\wj{\Gamma}{\tt T}$ \hfill  type {\tt T} is well formed
	\item Member lookup:\\
	  $\Gamma\vdash \fields({\tt x})=\tbar{f}:\tbar{T}$ \hfill variable {\tt x} has fields \tbar{f} of type \tbar{T}\\
	  $\Gamma\vdash {\tt x}~\has~{\tt f}:{\tt T}$ \hfill variable {\tt x} has field {\tt f} of type {\tt T}\\
	  $\Gamma\vdash {\tt x}~\has~{\tt m}(\tbar{x}:\tbar{T})\{{\tt c}\}:{\tt U}={\tt e}$ \hfill variable {\tt x} has method {\tt m}
	\item Constraints:\\
	  $\Gamma\vdash {\tt c}$ \hfill constraint {\tt c} holds
	\item Typing:\\
	  $\Gamma\vdash {\tt e}:{\tt T}$ \hfill expression {\tt e} has type {\tt T}\\
	  $\vdash {\tt def}~{\tt m}(\tbar{x}:\tbar{T})\{{\tt c}\}:{\tt U}={\tt e}~{\rm OK~in}~{\tt C}$ \\ $~$ \hfill method {\tt m} in class {\tt C} type checks\\
	  $\vdash {\tt class}~{\tt C}(\tbar{f}:\tbar{T})\{{\tt c}\}~{\tt extends}~{\tt D}~\{~\tbar{M}~\}~{\rm OK}$ \\ $~$ \hfill class {\tt C} type checks
	\item Subtyping:\\
	  $\Gamma \vdash {\tt S} \subtype {\tt T}$ \hfill type {\tt S} is a subtype of type {\tt T}
\end{enumerate}

A program type checks iff all its classes are provably OK.

\paragraph{Well-formedness.} The rules for well-formedness of
types in Figure~\ref{fig:well} are straightforward. A constraint
$\tt c$ is well-formed for context $\Gamma$ iff its free variables are declared in $\Gamma$, i.e., $\mathcal{F}({\tt c})\subseteq\mathcal{D}(\Gamma)$. $\mathcal{D}$ and $\mathcal{F}$ are defined as usual.\footnote{Constraints such as ``$\new~{\tt C}(\bullet)==\new~{\tt D}(\bullet)$'' are well formed even if inconsistent. By design, it will not be possible to derive an inconsistent constraint from a consistent context.}

We say a program, context, or judgment is well formed iff all the constraints and types occurring it contains are well formed. By design, if a program type checks then it is well formed. Moreover, every judgment derived from a well formed context is also well formed.

\paragraph{Member lookup.} Figure~\ref{fig:lookup} specifies the fields and methods available on each type. Note that classes may only be extended by classes with stronger invariants. Fields cannot be overridden.
A method may only be overridden by a method with the same name, arity, parameter types, a weaker guard, and a return type that is a subtype of the overridden return type.


\paragraph{Constraints.}
In defining these judgments we will use \mbox{$\Gamma \vdashX {\tt c}$},
the judgment corresponding to the underlying constraint system.

Each language $\cal L$ in the family is defined over a given input
constraint system $\cal X$ that has {\em at least} support for equality constraints over uninterpreted terms.
Formally, $\cal X$ permits judgments of the form
$\Gamma \vdashX {\tt c}$ where $\Gamma::=\tbar{c}$ is a (finite, possibly empty) sequence of constraints.

For
simplicity, we define $\Gamma \vdash {\tt c}$ to mean
$\sigma(\Gamma)\vdashX {\tt c}$, where the {\em constraint
projection}, $\sigma(\Gamma)$ is defined as follows. 
%
\begin{center}
\begin{tabular}{l}
$\sigma(\epsilon)={\tt true}$\\
$\sigma({\tt x}:{\tt C}, \Gamma)=\sigma(\Gamma)$\\
$\sigma({\tt x}:{\tt T\{c\}}, \Gamma)={\tt c}[{\tt x}/\self], \sigma({\tt x}:{\tt T},\Gamma)$\\
$\sigma({\tt x}:\exists {\tt y}:{\tt T}.~{\tt U}, \Gamma)=\sigma({\tt z:T}, {\tt x}:{\tt U[{\tt z}/{\tt y}]},\Gamma)$\\
$\sigma({\tt c},\Gamma) = {\tt c}, \sigma(\Gamma)$
\end{tabular}
\end{center}
%
Above, in the fourth rule we assume that alpha-equivalence is used to
choose a variable {\tt z} that does not
occur in the context under construction.

In order to capture the object-oriented structure of a program {\tt P}, we extend $\cal X$ with the {\sc X-Sel} rule in Figure~\ref{fig:object}. We also add rules {\sc X-Proj} and {\sc X-Inv} to extra constraints in types and class invariants.

\paragraph{Typing rules.} The typing rules are specified in Figure~\ref{fig:FX}.

{\sc T-Var} is as expected, except that it asserts the constraint {\tt
self==x} which records the fact that any value of this type is known
statically to be equal to {\tt x}. This constraint is actually very
crucial---as we shall see in the other rules once we establish that
an expression {\tt e} is of a given type {\tt T}, we ``transfer'' the
type to a freshly chosen variable {\tt z}. If in fact {\tt e} has a
static ``name'' {\tt x} (i.e., {\tt e} is known statically to be
equal to {\tt x}, i.e., {\tt e} is of type {\tt T\{self==x\}}), then
{\sc T-Var} lets us assert that {\tt z:T\{self==x\}}, i.e., {\tt z}
equals {\tt x}. Thus {\sc T-Var} provides an important base case for
reasoning statically about equality of values in the environment.

We do away with the three casts provided in \FJ{} in favor of a single
cast, requiring only that {\tt e} be of some type {\tt U}. At run time
{\tt e} will be checked to see if it is actually of type {\tt T} (see
Rule~{\sc R-Cast}).

{\sc T-Field} may be understood through ``proxy'' reasoning as
follows.  Given the context $\Gamma$ assume the receiver {\tt e} can
be established to be of type {\tt T}. Now we do not know the run-time
value of {\tt e}, so we shall assume that it is some fixed but unknown
``proxy'' value {\tt x} (of type {\tt T}) that is ``fresh'' in that it
is not known to be related to any known value (i.e., those recorded
in $\Gamma$).  If we can establish that {\tt x} has a field {\tt f} of
type {\tt U}\footnote{Note from the definition of
\fields{} in Figure~\ref{fig:lookup} that all occurrences of
\this{} in the declared type of the field {\tt f} will have been replaced
by {\tt x}.}, then we can assert that
{\tt e.f} has type {\tt U} and, further, that it equals {\tt x.f}.
Hence, we can assert that {\tt e.f} has type 
$\exists {\tt x}:{\tt T}.~{\tt U}\{\self={\tt x}.{\tt f}\}$.

{\sc T-Invk} has a very similar structure to {\sc T-Field}: we use
``proxy'' reasoning for the receiver and the arguments of the method
call. {\sc T-New} also uses the same proxy reasoning: however in this case
we can establish that the resulting value is equal to $\new~{\tt C}(\tbar{y})$
for some values $\bar{\tt y}$ of the given types.

{\sc T-Method} and {\sc T-Class} ensure that the types and constraints occurring in a program are well formed. With the restrictions on class inheritance and method overriding we described earlier, {\sc T-Method} specifies that a method type checks iff its body {\tt e} can be shown to have a type {\tt W} that is a subtype of its declared return type {\tt V}. {\sc T-Class} specifies that a class type checks iff all its methods type check.

Following from \FJ{}, the typing rules do not preclude the existence of cycles in the type declarations. In the sequel, we will always assume these are acyclic.

\paragraph{Subtyping rules.} The subtyping rules in Figure~\ref{fig:subtyping} are straightforward.


\begin{figure*}
\centering
\begin{tabular}{r@{\quad}rcl}
  (Program) & {\tt P} &{::=}& $\tbar{L}$ \\
  (Class declaration) & {\tt L} &{::=}& $\tt class~C(\tbar{f}:\tbar{T})\{c\}~extends~D~\{~\tbar{M}~\}$ \\
  (Method declaration)& {\tt M} &{::=}& $\tt def~m(\tbar{x}:\tbar{T})\{c\}:T=e;$ \\
  (Expression)& {\tt e} &{::=}& $\tt x$ \alt $\tt e.f$ \alt $\tt\new~C(\tbar{e})$ \alt $\tt e.m(\tbar{e})$ \alt $\tt e~\as~T$ \\
  (Type)& {\tt T} &{::=}& $\tt C$ \alt $\tt T\{c\}$ \alt $\tt \exists x:T.~T$ \\
  (Constraint term) & {\tt t} &{::=}& $\tt x$ \alt $\tt t.f$ \alt $\tt\new~C(\tbar{t})$ \\
  (Constraint) & {\tt c} &{::=}& $\true$ \alt $\tt t==t$ \alt $\tt c,c$ \alt $\tt \exists x:T.~c$ \\
\end{tabular} 
\par\flushleft
{\tt C} ranges over class names, {\tt f} over field names, {\tt m} over method names, {\tt x} over variable names.
\caption{\FX{} productions}
\label{fig:fx-grammar}
\end{figure*}


\begin{figure*}
\begin{minipage}{.4\textwidth}
\quad\typicallabel{XXXXXX}
\infrule[\RField]
	{{\tt x}:{\tt C}\vdash\fields({\tt x})=\tbar{f}:\tbar{T}}
	{\new~{\tt C}(\tbar{t}).{\tt f}_i \derives {\tt t}_i}

\infrule[\RCField]
	{{\tt e}\derives {\tt e}'}
	{{\tt e}.{\tt f}\derives {\tt e}'.{\tt f}}

\infrule[\RCast]
	{\vdash {\tt C}\{\self==\new~{\tt C}(\tbar{t})\}\subtype {\tt T}}
	{\new~{\tt C}(\tbar{t})~\as~{\tt T}\derives\new~{\tt C}(\tbar{t})}

\infrule[\RCCast]
	{{\tt e}\derives {\tt e}'}
	{{\tt e}~\as~{\tt T}\derives {\tt e}'~\as~{\tt T}}

\end{minipage}%
\begin{minipage}{.6\textwidth}
\quad\typicallabel{XXXX}
\infrule[\RInvk]
	{{\tt x}:{\tt C}\vdash {\tt x}~\has~{\tt m}(\tbar{y}:\tbar{T})\{{\tt c}\}:{\tt U}={\tt e}}
	{\new~{\tt C}(\tbar{t}).{\tt m}(\tbar{a})\derives {\tt b}[\new~{\tt C}(\tbar{t}),\tbar{a}/{\tt x},\tbar{y}]}

\infrule[\RCInvkRecv]
	{{\tt e}\derives {\tt e}'}
	{{\tt e}.{\tt m}(\tbar{a})\derives {\tt e}'.{\tt m}(\tbar{a})}

\infrule[\RCInvkArg]
	{{\tt a}_i\derives {\tt a}'_i}
	{{\tt e}.{\tt m}(\ldots,{\tt a}_i,\ldots)\derives {\tt e}.{\tt m}(\ldots,{\tt a}'_i,\ldots)}

\infrule[\RCNewArg]
	{{\tt e}_i\derives {\tt e}'_i}
	{\new~{\tt C}(\ldots,{\tt e}_i,\ldots)\derives\new~{\tt C}(\ldots,{\tt e}'_i,\ldots)}
\end{minipage}
\caption{\FX{} operational semantics}
\label{fig:sos}
\end{figure*}


\begin{figure*}
\begin{minipage}{.5\textwidth}
\quad\typicallabel{XXX}
\infax[C-True]
  {\cj{}{\true}}

\infrule[C-Equals]
	{\mathcal{F}({\tt t}=={\tt u})\subseteq\mathcal{D}(\Gamma)} 
	{\cj{\Gamma}{{\tt t}=={\tt u}}}

\infrule[C-And]
	{\cjj{\Gamma}{\tt c}{\tt d}}
	{\cj{\Gamma}{{\tt c}, {\tt d}}}

\infrule[C-Exists]
  {\wj{\Gamma}{\tt T} \andalso \cj{\Gamma, {\tt x} \ty {\tt T}}{\tt c}}
  {\cj{\Gamma}{\exists {\tt x} \ty {\tt T}.~{\tt c}}}
\end{minipage}%
\begin{minipage}{.5\textwidth}
\quad\typicallabel{XXX}
\infax[W-Object]
  {\wj{}{\tt Object}}

\infrule[W-Class]
  {{\tt class}~{\tt C}(\tbar{f}:\tbar{T})\{{\tt c}\}~{\tt extends}~{\tt D}~\{~\tbar{M}~\} \in {\tt P}}
  {\wj{}{\tt C}}

\infrule[W-Dep]
        {\wj{\Gamma}{\tt T} \andalso \cj{\Gamma, \self \ty {\tt T}}{\tt c}}
	{\wj{\Gamma}{{\tt T}\{{\tt c}\}}}

\infrule[W-Exists]
        {\wj{\Gamma}{\tt T} \andalso \wj{\Gamma, {\tt x} \ty {\tt T}}{\tt U}}
        {\wj{\Gamma}{\exists {\tt x} \ty {\tt T}.~{\tt U}}}
\end{minipage}
\caption{\FX{} well-formed constraints and types}
\label{fig:well}
\end{figure*}


\begin{figure*}
\begin{minipage}{\textwidth}
\quad\typicallabel{XXXXXX}
\infrule[X-Exists]
  {\Gamma\vdash {\tt t}:{\tt T},{\tt c}[{\tt t}/{\tt x}]}
  {\Gamma\vdash \exists {\tt x}:{\tt T}.~{\tt c}}
\eat{
\infrule[X-Lift]
  {\Gamma\vdash {\tt t}:{\tt T}, {\tt c}[{\tt t}/\self]}
  {\Gamma\vdash {\tt t}:{\tt T}\{{\tt c}\}}

\infrule[X-Proj]
  {\Gamma\vdash {\tt t}:{\tt T}\{{\tt c}\}}
  {\Gamma\vdash {\tt c}[{\tt t}/\self]}
}
\infrule[X-Sel]
  {{\tt x}:{\tt C}\vdash\fields({\tt x})=\tbar{f}:\tbar{T}
  	\andalso
  	\Gamma\vdash\new~{\tt C}(\tbar{t}):{\tt U}}
  {\Gamma\vdash\new~{\tt C}(\tbar{t}).{\tt f}_i=={\tt t}_i}

\infrule[X-Inv]
  {{\tt class}~{\tt C}(\tbar{f}:\tbar{T})\{{\tt c}\}~{\tt extends}~{\tt D}~\{~\tbar{M}~\}\in {\tt P}
   \andalso
   \Gamma\vdash {\tt t}:{\tt U},{\tt U}\subtype{\tt C}}
  {\Gamma\vdash {\tt c}[{\tt t}/\this]}
\end{minipage}%
\eat{
\begin{minipage}{\textwidth}
\quad\typicallabel{XXXX}
\infrule[X-New]
  {{\tt x}:{\tt T}\vdash\fields({\tt x})=\tbar{f}:\tbar{U}
   \andalso
   \Gamma\vdash\exists{\tt x}:{\tt T}.~{\tt c}}
  {\Gamma\vdash{\tt C}~\type,\tbar{V}~\type,\tbar{V}\subtype\tbar{U},\exists\tbar{y}:\tbar{V}.~\exists{\tt x}:{\tt T}.~{\tt c},{\tt x}==\new~{\tt C}(\tbar{y})}
\end{minipage}%
}
\caption{\FX{} object constraint system}
\label{fig:object}
\end{figure*}

\begin{figure*}
\quad\typicallabel{XXXXXX}
\infax[L-Fields-B]
  {\tt x:Object\vdash\fields(x)=\bullet}

\infrule[L-Fields-I]
  {{\tt class}~{\tt C}(\tbar{f}:\tbar{T})\{{\tt c}\}~{\tt extends}~{\tt D}~\{~\tbar{M}~\}\in {\tt P}
   \andalso
    {\tt x}\ty {\tt D}\vdash\fields({\tt x})=\tbar{g}:\tbar{U}}
   {
    {\tt x}\ty {\tt C}\vdash\fields({\tt x})=\tbar{g}: \tbar{U}, \tbar{f}: \tbar{T}[{\tt x}/\this]}

\infrule[L-Field-B]
  {{\tt x}\ty {\tt C}\vdash\fields({\tt x})=\tbar{f}:\tbar{T}}
  {{\tt x}\ty {\tt C}\vdash {\tt x}~\has~{\tt f}_i:{\tt T}_i}

\infrule[L-Field-C,E]
  {\Gamma,{\tt x}\ty {\tt T}\vdash {\tt x}~\has~{\tt f}\ty {\tt U} \andalso {\tt y}~{\rm fresh}}
  {\Gamma,{\tt x}\ty {\tt T}\{{\tt c}\}\vdash {\tt x}~\has~{\tt f}\ty {\tt U} \\
   \Gamma,{\tt x}\ty \exists {\tt y}\ty {\tt V}.~{\tt T}\vdash {\tt x}~\has~{\tt f}:{\tt U}}

\infrule[L-Method-B]
  {{\tt class}~{\tt C}(\tbar{f}:\tbar{T})\{{\tt c}\}~{\tt extends}~{\tt D}~\{~\tbar{M}~\}\in {\tt P}
   \andalso
   {\tt def}~{\tt m}(\tbar{y}\ty \tbar{U})\{{\tt d}\}\ty {\tt V}={\tt e}\in \tbar{M}}
  {{\tt x}\ty {\tt C}\vdash {\tt x}~\has~{\tt m}(\tbar{y}:\tbar{U}[{\tt x}/\this])\{{\tt d}[{\tt x}/\this]\}:{\tt V}[{\tt x}/\this]={\tt e}[{\tt x}/\this]}

\infrule[L-Method-I]
  {{\tt class}~{\tt C}(\tbar{f}:\tbar{T})\{{\tt c}\}~{\tt extends}~{\tt D}~\{~\tbar{M}~\}\in {\tt P}
   \andalso
   {\tt x}:{\tt D}\vdash {\tt x}~\has~{\tt m}(\tbar{y}:\tbar{U})\{{\tt d}\}:{\tt V}={\tt e}
   \andalso
   {\tt m}\not\in\tbar{M}}
  {{\tt x}:{\tt C}\vdash {\tt x}~\has~{\tt m}(\tbar{y}:\tbar{U})\{{\tt d}\}:{\tt V}={\tt e}}

\infrule[L-Method-C,E]
  {\Gamma,{\tt x}:{\tt T}\vdash {\tt x}~\has~{\tt m}(\tbar{y}:\tbar{U})\{{\tt d}\}:{\tt V}={\tt e} \andalso {\tt z}~\rm fresh}
  {\Gamma,{\tt x}:{\tt T}\{{\tt c}\}\vdash {\tt x}~\has~{\tt m}(\tbar{y}:\tbar{U})\{{\tt d}\}:{\tt V}={\tt e} \\
   \Gamma,{\tt x}:\exists {\tt z}:{\tt W}.~{\tt T}\vdash {\tt x}~\has~{\tt m}(\tbar{y}:\tbar{U})\{{\tt d}\}:{\tt V}={\tt e}}
\caption{\FX{} member lookup}
\label{fig:lookup}
\end{figure*}


\begin{figure*}
\quad\typicallabel{XXXXXX}
\infax[T-Var]
  {\Gamma,{\tt x}:{\tt T}\vdash {\tt x}:{\tt T}\{\self=={\tt x}\}}

\infrule[T-Cast]
	{\Gamma\vdash {\tt e}:{\tt U}\andalso\wj{\Gamma}{\tt T}}
	{\Gamma\vdash {\tt e}~\as~{\tt T}:{\tt T}}
	
\infrule[T-Field]
	{\Gamma\vdash {\tt e}:{\tt T} \andalso \Gamma,{\tt x}:{\tt T}\vdash {\tt x}~\has~{\tt f}:{\tt U} \andalso {\tt x}~\rm fresh}
	{\Gamma\vdash {\tt e}.{\tt f}:\exists {\tt x}:{\tt T}.~{\tt U}\{\self=={\tt x}.{\tt f}\}}

\infrule[T-Invk]
	{\Gamma\vdash {\tt e}:{\tt T},\tbar{a}:\tbar{U} \andalso 
	  \Gamma,{\tt x}:{\tt T},\tbar{y}:\tbar{U}\vdash {\tt x}~\has~{\tt m}(\tbar{z}:\tbar{V})\{{\tt d}\}:{\tt W}={\tt b},
		\tbar{U}\subtype\tbar{V}[\tbar{y}/\tbar{z}],{\tt d}[\tbar{y}/\tbar{z}] \andalso {\tt x},\tbar{y}~\rm fresh}
	{\Gamma\vdash {\tt e}.{\tt m}(\tbar{a}):\exists {\tt x}:{\tt T}.~\exists\tbar{y}:\tbar{U}.~{\tt W}[\tbar{y}/\tbar{z}]}

\infrule[T-New]
	{{\tt class}~{\tt C}(\tbar{f}:\tbar{T})\{{\tt c}\}~{\tt extends}~{\tt D}~\{~\tbar{M}~\}\in {\tt P}
		\andalso
		{\tt x}:{\tt C}\vdash\fields({\tt x})=\tbar{g}:\tbar{V} \\
	  \Gamma\vdash\tbar{e}:\tbar{U} \andalso
    \Gamma,{\tt x}:{\tt C},\tbar{y}:\tbar{U},{\tt x}.\tbar{g}==\tbar{y}\vdash
    \tbar{U}\subtype\tbar{V},{\tt c}[{\tt x}/\this] \andalso {\tt x},\tbar{y}~\rm fresh}
	{\Gamma\vdash\new~{\tt C}(\tbar{e}):\exists\tbar{y}:\tbar{U}.~{\tt C}\{\self==\new~{\tt C}(\tbar{y})\}}
        
\infrule[T-Method]
  {{\tt class}~{\tt C}(\tbar{f}:\tbar{T})\{{\tt c}\}~{\tt extends}~{\tt D}~\{~\tbar{M}~\}\in {\tt P} \andalso
    {\tt def}~{\tt m}(\tbar{y}:\tbar{U})\{{\tt d}\}:{\tt V}={\tt e}\in\tbar{M}\\
    \this:{\tt C},\tbar{y}:\tbar{U}\vdash\tbar{U}~\type,{\tt d}~\constraint
    \andalso
    \this:{\tt C},\tbar{y}:\tbar{U},{\tt d}\vdash {\tt e}:{\tt W},{\tt W}\subtype {\tt V}}
  {{\tt def}~{\tt m}(\tbar{y}:\tbar{U})\{{\tt d}\}:{\tt V}={\tt e}~{\rm OK~in}~{\tt C}}

\infrule[T-Class]
  {\this:{\tt C},\tbar{f}:\tbar{T}\vdash\tbar{T}~\type,{\tt c}~\constraint \andalso \wj{}{\tt D} \andalso \tbar{M}~{\rm OK~in}~{\tt C}}
  {{\tt class}~{\tt C}(\tbar{f}:\tbar{T})\{{\tt c}\}~{\tt extends}~{\tt D}~\{~\tbar{M}~\}~\rm OK}
\caption{\FX{} typing rules}\label{fig:FX}
\end{figure*}


\begin{figure*}
\begin{minipage}{.5\textwidth}
\quad\typicallabel{XXXXX}
\infrule[S-Class]
  {{\tt class}~{\tt C}(\tbar{f}:\tbar{T})\{{\tt c}\}~{\tt extends}~{\tt D}~\{~\tbar{M}~\}\in {\tt P}}
  {\Gamma\vdash {\tt C}\subtype {\tt D}}

\infrule[S-Refl]
  {\wj{\Gamma}{\tt T}}
  {\Gamma\vdash {\tt T}\subtype {\tt T}}

\infrule[S-Trans]
	{\Gamma\vdash {\tt T}\subtype {\tt U}, {\tt U}\subtype {\tt V}}
	{\Gamma\vdash {\tt T}\subtype {\tt V}}
\end{minipage}%
\begin{minipage}{.5\textwidth}
\quad\typicallabel{XXXXX}
\infrule[S-Const-L]
	{\Gamma,{\tt self}:{\tt T},{\tt c}\vdash{\tt T}\subtype {\tt U}}
	{\Gamma\vdash {\tt T}\{{\tt c}\}\subtype {\tt U}}

\infrule[S-Const-R]
	{\wj{\Gamma}{{\tt U}\{{\tt c}\}}\andalso\Gamma,\self:{\tt T}\vdash {\tt c},{\tt T}\subtype {\tt U} }
	{\Gamma\vdash {\tt T}\subtype {\tt U}\{{\tt c}\}}

\infrule[S-Exists-L]
  {\Gamma\vdash {\tt T}\subtype {\tt U} \andalso \wj{\Gamma}{\tt V} \andalso {\tt x}~\rm fresh}
  {\Gamma\vdash\exists {\tt x}:{\tt V}.~{\tt T}\subtype {\tt U}}

\infrule[S-Exists-R]
  {\Gamma\vdash {\tt t}:{\tt T} \andalso \Gamma\vdash {\tt U}\subtype {\tt V}[{\tt t}/{\tt x}]}
  {\Gamma\vdash {\tt U}\subtype\exists {\tt x}:{\tt T}.~{\tt V}}
\end{minipage}        
\caption{\FX{} subtyping rules}\label{fig:subtyping}
\end{figure*}


\begin{figure*}
\centering
\begin{tabular}{r@{\quad}rcl}
  (Expression)& {\tt e} &{::=}& ${\tt C}\{{\tt c}\}$ \\
  (Path)& {\tt p} &{::=}& ${\tt x}$ \alt {\tt p}.{\tt f} \\
  (Type)& {\tt T} &{::=}& ${\tt p}$ \alt \type \\
  (Constraint term)& {\tt t} &{::=}& ${\tt T}$ \\
  (Constraint) & {\tt c} &{::=}& ${\tt T}\extends {\tt T}$
\end{tabular}

\infax[W-Type]
	{\wj{}{\type}}

\infax[W-Var]
	{\wj{\Gamma,{\tt x}:\type}{\tt x}}

\infrule[W-Path]
	{\Gamma\vdash {\tt p}:{\tt T}
         \andalso
         \Gamma,{\tt x}:{\tt T}\vdash {\tt x}~\has~{\tt f}:\type}
	{\wj{\Gamma}{{\tt p}.{\tt f}}}
	
\infrule[W-Extends]
	{\wj{\Gamma}{\tt T} \andalso \wj{\Gamma}{{\tt U}}}
	{\cj{\Gamma}{{\tt T}\extends {\tt U}}}

\infrule[L-Extends]
	{\Gamma\vdash {\tt T}\extends {\tt U}
         \andalso
         \Gamma,{\tt x}:{\tt U}\vdash {\tt x}~\has~{\tt I}}
	{\Gamma,{\tt x}:{\tt T}\vdash {\tt x}~\has~{\tt I}}

\infrule[S-Extends]
	{\Gamma\vdash {\tt T}\extends {\tt U}}
	{\Gamma\vdash {\tt T}\subtype {\tt U}}

\infrule[X-Subtype]
	{\Gamma\vdash {\tt T}\subtype {\tt U}}
	{\Gamma\vdash {\tt T}\extends {\tt U}}

\infrule[T-Type]
        {\wj{\Gamma}{\tt C\{{\tt c}\}}}
  {\Gamma\vdash{\tt C}\{{\tt c}\}:\type}
\caption{\FXG}
\label{fig:FXG}
\end{figure*}


\begin{figure*}
\centering
\begin{tabular}{r@{\quad}rcl}
  (Type)& {\tt T} &{::=}& \mbox{new base types, e.g., {\tt int}} \\
%  (Expression) & {\tt e} &{::=}& ${\tt f}(\tbar{e})$ \\
  (Constraint term) & {\tt t} &{::=}& ${\tt f}(\tbar{t})$ \\
  (Constraint) & {\tt c} &{::=}& ${\tt p}(\tbar{t})$ \\  
\end{tabular}

\infrule[W-Pred]
	{\mathcal{F}({\tt p}(\tbar{t}))\subseteq\mathcal{D}(\Gamma)} 
	{\cj{\Gamma}{{\tt p}(\tbar{t})}}
\caption{\FXD}
\end{figure*}

\subsection{\FXG}
We now turn to showing how \FGJ{} style generics can be supported in the \FX{} family.

\FXG{} is the language obtained by adding to \FXZ{} the productions and deduction rules of Figure~\ref{fig:FXG}.
%The constraint system specified by these changes will be called ${\cal G}$.

That is, first we introduce the ``type'' \type. \FGJ{} method type
parameters are modeled in \FXG{} as normal parameters of type
\type.\footnote{In concrete \Xten{} syntax type parameters are
distinguished from ordinary value parameters through the use of
``square'' brackets. This is particularly useful in implementing type
inference for generic parameters. We abstract these concerns away in
the abstract syntax presented in this section.}  Generic class
parameters are modeled as ordinary fields of type \type, with
parameter bound information recorded as a constraint in the class
invariant. This decision to use fields rather than parameters is
discussed further in Section~\ref{sec:parameters-vs-fields}. In brief,
it permits powerful idioms using fixed but unknown types without
requiring ``wildcards''.

The set of well-formed types is now enhanced to permit some fixed but unknown
types {\tt x} as well as \emph{path types} (cf. \cite{scala}), that is use type-valued fields of objects as types.\footnote{But we will not permit invocations of methods with return type \type\ to be 
used as types. This does indeed make sense, but developing
this theory further is beyond the scope of this paper.}

The key idea is that information about such types can
be accumulated through constraints.  Specifically we
permit the constraint . It may be used, for
instance, to specify upper bounds on type variables or fields (path
types).\eat{\footnote{To support structural typing, we permit the
programmer to use {\tt x\ \has\ I} constraints, see
Section~\ref{sec:structural-typing}.}}

\eat{
\begin{figure*}
\quad\\[-12pt]
\infrule[Path]
	{\Gamma \vdash {\tt p}:{\tt T} \andalso \Gamma, {\tt x:T} \vdash {\tt x}\ \has\ {\tt X}:\ \type}
	{\Gamma \vdash {\tt p}.{\tt X}\ {\tt ok}} 

\infax[Type-Var]{\Gamma, {\tt X}:\type \vdash {\tt X}~\type}

\infax[Equals]{{\tt S==T} \vdash S \extends T, T \extends S}

\infrule[Inh-p]
	{\Gamma \vdash {\tt p} \extends {\tt T} \andalso
        \Gamma, {\tt x}:{\tt T} \vdash {\tt x}\ \has\ {\tt I}}
	{\Gamma,{\tt x}:{\tt p} \vdash {\tt x}\ \has\ {\tt I}}

\infrule[Inh-X]
	{\Gamma \vdash {\tt X} \extends {\tt T} \andalso
        \Gamma, {\tt x}:{\tt T} \vdash {\tt x}\ \has\ {\tt I}}
	{\Gamma,{\tt x}:{\tt X} \vdash {\tt x}\ \has\ {\tt I}}
\caption{\FXG{} semantics}
\label{fig:fgj}
\end{figure*}
}

\begin{example}
The \FGJ{} parametric method:

\begin{xten} 
<T> T id(T x) { return x; }
\end{xten}
\noindent can be represented as
\begin{xten} 
def id(T: type, x: T): T = x;
\end{xten}
\end{example}

\begin{example}
\noindent The \FGJ{} class 
\begin{xten} 
class Comparator<B> {
  int compare(B y) { ... } }
class SortedList<T extends Comparator<T>> { 
  int m(T x, T y) {
     return x.compare(y); } }
\end{xten}
\noindent can be represented as
\begin{xtenmath} 
class Comparator(B: type) {
  def compare(y:B):int = ...;
}
class SortedList(T: type)
    {T $\extends$ Comparator{self.B==T}} { 
  def m(x:T, y:T):int = x.compare(y);
}
\end{xtenmath}
\end{example}

\subsection{\FXD}
We assume given a constraint system $\cal A$, with a vocabulary of
predicates {\tt q} and functions {\tt f}. These are used to 
augment the constraints expressible in the language. 

\begin{tabular}{r@{\quad}rcl}
  (Type) & {\tt T} & {::=}& \mbox{new base types, e.g., {\tt int}}\\
  (Constraint term) & {\tt t} &{::=}& $\tt f(\bar{\tt t})$ \\
  (Constraint) & {\tt c} &{::=}& ${\tt q(\bar{\tt t})}$ 
\end{tabular}

\noindent
The obvious rules are needed to ensure that formulas are well-formed.

{
\typicallabel{Equals}
\infrule[Pred]
	{\tt p(\bar{\tt T}):{\tt ok}\in {\cal C} \andalso \Gamma \vdash \bar{\tt t}:\bar{\tt T}}
	{\Gamma \vdash \tt p(\bar{\tt T}):o}

\infrule[Fun]
	{\tt f(\bar{\tt T}):{\tt T}\in {\cal C} \andalso \Gamma \vdash \bar{\tt t}:\bar{\tt T}}
	{\Gamma\tt \vdash \tt f(\bar{\tt T}):T}

\infrule[Equals]
	{\Gamma\tt \vdash t_0: T_0 \andalso \Gamma \vdash t_1: T_1}
	{\Gamma\tt \vdash t_0=t_1:o}
}
\noindent
No additional type judgments or transition rules are needed. 

\subsection{\FXGD} 

No additional rules are needed beyond those of \FXG{} and \FXD{}. This
language permits type and value constraints, supporting \FGJ{} style
generics and value-dependent types.


\subsection{Results}
The following results hold for \FXGD.

\begin{theorem}[Subject Reduction] If $\Gamma \vdash {\tt e:T}$
and $\Gamma \vdash {\tt T}~\type$ and ${\tt e} \derives {\tt e'}$, then
for some type {\tt S}, $\Gamma \vdash {\tt e':S},{S \subtype T}$.
\end{theorem}

The theorem needs the Substitution Lemma:
\begin{lemma} The following is a derived rule:
\infrule[Subst]
{\Gamma \vdash \bar{\tt d}:\bar{\tt U} \andalso \Gamma, \bar{\tt x}:\bar{\tt U} \vdash \bar{\tt U}\subtype\bar{\tt V} \andalso \Gamma, \bar{\tt x}:\bar{\tt V} \vdash {\tt e:T}}
{\Gamma \vdash {\tt e[\bar{\tt d}/\bar{\tt x}]:S}, {\tt S \subtype \bar{\tt x}:\bar{\tt A};T}}
\end{lemma}

We let values be of the form $\tt v ::= \new\ C(\bar{\tt v})$. 
\begin{theorem}[Progress]
If $\vdash {\tt e:T}$ and $\vdash {\tt T}~\type$
then one of the following conditions holds:
\begin{enumerate}
\item {\tt e} is a value,
\item {\tt e} contains a cast sub-expression that is stuck,
\item there exists an $\tt e'$ s.t. $\tt e\derives e'$.
\end{enumerate}
\end{theorem}

\begin{theorem}[Type soundness]
If $\vdash {\tt e:T}$ and $\vdash {\tt T}~\type$ and {\tt e}
reduces to a normal form ${\tt e'}$, then
either $\tt e'$ is a value {\tt v} and $\vdash {\tt v:S},{\tt S\subtype T}$ or
${\tt e'}$ contains  a stuck cast sub-expression.
\end{theorem}






\eat{
\begin{figure*}
\centering
\begin{tabular}{r@{\quad}rcl}
  (Member) & {\tt I} &{::=}& ${\tt f}: {\tt T}$ \alt ${\tt m}(\tbar{x} : \tbar{T})\{{\tt c}\}: {\tt T} = {\tt e}$ \\
  (Hypothesis) & {\tt h} &{::=}& ${\tt c}$ \alt ${\tt x}:{\tt T}$ \\
  (Consequence) & {\tt k} &{::=}& ${\tt c}$ \alt ${\tt e}:{\tt T}$ \alt ${\tt x\ \has\ I}$ \alt $\fields({\tt x})=\tbar{f}:\tbar{T}$ \alt ${\tt T}\subtype{\tt T}$ \\
  (Judgment) & {\tt j} &{::=}& $\tbar{h}\vdash\tbar{k}$
\end{tabular} 
\caption{\FX{} judgments}
\end{figure*}
}
