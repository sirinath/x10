\Xten{} is a class-based object-oriented language.
that provides both dependent and generic types.
The language has a sequential core similar to Java or Scala, but
also
constructs for concurrency and distribution.
This section describes the design of generics for \Xten,
including several alternative designs.

%\footnote{We plan
%to support traits in a future version of the language.}
\todo{emph interactions with data constraints}

\subsection{Type constraints}

To permit genericity, variables \Xcd{X} must be admitted over types.
The choice of type variables is discussed below.  We assume here
that classes have a means of introducing new type variables.
For instance,
the class \xcd"List" introduces a type variable \xcd"X"
representing the list's element type.
Here, we ask: how should type variables be constrained?
\Xten already supports constraints over values, so it is natural
to extend these to constraints over types.

\subsubsection{Subtyping and equality constraints}

In class-based OO languages such as Java,
types are equipped with a partial
order (the \emph{subtyping} order) generated from the user program
through the ``\Xcd{extends}'' relationship.  Further, each type is
associated with member fields and methods, each with their
name and signature.
This motivates a very natural constraint system on types.  For a type
variable \Xcd{X} we should be able to assert the constraint \Xcd{X}
$\extends$ \Xcd{T}: a valuation (mapping from variables to types) realizes
this constraint if it maps \Xcd{X} to a type that extends \Xcd{T}.
Constraints on types can specify either subtype (\xcd"<="),
supertype (\xcd">="), or equality bounds (\xcd"==").

Constraints occur in several places in the \Xten syntax.  They
are of course permitted in constrained types \xcd"C{c}".
Constraints may also be used as \emph{class invariants}, 
which are constraints on the class's properties and other
final variables in scope.
The class invariant must be established by the class's
constructor and subsequently holds for all instances of the
class.

Using subtyping constraints in the class invariant provides a
means to bound the type variables introduced by the class
declaration.  Subtyping constraints in constrained types
\xcd"C{c}", can bound
type-valued members of the base type \xcd"C".

Methods and constructors
may also have additional
constraints, or \emph{guards}, on their parameters.  A
guard must be satisfied by the caller of the method and
will hold throughout its body.  Type constraints used in the
method guard restrict the types of the arguments or the method
receiver.  
This feature is similar to optional methods in CLU~\cite{clu} and to generlized type constraints in C$\sharp$~\cite{emir06}.

For instance, given a list of \xcd"T", one could define a
method \xcd"print" with a guard that requires that \xcd"T" be a
subtype of \xcd"Printable":
\begin{xtenmathnoindent}
  def print(){T <= Printable} {
    head.print();
    Console.OUT.print(" ");
    tail.print();
  }
\end{xtenmathnoindent}
This constraint ensures that the \xcd"head" field of type
\xcd"T" has a \xcd"print()" method.

\subsubsection{Structural consraints}
We considered other constraints on types as well.
One should
be able to require that a type have a
particular member---a field with a given name and type, or a method
with a given name and signature.
We introduce the constraints 
\Xcd{T} \Xcd{has} \Xcd{f:T} and \Xcd{T} \Xcd{has}
\Xcdmath{m($\tbar{x}\ty\tbar{S}$):T} to express this.
These
constraints allow one to define \xcd"List.print" as:
\begin{xtenmathnoindent}
  def print(){T has print(): void} {
    head.print();
    Console.OUT.print(" ");
    tail.print();
  }
\end{xtenmathnoindent}

Structural constraints on types are found in many languages.
For instance,
Haskell supports type
classes~\cite{haskell,haskell-type-classes}.
%
%ML's module system allows modules to be constrained by
%structural signatures~\cite{ml}.
In Modula-3, type equivalence is structural
rather than nominal as in object-oriented languages of the C
family (e.g., C++, Java, and \Xten{}).
Unity~\cite{malayeriIntegrating08}
is a Java-like language with both nominal and structural subtyping.

In the class invariant, a structural constraint can bound the
class's type variables, similarly to 
the language PolyJ~\cite{java-popl97}, which allows type
parameters to be
bounded using
structural \emph{where clauses}~\cite{where-clauses}.
For example, a sorted list class
could be written as follows in PolyJ:
{
\begin{xtennoindent}
class SortedList[T]
    where T {int compareTo(T)} {
  void add(T x) {... x.compareTo(y) ...}
  ...
}
\end{xtennoindent}}
The \xcd"where" clause states that the type parameter
\xcd"T" must have a
method \xcd"compareTo" with the given signature.
\xcd"SortedList" can be instantiated on any type
that provides the method with the given signature.
With nominal bounds, \xcd"SortedList" could only require that
its parameters implement an interface such as \xcd"Comparable".

\subsubsection{Default values}
\Xten's type system provides both reference types and value
types.  An instance of a reference type is an object on the
heap.  Variables of reference type may be \xcd"null".
In contrast, an instance of a value type might live on the stack
and can never be \xcd"null".  In languages like Java with
primitive types, every type has a default value---\xcd"null" for
reference types and \xcd"false" or \xcd"0" for primitive
types---used to initialize arrays of that type.
In \Xten, some types do not have a default.  For example
\xcd"int{self>0}" does not contain the value \xcd"0".
Consequently, a useful constraint is \xcd"T has default", which
holds if the type \xcd"T" has a default value.

\subsubsection{instanceof constraints}

Lastly, we consider constraints of the form \xcd"x" \xcd"instanceof" \xcd"T".
By relating types and values in a single constraint, 
these constraints provide considerable expressive power.
For instance, 
consider the class declaration:
\begin{xtennoindent}
class Cell {
  var value: Object;
  def increment() {value instanceof Number} { value += 1; }
}
\end{xtennoindent}
The \xcd"increment" method can be called only if the value
stored in the \xcd"Cell" is an instance of \xcd"Number".

\xcd"instanceof" constraints can be used to build intersection
types, e.g., \xcd"Object{self instanceof A, self instanceof B}"

\subsection{Type variables}
\label{sec:type-properties}
\label{sec:variance}

To permit genericity, variables \Xcd{X} must be admitted over types.
Languages such as Java~\cite{Java3} and
Scala~\cite{scala} introduce \emph{type parameters} on classes
and methods.
Constrained types suggest another approach:
generalizing properties to include type-valued properties.
A \emph{type property}
is a final object member initialized at construction-time with a
concrete type.  

\subsubsection{Type properties}

\label{sec:usability}
\label{sec:parameters-vs-fields}

Like normal value properties, type properties
can be used in constrained types through the variable \xcd"self".
%
This immediately suggests use-site variance constraints on type
properties.
The type of a list of integers, say, can be written as
\xcd"List{self.T==int}".  
Subtyping constraints, then, may be used to
provide \emph{use-site variance} constraints.
Use-site variance based on structural virtual types was proposed by
Thorup and Torgerson~\cite{unifying-genericity} and extended for
parametrized type systems by Igarashi and
Viroli~\cite{variant-parametric-types}.  The latter type system lead
to the development of wildcards in
Java~\cite{Java3,adding-wildcards,wildcards-safe}.  Constrained
type properties
have similar expressive power.

Consider the following subtypes of \xcd"List":
\begin{itemize}
\item \xcd"List".  This type has no constraints on the type
property \xcd"T".
Any type that constrains \xcd"T"
is a subtype of \xcd"List".  The type \xcd"List" is equivalent to
\xcd"List{true}".
%
For a \xcd"List" \xcd"v", the return type of the \xcd"get" method
is \xcd"v.T".
Since the property \xcd"T" is unconstrained,
the caller can only assign the return value of \xcd"get"
to a variable of type \xcd"v.T" or of type \xcd"Object".

\item \xcd"List{T==float}".
The type property \xcd"T" is bound to \xcd"float".
For a final expression \xcd"v" of this type,
\xcd"v.T" and \xcd"float" are equivalent types and can be used
interchangeably.
The syntax \xcd"List[float]" is used as
shorthand for \xcd"List{T==float}".

\item \xcdmath"List{T$\extends$Collection}".
This type constrains \xcd"T" to be a subtype of \xcd"Collection".
All instances of this type must bind \xcd"T" to a subtype of
\xcd"Collection"; for example \xcd"List[Set]" (i.e.,
\xcd"List{T==Set}") is a subtype of
\xcdmath"List{T$\extends$Collection}" because \xcd"T==Set" entails
\xcdmath"T"
\xcdmath"$\extends$"
\xcdmath"Collection".
%
If \xcd"v" has the type \xcdmath"Vector{T$\extends$Collection}",
then the return type of \xcd"get" has type \xcd"v.T", which is an unknown but
fixed subtype of \xcd"Collection"; the return value can be
assigned into a variable of type \xcd"Collection".

\item \xcdmath"Vector{T$\super$String}".  This type bounds the type property
\xcd"T"
from below.  For a \xcd"Vector" \xcd"v" of this type, any
supertype of \xcd"String" may flow into a variable of type \xcd"v.T".
The return type of the \xcd"get"
method is known to be a
supertype of \xcd"String" (and implicitly a subtype of \xcd"Object").
\end{itemize}

However,
type properties have a number of usability issues.
The key difference between type parameters and type properties
is that type properties are
instance \emph{members} bound during object construction.  Type
properties are thus accessible through expressions---\xcd"e.T" is
a legal type (if \xcd"e" is final)---and are inherited by subclasses.
These features gives type properties more expressive power than
type parameters, as we shall describe below; however, because they 
provide similar functionality with often subtle distinctions,
type properties can be difficult to use, especially for novices,
and requires more care in the design.

One usability issue is that
type properties, like normal value properties, are inherited.
The language design needs
to account for ambiguities introduced when the same name is
used for different type properties declared in or inherited into a class.
These can be disambiguated
by ``casting'' the target up to the desired supertype,
e.g., \xcd"(e as C).X" specifies
the property \xcd"X" inherited from \xcd"C".

Another issue is the interaction of type properties and run-time
type representations.  If type properties are not erased from
the run-time representation (as
type parameters as in Java, for instance), then a naive user
might waste storage by unnecessarily declaring properties.
As an example, in the following hypothetical code extended with
type properties (declared as normal properties with the ``type''
\xcd"*"),
\xcd"HashMap"  inherits the properties \xcd"K" and \xcd"V" from
\xcd"AbstractMap".
\begin{xten}
class AbstractMap(K:*, V:*) {
  abstract def get(K): V;
  abstract def put(K, V): V;
}

class HashMap implements Map {
  def get(k: K): V = ...;
  def put(k: K, v: V): V = ...;
}
\end{xten}
A user more familiar with type parameters might declare
\xcd"HashMap" as follows:
\begin{xten}
class HashMap(K:*,V:*) implements Map(K,V) {
  def get(k: K): V = ...;
  def put(k: K, v: V): V = ...;
}
\end{xten}
This declaration would introduce a new pair of type properties
named \xcd"K" and
\xcd"V" that shadow the inherited properties.
A na{\"\i}ve implementation of type properties would store run-time
type information for all four properties in each instance
of \xcd"HashMap".

\subsubsection{Virtual types}

Type properties provide expressive power much like 
\emph{virtual types}~\cite{beta,mp89-virtual-classes,ernst06-virtual}
, but they can also
be constrained at the use-site,
can be refined on a per-object basis without explicit subclassing,
and can be refined contravariantly as well as covariantly.

Thorup~\cite{thorup97}
proposed adding genericity to Java using virtual types.  For example,
a generic \xcd"List" class can be written as follows:
{
\begin{xten}
abstract class List {
  abstract typedef T;
  T get(int i) { ... }
}
\end{xten}}
\noindent
The virtual type \xcd"T" is unbound in \xcd"List", but 
can be refined by binding \xcd"T" in a subclass:
{
\begin{xten}
abstract class NumberList extends List {
  abstract typedef T as Number;
}
class IntList extends NumberList {
  final typedef T as Integer;
}
\end{xten}}
\noindent
Only classes where \xcd"T" is final bound, such as \xcd"IntList",
can be non-abstract.
%
The analogous definition of 
\xcd"List" in \Xten{} using type properties is as follows:
{
\begin{xten}
class List[T] {
  def get(i: int): T { ... }
}
\end{xten}}

\noindent
Unlike the virtual-type version,
the \Xten{} version of \xcd"List" is not abstract;
\xcd"T" need not be instantiated by a subclass because it can be
instantiated on a per-object basis.
Rather than declaring subclasses of \xcd"List",
one uses the constrained subtypes
\xcdmath"List{T$\extends$Number}" and \xcd"List{T==Integer}".

Type properties can also be refined contravariantly.
For instance, one can write the type \xcdmath"List{T$\super$Integer}".

Dependent classes~\cite{dependent-classes} generalize virtual
classes to express similar semantics via parameterization rather
than nesting.  Virtual classes depend only other their enclosing
instance; dependent classes, in contrast, depend on any number
of objects in which they are parameterized.  With type
properties, classes are not parameterized on their values;
rather properties are members and types are constructed by
constraining these properties.  Parameterization can be 
encoded with type properties using equality constraints.

\subsubsection{Type parameters}

Most OO languages provide genericity through type parameters on
classes and methods.  The development of a nominal OO type
system with type parameters is now standard (cf.  FGJ~\cite{FJ}).

Scala~\cite{scala} supports definition-site variance
annotations:
a parameter may be declared invariant, covariant, or
contravariant.
If the parameter \xcd"X" of a class \xcd"C" is covariant,
then if \xcd"S" is a subtype of
\xcd"T", the type \xcd"C[S]" is a subtype of \xcd"C[T]".
Similarly, if \xcd"X" is contravariant,
\xcd"C[T]" is a subtype of \xcd"C[S]".
Invariant parameters are the default; a covariant parameter is
declared by prepending ``\xcd"+"'' to the parameter name in the
class header; a contravariant parameter is declared by
prepending ``\xcd"-"''.  The usage of variant parameter types is
restricted to ensure the subtyping relation holds.

Java~\cite{Java3}, by contrast, supports use-site variance through wildcards.
This has a number of usability problems~\cite{wildcards-are-evil},
which also occur with constrained type properties, above.


\subsection{Overloading and dispatch}

overloading on constraints

predicate dispatch

\begin{xtennoindent}
class List[T] {
  head: T;
  tail: List[T];

  def print() {T <= Printable} {
    head.print();
    tail.print();
  }

  def print() {
    print("unprintable");
  }
}
\end{xtennoindent}

\subsection{Implementation}

erasure -- erase everything, erase constraints only, etc

parameterized closures

homo- or heterogeneous translation

        complicated by struct types

run-time constraint solving

Unlike Java's generics, the \Xten does not erase type
parameters.  This allows \Xten to support run-time casts to 
generic types, including types instantiated on constrained
types.
With
non-generic constrained types, casts like \xcd"r" \xcd"as"
\xcd"Region{rank==k}" can be implemented by
checking the run-time class of the value being cast---\xcd"r" \xcd"instanceof" \xcd"Region"---and then
evaluating the constraint---\xcd"r.rank==k".

However, the issue is more subtle with generic casts.
For instance, to implement
\xcd"a" \xcd"as" \xcd"Array[int{self>=0}]"
one must check at run time that the concrete type used to instantiate
the \xcd"Array"'s type parameter is equivalent to
\xcd"int{self>=0}".  This check could involve a run-time
entailment check, 
breaking the phase distinction between
compile time and run time for constraint solving.

\input{cast}

\subsection{X10 design decisions}

Nominal bounds.

Use closures if you want structural bounds.

Type variables: parameters.  Properties are just too unfamiliar.
Usability outweights expressive power. 

Variance: def site.

