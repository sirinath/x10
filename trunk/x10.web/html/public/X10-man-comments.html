<html>
<p> List of comments received on Version 0.4095 of the X10 Language Reference Manual.

<p> From Armando Solar-lezama:
<pre>
I haven't gone over the whole thing yet (I am on page 14), but here are the comments I have so far.

Section 1.1
* Section 1.1 would be a good place to state that you have a branch-and-merge model where you initially start with one activity. (See comment 2 for section 6); I think it's easy for a programmer from the SPMD world to make it to section 2 and still think that you start with one activity per place in an SPMD fashion.

Section 1.2
* The last sentence mentions clocked final variables, but I don't think they are mentioned anywhere else in the report.

Section 1.5
* In the first paragraph, I don't think the description of an array as a function from a distribution to a base type is accurate. When you say f is a function from A to B, it is understood that A and B are sets and the function takes an element from A and returns an element in B, but a distribution is not a set, it's a map, so I am left to guess whether the sentence is to be read as:" an array is a function from the set of distributions to a base type", which it is not, or to interpret a distribution as a set of pairs of the form (point, place), in which case the definition makes more sense, but is still confusing.

Section 1.8
* When you say that X10 is more general than MPI, I think some of the MPI people will take issue with some of the arguments, in particular: 
a) I believe MPI 2 allows for one sided communication, so it can be said that MPI2 also does not require synchronization between two processes in order to enable one to read and write the other's values.
b) If you do pure MPI, you will never have multiple activities running in the same node, so atomic sections don't matter.
c) If you are disciplined about using MPI communicators, they address this problem. Granted, nobody who writes real MPI code is that disciplined, but MPI people will take issue with this point.
d) I think this is the most relevant one and should be the very first one mentioned instead of the last one.

Section 3.2
* In paragraph "Arrays of nullary type", you should reference section 10.3 where you describe array initializers, and point out that when the array type is non-nullable, you require an array initializer (because you do, right?).
* I don't quite understand the rationale you give for nullable. It says "The need for nullable arose because X10 has value types and reference types..."; does this mean that if you didn't have value types there would be no need for nullable? In fact the sentence is kind of selfe contradictory because after claiming value and reference types to be a motivation for nullable, it acknowledges that the ability to add a null value to a type is orthogonal to whether the type is a value type or a reference type. Given that at least part of the target audience are people from the high performance community, we should at least mention the fact that non-nullable fields eliminate the need for null checks.

Section 3.6
* Last bullet, why do you have to incurr communication cost even once to compare two pointers you already have using the == or != operators?


Section 3.7.3 
* Bad reference in the last paragraph before Future Extensions.

Section 6
* In the first paragraph, you say "An activity may not be interrupted, suspended or resumed as a result of actions taken by any other activity" I believe the interrupted and suspended part, but clocks and conditional atomic sections allow activities to resume a suspended activity, right?
* The sentence "An X10 computation is initiated as a single activity from the command line."; this should be said somewhere in the introduction. For people coming from the UPC/Co-Array-Fortran world, this will come as a surprise, and not knowing this will make some of the previous sections confusing. May be say this next to where you say that X10 is not SPMD.

Section 6.1
* The very last sentence, "thrown on the floor"; should probably that read "droped on the floor"?

Section 6.5
* On page 14 you say "Here we use syntax for gneric classes. X10 v0.4 does not support..." This comment should probably appear the first time you mention generics.
* What are the restrictions on futures? I seem to remember that to guarantee deadlock freedom, you didn't allow futures to be forced from an activity other than the activity that created the future, and you can't clock a future. No restrictions are mentioned in 6.5.

Section 3.6
* Last bullet, why do you have to incurr communication cost even once to compare two pointers you already have using the == or != operators?
ANSWER: OK, I got it; this is clear once you realize what stable equality actually means; so you are not just comparing pointers, also values.

Section 6.3
*Exceptions thrown by a finish. Does a finish throw only one of the many exceptions thrown by threads inside it, or does it throw some kind of exception set. If it throws an exception set, what's the name of this class?


Section 7
* On page 17, the sentence "In particular, nested clocks are permitted: an activity may create a nested clock and within one phase of the outer clock schedule activities to run to completion on the nested clock" has a couple of problems. First, it would be more readable if it said:
"In particular, nested clocks are permitted: an activity may create a nested clock and schedule activities to run to completion on the nested clock within one phase of the outer clock."
Also, what does it mean to "schedule activities to run to completion on the nested clock"? My guess is that this means that the activity can create a set of activities, and make them run synchronized on the nested clock without advancing the outer clock.

* In the last paragraph, "For, before blocking each activity resumes all clocks it is registered with." Using For as a transition sounds funny. Also, at this point it is mentioned that the next resumes all clocks it is registered with as if it was something the reader already knew, but this is in fact the first time it is mentioned.

*The last paragraph condenses very nicely the argument for why clocks can not lead to deadlock. After reading this paragraph, I am pretty much convinced that clocks are deadlock free. However, there is no such paragraph for the other important claim, the fact that clocks are race free. When I first read about X10, it took me a while to convince myself that clocks are indeed race free. 
It would be good to note that the only race that could cause problems is a race between thread registration on a clock and quiescence detection on a clock, but such a race can't happen because the only two ways a thread can register on a clock is by creating the clock, which is obviously race free because at that point only one thread has access to the clock, and thread creation. Thread creation is thread free because the only way a newly created thread can be registered on a clock is if the parent is registered on the same clock, so there can't be any race between quiescence detection and thread creation.

Section 10
* A question that is bound to pop into the head of anyone from the scientific computing community who reads this:
"If you have array A1 on place P1, and array A2 on place P2, how do you copy the contents of A1 into A2 without spawning one async per element of A1/A2?"
I don't know the answer. Can you do this?


Other than that, it looks good. One more thing though; the grammar for the different constructs looks a bit cluttered, for example, I think a lot of the NoShortIf statements are there mostly to please a compiler generator, but they don't help with redability.

</pre>

