<html>
<p> List of comments received on Version 0.4095 of the X10 Language Reference Manual.

<p> From Armando Solar-lezama (07/27/05):
<pre>

I haven't gone over the whole thing yet (I am on page 14), but here
are the comments I have so far.

Section 1.1

* Section 1.1 would be a good place to state that you have a
branch-and-merge model where you initially start with one
activity. (See comment 2 for section 6); I think it's easy for a
programmer from the SPMD world to make it to section 2 and still think
that you start with one activity per place in an SPMD fashion.

Section 1.2

* The last sentence mentions clocked final variables, but I don't
think they are mentioned anywhere else in the report.

Section 1.5

* In the first paragraph, I don't think the description of an array as
a function from a distribution to a base type is accurate. When you
say f is a function from A to B, it is understood that A and B are
sets and the function takes an element from A and returns an element
in B, but a distribution is not a set, it's a map, so I am left to
guess whether the sentence is to be read as:" an array is a function
from the set of distributions to a base type", which it is not, or to
interpret a distribution as a set of pairs of the form (point, place),
in which case the definition makes more sense, but is still confusing.

Section 1.8

* When you say that X10 is more general than MPI, I think some of the
MPI people will take issue with some of the arguments, in particular:

a) I believe MPI 2 allows for one sided communication, so it can be
said that MPI2 also does not require synchronization between two
processes in order to enable one to read and write the other's values.

b) If you do pure MPI, you will never have multiple activities running
in the same node, so atomic sections don't matter.

c) If you are disciplined about using MPI communicators, they address
this problem. Granted, nobody who writes real MPI code is that
disciplined, but MPI people will take issue with this point.

d) I think this is the most relevant one and should be the very first
one mentioned instead of the last one.

Section 3.2

* In paragraph "Arrays of nullary type", you should reference section
10.3 where you describe array initializers, and point out that when
the array type is non-nullable, you require an array initializer
(because you do, right?).


* I don't quite understand the rationale you give for nullable. It
says "The need for nullable arose because X10 has value types and
reference types..."; does this mean that if you didn't have value
types there would be no need for nullable? In fact the sentence is
kind of selfe contradictory because after claiming value and reference
types to be a motivation for nullable, it acknowledges that the
ability to add a null value to a type is orthogonal to whether the
type is a value type or a reference type. Given that at least part of
the target audience are people from the high performance community, we
should at least mention the fact that non-nullable fields eliminate
the need for null checks.

Section 3.6

* Last bullet, why do you have to incurr communication cost even once
to compare two pointers you already have using the == or != operators?


Section 3.7.3 
* Bad reference in the last paragraph before Future Extensions.

Section 6

* In the first paragraph, you say "An activity may not be interrupted,
suspended or resumed as a result of actions taken by any other
activity" I believe the interrupted and suspended part, but clocks and
conditional atomic sections allow activities to resume a suspended
activity, right?

* The sentence "An X10 computation is initiated as a single activity
from the command line."; this should be said somewhere in the
introduction. For people coming from the UPC/Co-Array-Fortran world,
this will come as a surprise, and not knowing this will make some of
the previous sections confusing. May be say this next to where you say
that X10 is not SPMD.

Section 6.1

* The very last sentence, "thrown on the floor"; should probably that
read "droped on the floor"?

Section 6.5

* On page 14 you say "Here we use syntax for gneric classes. X10 v0.4
does not support..." This comment should probably appear the first
time you mention generics.

* What are the restrictions on futures? I seem to remember that to
guarantee deadlock freedom, you didn't allow futures to be forced from
an activity other than the activity that created the future, and you
can't clock a future. No restrictions are mentioned in 6.5.

Section 3.6

* Last bullet, why do you have to incurr communication cost even once
to compare two pointers you already have using the == or != operators?
ANSWER: OK, I got it; this is clear once you realize what stable
equality actually means; so you are not just comparing pointers, also
values.

Section 6.3

*Exceptions thrown by a finish. Does a finish throw only one of the
many exceptions thrown by threads inside it, or does it throw some
kind of exception set. If it throws an exception set, what's the name
of this class?


Section 7

* On page 17, the sentence "In particular, nested clocks are
permitted: an activity may create a nested clock and within one phase
of the outer clock schedule activities to run to completion on the
nested clock" has a couple of problems. First, it would be more
readable if it said:

"In particular, nested clocks are permitted: an activity may create a
nested clock and schedule activities to run to completion on the
nested clock within one phase of the outer clock."

Also, what does it mean to "schedule activities to run to completion
on the nested clock"? My guess is that this means that the activity
can create a set of activities, and make them run synchronized on the
nested clock without advancing the outer clock.

* In the last paragraph, "For, before blocking each activity resumes
all clocks it is registered with." Using For as a transition sounds
funny. Also, at this point it is mentioned that the next resumes all
clocks it is registered with as if it was something the reader already
knew, but this is in fact the first time it is mentioned.

*The last paragraph condenses very nicely the argument for why clocks
can not lead to deadlock. After reading this paragraph, I am pretty
much convinced that clocks are deadlock free. However, there is no
such paragraph for the other important claim, the fact that clocks are
race free. When I first read about X10, it took me a while to convince
myself that clocks are indeed race free.

It would be good to note that the only race that could cause problems
is a race between thread registration on a clock and quiescence
detection on a clock, but such a race can't happen because the only
two ways a thread can register on a clock is by creating the clock,
which is obviously race free because at that point only one thread has
access to the clock, and thread creation. Thread creation is thread
free because the only way a newly created thread can be registered on
a clock is if the parent is registered on the same clock, so there
can't be any race between quiescence detection and thread creation.

Section 10

* A question that is bound to pop into the head of anyone from the
scientific computing community who reads this: "If you have array A1
on place P1, and array A2 on place P2, how do you copy the contents of
A1 into A2 without spawning one async per element of A1/A2?"  I don't
know the answer. Can you do this?


Other than that, it looks good. One more thing though; the grammar for
the different constructs looks a bit cluttered, for example, I think a
lot of the NoShortIf statements are there mostly to please a compiler
generator, but they don't help with redability.

</pre>

<p> More comments from Armando:
<pre>
First, another comment on the Report, 

Section 3.4

* In the grammar, rules 442-444 use DepParameterExpr, but it is never
explained what this DepParameterExpr is, or how it looks like.


Now, I noticed that the X10 compiler produces an error if I try an
initialization like:

	int [1:64] p = { 58, 50, 42, 34, 26, 18, 10, 2,
		       60, 52, 44, 36, 28, 20, 12, 4,
		       62, 54, 46, 38, 30, 22, 14, 6,
		       64, 56, 48, 40, 32, 24, 16, 8,
		       57, 49, 41, 33, 25, 17, 9, 1,
		       59, 51, 43, 35, 27, 19, 11, 3,
		       61, 53, 45, 37, 29, 21, 13, 5,
		       63, 55, 47, 39, 31, 23, 15, 7
	};

I get the following error:
/home/asolar/eclipse/workspace/x10/examples/Dataflow/DES.x10:71-79: Cannot
    initialize x10.lang.IntReferenceArray with int[].
	int [1:64] p = { 58, 50, 42, 34, 26, 18, 10, 2,
	                   ^---------------------------
	...
	};
	---^

What is the proper way to initialize an array with a set of values? 

Also, the distinction between Type [] and Type [.] is kind of
anoying. It reminds me of a problem Titanium has that it makes a
distinction between Java arrays and Titanium arrays, in their case
because they wanted to be backward compatible with java, but this is
troublesome, particularly because it's too tempting for programmers to
just stick to the Java arrays when writing code, and once you have
written alot of code using Java arrays it's too much trouble to go
back and change things to work with Titanium arrays.

Also, when having an array as a formal parameter to a method, you can
only choose between the Type[] type, where the system knows the array
is dimension 1 and from 0 to N, and the Type[.] type, where the
compiler knows absolutely nothing about the array that is coming
in. Is that all? What if you know you are going to be passing an array
of dimension 2, how do you express that?  
</pre>

<p> Comments from David Bacon (07/28/05):
<pre>
general comments:

the clock stuff is cool.  ditto the use of titanium-like domains.

i've played around with extending domains to "partitions", which have the
property of being a domain and a set of domains whose disjoint union is that
domain (one can be called "rest" and sometimes treated specially).  this
gives you the capability to do operations that are flexible in terms of
run-time distribution and yet statically checkable.  seems like a
generalization of range restriction (10.2.1).

you should really consider modularity issues, and adding something like
modjava.  there is now a modularity jsr (277).  what are the semantics of
classloaders wrt places?  how will classloaders scale across this huge
system?  what are the code synchronization implications?

finalization/weak/soft/phantom references are fairly deeply broken, and the
problems are likely to be exacerbated in a language like x10 and its
massively parallel target environment.  consider fixing this.

comments in document order:

3.5.1 "x10 follows java rules for final" -- java's rules allow finals that
aren't final if the constructed object escapes the c'tor.  this causes all
manner of misery, and doesn't scale.   i think you should architect that
out.  same thing for static final fields -- another good reason to have
modules.

3.6 "instanceof" -- add an "exactinstanceof" which is often what you want,
and whose lack in java is a major annoyance that leads to frequent errors.

5.0 "next() returns the next place in the total order" -- is this scalable?

6.3 "may introduce a finishone construct" -- if you are thinking about
asynchronous aborts you need to design this in now to avoid the problems
java had wrt killing off threads.  take a look at the RTSJ
AsynchronouslyInterrupedException, for example, although that has its
problems.

7.1.1 "nullary constructor for clock via a factory method" -- this is
awkard.  why is this exposed to the programmer?  i assume the constructor is
private?

9.0 "should use singleton classes" -- i'm not sure how singletons interact
with places, but if you can't have "per place statics", you might want to
consider something like what we did in guava where you could attach
variables to a process.  it scales and has a clean semantics.  it allows you
to avoid the conflict between having a global (very bad) and passing a
gazillion parameters (very ugly).

9.2.0 values -- i'm pleased to see that the inheritance hierarchy now
disallows cross-mutability inheritance.  there still isn't mention of a
Value class from which values inherit, which would allow the definition of
methods that operate on parameters known to be immutable.  depending on java
compatibility issues, it would also be good to have a Mutable (or Stateful
or whatever) interface.

however, your values are still not values.  "3" is a value, and has the
property that f(3)==f(3) assuming that f() does not access global non-value
state.  an x10 "value" with non-value references in it lacks this property,
and is therefore "constant" but not "value".  consider having a
sub-hierarchy of true values (called "value") and an intermediate thing (a
"stateless").  this allows the specification of things that are truly
values, and the enforcement that subclasses will not violate the value-ness
property.

if not, at the very least don't confuse people with the term "value" and use
something like "stateless" or "immutable" or "constant" or whatever.
preferably, something that emphasizes their distastefulness.

another important distinction for (true) values is that you can have
"literals" for them.  the java rules for constant expressions can easily be
extended to allow a rich set of value literals.  the non-value stateless
things will bite you when you try to do this, and you will likely wind up
effectively adding values with some tortured language rule that says that
only "values" that are really *values* can have literals -- effectively
defining a non-type type.

consider having a more convenient value constructor syntax, like
"#complex(1.0, -5.3)" to avoid horrifically ugly code for scientific
programmers.  this then folds in to the literal issue.

consider adding operator overloading for the same reason.  josh bloch had
some interesting ideas about adding some sanity to overloading by having
overloaded operators become available when you define classes that implement
certain (pseudo) algebraic properties.

of course, the "non-final final" issue of 3.5.1 is even more crucial for
values.

9.2.1 "implementation may even dynamically change the representation" -- 
irrelevant, and not specific to values.  this is simply a by-product of a
true virtual machine.

9.2.2 "first" field in example -- very weird to have a linked list with N
"first" things.

10.1.0 "1:100" same as "[1:100]" -- why??  yuck.

10.1.0 "region AandB = A && B" -- you should use the "&" operator here, by
extension with bitwise "intersection" operator.  "&&" has a semantics which
ignores individual set elements.  ditto for "||".

10.2.1 "point i to pi" -- everyone will assume that "pi" is "point i".  use
qi by analogy to the set Q.

10.2.3 "D1 && D2" -> "D1 & D2", as for 10.1.0

10.4.1 "a[i] op= e" -- huh?  meaning totally unclear.

10.4.5 scans, "a || m()" -- eek!  another good reason not to use "||" for
set operations.

</pre>

<p> Comments from Maged Michael (07/28/05)
<pre>

- Section 1: The first sentence states that "X10 may be thought of as
(generic) Java less concurrency, ..." Is it necessary to say "less
concurrency"? X10 supports concurrency (both inter-place and
intra-place) no less than Java.

- Section 1.1: "Indeed, all accesses to mutable shared data must
occur." This may be confusing. It may be construed to mean that the
programmer have to put every access to shared data explicitly in an
atomic section. This may also be confusing about the meaning of z = x
+ y (x, y, z are mutable shared). Does it mean atomic {z = x + y;}
which maybe stronger than the programmer intends, or is it atomic {r1
= x;} atomic {r2 = y;} atomic {z = r1 + r2;}.

- Section 1.9.2: In the context of saying that clocks and
unconditional atomic are guaranteed to be deadlock-free the text
states "(assuming the implementation is correct)". This is a bit
confusing. Which implementation? The X10 implementation of clocks and
atomics? or the programmer's use of clocks and atomics?

- Section 6.6.2" "Further, an atomic block will eventually terminate
successfully or throw[n] an exception, it may not introduce a
deadlock." Actually, an unconditional atomic section may run forever
without any possibility of either terminating successfully or throwing
an exception. For example, consider the following code fragment:

	head = new Node(); head.data = null;
	head.next = head; /* Programming bug. Should be head.next = null; */
	.....
	/* search for a node with data == 42 */
	atomic {
		nullable Node n = head.next;
		while (n != null)	{ if (n.data == 42) return true; n = n.next; }
		return false;
	}

- The document could say something about supporting scalable high
concurrency implementations of shared data structures. I'll send you
something shortly.

Typos:
- Background: "mange" instead of "manage".
- Section 1.4: "may defined" instead of "may define".
- Section 1.9.2: "permit permit" instead of "permit".
- Section 3.73: "refLiterals" instead of "\ref{Literals}".
- Section 6.6.1: "or thrown" instead of "or throw".
- Section 6.6.3: "aync" instead of "async".
- All over the document: "X10 v0.4" Is this right? or should be "X10 v0.4095"?
</pre>