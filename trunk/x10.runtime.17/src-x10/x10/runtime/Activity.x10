/*
 *
 * (C) Copyright IBM Corporation 2006-2008.
 *
 *  This file is part of X10 Language.
 *
 */

package x10.runtime;

import x10.util.List;
import x10.util.Stack;

/**
 * The representation of an X10 async activity.
 * Note that an Activity object is created by a different thread than the one that executes it. 
 * @author Christian Grothoff, Christoph von Praun, vj
 * @author Raj Barik, Vivek Sarkar
 * @author tardieu
 */
public abstract class Activity(name: String) {
	/**
	 * The FinishState of this activity. 
	 */
	private var finishState: FinishState;

	/**
	 * The finishStack is lazily created.
	 */
	private var finishStack: Stack[FinishState];

	/**
	 * The clock phases of this activity. Lazily created.
	 */
	private var clocks: Clocks;
	
	/**
	 * The clocks of the current activity.
	 */
	def clocks(): Clocks {
		if (null == clocks) clocks = new Clocks();
		return clocks;
	}
	
	/**
	 * Next statement = next on all clocks in parallel.
	 */
	def next(): void {
		if (null != clocks) clocks.next();
	}
	
	// public constructors

	/**
	 * Create an activity.
	 */
	public def this(name: String) {
	    property(name);
	}

	public def this() {
	    this("");
	}

	/**
	 * Create an activity with the given list of clocks.
	 */
	public def this(list: List[Clock], name: String) {
	    this(name);
	    clocks = new Clocks();
		clocks.register(list);
	}

	public def this(list: List[Clock]) {
	    this(list, "");
	}

	/**
	 * Create an activity with the given clock.
	 */
	public def this(clock: Clock, name: String) {
	    this(name);
	    clocks = new Clocks();
	   	clocks.register(clock);
	}

	public def this(clock: Clock) {
	    this(clock, "");
	}

	// runnable

	/**
	 * Implemented by X10 activities, actual activity "user" code 
	 * generated by xcd templates.
	 */
	public abstract def runX10Task(): void throws Throwable;
	
	/**
	 * Default implementation of the Runnable interface.
	 * An Activity executing in a place should always be invoked using it's runnable interface,
	 * and not directly by calling it's runX10Task method; which is an abstract method in this class.
	 * This run method allows performing actions before and after activity execution allowing
	 * to submit the activity safely as regard to runtime and pool thread.
	 */
	def run(): void {
		try {
			runX10Task();
		} catch (t: Throwable) {
			pushException(t);
		}
		if (null != clocks) clocks.drop();
    	finishState.notifySubActivityTermination();
	}
	
	// finish state

	/**
	 * Return the finish state of the current activity
	 */
	def finishState(): FinishState {
		return finishState;
	}
	
	/**
	 * Set the root finish state of the current activity 
	 * Notify the finish state of a spawned activity
	 */
	def finishState(state: FinishState): void {
		finishState = state;
		state.notifySubActivitySpawn();
	}
	
	/**
	 * Start executing this activity synchronously 
	 * (i.e. within a finish statement).
	 */
	def startFinish(): void {
		if (null == finishStack) finishStack = new Stack[FinishState]();
		finishStack.push(finishState);
		finishState = new FinishState();
	}

	/**
	 * Suspend until all activities spawned during this finish 
	 * operation have terminated. Throw an exception if any
	 * async terminated abruptly. Otherwise continue normally.
	 * Should only be called by the thread executing the current activity.
	 */
	def stopFinish(): void {
		val state = finishState;
		finishState = finishStack.pop();
		state.waitForFinish();
	}

	/** 
	 * Push the exception thrown while executing s in a finish s, 
	 * onto the finish state.
	 */
	def pushException(t: Throwable): void  {
		finishState.pushException(t);
	}
}
