/*
 *
 * (C) Copyright IBM Corporation 2006-2008.
 *
 *  This file is part of X10 Language.
 *
 */

package x10.lang;

import x10.compiler.Native;
import x10.compiler.NativeRep;

import x10.runtime.kernel.InterruptedException;
import x10.runtime.kernel.Runnable;

/**
 * The representation of an X10 async activity.
 * Note that an Activity object is created by a different thread than the one that executes it. 
 * @author Christian Grothoff, Christoph von Praun, vj
 * @author Raj Barik, Vivek Sarkar
 * @author tardieu
 */
public abstract class Activity(name: String) implements Runnable {
	/**
	 * The FinishState of this activity. 
	 */
	private var finishState: FinishState;

	/**
	 * The finishStack is lazily created.
	 */
	private var finishStack: Stack[FinishState];

	/**
	 * The clock phases of this activity. Lazily created.
	 */
	private var clocks: Clocks;

	// native threads

	@NativeRep("java", "x10.runtime.X10Thread")
	private static class Thread {
		@Native("java", "java.lang.Thread.sleep(#1)")
    	native static def sleep(millis: long): void throws InterruptedException;

		@Native("java", "x10.runtime.X10Thread.currentThread()")
    	native static def currentThread(): Thread;

	    @Native("java", "#0.getRunnable()")
	    native def getRunnable(): Runnable;
	
		@Native("java", "#0.getPlaceId()")
		native def getPlaceId(): nat;
	
		@Native("java", "#0.setRunnable(#1)")
		native def setRunnable(r: Runnable): void;
	}

	/**
	 * Return the activity being executed by the current thread.
	 */
	public static def current(): Activity {
		return Thread.currentThread().getRunnable() as Activity;
	}

	/**
	 * The place at which the current activity is running.
	 */
	public static def here(): Place {
		val th = Thread.currentThread();
		if (null == th) return Place.place(0);
		return Place.place(th.getPlaceId());
	}

	// clocks
	
	/**
	 * The clocks of the current activity.
	 */
	def clocks(): Clocks {
		if (null == clocks) clocks = new Clocks();
		return clocks;
	}
	
	/**
	 * Next statement = next on all clocks in parallel.
	 */
	public def next(): void {
		if (null != clocks) clocks.next();
	}
	
	/**
	 * @deprecated
	 */
	public static def checkClockUse(c: Clock): Clock {
		return c;
	}

	// constructors

	/**
	 * Create an activity.
	 */
	public def this(name: String) {
	    property(name);
	}

	public def this() {
	    this("");
	}

	/**
	 * Create an activity with the given list of clocks.
	 */
	public def this(list: x10.lang.List[Clock], name: String) {
	    this(name);
	    clocks = new Clocks();
		clocks.register(list);
	}

	public def this(list: x10.lang.List[Clock]) {
	    this(list, "");
	}

	/**
	 * Create an activity with the given clock.
	 */
	public def this(clock: Clock, name: String) {
	    this(name);
	    clocks = new Clocks();
	   	clocks.register(clock);
	}

	public def this(clock: Clock) {
	    this(clock, "");
	}

	// runnable

	/**
	 * Implemented by X10 activities, actual activity "user" code 
	 * generated by xcd templates.
	 */
	public abstract def runX10Task(): void throws Throwable;
	
	/**
	 * Default implementation of the Runnable interface.
	 * An Activity executing in a place should always be invoked using it's runnable interface,
	 * and not directly by calling it's runX10Task method; which is an abstract method in this class.
	 * This run method allows performing actions before and after activity execution allowing
	 * to submit the activity safely as regard to runtime and pool thread.
	 */
	public def run(): void {
		// Binding current thread to this activity
		Thread.currentThread().setRunnable(this);
		try {
			runX10Task();
		} catch (t: Throwable) {
			pushException(t);
		}
		if (null != clocks) clocks.drop();
    	finishState.notifySubActivityTermination();
	}
	
	// finish state

	public def finishState(): FinishState {
		return finishState;
	}
	
	public def setFinishState(state: FinishState): void {
		finishState = state;
	}
	
	/**
	 * Start executing this activity synchronously 
	 * (i.e. within a finish statement).
	 */
	public def startFinish(): void {
		if (null != finishState) {
			if (null == finishStack) finishStack = new Stack[FinishState]();
			finishStack.push(finishState);
		}
		finishState = new FinishState();
	}

	/**
	 * Suspend until all activities spawned during this finish 
	 * operation have terminated. Throw an exception if any
	 * async terminated abruptly. Otherwise continue normally.
	 * Should only be called by the thread executing the current activity.
	 */
	public def stopFinish(): void {
		finishState.waitForFinish();
		val exceptions = finishState.exceptions();
		if ((null != finishStack) && !finishStack.empty()) {
			finishState = finishStack.pop();
		}
		if ((null != exceptions) && !exceptions.empty()) {
			if (exceptions.size() == 1) {
				val t = exceptions.pop();
				if (t instanceof Error) {
					throw t as Error;
				}
				if (t instanceof RuntimeException) {		
					throw t as RuntimeException;
				}
				assert false as boolean;
			}
			throw new MultipleExceptions(exceptions);
		}
	}

	/** 
	 * Push the exception thrown while executing s in a finish s, 
	 * onto the finish state.
	 */
	public def pushException(t: Throwable): void  {
		finishState.pushException(t);
	}
	
	// utilities

	/**
	 * Sleep for the specified number of milliseconds.
	 * [IP] NOTE: Unlike Java, x10 sleep() simply exits when interrupted.
	 * @param millis the number of milliseconds to sleep
	 * @return true if completed normally, false if interrupted
	 */
	public static def sleep(millis: long): boolean {
		try {
			here().threadBlockedNotification();
			Thread.sleep(millis);
			return true;
		} catch (e: InterruptedException) {
			return false;
		} finally {
			here().threadUnblockedNotification();
		}
	}
}
