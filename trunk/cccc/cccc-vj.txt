Wed Dec 06 07:20:22 2006
CCCC -- Cache-coherent Causal Consistency
Revision Notes

** Changed SACC-HB --> CCCC.
** Used Doug's name for rules.
** This document contains the generalized "boundary" version of Local
   Consistency. (01/30/07)

-----------

The core idea behind CCCC is to provide a weaker model than sequential
consistency which is still strong enough to permit various mutual
exclusion algorithms to be written. In particular this model permits
different processors to have different perceptions about the write
orders of writes performed by other processors. For instance, assume
processor 1 performs a write w1, and p2 performs write w2. A processor
p3 may observe w1 before w2, and processor p4 may observe w2 before
w1. Specifically, the model is not required to satisfy that w --> w'
(that is, w must publically be known to precede w') from  w --> r -->
w'  if w, r, w' are executed by different processors. However, each
processor is required to respect the obsevrations made by a processor
involving its own writes. Thus if p1 observes w1 before w2, then all
processors must respect this observation.

CCCC is being attempted as a common abstraction of properties
satisfied by today's leading architectures. It is related to several
other weak memory models for hardware that have been proposed since
1990 (e.g. various flavors of processor consistency).

This formalization of CCCC presents an execution as a graph G = (S,
-->) where S is a set of read/write events (generated by a given set
of processors operating against a given shared memory) and -->
captures "common knowledge" facts about the ordering of events in S,
together with facts established by the program order of each
processor. (A fact is common knowledge if it is known to each
processor.)

However there are facts that may be known by a processor i privately,
e.g. write/write orders which involve third party writes. These facts
will lie in (G | E(i) u W)* but not in  (G | E(i) u W).  We need these
additional facts to be consistent, that is, (G | E(i) u W)* should be
a partial order (no cycles).

================================= CCCC-HB  ========================= 
Here is a global formulation of CCCC. 

Let e ranges over read and write events, r over read events and w over
write events. For any event e, p(e) is the processor which executed e,
and for any processor p, E(p) is the set of events executed by p.  Let
W(x) be the set of all write events on location x, and W the set of
all write events.

A graph G=(S,-->) is a set of nodes S and a binary (directed) relation
--> on the nodes.

G is a partial order if --> is transitive and irreflexive. 

G is a total order if --> is a partial order and for any two nodes a,
b in S either a --> b or b --> a.

If G=(S, -->) is a graph and T is a subset of S, then G | T (the graph
G restricted to T) is the graph with nodes in T and with a --> b in T
iff a --> b in S.

If G is a graph then G* is the transitive closure of the graph. 

For a set T of events, b(T) is T together with boundary events, i.e. 
events e s.t. e-->e' or e'-->e, for e' in T.

================== CCCC =============== 
An execution is a graph G=(S, -->) over a set of events S satisfying: 

 A.(Write Serialization) 
     For each variable x, W(x) is non-empty and G | W(x) is a total order.

 B. (Freshness) For every read r of x, min(W(x)) --> r and  G | (W(x)
    u {r}) is a total order.

 C. (Causal Propagation) e --> e'' if there is an e' in E(p(e'')) u E(p(e))
    st e --> e' --> e'' .

 D. (Local Consistency) For all processors i,  (G | b(E(i)))* is a
    partial order. Further, G | E(i) is a total order.

======================================== 

Note: --> is *not* a partial order. It is an arbitrary relation. Its
restrictions are partial orders, corresponding to <i, the order
induced by each processor.

The propagation rule does not support the inference w --> w' from  w
--> r --> w'  if w, r, w' are executed by different processors.

===================================================================== 

EXAMPLES: See cccc-examples.txt