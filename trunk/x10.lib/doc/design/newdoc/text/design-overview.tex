\subsection{Design Overview}

An \Xten{} {\em job} consists of a number of \Xten{} Operating System
processes which can distributed among various compute nodes connected
via a network. Each compute node may have several processing cores and
multiple processes in the job can be co-located on the node. Each
Operating System process hosts one \Xten{} \em{place}, and uses one or
more threads to execute the asyncs in these places.
Each process uses the messaging layer to communicate with other
processes. Upon startup of a job, configuration settings are consulted 
to start up the processes at the nodes. Each process then initializes
its internal data structures and synchronizes with all other processes
to co-ordinate its initial state.

Each process maintains a collection of threads and a (double-ended)
queue of asyncs per place. The threads associated with a place suspend
waiting for a new activity to be added to its queue. Activities may be
added by the execution of asyncs at a different place on the current
node or on receipt of an ``active message'' from the messaging layer.

When a thread is awakened it pulls the next async out of the queue,
determines whether the blocking condition (if any) associated with the
activity is satisfied and then executes it to completion. If the
condition is not satisfied then object corresponding to the async is
suspended on the condition variable. It will be awakened (and added
again to the activity pool) once there is reason to believe its
condition has changed.

An async is represented as an object with a particular interface.
Asyncs are classified statically based on the characteristics of the
code they run: {\em nonblocking} (code does not perform a conditional
wait on some variable), {\em local} (executing in the same place), {\em
immediate} (can be executed without acquiring a lock). Blocking asyncs
are required to be {\em top level} blocking: the call to conditional
wait must not occur within a method call. During execution, an activity
$A$ may spawn new asyncs. If the new async is to be executed at a
different place in the current node and is immediate, it may be
performed immediately by the thread executing $A$.  If the new async is
local and nonblocking (or immediate) it will be executed immediately (by
the spawning activity).  For all other asyncs intended to execute at
another place in the same process, an object is created and added to its
queue of asyncs. If the new async is intended to execute at a remote
place then a LAPI active message is queued for the target place. 

The compiler may use static analysis and type information to
determine that an activity should be inlined (e.g.{} because it is
local and immediate). Such activities do not even show up as
activities in the runtime system. In particular the compiler is
strongly encouraged to examine the bodies of asyncs and determine if
they can be classified as immediate/local/nonblocking.
