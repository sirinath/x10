#include "cilk.h"
#include "cilk-lib.cilkh"
#include <stdio.h>
#include <stdlib.h>
#include "graph.h"

volatile int * color;
volatile int * bufferRedBase, *bufferBlackBase, bufferSizeBase, *labelBase;
volatile int * bufferRed, *bufferBlack, *label, *bufferSizeRed,*bufferSizeBlack;
int bufferSize, bufferStride, bufferPartition, numWorkers, baseWorkLoad = 10;
//Cilk_lockvar * lock;
Cilk_lockvar lock;

/*Nov 7,03: the previous random graph generator may create repeated edges between two vertices, fixed*/
/*Jun 4, 04: m 's value can be changed as we add edges to make it a connected graph*/
/*Aug 17, 07: BSF added by Tong Wen @ IBM*/
/*Oct 07, 07: BSF modified by T.W. @ IBM; The previous version is in BT.cilk*/

V* r_graph(int n,int m)
{
    int i,j,v1,v2,v,top,tail,r, numEdges=0;
    E *L;
    char * color;
    int * * M;
    int * D,*info,*stack;
    V* graph;

    L=(E *) malloc(sizeof(E)*m);
    j=0; 
    for(i=0;i<m;i++)
     {
	v1=(int)(drand48()*n)%n;
	v2=(int)(drand48()*n)%n;
	while(v2==v1) v2=(int)(drand48()*n) %n;
        L[j].v1=v1;
	L[j++].v2=v2;
     } 
    printf(" number of edges got is %d\n",j);

    M = malloc(sizeof(int *)*n);
    D = malloc(sizeof(int)*n);

    for(i=0;i<n;i++) D[i]=0;

    for(i=0;i<m;i++) {
	D[L[i].v1]++;
	D[L[i].v2]++;
    }

    for(i=0;i<n;i++) {
	M[i]=malloc(sizeof(int)*(D[i]+2)); /*+2 leaves space for making connected*/
    }
    printf("finished allocating structures\n");

    for(i=0;i<n;i++) D[i]=0;

    for(i=0;i<m;i++)
    {
		r=0;
		for(j=0;j<D[L[i].v1];j++)
			if(L[i].v2==M[L[i].v1][j]) r=1; 
		if(r==1) continue;
		
		M[L[i].v1][D[L[i].v1]]=L[i].v2;
        M[L[i].v2][D[L[i].v2]]=L[i].v1;
        D[L[i].v1]++;
        D[L[i].v2]++;
    }   
    free(L);
    printf("finished generating the matrix\n");
    printf("checking if is connected\n");
    
    color = malloc(sizeof(char)*n);
    stack = malloc(sizeof(int)*n);
    info  = malloc(sizeof(int)*n);
    
    if(!color || ! stack || ! info ){
      printf("error allocating memory\n");
      exit(0);
    }

    for(i=0;i<n;i++)  color[i]=0;
    top=-1;
    tail=0;
    
    for(i=0;i<n;i++)
    {
      if(color[i]==1) continue;
      else info[tail++]=i;
      
      stack[++top]=i;
      color[i]=1;
      while(top!=-1) {
      v = stack[top];
      top--;
     
      for(j=0;j<D[v];j++)
        if(color[M[v][j]]==0){
	         top++;
		 stack[top]=M[v][j];
		 color[M[v][j]]=1;
         }
      }
    }

    printf("checking done,tail is %d\n",tail);
    for(i=0;i<tail-1;i++)
    {
       M[info[i]][D[info[i]]++]=info[i+1];
       M[info[i+1]][D[info[i+1]]++]=info[i];
    } 
    	
   graph = (V*)malloc(n *sizeof (V));
   if(graph==NULL)
   {
        printf("1 mem alloc error\n");
        return (NULL);
   }
   for(i=0;i<n;i++)
   {
        /*there should be n neighbors for this vertex*/
		/*graph[i].self=i;*/
 		graph[i].n_neighbors=D[i];
        graph[i].my_neighbors=(int *)malloc(D[i]*sizeof(int));
		/*graph[i].is_tree_edge=(int *)malloc(D[i]*sizeof(int));*/
        if(graph[i].my_neighbors==NULL) {
                printf("2 mem alloc error\n");
                return(NULL);
        }
        for(j=0;j<D[i];j++)
        {
            graph[i].my_neighbors[j]=M[i][j];
	   /* graph[i].is_tree_edge[j]=0; */
        }
	numEdges+=graph[i].n_neighbors;
   }

    printf("done generating graph structure\n");
  printf("number of edges is %d\n",numEdges/2);
    for(i=0;i<n;i++)
     free(M[i]);
    free(M);
    free(D);   
    free(stack);
    free(info);
    free(color); 
    return(graph);
 }

V* torus(int k)
{
  int *Buff;
  int ** Adj;
  int i,j,l,s; 
  V* graph;
  int n = k*k; 
  
  Buff = malloc(sizeof(int)*n);
  Adj  = malloc(sizeof(int*)*n);
  for(i=0;i<n;i++) Adj[i]=malloc(sizeof(int)*4);

#if 1
  for(i=0;i<n;i++) Buff[i]=i;

  for(i=0;i<n/2;i++){
	l=(int)(drand48()*n)%n;
 	s=(int)(drand48()*n)%n;
	j=Buff[l];
	Buff[l]=Buff[s];
	Buff[s]=j;
  }
	
  for(i=0;i<k;i++)
    {
      for(j=0;j<k;j++)
	{
	  Adj[Buff[i*k+j]][0]= Buff[((k+i-1)%k)*k+j];
	  Adj[Buff[i*k+j]][1]= Buff[((i+1)%k)*k+j];
	  Adj[Buff[i*k+j]][2]= Buff[i*k+((k+j-1)%k)];
	  Adj[Buff[i*k+j]][3]= Buff[i*k+((j+1)%k)];
	}
  
    }	
#endif


#if 0

	for(i=0;i<k;i++)
    {
      for(j=0;j<k;j++)
	{
	  Adj[i*k+j][0]= ((k+i-1)%k)*k+j;
	  Adj[i*k+j][1]= ((i+1)%k)*k+j;
	  Adj[i*k+j][2]= i*k+((k+j-1)%k);
	  Adj[i*k+j][3]= i*k+((j+1)%k);
	}
  
    }
	
#endif
	  
   graph = (V*)malloc(n *sizeof (V));
   if(graph==NULL)
   {
        printf("1 mem alloc error\n");
        return (NULL);
   }
   for(i=0;i<n;i++)
   {
        /*there should be n neighbors for this vertex*/
		/*graph[i].self=i;*/
 		graph[i].n_neighbors=4;
        graph[i].my_neighbors=(int *)malloc(4*sizeof(int));	
	/*graph[i].is_tree_edge=(int *)malloc(4*sizeof(int));*/	
        if(graph[i].my_neighbors==NULL) {
                printf("2 mem alloc error\n");
                return(NULL);
        }
        for(j=0;j<4;j++)
        {
            graph[i].my_neighbors[j]=Adj[i][j];
	    /*graph[i].is_tree_edge[j]=0;*/
        }
   }
  
  for(i=0;i<n;i++) free(Adj[i]);
  free(Adj);
  free(Buff);
  return(graph);

 }


V* k_graph(int n, int k)
{
  int neighbor;
  char * visited;
  int * stack,*super;
  int i,j,u,v,nextn,top=-1,n_comp=0,rep,s;
  int ** array,*counter; 
  V* graph;
  
  int TIMES=3;
  int THRESHOLD=100;

  array = malloc(sizeof(int *)*n);
  visited = malloc(sizeof(char)*n);
  counter = malloc(sizeof(int )*n);

  if(array==NULL || visited==NULL || counter==NULL) 
    {
      printf("not enough mem\n");
      exit(-1);
    }

  for(i=0;i<n;i++)
  {
    array[i]=malloc(sizeof(int)*k*TIMES);
    if(array[i]==NULL) { 
      printf("not enough mem\n");
      exit(-1);
    }
    counter[i]=0;
    visited[i]=0;
  }

 
  stack = malloc(sizeof(int)*(n)/2);
  super = malloc(sizeof(int)*(n)/2);
  
  if(stack==NULL || super==NULL)
    {
      printf("not enough mem\n");
      exit(-1);
    }

  for(i=0;i<n;i++)
  {
     for(j=counter[i];j<k;j++)
     {
     	if(i<n-THRESHOLD)
       		neighbor=(int)(drand48()*(n-i))%(n-i)+i;
       	else neighbor=(int)(drand48()*THRESHOLD)%(THRESHOLD);
		rep=0;
		for(s=0;s<counter[i];s++) 
	   		if(array[i][s]==neighbor) rep=1;
		while(rep==1)
		{
			rep=0;
			if(i<n-THRESHOLD)
       			neighbor=(int)(drand48()*(n-i))%(n-i)+i;
       		else neighbor=(int)(drand48()*THRESHOLD)%(THRESHOLD);
			for(s=0;s<counter[i];s++) 
	   			if(array[i][s]==neighbor) rep=1;
		}
#if 0
        neighbor=rand()%(n-i)+i;
       else neighbor=rand()%THRESHOLD;
#endif
	while(counter[neighbor]>TIMES*k-1 || neighbor==i) neighbor=(neighbor+1)%n;
        array[i][counter[i]]=neighbor;
        counter[i]++;
        array[neighbor][counter[neighbor]]=i;
        counter[neighbor]++;
     }
  }

  printf("check if it is connected\n");

  /* now make the graph connected if it is not*/
  for(i=0;i<n;i++)
    {
      if(!visited[i]){
	visited[i]=1;
	stack[++top]=i;
	super[n_comp++]=i;

	while(top!=-1)
	  {
	    v = stack[top];
	    top--;

	    for (j=0; j<counter[v]; j++) {
	      nextn = array[v][j];
	      if(!visited[nextn]) {  /* not seen yet */
		visited[nextn]=1;
		stack[++top]=nextn;
	      }
	    }
	  }
      }
    }
  
  for(i=1;i<n_comp;i++)
    {
      u = super[i];
      v = super[i-1];
      array[u][counter[u]++]=v;
      array[v][counter[v]++]=u;
    }
  
   graph = (V*)malloc(n *sizeof (V));
   if(graph==NULL)
   {
        printf("1 mem alloc error\n");
        return (NULL);
   }
   for(i=0;i<n;i++)
   {
        /*there should be n neighbors for this vertex*/
		/*graph[i].self=i;*/
 		graph[i].n_neighbors=counter[i];
        graph[i].my_neighbors=(int *)malloc(counter[i]*sizeof(int));
		/*graph[i].is_tree_edge=(int *)malloc(counter[i]*sizeof(int));*/
        if(graph[i].my_neighbors==NULL) {
                printf("2 mem alloc error\n");
                return(NULL);
        }
        for(j=0;j<counter[i];j++)
        {
            graph[i].my_neighbors[j]=array[i][j];
	/*graph[i].is_tree_edge[j]=0;*/
        }
   }

  for(i=0;i<n;i++) free(array[i]);
  free(array);
  free(counter);
  free(stack);
  free(super);
  free(visited);
  return(graph);
}

cilk void traverse(V* G,int r)
{
   int i,v;
 
   for(i=0;i<G[r].n_neighbors;i++)
   {
      v = G[r].my_neighbors[i];
      if(Cilk_xchg(&color[v],1)==0) {
	 color[v]=1;
	 spawn traverse(G,v);
      }
   }
}

cilk void ST(V* G,int n)
{
    spawn traverse(G,0);
    sync;
}
/* bufferRed, bufferBlack, bufferSize, and label are global data structures */

cilk void findChildrenBase(V *G, int idx, int lbl, int n_vertices){
	volatile int *bufferA, *bufferB;
	int i,j,k,l, tempSize =0;
	//int * temp;
	
	if (lbl%2 == 1){
		bufferA = bufferRedBase; bufferB = bufferBlackBase;
	}else{
		bufferA = bufferBlackBase; bufferB = bufferRedBase;
	}
	k= G[bufferA[idx]].n_neighbors;
	//temp  = Cilk_alloca(sizeof(int)*k);
	for (i = 0; i < k; i++){
		j = G[bufferA[idx]].my_neighbors[i];
		if (labelBase[j] == n_vertices){ //not labeled
			labelBase[j] = lbl;
			//temp[tempSize++]=j; 
			//l = bufferSize;
			//Cilk_lock(lock);bufferB[bufferSizeBase++] = j;Cilk_unlock(lock);
			bufferB[bufferSizeBase++] = j;
		}
	}
	//printf("copy buffer %d %d \n",k, tempSize); 
	//Cilk_lock(lock);
	//for (i =0; i<tempSize; i++)
		//bufferB[bufferSize++] = temp[i];
	//Cilk_unlock(lock);
}

cilk void findChildrenBlock(V *G, int idxStart, int idxEnd, int lbl, int n_vertices){
	volatile int *bufferA, *bufferB;
	int idx, i,j,k;
	
	
	if (lbl%2 == 1){
		bufferA = bufferRedBase; bufferB = bufferBlackBase;
	}else{
		bufferA = bufferBlackBase; bufferB = bufferRedBase;
	}
	for (idx = idxStart;  idx <= idxEnd; idx++){
		k= G[bufferA[idx]].n_neighbors;
		for (i = 0; i < k; i++){
			j = G[bufferA[idx]].my_neighbors[i];
			if (labelBase[j] == n_vertices){ //not labeled
				labelBase[j] = lbl;
				Cilk_lock(lock);bufferB[bufferSizeBase++] = j;Cilk_unlock(lock);
				//bufferB[bufferSizeBase++] = j;
			}
		}
	}
}

cilk void BSFBase(V* G, int n_vertices, int root){

	int level = 0, i, size, iter;
	bufferSizeBase = 1;
	bufferRedBase[0] = root;
	labelBase[0] = level;
	size = bufferSizeBase;
	//iter = 10;
	//while(size > 0 && iter > 0){
	 while(size >0){
		bufferSizeBase = 0;
		level++;
		/*for (i =0; i < size; i++) 
			spawn findChildrenBase(G, i, level, n_vertices);*/
		spawn findChildrenBlock(G, 0, size/2, level, n_vertices);
		spawn findChildrenBlock(G, size/2+1, size-1, level, n_vertices);
		sync;
		size = bufferSizeBase;
		//printf("BSF bufferSize = %d \n", size);	
		iter--;	
	}
	printf("BFSBase: The number of levels = %d \n", level);
}

cilk void BFSSeq(V* G, int n_vertices, int root){
	volatile int *bufferA, *bufferB;
	int idx, j,k,l;
	int level = 0, i, size, iter;
	bufferSizeBase = 1;
	bufferRedBase[0] = root;
	labelBase[0] = level;
	size = bufferSizeBase;

	 while(size >0){
	//for (l=0;l<2;l++){	
		bufferSizeBase = 0;
		level++;
		if (level%2 == 1){
			bufferA = bufferRedBase; bufferB = bufferBlackBase;
		}else{
			bufferA = bufferBlackBase; bufferB = bufferRedBase;
		}
		for (i =0; i < size; i++) {
			//spawn findChildrenBase(G, i, level, n_vertices);
			k= G[bufferA[i]].n_neighbors;
			for (idx = 0; idx < k; idx++){
				j = G[bufferA[i]].my_neighbors[idx];
				if (labelBase[j] == n_vertices){ //not labeled
					labelBase[j] = level;
					//Cilk_lock(lock);bufferB[bufferSizeBase++] = j;Cilk_unlock(lock);
					bufferB[bufferSizeBase++] = j;
					//printf(" [ %d ] = %d, ", bufferSizeBase-1, j); 
				}
			}
		}
		//printf("\n");
		//printf("bufferB %d %d %d %d %d \n", bufferB[0], bufferB[1], bufferB[2], bufferB[3], bufferB[4]);
		sync;
		size = bufferSizeBase;
		//printf("BSF bufferSize = %d \n", size);	
		iter--;	
	}
	printf("BFSseq: The number of levels = %d \n", level);
}


cilk void findChildrenParallel(V *G, int start, int end, int bufferIdx, int level, int n_vertices,
	volatile int *bufferA, volatile int *bufferSizeA, volatile int *bufferB, volatile int *bufferSizeB){
	int doSize = end-start+1, I=0, i=0, J=0, j=0, k, l, m, n, findI=0;
	int temp = 0;
	int localStart, localEnd, idxNode, idxBuff;
	//printf("  FC[ %d ] doSize = %d \n", bufferIdx, doSize);
		
	
		for (m=0; m<bufferPartition;m++){
			temp += bufferSizeA[m];
			if (findI ==0)
				if (temp > start){ findI=1; I=m; i=start+bufferSizeA[m]-temp;}
				else if (temp == start){findI=1; I=m+1; i=0;}
			if (temp > end){ J=m; j=end+bufferSizeA[m]-temp; break;}
			else if (temp == end){J=m+1; j=0; break;}
		}
	
		idxBuff = bufferIdx*bufferStride;
		//printf("       Base: I = %d i = %d J = %d j = %d idxBuff = %d \n", I, i, J, j, idxBuff);
		for (m=I; m<=J;m++){
		  if(bufferSizeA[m]>0){
			if (I==J){localStart=I*bufferStride+i;localEnd=I*bufferStride+j;}
			else if (m==J){localStart=J*bufferStride; localEnd=localStart+j;} 			
				else{localStart=m*bufferStride; localEnd=m*bufferStride+bufferSizeA[I]-1;}
			//printf("       localStart= %d localEnd = %d \n", localStart, localEnd);
			for (n=localStart; n<=localEnd; n++){
				k= G[bufferA[n]].n_neighbors;
				for (l = 0; l < k; l++){
					idxNode = G[bufferA[n]].my_neighbors[l];
					if (label[idxNode] == n_vertices){ //not labeled
						label[idxNode] = level;
						bufferB[idxBuff++] = idxNode;
						//printf(" [ %d ] = %d, ", idxBuff-1, idxNode); 
					}
				}

			}
		  }
		}
		//printf("\n");
		bufferSizeB[bufferIdx]=idxBuff-bufferIdx*bufferStride;
		//printf("            bufferSizeB[ %d ]= %d vs %d\n", bufferIdx, bufferSizeB[bufferIdx], idxBuff);
		//printf("       bufferB %d %d %d %d %d\n", bufferB[0], bufferB[1], bufferB[2], bufferB[3], bufferB[4]);
}
cilk void BFSParallel(V* G, int n_vertices, int root){
	volatile int *bufferA, *bufferB, *bufferSizeA, * bufferSizeB;
	int level = 0, i, j, size, sizeOld, startIdx, idx, actWorkers, workLoad, totalWork, workPerWorker;
	bufferRed[0] = root;
	label[0] = level;
	size = 1; sizeOld = 1;
	for (i=0; i<bufferPartition; i++) {bufferSizeRed[i]=0; bufferSizeBlack[i]=0;}
	bufferSizeRed[0] = 1;
	while(size > 0){
	//for (j=0;j<2;j++){
		level++;
		if (level%2 == 1){
			bufferA = bufferRed; bufferB = bufferBlack;
			bufferSizeA = bufferSizeRed; bufferSizeB = bufferSizeBlack;
		}else{
			bufferA = bufferBlack; bufferB = bufferRed;
			bufferSizeA = bufferSizeBlack; bufferSizeB = bufferSizeRed;
		}
		workLoad=((size/numWorkers) > baseWorkLoad)?size/numWorkers:baseWorkLoad;
		totalWork=size;
		actWorkers=0;
		while ( totalWork>0 && actWorkers<numWorkers){
			if (actWorkers == numWorkers-1) workPerWorker = totalWork;
			else workPerWorker=(totalWork>=workLoad)?workLoad:totalWork;
			//printf("start=%d, end=%d workerID= %d\n", size-totalWork, size-totalWork+workPerWorker-1, actWorkers);
			spawn findChildrenParallel(G, size-totalWork, size-totalWork+workPerWorker-1, actWorkers, level, n_vertices, bufferA, bufferSizeA, bufferB, bufferSizeB);
			totalWork-=workPerWorker; actWorkers++;
		}
		sync;
		size = 0;
		for (i = 0; i < bufferPartition; i++){ size += bufferSizeB[i]; bufferSizeA[i]=0;}
		//printf("BFSParallel vertex at the next level %d = %d \n", level, size);		
	}
	printf("Total levels %d  \n", level);
}

void BFS_verify(int n_vertices){
	int result =0, i;
	for (i =0; i< n_vertices;i++)
		if (label[i] == n_vertices) result++;
	printf("BFS verification: the number of vertices missed %d (should be zero) \n", result);
}
void BFSBase_verify(int n_vertices){
	int result =0, i;
	for (i =0; i< n_vertices;i++)
		if (labelBase[i] == n_vertices) result++;
	printf("BFS verification: the number of vertices missed %d (should be zero) \n", result);
}
cilk int main(int argc, char *argv[])
{
	V* G;

	int n_vertices=100000, n_edges=400000, n_workers,i,size=111;

	Cilk_time tm_begin, tm_elapsed;
	Cilk_time wk_begin, wk_elapsed;
	Cilk_time cp_begin, cp_elapsed;

	if(argc!=4) printf("usage: ST <n> <m> <Workers>\n");

	n_vertices = atoi (argv[1]);
	n_edges = atoi(argv[2]);
	n_workers = atoi(argv[3]);
	numWorkers = (n_workers>0)?n_workers:1;
	
	printf("n_vertics=%d, n_edges=%d, n_workers=%d \n", n_vertices, n_edges, n_workers);
 	G=r_graph(n_vertices,n_edges);
	color = (int *) malloc(sizeof(int)*n_vertices);
	for(i=0;i<n_vertices;i++) color[i]=0;

	/* global data structures used by BFS */
	bufferRedBase = (int *) malloc(sizeof(int)*n_vertices); //the size is good enough for this test problem.
	bufferBlackBase = (int *) malloc(sizeof(int)*n_vertices);
	labelBase = (int *) malloc(sizeof(int)*n_vertices); 	
	for(i=0;i<n_vertices;i++) labelBase[i]=n_vertices;

	bufferSize = (n_edges > n_vertices)? n_edges:n_vertices;
	bufferPartition = n_workers;
	bufferStride = bufferSize/bufferPartition;
	bufferRed = (int *) malloc(sizeof(int)*bufferSize);
	bufferBlack = (int *) malloc(sizeof(int)*bufferSize);
	bufferSizeRed = (int *) malloc(sizeof(int)*n_workers);
	bufferSizeBlack = (int *) malloc(sizeof(int)*n_workers);

	label = (int *) malloc(sizeof(int)*n_vertices); 
	for(i=0;i<n_vertices;i++) label[i]=n_vertices;

	Cilk_lock_init(lock);
	printf("r_graph done\n");
	/* Timing. "Start" timers */
	sync;
	cp_begin = Cilk_user_critical_path;
	wk_begin = Cilk_user_work;
	tm_begin = Cilk_get_wall_time();
	//spawn ST(G,n_vertices);
	spawn BFSParallel(G,n_vertices,0);
	//spawn BFSSeq(G,n_vertices,0);	
	sync;
	/* Timing. "Stop" timers */
	tm_elapsed = Cilk_get_wall_time() - tm_begin;
	wk_elapsed = Cilk_user_work - wk_begin;
	cp_elapsed = Cilk_user_critical_path - cp_begin;
	BFS_verify(n_vertices);
	printf("Critical path = %4f s\n\n", Cilk_time_to_sec(cp_elapsed));
	printf(" running on %d processor(s)\n\n", Cilk_active_size);
	printf("options: number of elements = %ld\n\n", size);
	printf("Running time = %4f s\n", Cilk_wall_time_to_sec(tm_elapsed));
	printf("Work = %4f s\n", Cilk_time_to_sec(wk_elapsed));
	//for (i=0;i<G[0].n_neighbors;i++) printf(" (%d, %d) ", G[0].my_neighbors[i], label[G[0].my_neighbors[i]]);
	//printf("\n");
	//spawn BFSSeq(G,n_vertices,0);
	//BFSBase_verify(n_vertices);
	//for (i=0;i<G[0].n_neighbors;i++) printf(" (%d, %d) ", G[0].my_neighbors[i], labelBase[G[0].my_neighbors[i]]);
	//printf("\n");	
	free(color);
	free(bufferBlack);
	free(bufferRed);
	free(label);
	return(0);
}
