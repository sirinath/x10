
\section{Introduction}
\label{s:intr}

 Graph theoretic problems arise in several traditional and emerging scientific disciplines such as VLSI design, optimization, databases, and computational biology. There are plenty of theoretically fast parallel algorithms, for example, work-time optimal PRAM algorithms, for graph problems; however, in
 practice few parallel implementations beat the best sequential implementations for arbitrary, sparse
 graphs. The mismatch between theory and practice suggests a large gap between algorithmic model and the actual architecture. We observe that the gap is increasing as new diversified architectures emerge. Elegant solutions seem hard to come by from even combined efforts of algorithmic and architectural improvement. What is lacking is an efficient way of mapping fine-grained parallelism expressed by the algorithm to target architectures with good performance. X10 is a new parallel programming language that provides expressive programming constructs and efficient runtime support that effectively helps reduce the gap between theory and practice in solving graph problems. In this paper we show that with X10 the fine-grained parallelism for a graph problem can be expressed much easier at a high algorithmic level, and the X10 program, compared with native C implementation, is much simpler and more elegant, and achieves comparable, and sometimes, even better performance. 

 The challenges of solving large-scale graph problems on current and emerging systems come from the irregular and combinatorial nature of the problem. Many of the important real world graphs, for example, Internet topology, social interaction network, transportation network, protein-protein interaction network, and etc., exhibit a ``small-world'' pattern, and can be modeled as `scale-free'' graphs \cite{CZF04}. There is no known efficient technique to partition such graph, which makes it hard to solve on distributed-memory systems. Also compared with the well-known sequential algorithms, for example, depth-first search (DFS) or breadth-first search (BFS) for the spanning tree problem, the parallel graph algorithms take exotic approaches such as ``graft-and-shortcut'' \cite{SV82}. In the absence of efficient scheduling support of parallel activities, fine-grained parallelism incurs large overhead on current systems and oftentimes do not show practical parallel performance advantage. Lastly, graph algorithms tend to be load/store intensive compared with other scientific problems \cite{G06}, and they put great pressure on the memory subsystem. It gets even worse on distributed-memory architectures if necessary task management and memory affinity scheduling are not provided.  
 
 Several features of X10 make it an ideal language for solving large-scale graph problems. X10 provides a shared address space that obviates the need to partition a graph and to issue message passing requests explicitly to access remote data. It would be very difficult to implement a graph algorithm with irregular inputs on distributed-memory architecture.  In fact, non of the SSCA graph benchmarks has MPI implementation. X10 provides a rich collection of programming constructs that may be used to express various levels of parallelism and synchronization scheme. Depending on the input and the target systems, different algorithms can be easily implemented to fit with the architecture. X10 runtime manages parallel activities effectively with low cost.

 In this paper we present the X10 support for solving irregular graph problems on a cluster of SMPs. As most current and emerging supercomputers are clusters of SMPs, it is important to solve the problems efficiently on these platforms. The algorithms we consider include both PRAM algorithms and efficient algorithms that based on more realistic models such as the SMP model \cite{HJ01}. PRAM algorithms are synchronous and provide massive amount of parallelism. The other types of algorithms are either asynchronous or bulk-synchronous with limited amount of parallelism that maps well to architectures with a moderate number of processors. Both classes of algorithms can be expressed and implemented efficiently in X10.

As an example, we consider the spanning tree problem. Despite dozens of parallel spanning tree algorithms, it is notoriously hard to achieve good parallel performance \cite{BC04a}. We design and/or implement in X10 three parallel algorithms that are representative of different algorithmic approaches. The performance is comparable to or better than the best known prior implementations. Moreover, the algorithm expressed in X10 code is concise and elegant.

 The rest of the paper is organized as follows. Section~\ref{s:x10} describes the language features of X10. Section~\ref{s:design} presents spanning tree algorithms in X10. Section~\ref{s:runtime} presents the runtime support for X10, especially for activity scheduling, with comparison to other runtime systems. 
 Section~\ref{s:results} gives our experimental results. In Section~\ref{s:concl} we conclude and give future work. 
 %% Throughout the paper, we
%%  use $n$ and $m$ to denote the number of vertices and the number of
%%  edges of an input graph $G=(V,E)$, respectively. 
  


