/*
 * Created on Oct 3, 2004
 */
package x10.lang;

import java.util.Iterator;

import x10.array.PointOutOfRegionException;
import x10.array.Range;
import x10.array.ContiguousRange;
import x10.array.Region;

/**
 *  A region represents a (sparse or dense) k-dimensional space of
 * points. A region is a dependent class, with the value parameter
 * specifying the dimension of the region.  A convex k-dimensional
 * region is easy to represent, e.g. as a list of k (min, max)
 * pairs. In general, regions may not be convex. (For instance
 * difference( region(dimension) r) produces non-convex regions.)
 * Non-convex regions are very important for many physical
 * problems. For instance the region of the halo around a 2-d array is
 * non-convex.

 * Implementation of Region. The Points in a region, aka. tuples, are
 * implemented as one-dimensional int arrays. Instance of this class are
 * immutable!
 * 
 * @author Christoph von Praun
 * @author Christian Grothoff
 * @author vj
 */
public /*value*/ class region implements Region {
	final nat dimension;
	
	public static abstract /*value*/ class factory {
		public abstract region /*(0)*/ region();
		
	}

    private final Range[] dims_;

    final int card;

    final int rank;

	public static region makeUpperTriangular(int n) {
        assert n >= 0;
        throw new Error ("TODO");
	}
	
	public static region makeLowerTriangular(int n) {
        assert n >= 0;
        throw new Error ("TODO");
	}
 
	public static region makeBanded(int n, int k) {
        assert n >= 0;
        throw new Error ("TODO");
	}
	    
	public region()
    /**
     * Convenience constructor. Region starts in all dimensions 
     * at index 0, to index idx[i], including the latter.
     */
    public region(int[] dims) {
        assert dims != null;
        rank = dims.length;

        int tmp_card = 1;
        dims_ = new Range[dims.length];
        for (int i = 0; i < dims.length; ++i) {
            dims_[i] = new ContiguousRange(0, dims[i]);
            tmp_card *= dims[i];
        }
        card = tmp_card;
    }

    public region(Range[] dims) {
        assert dims != null;
        rank = dims.length;
        int tmp_card = 1;
        dims_ = dims;
        for (int i = 0; i < dims.length; ++i)
            tmp_card *= dims_[i].count;
        card = tmp_card;
    }

    /**
     * Copy constructor.
     */
    public region (region r) {
        dims_ = r.dims_;
        card = r.card;
        rank = r.rank;
    }
    
    public int rank() {
        return rank;
    }

    /**
     * Creates a subregion from this region
     * @param partitions
     * @param part
     * @return The new sub-region.
     */
    public region sub(int partitions, int part) {
        assert partitions > 0 && part >= 0 && part < partitions;
        assert count() % partitions == 0;
        assert dims_[0] instanceof ContiguousRange;
        assert dims_[0].count % partitions == 0;
        
        ContiguousRange cr = (ContiguousRange) dims_[0];
        int len = cr.count / partitions;
        int offset = len * part;
        Range[] new_dims = new Range[rank];
        // determine most significant dimension
        new_dims[0] = new ContiguousRange(cr.lo + offset, cr.lo + offset + len - 1);
        
        // initialize other dimensions
        for (int i = 1; i < rank; ++i) 
            new_dims[i] = dims_[i];
        return new region(new_dims);
    }
    
    public Region union(Region r) {
        assert r != null;
        assert r.rank() == rank;
        assert r instanceof region;
        
        region rc = (region) r;
        Range[] d = new Range[rank];
        for (int i = 0; i < d.length; ++ i)
            d[i] = dims_[i].union(rc.dims_[i]);
        return new region(d);
    }

    public Region intersection(Region r) {
        assert r != null;
        assert r.rank() == rank;
        assert r instanceof region;
        
        region rc = (region) r;
        Range[] d = new Range[rank];
        for (int i = 0; i < d.length; ++ i)
            d[i] = dims_[i].intersect(rc.dims_[i]);
        return new region(d);
    }

    public Region difference(Region d) { 
        throw new Error("TODO");
    }
    
    /**
     * @return range in the i-th dimension.
     */
    public Range range(int i) {
        assert i < rank;
        return dims_[i];
    }

    public Range[] dim() {
        Range[] ret = new Range[rank];
        System.arraycopy(dims_, 0, ret, 0, ret.length);
        return ret;
    }
    
    public boolean subset(Region r) {
        assert r.rank() == rank;

        region r_c = (region) r;
        boolean ret = true;

        for (int i = 0; i < r_c.rank && ret; ++i)
            ret = r_c.dims_[i].contains(dims_[i]);
        return ret;
    }

    public boolean contains(int[] p) {
        if (p.length != rank)
            throw new PointOutOfRegionException();

        boolean ret = true;
        for (int i = 0; ret && i < rank; ++i) {
            Range r = dims_[i];
            if (!r.contains(p[i]))
                ret = false;
        }
        return ret;
    }

    public int count() {
        int ret = 1;
        for (int i = rank - 1; i >= 0; i--)
            ret *= dims_[i].count; // TODO: check overflow?
        return ret;
    }
    
    /**
     * @param p A point in the region; the dimension of p must be compatible
     *          with this region.
     * @return Returns the ordinal of the point in this region (its position,
     *         where the initial constant is assigned an ordinal of zero).
     */
    public int ordinal(int[] p) {
        if (p.length != rank)
            throw new PointOutOfRegionException();

        int ret = 0;
        int base = 1;
        for (int i = 0; i < p.length; ++i) {
            ret += dims_[i].ordinal(p[i]) * base;
            base *= dims_[i].count;
        }
        return ret;
    }

    /**
     * @return Iterator that yields the individual points of a region in lexicographical
     * order. Points are specified as arrays of int.
     */
    public Iterator iterator() {
        return new RegionIterator();
    }

    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append("{");
        for (int i = 0; i < rank; ++i) {
            sb.append(dims_[i].toString());
            if (i < rank - 1)
                sb.append(",");
        }
        sb.append("}");
        return sb.toString();
    }

    public boolean equals(java.lang.Object o) {
        assert o.getClass() == getClass();

        region rhs = (region) o;
        boolean ret = rhs.rank == rank && rhs.card == card;
        for (int i = 0; ret && i < rank; ++i)
            ret = dims_[i].equals(rhs.dims_[i]);
        return ret;
    }

    public int hashCode() {
        return card;
    }

    public static final class Empty extends region {
        public Empty() {
            super(new Range[0]);
        }
    }
    
    private class RegionIterator implements Iterator {
        private int nextOrd_;

        public boolean hasNext() {
            return nextOrd_ < card;
        }

        public void remove() {
            throw new Error("not implemented");
        }

        public java.lang.Object next() {
            assert hasNext();

            int[] ret = new int[rank];
            // express nextOrd_ as a base of the regions
            int rest = nextOrd_;
            int base = 0;
            for (int i = 0; rest > 0 && i < rank; ++i) {
                base = dims_[i].count;
                int tmp = rest % base;
                rest = (rest - tmp) / base;
                ret[i] = dims_[i].coord(tmp);
            }
            nextOrd_++;
            return ret;
        }
    }
}
