#ifndef __X10_UTIL_INDEXEDMEMORYCHUNK__RAWCHUNK_STRUCT_H
#define __X10_UTIL_INDEXEDMEMORYCHUNK__RAWCHUNK_STRUCT_H

#include <x10aux/config.h>
#include <x10aux/RTT.h>
#include <x10aux/alloc.h>

#include <assert.h>

// platform-specific min chunk alignment
#ifdef _POWER
#define X10_MIN_CHUNK_ALIGNMENT 16
#else
#define X10_MIN_CHUNK_ALIGNMENT ((x10_int)sizeof(x10_double))
#endif

namespace x10 {
    namespace util { 

        template<class T> class IndexedMemoryChunk__RawChunk {
        private:
            T* data; /* TODO: This should be const T* const data */

            static IndexedMemoryChunk__RawChunk allocInternal(size_t numElements,
                                                              x10_int alignment,
                                                              x10_boolean pinned,
                                                              x10_boolean zeroed);

        public:
            IndexedMemoryChunk__RawChunk(): data(NULL) {}
            IndexedMemoryChunk__RawChunk(T* _data): data(_data) {}

            static IndexedMemoryChunk__RawChunk allocate(x10_int numElements,
                                                         x10_int alignment,
                                                         x10_boolean pinned,
                                                         x10_boolean zeroed) {
                assert(numElements >=0);
                return allocInternal((size_t)numElements, alignment, pinned, zeroed);
            }

            static IndexedMemoryChunk__RawChunk allocate(x10_long numElements,
                                                         x10_int alignment,
                                                         x10_boolean pinned,
                                                         x10_boolean zeroed) {
                assert(numElements >= 0);
                assert(((x10_long)((size_t)numElements)) == numElements); // check for alloc requests >31 bits on 32 bit system
                return allocInternal((size_t)numElements, alignment, pinned, zeroed);
            }

            x10::util::IndexedMemoryChunk__RawChunk<T>* operator->() { return this; }
    
            inline T apply(x10_int index) { return data[index]; }
            inline T apply(x10_long index) { return data[index]; }
            
            inline void set(T val, x10_int index) { data[index] = val; }
            inline void set(T val, x10_long index) { data[index] = val; }
        };


        template<class T> IndexedMemoryChunk__RawChunk<T> 
        IndexedMemoryChunk__RawChunk<T>::allocInternal(size_t numElements,
                                                       x10_int alignment,
                                                       x10_boolean pinned, 
                                                       x10_boolean zeroed) {
            assert((alignment & (alignment-1)) == 0);
            if (alignment < X10_MIN_CHUNK_ALIGNMENT) {
                alignment = X10_MIN_CHUNK_ALIGNMENT;
            }

            bool containsPtrs = x10aux::getRTT<T>()->containsPtrs;
            size_t size = alignment + numElements*sizeof(T);
            T* allocMem = x10aux::alloc<T>(size, containsPtrs);
	    if (zeroed) {
                memset(allocMem, 0, size);
            }
            size_t alignDelta = alignment-1;
            size_t alignMask = ~alignDelta;
            size_t alignedMem = ((size_t)allocMem + alignDelta) & alignMask;
            return IndexedMemoryChunk__RawChunk((T*)alignedMem);
        }

    }
}

#endif // X10_UTIL_INDEXEDMEMORYCHUNK__RAWCHUNK_STRUCT_H

