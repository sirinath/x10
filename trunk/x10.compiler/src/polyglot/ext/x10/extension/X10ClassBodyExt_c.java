
/**
 * @author Chris Donawa 
 * Implementation of extern (previously known as native)
 *         calls
 */
package polyglot.ext.x10.extension;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.ListIterator;
import java.util.HashMap;


import polyglot.ast.Call;
import polyglot.ast.Expr;
import polyglot.ast.MethodDecl;
import polyglot.ast.Node;
import polyglot.ast.NodeFactory;
import polyglot.ast.TypeNode;
import polyglot.ext.jl.ast.Block_c;
import polyglot.ext.jl.ast.Call_c;
import polyglot.ext.jl.ast.ClassBody_c;
import polyglot.ext.jl.ast.Formal_c;
import polyglot.ext.jl.ast.MethodDecl_c;
import polyglot.ext.jl.types.Type_c;
import polyglot.ext.x10.types.X10TypeSystem;
import polyglot.types.MethodInstance;
import polyglot.util.Position;


/**
 * 
 * @author donawa
 *
 * Check class bodies for 'extern' keyword (aka native)
 * and generate approriate wrappers and stubs to support
 * the simplified JNI-like interface to native code from X10
 */
public class X10ClassBodyExt_c extends X10Ext_c {

	private BufferedWriter wrapperFile;

	String[] wrapperPrelogue = {
			"/*Automatically generated -- DO NOT EDIT THIS FILE */\n",
			"#include <jni.h>\n", "#ifdef __cplusplus\n", "extern \"C\" {\n",
			"#endif\n", "" };

	String[] wrapperEpilogue = { "\n", "#ifdef __cplusplus\n", "}\n",
			"#endif\n" };

	
	private void generateWrapperPrologue() {
		
		try {
			for (int i = 0; i < wrapperPrelogue.length; ++i) {
				wrapperFile.write(wrapperPrelogue[i]);
			}
			
		} catch (IOException e) {
			System.out.println("Problems with " + wrapperFile);
			e.printStackTrace();
			// FIXME: how to handle errors?
		}
	}

	private void generateWrapperEpilogue() {
		try {
			for (int i = 0; i < wrapperEpilogue.length; ++i) {
				wrapperFile.write(wrapperEpilogue[i]);
			}
			wrapperFile.close();
		} catch (IOException e) {
			System.out.println("Problems with " + wrapperFile );
			e.printStackTrace();
			// FIXME: how to handle errors?
		}
	}

/**
 * Create a text file with suffix _x10stub.c, one for each outermost class which
 * contains x10 extern methods
 * @param containingClassName
 */
	private void createWrapperFile(String containingClassName) {
		String fileName = containingClassName + "_x10stub.c";
		Date timeStamp = new Date();
		SimpleDateFormat formatter = new SimpleDateFormat();
		
		
		try {
			wrapperFile = new BufferedWriter(new FileWriter(fileName));
			wrapperFile.write("/*\n * Filename:"+fileName +
					"\n * Generated: "+formatter.format(timeStamp)+" */\n");
			
		} catch (IOException e) {
			System.out.println("Problems with " + wrapperFile);
			e.printStackTrace();
			// FIXME: how to handle errors?
		}
	}

	private String typeToCString(Type_c theType) {
		if (theType.isPrimitive()) {
			//System.out.println(theType.toString() + " is primitive");
			if (theType.isArray())
				System.out.println("Error!" + theType);
			if (theType.isInt())
				return "signed int";
			if (theType.isChar())
				return "signed short";
			if (theType.isBoolean())
				return "unsigned char";
			if (theType.isByte())
				return "signed char";
			if (theType.isShort())
				return "signed short";
			if (theType.isLong())
				return "signed long";
			if (theType.isFloat())
				return "float";
			if (theType.isDouble())
				return "double";
			if (theType.isVoid())
				return "void";
			System.out.println("Error!");
		} else
			System.out.println(theType.toString() + " is NOT yet handled"); // FIXME Feb 2005 cmd->cmd handle X10 types
		return "<unknown>";
	}
	
	private String typeToJavaSigString(Type_c theType){
		if (theType.isPrimitive()) {
			//System.out.println(theType.toString() + " is primitive");
			if (theType.isArray())
				System.out.println("Error!" + theType);
			if (theType.isInt())
				return "I";
			if (theType.isChar())
				return "J";
			if (theType.isBoolean())
				return "Z";
			if (theType.isByte())
				return "B";
			if (theType.isShort())
				return "S";
			if (theType.isLong())
				return "J";
			if (theType.isFloat())
				return "F";
			if (theType.isDouble())
				return "D";
			if (theType.isVoid())
				return "V";
			System.out.println("Error!");
		} else
			System.out.println(theType.toString() + " is NOT yet handled"); // FIXME Feb 2005 cmd->cmd handle X10 types
		return "<unknown>";
	}
	
	
	private String generateJavaSignature(MethodDecl_c method){
		MethodInstance mi = method.methodInstance();
		String signature = "";// "("

		for (ListIterator i = method.formals().listIterator(); i.hasNext();) {
			Formal_c parameter = (Formal_c) i.next();
			signature += typeToJavaSigString((Type_c) parameter.declType());
		}
		if(false)signature += ")" + typeToJavaSigString((Type_c) mi.returnType());
		return signature;
	}
	private String generateJNIName(MethodDecl_c method, boolean isOverloaded){
		String name = "Java_" + method.methodInstance().container().toString()+ 
		"_" + method.methodInstance().container().toString() +
		"_1" + method.name();
		if(isOverloaded)
			name += "__" + generateJavaSignature(method);
		return name;
	}
	
	private String generateX10NativeName(MethodDecl_c method){
		return  method.methodInstance().container().toString()+ 
		"_" + method.name();
	
	}
	private MethodDecl_c createNewNative(MethodDecl_c nativeMethod, NodeFactory nf) {
	
		MethodInstance mi = nativeMethod.methodInstance();
		
		String nativeName = generateX10NativeName(nativeMethod);
		MethodDecl_c newNative = (MethodDecl_c)nativeMethod.name(nativeName);
		return newNative;
	}
	
	
	/**
	 * Create java wrapper which calls a JNI call which implementes
	 * interface with X10 extern
	 * @param nativeMethod
	 * @param nf node factory
	 * @return wrapper method
	 */
	private MethodDecl_c createNativeWrapper(MethodDecl_c nativeMethod, NodeFactory nf) {
		nativeMethod = (MethodDecl_c)nativeMethod.flags(nativeMethod.flags().clearNative());
		MethodInstance mi = nativeMethod.methodInstance();
		Position pos = nativeMethod.position();
		MethodDecl_c nativeWrapper = nativeMethod;
		
		ArrayList newArgs = new ArrayList();
		String jniName = generateX10NativeName(nativeMethod);
		
		TypeNode receiver = nf.CanonicalTypeNode(pos,mi.container());
		
		Call jniCall = nf.Call(pos,receiver,jniName,newArgs);
		jniCall = (Call_c)jniCall.targetImplicit(true);
		jniCall = (Call_c)jniCall.methodInstance(mi);
		
		ArrayList args = new ArrayList();
		for (ListIterator i = nativeMethod.formals().listIterator(); i.hasNext();) {
			Formal_c parameter = (Formal_c) i.next();
			args.add(nf.Local(pos,parameter.name()));
		}
		
		jniCall = (Call_c)jniCall.arguments(args);
		
		ArrayList newStmts = new ArrayList();
		if (nativeMethod.methodInstance().returnType().isVoid())
			newStmts.add(nf.Eval(pos,(Expr)jniCall));
		else
			newStmts.add(nf.Return(pos,(Expr)jniCall));
		
		Block_c newBlock = (Block_c)nf.Block(pos,newStmts);
		
		nativeWrapper = (MethodDecl_c)nativeWrapper.body(newBlock);
		return nativeWrapper;
	}
	
	/**
	 * Create C stub that user will later compile into a dynamic library
	 * contains JNI signature C code which calls the expected X10 routine
	 * @param nativeMethod
	 * @param isOverloaded
	 */
	private void generateStub(MethodDecl_c nativeMethod, boolean isOverloaded){
		

		String newName = generateX10NativeName(nativeMethod);
		if(isOverloaded)
			newName += "__" + generateJavaSignature(nativeMethod);
	

		String jniCall, wrapperCall, wrapperDecl,returnTheValue = "";

		wrapperCall = newName + "(";
		wrapperDecl = "extern " + typeToCString((Type_c)nativeMethod.methodInstance().returnType()) + " ";
		wrapperDecl += wrapperCall;
		
		newName = generateJNIName(nativeMethod,isOverloaded);

		jniCall = "JNIEXPORT "
				+ typeToJNIString((Type_c) nativeMethod.methodInstance()
						.returnType()) + " JNICALL\n" + newName
				+ "(JNIEnv *env, jobject obj";

		if (!nativeMethod.methodInstance().returnType().isVoid())
			returnTheValue = "return ";
		String commaString = "";
		for (ListIterator i = nativeMethod.formals().listIterator(); i
				.hasNext();) {
			Formal_c parameter = (Formal_c) i.next();
			jniCall += ", " + typeToJNIString((Type_c) parameter.declType())
					+ " " + parameter.name();
			wrapperCall += commaString + " " + parameter.name();
			wrapperDecl += commaString
					+ typeToCString((Type_c) parameter.declType()) + " "
					+ parameter.name();
			commaString = ", ";
		}
		jniCall += ")";
		wrapperCall += ")";
		wrapperDecl +=");";
		try {
			wrapperFile.write("\n/* * * * * * * */\n"+wrapperDecl + "\n"+jniCall + "{\n   " + 
					returnTheValue + wrapperCall
					+ ";\n}\n");


		} catch (IOException e) {
			e.printStackTrace();
			//FIXME: how do we handle errors?
		}
		
	}

	/**
	 * 
	 * @param theType
	 * @return JNI name for the type
	 */
	private String typeToJNIString(Type_c theType) {
		if (theType.isPrimitive()) {
			//System.out.println(theType.toString() + " is primitive");
			if (theType.isArray())
				System.out.println("Error!" + theType);
			if (theType.isInt())
				return "jint";
			if (theType.isBoolean())
				return "jboolean";
			if (theType.isByte())
				return "jbyte";
			if (theType.isShort())
				return "jshort";
			if (theType.isLong())
				return "jlong";
			if (theType.isFloat())
				return "jfloat";
			if(theType.isChar())
				return "jchar";
			if (theType.isDouble())
				return "jdouble";
			if (theType.isVoid())
				return "void";
			System.out.println("Error!");
		} else
			System.out.println(theType.toString() + " is NOT yet handled"); // FIXME Feb 2005 cmd->cmd handle X10 types
		
		return "<unknown>";
	}


	
	private static int containingClassDepth = 0; // use to create stub file for outermost class w/ natives
	
	/** 
	 * Identify native (aka extern) x10 methods and create a wrapper with
	 * the same name.  The wrapper make a JNI call to a routine which
	 * then calls the expected X10 native call.
	 * e.g. 
	 * <code>
	 * class C{
	 * static int extern foo(int x);
	 * }
	 * </code>
	 * would result in java code
	 * <code>
	 * class C {
	 * static int native C_foo(int x);
	 * static int foo(int x) { return C_foo(x);}
	 * }
	 * </code>
	 * 
	 * C_foo is a native C call, which would end up looking like
	 * <code> int Java_C_C_1foo(int x){ return C_foo(x);}</code>
	 * Stub files for each containing class are generated containing
	 * the C wrappers.  It is up to the user to compile these, along
	 * with the actual native implementation of C_foo(int), into
	 * a dynamic library, and ensure that the X10 program can find them
	 */
	public Node rewrite(X10TypeSystem ts, NodeFactory nf) {
		boolean seenNativeMethodDecl = false;
		
		ClassBody_c cb = (ClassBody_c) node();
		List members = cb.members();
		HashMap methodHash=null;
		ArrayList listOfNewMethods = new ArrayList();	
		for (ListIterator i = members.listIterator(); i.hasNext();) {
			Object o = i.next();
			if (o instanceof MethodDecl) {
				MethodDecl_c md = (MethodDecl_c) o;
				MethodInstance mi = md.methodInstance();
			
				if (!mi.flags().isNative()){
					listOfNewMethods.add(o);
					continue;
				}

				if (!seenNativeMethodDecl) {
					
					// JNI signature changes depends on whether the method
					// is overloaded or not.  Determine that by scanning
					// through and hashing all native method names
					methodHash = new HashMap();
					for (ListIterator j = members.listIterator(); j.hasNext();) {
						Object theObj = j.next();
						if (!(theObj instanceof MethodDecl))
							continue;
						MethodDecl_c methodDecl = (MethodDecl_c) theObj;
						if (!methodDecl.methodInstance().flags().isNative())
							continue;
						Boolean boolObj = null;

						if (methodHash.containsKey(methodDecl.name())) {
							methodHash.put(methodDecl.name(), methodDecl); // more than one instance
						} else {
							methodHash.put(methodDecl.name(), null);
						}
						
					}
					if (0 == containingClassDepth++) {
						createWrapperFile(mi.container().toString());
						generateWrapperPrologue();
					}
					seenNativeMethodDecl = true;
				}
				
				
				boolean isOverLoaded = (null != methodHash.get(md.name()));
				
				//System.out.println("method: "+md.name() +" overload:"+isOverLoaded);
				generateStub(md,isOverLoaded);
				listOfNewMethods.add(createNewNative(md,nf));	
				listOfNewMethods.add(createNativeWrapper(md,nf));
			}
			else
				listOfNewMethods.add(o);
		}
		
		if (seenNativeMethodDecl) {
			--containingClassDepth;
			if (0 == containingClassDepth)
				generateWrapperEpilogue();
		}

		cb = (ClassBody_c)cb.members(listOfNewMethods);
        return cb;
	}
}