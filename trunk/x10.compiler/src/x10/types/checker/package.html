<h1>Implementation of place types.</h1>

<p>
The key idea is that we add to the context a constrained term,
<code>placeTerm</code> (of type place), representing the current known information
about <code>here</code>.

<code>placeTerm</code>'s term represents the current place (the value of
<code>here</code>).  <code>placeTerm</code> is an <code>XTerm</code> of type place, and its
constraint specifies equalities relating this XTerm to other
XTerms.  E.g. we may know that <code>here = p1, here = p2</code>. So then PlaceTerm
will be <code>p1 given p1=p2</code> or <code>p2, given p1=p2</code>. 

<p><code>here</code> must never occur in the PlaceTerm.

<p>
Here is how the value of placeTerm is defined for various pieces of code where
"here" can be used:

<ul>
<li>
  <bf>global method:</bf> (arg list, return type, body)
  (Recall that all struct instance methods and all static methods are global.)
  placeTerm is set to a new UQV, representing a fixed but unknown place.

<li>
  <bf>Body of an initializer of a static field, static initializer:</bf>
  placeTerm is set to <code>FIRST_PLACE</code>.
<li>
  <bf>Body of a non-global class instance method:</bf>
  <code>placeTerm</code> is set to <code>this.home</code>
</ul>

<p>
The <code>at(p) e</code> or <code>at(p) S</code> introduces place-shifts. 

<p>
<ul>
<li>
  To make it easier for programmers to write code, we permit the place
  argument p of the at expression <code>at(p) e</code> or statement <code>at(p) s</code> to be of
  type <code>Object</code> or of type <code>Place</code>. In case it is of type <code>Object</code>, the <code>at</code>
  expression/statement will automatically coerce <code>p</code> to <code>p.home</code>.
<li>
  <code>p</code> is permitted to be any expression, including a method call. 
</ul>

<p>
A new placeTerm is created and pushed into the current context. The
placeTerm is the variable v if p's type equates self to v. Otherwise
the placeTerm is set to a new UQV v. The constraint of the placeTerm
is the constraint in the type of p, with the substitution v/self applied
if v was generated.

<p>
At an implementation level, XContext and ClosureDef_c now carry two
additional items, a placeTerm and a placeConstraint. The
typeCheckOverride method of AtExpr_c is modified to establish the
value of the placeTerm and placeConstraint fields in the ClosureDef_c
associated with the body of the AtExpr_c. 

<p>
<ul>
<li>
   This is necessary so that type inference for the body of the
   AtExpr_c work correctly. The type of the AtExpr is the return type
   of the closure representing its body. Now a closure body may have
   multiple return statements inside it. The type of the closure is
   taken to be the merge (least upper bound) of the types of the
   expressions returned from within the body of the closure. This
   information is recorded in the associated codeDef(), of type
   ClosureDef.
<li>
   The way type inference for a closure/method body works is as
   follows. A resolver is set for the return type, containing a
   reference to the AST for the body at the time of type
   building. This resolver will be forced to execute when the
   returnType is visited during type-checking, and is
   disambiguated. By this point, typeCheckOverride will have been
   called on the parent AST node (atExpr). Unfortunately, this node is
   *a copy* of the node with which the resolver was initialized!
   Hence, we need to ensure that when the resolver runs it has access
   to the constrained placeTerm. We ensure this by storing the
   information in the ClosureDef associated with the AtExpr AST, since
   all copies of the AST refer to the same ClosureDef.
</ul>
<p>
Additionally, we modify the type-checking of X10New_c to add the
clause "self.home=v,c", where "v given c" is the current placeTerm obtained
from the context.

<ul><li>
   An important point: We we have to implement "adding the clause
   |self.location==here|" by adding to the type of the X10New_c
   expression the constraints |self.location==placeTerm,
   placeConstraint|. This is the right thing to do since placeTerm may
   be a symbolic variable about which the only pieces of information
   we have are those in placeConstraint.
<li>
   Thus if |p| is a final variable, the type-checker can infer that
   the type of |at (p) (new Foo())| is |Foo{self.location==p}|. If
   |p()| is a procedure call with the return type |Place{self==x}|
   then the type of |at (p())(new Foo())| will be inferred as
   |Foo{self.location==_1786, _1786==x}| (for some new symbolic variable
   |_1786|), i.e. |Foo{self.location==x}|.
</ul>