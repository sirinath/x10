The C++ and X10/C++ tests are now run under Linux and compiled with
gcc 4.3.2. The version of Linux being used does not support
multi-core, so the par/seq comparisons give a true indication of
overhead due parallel constructs.

With recent changes, the C++ back-end is now uniformly faster than
Java back-end, and with some exceptions is close to the performance of
hand-coded C++.

------- KEY ISSUES:

Java back-end is considerably slower (typically 10-20x) than
hand-coded Java on most tests. Two recent changes (generated code for
++, final methods for closures) has made this worse for some tests,
better for others.

Parallel UTS is 30x slower than sequential UTS with Java back
end. (Parallel version does not yet work with C++ back end). Probably
due to excessive memory allocation.

Matrix multiply 80x slower than hand-coded with Java
back-end.

C++ back-end X10-style loop test without GC fails by running out of
memory due to unnecessary allocation of Point.

Sequential random access is 1.7x slower than hand-coded with C++ back
end. Profiling shows likely due to handling of primitive casts.

With C++ back-end distributed random access now seg faults. TBD
whether this is due to a code change or due to running under Linux
rather than Cygwin. It could also be a memory issue.

With C++ back end Non-generic arrays are now 2.3x slower than generic
arrays due to lack of inlining support for non-generic classes.

------- PERFORMANCE DATA:

                    cpp-opt        x10-cpp-opt    java-opt       x10-java-opt   

SeqRail2            a: 242  Mop/s  b: 248  Mop/s  c: 267  Mop/s  d: 12.2 Mop/s
SeqPseudoArray2a    e: 231  Mop/s  f: 101  Mop/s  g: 265  Mop/s  h: 25.5 Mop/s
SeqPseudoArray2b                   i: 239  Mop/s                 j: 25.5 Mop/s
SeqArray2a                         k: 98.9 Mop/s                 l: 8.26 Mop/s
SeqArray2b                                                       m: 12.3 Mop/s

SeqUTSBin1          n: 8.57 Mop/s  o: 7.77 Mop/s  p: 9.03 Mop/s  q: 5.05 Mop/s
ParUTSBin1                                                       r: 176  kop/s

SeqMatMultAdd1a     s: 332  Mop/s  t: 310  Mop/s  u: 352  Mop/s  v: 5.18 Mop/s

SeqStream1          w: 108  Mop/s  x: 108  Mop/s  y: 117  Mop/s  z: 3.56 Mop/s
ParStream1                         A: 103  Mop/s                 B: 39.2 Mop/s
DistStream1                        C: 8.56 Mop/s                 D: 37.6 Mop/s

SeqRandomAccess1    E: 47.3 Mop/s  F: 27.6 Mop/s  G: 35.6 Mop/s  H: 7.36 Mop/s
ParRandomAccess1                   I: 29.4 Mop/s                 J: 6.32 Mop/s
DistRandomAccess1                  K: 3.32 kop/s                 L: 120  kop/s

------- COMPARISONS:

C++ back end relative to hand-coded
    rail access                  1.0x faster (b/a)
    non-generic pseudo-array     2.3x slower (e/f)
    generic pseudo-array         1.0x faster (i/e)
    array w/ c-style loop        2.3x slower (e/k)
    sequential UTS               1.1x slower (n/o)
    matrix multiply              1.1x slower (s/t)
    sequential frag. stream      1.0x slower (w/x)
    sequential random access     1.7x slower (E/F)

Java back end relative to hand-coded
    rail access                 21.8x slower (c/d)
    non-generic pseudo-array    10.4x slower (g/h)
    generic pseudo-array        10.4x slower (g/j)
    array w/ c-style loop       32.1x slower (g/l)
    array w/ x10-style loop     21.5x slower (g/m)
    sequential UTS               1.8x slower (p/q)
    matrix multiply             67.9x slower (u/v)
    sequential frag. stream     32.9x slower (y/z)
    sequential random access     4.8x slower (G/H)

C++ back end relative to Java back end
    rail access                 20.3x faster (b/d)
    non-generic pseudo-array     3.9x faster (f/h)
    generic pseudo-array         9.4x faster (i/j)
    array w/ c-style loop       12.0x faster (k/l)
    sequential UTS               1.5x faster (o/q)
    matrix multiply             59.8x faster (t/v)
    sequential frag. stream     30.2x faster (x/z)
    sequential random access     3.8x faster (F/H)

C++ generic vs non-generic       2.4x faster (i/f)

UTS par. speedup (Java)         28.6x slower (q/r)

Stream par. speedup (Java)      11.0x faster (B/z)
Stream par. speedup (C++)        1.0x slower (x/A)

Stream dist. speedup (Java)     10.6x faster (D/z)
Stream dist. speedup (C++)      12.6x slower (x/C)

Rand. access par. speedup (Java)   1.2x slower (H/J)
Rand. access par. speedup (C++)   1.1x faster (I/F)

Rand. access dist. speedup (Java)  61.5x slower (H/L)
Rand. access dist. speedup (C++) 8320.2x slower (F/K)

------- COLUMNS:

cpp-opt       hand coded C++, compiled g++ -O3

x10-cpp-opt   X10 with C++ back end, compiled g++ -O3 with checking off

java-opt      hand coded Java

x10-java-opt  X10 with Java back end, checking off

------- ROWS (TESTS):

The first five tests are grouped together because they do essentially
the same work (from the application perspective) and so should ideally
perform the same.

SeqRail2

    Basic rail performance test. Allocate a rail, assign values to
    each element, read it back. Test is written to simulate treating
    the rail as a 2-d array in order (nested loop with index
    calculation) to facilitate comparisons with array performance
    tests SeqPseudoArray2{a,b} and SeqArray2

SeqPseudoArray2a

    Does the same work as SeqRail2, but wrapped in a class with an
    apply and set method to simulate the "best possible" X10 code for
    a 2-d double (non-generic) array class.

SeqPseudoArray2b

    Like SeqPseudoArray2a, but generic instead of double.

SeqArray2a

    The actual x10.lang.Array code, using a C-style loop.

SeqArray2b

    The actual x10.lang.Array code, using an X10-style loop with
    destructured points.

SeqUTSBin1

    Sequential version of an the Unbalanced Tree Search
    benchmark. Recursively visits nodes of a randomly generated tree.

ParUTSBin1

    Parallel version of an the Unbalanced Tree Search
    benchmark. Recursively visits nodes of a randomly generated tree.

SeqStream1

    Sequential simplified (rail-only) fragmented stream.

ParStream1

    Parallel version of above.

DistStream1

    Distributed version of above.

SeqRandomAccess1

    Sequential simplified (rail-only) fragmented random access.

ParRandomAccess1

    Parallel version of above.

DistRandomAccess1

    Distributed version of above.
