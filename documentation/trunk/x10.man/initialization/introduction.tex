Constructing an object in a safe way is not easy:
    it is well known that dynamic dispatching
    or leaking \this during object construction
    is error-prone~\cite{Dean:1996,Seo:2007:SBD:1522565.1522587,Gil:2009:WRS:1615184.1615216},
    and various type systems and verifiers have been proposed to
    handle safe object initialization~\cite{Hubert:2010:ESO:1888881.1888890,Zibin:2010:OIG:1869459.1869509,Fahndrich:2007:EOI:1297027.1297052,XinQi:2009}.
As languages become more and more complex,
    new pitfalls are created due to the interactions between
    language features.

X10 is an object oriented programming language with a sophisticated
    type system (constraints, class invariants, non-erased generics, closures)
    and concurrency constructs (asynchronous activities, multiple places, global references).
This paper shows that object initialization is a cross-cutting concern
    that interact with other features in the language.
We discuss several language designs that restrict these interactions,
    and explain why we chose the \emph{hardhat} design for X10.

{Hardhat} was termed in~\cite{Gil:2009:WRS:1615184.1615216}
    and it describes a design that prohibits dynamic dispatching or leaking \this during construction.
A hardhat design limits the user
    but also protects her from future bugs.
X10's hardhat design is even stricter due to additional language features
    such as concurrency, places, and closures.

On the other end of the spectrum,
    Java and C\# allow
    dynamic dispatching and leaking \this.
However, they still maintain type- and runtime- safety
    by relying on the fact that every type has a default value
    (also called zero value, which is either 0, \code{false}, or \code{null}),
    and all fields are zero-initialized before the constructor begins.
As a consequence,
    a half-baked object can leak before all its fields are set. %\cite{Seo:2007:SBD:1522565.1522587} - reading uninitialized field references
Phrased differently,
    when reading a final field, one can read the default value initially and later read a different value.
Another source of subtle bugs is due to the synchronization barrier
    at the end of a constructor~\cite{JSR133}
    after which all assignments to final fields are guaranteed to be written.
The programmer is warned (in the documentation only!)
    that immutable objects (using final fields) are thread-safe only if
    \this does not escape its constructor.
%Before JSR 133~\cite{JSR133},
%    immutable objects could have different values in different threads
%    if synchronization was not used properly.
Finally, if the type-system is augmented, for example, with non-null types, then
    a default value no longer exists,
    which leads to complicated type-systems for initialization~\cite{Fahndrich:2007:EOI:1297027.1297052,XinQi:2009}.

\mbox{C++}, as usual, gives you enough rope to hang yourself.
Fields are not zero-initialized, and therefore if \this leaks,
    one can read an uninitialized field.
Moreover, method calls are statically bound during construction,
    which may result in an exception at runtime
    if one tries to invoke a virtual method of an abstract class (see \Ref{Figure}{Dynamic-dispatch} below).
(Determining whether this happens is an intractable problem~\cite{Gil:1998:CTA:646155.679689}.)

A design for object initialization should have the following
    desirable properties:
\begin{description}
%  \item[Reduce runtime errors]
%    Common errors should be caught at compile time.
%    \mbox{C++} pure virtual method error
%  \item[No security errors]
%    Java exception hole.

  \item[Cannot read uninitialized fields]
    One should not be able to read uninitialized fields.
    In \mbox{C++} it is possible to read uninitialized fields,
        returning an unspecified value which can lead to unpredictable behavior.
    In Java, fields are zero initialized before the constructor begins to execute,
        so it is possible to read the default or zero value,
        but never an unspecified value.

  \item[Single value for final fields]
    Final fields can be assigned exactly once, and
        should be read only after assigned.
    In Java it is possible to read a final field before it was assigned,
        therefore returning its default value.

  \item[Immutable objects are thread-safe]
    Immutable objects should be thread-safe without using any explicit synchronization.
    This is not the case even in Java 5 if \this escapes from the constructor~\cite{JSR133};
        See explanation on \Ref{Figure}{TwoPitfalls} below.

%  \item[Parallel]
%    Concurrent and distributed code is error-prone to begin with.
%    The design should prevent initialization-related errors.

  \item[Simple]
    The order of initialization should be clear from the syntax, % intuitive,
        and should not surprise the user.
    Dynamic dispatching during construction disrupts the order
        of initialization by executing a subclass's method before the superclass finished its initialization.
    This is error-prone and often surprises the user.

  \item[Flexible]
    The user should be able to express the common idioms
        found in other languages with minor changes.

  \item[Type safe]
    X10 has types without a default or zero value, such as \code{String\lb{}self!=null\rb}.
    Type safety is violated if reading from a variable of such type returns \code{null}.
    Adding non-null types to Java~\cite{Fahndrich:2003:DCN:949305.949332,Fahndrich:2007:EOI:1297027.1297052,XinQi:2009}
        has been a challenge precisely due to
        Java's relaxed initialization rules.
\end{description}
We believe the hardhat design in X10 has these desirable properties,
    however they come at a cost of limiting flexibility:
    it is not possible to express cyclic immutable structures in X10 2.1.
\Ref{Section}{designs} describes alternative designs for initialization
    such as the \code{proto} design (that was part of X10 2.0) that allows cyclic immutable structures
    at the cost of a more complicated design.

The remainder of this introduction
    presents error-prone sequential initialization idioms in \Ref{Section}{Initialization-pitfalls},
    thread-unsafe immutable objects and serialization in \Ref{Section}{FinalFields}, and
    common initialization pitfalls in parallel X10 programs in \Ref{Section}{Parallelism}.

\subsection{Initialization pitfalls in sequential code}
\label{Section:Initialization-pitfalls}

%class A {
%  static val INSTANCES = new HashSet[A]();
%  val a:Int; // final field
%  def this() { // constructor
%    a = initA(); // dynamic dispatch!
%    System.OUT.println(toString()); //again!
%    INSTANCES.add(this); // leakage!
%  }
%  def initA() { // instance method
%    return 1;
%  }
%  def toString() {
%    return "a="+a;
%  }
%}
%class B extends A {
%  var b:Int = 2; // non-final field
%  def initA() { // overriding
%    return b;
%  }
%  def toString() {
%    return super.toString()+",b="+b;
%  }
%}
\begin{figure}
\begin{lstlisting}
class A {
  static HashSet INSTANCES = new HashSet();
  final int a;
  A() {
    a = initA(); // dynamic dispatch!
    System.out.println(toString()); //again!
    INSTANCES.add(this); // leakage!
  }
  int initA() {
    return 1;
  }
  public String toString() {
    return "a="+a;
  }
}
class B extends A {
  int b = 2;
  B() { super(); }
  int initA() {
    return b+42;
  }
  public String toString() {
    return super.toString()+",b="+b;
  }
  public static void main(String[] args) {
    B b = new B(); // prints: a=42,b=0
    System.out.println(b); // prints: a=42,b=2
  }
}
\end{lstlisting}
\caption{Two initialization pitfalls in Java:
    leaking \this and dynamic dispatch during construction.}
\label{Figure:TwoPitfalls}
\end{figure}

\Ref{Figure}{TwoPitfalls} demonstrates the two most common initialization pitfalls in Java:
    leaking \this and dynamic dispatching.
We will first explain the surprising output due to dynamic dispatching,
    and then the less known possible bug due to leaking \this.

Running this code first prints \code{a=42,b=0}, which is
    surprising to most Java users.
One would expect \code{b} to be 2, and \code{a} to be either 1 or 44.
However, due to initialization order and dynamic dispatch,
    the user sees the default value for \code{b} which is 0,
    and therefore the value of \code{a} is 42.
We will trace the initialization order for \code{new B()}:
    we first allocate a new object with zero-initialized fields,
    and then invoke the constructor of \code{B}.
The constructor of \code{B} first calls \code{super()},
    and only afterward it will run the field initializer (setting \code{b} to 2).
This is the cause of surprise, because \emph{syntactically} the field initializer comes before
    \code{super()},
    however it is executed after.
During the \code{super()} call we perform two dynamic dispatches:
    calling \code{initA()} and \code{toString()}
    execute the implementation in \code{B} (and recall that \code{b} is still 0).
Therefore, \code{initA()} returns 42, and \code{toString()} returns \code{a=42,b=0}.

This bug might seem pretty harmless,
    however if we just change the type of \code{b} from \code{int} to \code{Integer},
    then this code will now produce a \code{NullPointerException},
    which is more severe.

The second pitfall is leaking \this before the object is fully-initialized,
    e.g., \code{INSTANCES.add(this)}.
Note that we leak a partially-initialized object, i.e.,
    the fields of \code{B} have not been assigned yet and they contain their default values.
Suppose that some other thread iterates over \code{INSTANCES} and prints them.
Then that thread might read \code{b=0}.
In fact, it might even read \code{a=0}, even though we just assigned 42 to \code{a}!
The reason is that this write is guaranteed to be seen by other threads only
    after an implicit synchronization barrier that is executed after the constructor ends.
\Ref{Section}{FinalFields} further explains about final fields in Java and this implicit synchronization barrier.



The hardhat design in X10 (described in \Ref{Section}{rules})
    prevents both pitfalls,
    because its rules prohibit leaking \this,
    and they only allow calling private or final methods (that cannot be overridden).
It is possible to annotate a method with \code{@NoThisAccess},
    which allows overriding but prohibits any access to \this.
It is possible to fix the bugs in this example by following the hardhat initialization rules
    in the following way:
    (i)~Instead of leaking \this in the constructor,
        we should add factory methods to create instances of \code{A} and \code{B},
        and add the new fully-initialized instance to \code{INSTANCES} in the factory method.
    (ii)~We should mark \code{initA} as \code{@NoThisAccess},
        and therefore it can be overridden in \code{B}, but it cannot access field \code{b}.
    (iii)~We need to define a private or final method \code{toStringOnlyA};
        this method cannot be overridden so it can be called during construction;
        method \code{toString} could delegate to \code{toStringOnlyA}.



\subsection{Final fields, Concurrency, and Serialization}
\label{Section:FinalFields}
We will start with an anecdote:
    suppose you have a friend that
    playfully removed all the occurrences of the \code{final} keyword
    from your legal Java program.
Would your program still \emph{run} the same?
On the face of it, \code{final} is used only to make the \emph{compiler} more {strict},
    i.e., to catch more errors at compile time
    (to make sure a method is not overridden, a class is not extended, and a field or local
        is assigned exactly once).
After \emph{compilation} is done, \code{final} should not change the \emph{runtime} behavior of the program.
However, this is not the case due to interaction between initialization and concurrency:
    a synchronization barrier is implicitly added
    at the end of a constructor~\cite{JSR133}
    ensuring that assignments to \emph{final} fields are visible to all other threads.
(Assignments to non-final fields might not be visible to other threads!)

This barrier was added to the memory model of Java 5
    to ensure that the common pattern of immutable objects is thread-safe.
Without this barrier another thread might see the default value of a field
    instead of its final value.
For example, it is well-known that \code{String} is immutable in Java,
    and its implementation uses three {final} fields:
    \code{char[] value}, and two integers fields named \code{offset} and \code{count}.
This code \code{"AB".substring(1)} will return a new string (\code{"B"})
    that shares
    the same \code{value} as the previous string, %\lb'A','B'\rb
    but with \code{offset} and \code{count} equal to 1.
Without the barrier, %or without the use of final fields in \code{String},
    another thread might see the default values for these three fields,
    i.e., \code{null} for \code{value} and 0 for \code{offset} and \code{count}.
For instance,
    if one removes the \code{final} keyword in \code{String},
    then
    the following code might print \code{B} (the expected answer),
    or it might print
    \code{A} or an empty string,
    or might even throw a \code{NullPointerException}:
\begin{lstlisting}
final String name = "AB".substring(1);
new Thread() {
  public void run() {
    System.out.println(name);
  }
}.run();
\end{lstlisting}

The same bug might happen in \Ref{Figure}{TwoPitfalls}
    because \this was leaked into \code{INSTANCES}.
Consider another thread that iterates over \code{INSTANCES} and reads field \code{a}.
It might read 0, because we leaked \this before the barrier was reached.

Therefore, when creating an immutable class,
    Java's documentation recommends using final fields
    and avoid leaking \this in the constructor.
However, \code{javac} does not even give a warning if that recommendation is violated.
X10 rules prevent any leaking of \this,
    thus making it safer to create immutable classes.

To summarize, final fields in Java
    enable thread-safe immutable objects.
However, there are two other features in Java that prevents you from using {final} fields:
    \emph{custom serialization} and \code{clone}.
(These two features are connected,
    because a clone can be made by serializing and then de-serializing.)


\subsubsection{Custom serialization}
\emph{Default serialization} in Java of an object \code{o}
    will serialize the entire object graph reachable from \code{o}.
Default serialization is not always efficient, e.g.,
    for a \code{LinkedList}, we only need to serialize the elements in the list,
    without serializing the nodes with their \code{next} and \code{prev} pointers.
(It is possible to mark a field with \code{transient} to exclude it from serialization.)

\emph{Custom serialization} is done by defining a pair of methods called
    \code{writeObject} and \code{readObject}
    that handle serializing and de-serializing, respectively.
For example, field \code{header} in \code{LinkedList} points to a dummy header node,
    and it could be \code{final} except that it is assigned in \code{readObject}
    (and in \code{clone}, as explained below).
The issue here is that \code{readObject} is a method,
    and final fields can only be assigned in
    constructors.
It is possible to use reflection in Java to set a final field,
    and the new memory model (Java's spec, Section~17.5.3)
    even considers this:
\begin{quote}
In some cases, such as deserialization, the system will need to change
    the final fields of an object after construction.
\ldots
Freezes of a final field occur both at the end of the constructor in which the final field is set,
    and immediately after each modification of a final field via reflection or other special mechanism.
\end{quote}

As another example, consider serializing the empty string \code{aVeryLongString.substring(0,0)}.
The default serialization in Java will serialize the very long \code{char[]} with a zero \code{offset} and \code{count}.
If one would have wanted to write a custom serializer for \code{String},
    then she would have to remove the \code{final} keyword (making the class thread-unsafe),
    or use reflection to set final fields.
To summarize, custom serialization in Java is incompatible with final fields.

X10 de-serialize an object by calling a \emph{constructor} with a \code{SerialData}
    argument (as opposed to \code{readObject} in Java which is a \emph{method}).
Therefore, de-serialization in X10 can assign to final fields.


\subsubsection{clone}
Cloning in Java has the same incompatibility with final fields as serialization:
    \code{clone} is a method and therefore it cannot assign to final fields.
X10 has no clone-magic as in Java.
Instead, the user can clone an object using the serialization mechanism,
    which is invoked when a final variable is copied to another place
    (\Ref{Section}{Parallelism} explains about \code{at} and places in X10):
\begin{lstlisting}
def clone[T](o:T) {
  return at (here) o;
}
\end{lstlisting}
Using serialization is less efficient than directly cloning an object,
    and future work is planned to add cloning support to X10.




\subsection{Parallelism and Initialization in X10}
\label{Section:Parallelism}

Concurrency in X10 uses two constructs:
\code{finish} and \code{async}

Using local variables for \code{fib2} and \code{fib1} ...
Explain that with locals the code would be more elegant,
    but we wanted to focus only on object initialization.

%\begin{figure}
%\begin{lstlisting}
%class Fib {
%  val fib2:Int; // fib(n-2)
%  val fib1:Int; // fib(n-1)
%  val fib:Int;  // fib(n)
%  def this(n:Int) {
%    finish {
%      async {
%        fib2 = n<=1 ? 0 : new Fib(n-2).fib;
%      }
%      fib1 = n<=0 ? 0 :
%             n<=1 ? 1 : new Fib(n-1).fib;
%    }
%    fib = fib2+fib1;
%  }
%}
%\end{lstlisting}
%\caption{Concurrent fibonacci example.
%    \code{async} starts an asynchronous activity,
%    and \code{finish} waits for all spawned activities to finish.
%    Initialization pitfall:
%        forget to use \code{finish},
%        and read from \code{fib2} before its write finished.}
%\label{Figure:ConcurrentFib}
%\end{figure}


\begin{figure}
\begin{lstlisting}
class Fib {
  val fib2:Int; // fib(n-2)
  val fib1:Int; // fib(n-1)
  val fib:Int;  // fib(n)
  def this(n:Int) {
    finish {
      async {
        val p = here.next();
        fib2 = at(p)
         n<=1 ? 0 : new Fib(n-2).fib;
      }
      fib1 = n<=0 ? 0 :
         n<=1 ? 1 : new Fib(n-1).fib;
    }
    fib = fib2+fib1;
  }
}
\end{lstlisting}
\caption{Concurrent and distributed fibonacci example.
    Concurrent code is expressed using \code{async} and \code{finish}:
        \code{async} starts an asynchronous activity,
        and \code{finish} waits for all spawned activities to finish.
    Distributed code uses \code{at} to shift between
        \emph{places};
        \code{here} denotes the current place.
    \code{at(p) E} evaluates expression \code{E}
        in place \code{p}, and finally copies the result back;
        any final variables captured in \code{E} from
        the outer environment (e.g., \code{n})
        are first copied to place \code{p}.
    Possible initialization pitfall:
        (i) %Concurrency bug:
            forget to use \code{finish},
            and read from \code{fib2} before its write finished,
        (ii) %Distributed bug:
            write to field \code{fib2} in another place, i.e.,
            \code{at(p) this.fib2=\ldots},
            which causes \this to be copied to \code{p}
            so one writes to a copy of \this.
    }
\label{Figure:DistributedFib}
\end{figure}


X10 initialization rules prohibits the pitfalls in \Ref{Figure}{DistributedFib}:
        concurrency: must wait for concurrent field writes to finish,
        distributed: can not write to a copy of \this.



The remainder of this paper is organized as follows.
\Ref{Section}{rules} presents the hardhat initialization rules of X10 version 2.1
    using examples,
    by slowly adding language features and describe their interaction with
    object initialization.
\Ref{Section}{designs} describes alternative designs for object initialization
    (one was implemented in X10 version 2.0 and another was under consideration for 2.1),
    weighing the pros and cons of each.
\Ref{Section}{implementation} outlines our implementation using the polyglot framework
    and the compilation time overhead of checking these initialization rules.
\Ref{Section}{case-study} investigates the consequences of having a hardhat design
    in a case study that converted a large collection of Java classes to X10.
\Ref{Section}{related-work} summarizes previous work in the field of object initialization.
Finally, \Ref{Section}{conclusion} concludes.
