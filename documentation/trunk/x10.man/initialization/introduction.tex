Constructing an object in a safe way is not easy:
    it is well known that dynamic dispatching
    or leaking \this during object construction
    is error-prone~\cite{Dean:1996,Seo:2007:SBD:1522565.1522587,Gil:2009:WRS:1615184.1615216},
    and various type systems and verifiers have been proposed to
    handle safe object initialization~\cite{Hubert:2010:ESO:1888881.1888890,Zibin:2010:OIG:1869459.1869509,Fahndrich:2007:EOI:1297027.1297052,XinQi:2009}.
As languages become more and more complex,
    new pitfalls are created due to the interactions between
    language features.

X10 is an object oriented programming language with a sophisticated
    type system (constraints, class invariants, non-erased generics, closures)
    and concurrency constructs (asynchronous activities, multiple places, global references).
This paper shows that object initialization is a cross-cutting concern
    that interact with other features in the language.
We discuss several language designs that restrict these interactions,
    and explain why we chose the \emph{hardhat} design for X10.

{Hardhat} was termed in~\cite{Gil:2009:WRS:1615184.1615216}
    and it describes a design that prohibits dynamic dispatching or leaking \this during construction.
A hardhat design limits the user
    but also protects her from future bugs.
X10's hardhat design is even stricter due to additional language features
    such as concurrency, places, and closures.

On the other end of the spectrum,
    Java and C\# allow
    dynamic dispatching and leaking \this.
However, they still maintain type- and runtime- safety
    by relying on the fact that every type has a default zero value
    (whether that zero is 0, false, or \code{null}),
    and all fields are zero-initialized before the constructor begins.
As a consequence,
    a half-baked object can leak before all its fields are set. %\cite{Seo:2007:SBD:1522565.1522587} - reading uninitialized field references
Phrased differently,
    when reading a final field, one can read the default value initially and later read a different value.
Another source of subtle bugs is due to the synchronization barrier
    at the end of a constructor~\cite{JSR133}
    after which all assignments to final fields are guaranteed to be written.
The programmer is warned (in the documentation only!)
    that objects with final fields are thread-safe only if
    \this does not escape its constructor.
%Before JSR 133~\cite{JSR133},
%    immutable objects could have different values in different threads
%    if synchronization was not used properly.
Finally, if the type-system is augmented, for example, with non-null types, then
    a default value no longer exists,
    which leads to complicated type-systems for initialization~\cite{Fahndrich:2007:EOI:1297027.1297052,XinQi:2009}.

\mbox{C++}, as usual, gives you enough rope to hang yourself.
Fields are not zero-initialized, and therefore if \this leaks,
    one can read an uninitialized field.
Moreover, method calls are statically bound during construction,
    which may result in an exception at runtime
    if one tries to invoke a virtual method of an abstract class (see \Ref{Figure}{Dynamic-dispatch} below).
(Determining whether this happens is an intractable problem~\cite{Gil:1998:CTA:646155.679689}.)


The remainder of this introduction introduce that
    hardhat design in X10 by examples,
    by slowly adding language features and describe their interaction with
    object initialization.
The hardhat rules are summarized in \Ref{Section}{hardhat}.

\subsection{Constructors and inheritance}
Inheritance is the first feature that interacts with initialization:
    when class \code{B} inherits from \code{A}
    then every instance of \code{B} has a sub-object that is like an instance of \code{A}.
When we initialize an instance of \code{B}, we must first initialize its \code{A} sub-object.
We do this in X10 by forcing the constructors of \code{B} to make a super call,
    i.e., call a constructor of \code{A}
    (either explicitly or implicitly).

\Ref{Figure}{Escaping-this} shows X10 code that demonstrates the interaction
    between inheritance and initialization,
    and explains by example why leaking \this during construction can cause bugs.
In all the examples, errors issued by the X10 compiler are marked with \code{//err}.

We say that object is \emph{raw} before its constructor ends,
    and afterward it is \emph{cooked}.
Note that when an object is cooked, all the super calls ended, so all its sub-objects are cooked.
X10 prohibits any aliasing or leaking of \this during construction,
    therefore only \this can be raw (any other variable is definitely cooked).

Object initialization begins by invoking a constructor,
    denoted by the method definition \code{def this()}.
The first leak would cause a problem because field \code{a} was not assigned yet.
However, even after all the fields of \code{A} have been assigned,
    leaking is still a problem
    because fields in a subclass (field \code{b}) have not yet been initialized.
Note that leaking is not a problem if \this is not raw, e.g., in \code{m1()}.

The fact that \code{m2} is non-escaping, and therefore cannot leak \this,
    was \emph{implicitly} inferred from the call to \code{m2}
    in the constructor.
(See rule 2: \code{m2} is non-escaping because it was called on a raw \this receiver.)
The user could also mark \code{m2} \emph{explicitly} as non-escaping by using the annotation
    \code{@NonEscaping}.
We recommend to explicitly mark public methods as \code{@NonEscaping} to show intent,
    as done on method \code{m3}.
Without this annotation the call \code{super.m3()} in \code{B} would be illegal.
(We could infer that \code{m3} must be non-escaping,
    but that would cause a dependency from a subclass to a superclass,
    which is not natural for people used to separate compilation.)


\begin{figure}
\begin{lstlisting}
class A {
  val a:Int;
  def this() {
    LeakIt.foo(this); //err
    this.a = 1;
    val me = this; //err
    LeakIt.foo(me);
    this.m2(); // so m2 is implicitly non-escaping
  }
  final def m1() {
    LeakIt.foo(this);
  }
  // implicitly non-escaping
  final def m2() {
    LeakIt.foo(this); //err
  }
  // explicitly non-escaping
  @NonEscaping final def m3() {
    LeakIt.foo(this); //err
  }
}
class B extends A {
  val b:Int;
  def this() {
    super();
    this.b = 2;
    super.m3();
  }
}
\end{lstlisting}
\caption{Escaping \this example.
    \myrule{\arabic{RuleCounter}}{\this and \code{super} are raw in \emph{non-escaping} methods and in field initializers}
    \myrule{\arabic{RuleCounter2}}{A method is \emph{non-escaping} if it is a constructor,
            or annotated with \code{@NonEscaping} or \code{@NoThisAccess},
            or a method that is called on a raw \this receiver}
    \myrule{\arabic{RuleCounter3}}{A raw \this or \code{super} cannot escape or be aliased}
    \myrule{\arabic{RuleCounter4}}{A call on a raw \code{super} is allowed only for a \code{@NonEscaping} method}
    (\code{\textbf{final}} and \code{@NoThisAccess} are related
        to dynamic-dispatching as shown in \Ref{Figure}{Dynamic-dispatch}.)}
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\label{Figure:Escaping-this}
\end{figure}




\subsection{Dynamic dispatch}
Dynamic dispatching interacts with initialization by transferring control to the subclass
    before the superclass completed its initialization.
\Ref{Figure}{Dynamic-dispatch} demonstrates why dynamic dispatching is error-prone during construction:
    calling \code{m1} in \code{A} would dynamically dispatch and
    call the implementation in \code{B}
    that would read the default value.

X10 prevents dynamic dispatching by requiring that non-escaping methods
    must be private or final
    (so overriding is impossible).
However, sometimes dynamic dispatching is required during construction.
For example, if a subclass needs to refine initialization
    of the superclass's fields.
Such refinement cannot have any access to \this, and therefore
    such methods are marked with \code{@NoThisAccess}.
(Like in Java, \code{@} is used for annotations in X10.)
\code{@NoThisAccess} prohibits any access to \this,
    however, one could still access the method parameters.


In C++, the call to \code{m1} is legal,
    but at runtime
    methods are statically bound,
    so you will get an error for calling a pure virtual function.
In Java, the call to \code{m1} is also legal,
    but at runtime
    methods are dynamically bound,
    so the implementation of \code{m1} in \code{B}
    will read the default value of \code{b}.
%This behavior is undesired in Java,
%    and Java discourages it by trying to catch statically most of these cases.
%For example, Java prohibits calls to member functions before the super object was initialized,
%    as this example shows (which is also illegal in X10):
%\begin{lstlisting}
%class B extends A { B() {super(f()); }}
%\end{lstlisting}

Finally, classes \code{C} and \code{D} show why it is sometimes required to mark
    methods explicitly as \code{@NonEscaping}:
    if a subclass (\code{D}) needs to call a method a method (\code{m3})
    during construction, then it must be marked as non-escaping.


\begin{figure}
\begin{lstlisting}
abstract class A {
  val a:Int;
  def this() {
    this.a = m1(); //err
    this.a = m2();
  }
  abstract def m1():Int;
  @NoThisAccess abstract def m2():Int;
}
class B extends A {
  var b:Int = 3;
  def this(i:Int) {
    super(i);
  }
  def m1() {
    val x = super.a; // returns 0 in Java
    val y = this.b; // returns 0 in Java
    return 1;
  }
  @NoThisAccess def m2() {
    val x = super.a; //err
    val y = this.b; //err
    return 2;
  }
}
\end{lstlisting}
\caption{Dynamic dispatching example.
    \myrule{\arabic{RuleCounter2}}{A non-escaping method must be private or final, unless it has \code{@NoThisAccess}}
    \myrule{\arabic{RuleCounter3}}{A method with \code{@NoThisAccess} cannot access \this or \code{super} (neither read nor write its fields)}
    }
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\label{Figure:Dynamic-dispatch}
\end{figure}




\subsection{Exceptions}
Constructing an object may not always end normally,
    e.g., building a date object from an illegal date string should throw an exception.
Exceptions combined with inheritance interact with initialization in the following way:
    a cooked object must have cooked sub-objects,
    therefore if a constructor ends normally (thus returning a cooked object)
    then all preceding constructor calls (either \code{super(\ldots)} or \code{this(\ldots)})
    must end normally as well.
Phrased differently, in a constructor it should not be possible to
    recover from an exception thrown by a constructor call.
This is one of the reason why a constructor call must be the first statement in Java;
    failure to verify this led to a famous security attack~\cite{Dean:1996}.

\Ref{Figure}{Exceptions} shows that it is an error to try to recover from an exception thrown
    by a constructor call.
\begin{figure}
\begin{lstlisting}
class B extends A {
  def this() {
    try { super(); } catch(Throwable e){} //err
  }
}
\end{lstlisting}
\caption{Exceptions example:
    if a constructor ends normally (without throwing an exception),
        then all preceding constructor calls ended normally as well.
    \myrule{\arabic{RuleCounter}}{If a constructor does not call \code{super(\ldots)} or \code{this(\ldots)},
        then an implicit \code{super()} is added at the beginning of the constructor;
        the first statement in a constructor is a constructor call (either \code{super(\ldots)} or \code{this(\ldots)});
        a constructor call may only appear as the first statement in a constructor
        }
    }
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\label{Figure:Exceptions}
\end{figure}



\subsection{Inner classes}
Inner classes usually read the outer instance's fields during construction,
    e.g., a list iterator would read the list's header node.
Therefore, X10 requires that the outer instance is cooked,
    and prohibits creating an inner instance when the receiver is a raw \this.
\Ref{Figure}{InnerClass} shows it is an error in X10 to create an inner instance
    if the outer is raw,
    but it is ok to create an instance of a static nested class,
    because it has no outer instance.

In fact, it is possible to view this rule as a special case to the rule that
    prohibits leaking a raw \this
    (because when you create an inner instance on a raw \this receiver,
    you created an alias,
    and now you have two raw objects: \code{Inner.this} and \code{Outer.this}).
We wish to keep the invariant that only \this might be raw.

\Ref{Figure}{InnerClass} todo...

\begin{figure}
\begin{lstlisting}
class Outer {
  val a:Int;
  def this() {
    // Outer.this is raw
    Outer.this. new Inner(); //err
    new Nested(); // ok
    a = 3;
  }
  class Inner {
    val b:Int;
    def this() {
      // Inner.this is raw, but Outer.this is cooked
      val x = Outer.this.a;
    }
  }
  static class Nested {}
}
\end{lstlisting}
\caption{Inner class example: the outer instance is always cooked.
    \myrule{\arabic{RuleCounter}}{a raw \this cannot be the receiver of \code{new}}
    }
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\label{Figure:InnerClass}
\end{figure}


\subsection{Static initialization}
X10 does not support dynamic class loading as opposed to Java,
    and all static fields in X10 are final.
Thus, initialization of static fields is a one-time phase, denoted the static-init phase,
    that is done before the \code{main} method is executed.

During the static-init phase we must finish writing to all static fields,
    and reading a static field \emph{waits} until the field is initialized
    (i.e., the current activity/thread blocks if the field was not written to,
    and it resumes after another activity writes to it).
Obviously, this may lead to deadlock as demonstrated by \Ref{Figure}{Static-init}.
However, in practice, deadlock is rare,
    and usually found quickly the first time a program is executed.

\begin{figure}
\begin{lstlisting}
class A {
  static val a:Int = B.b;
}
class B {
  static val b:Int = A.a;
}
\end{lstlisting}
\caption{Static initialization example:
    the program will deadlock at run-time
    during the static-init phase (before the \code{main} method is executed).
    }
\label{Figure:Static-init}
\end{figure}


\subsection{Constraints and default/zero values}
Constraints and default values.
The following types do not have a default value:
\code{Int\lb self!=0\rb}
\code{String\lb self!=null\rb}

Therefore the fields of an object cannot be zero-initialized in X10.

\Ref{Figure}{Constraints} todo ...

\begin{figure}
\begin{lstlisting}
class A {
  var a:Int{self!=0}; //err
}
\end{lstlisting}
\caption{No default value example.
    \myrule{\arabic{RuleCounter}}{A type \emph{has-zero} if a it contains the zero value
        (which is either \code{null}, \code{false}, 0, or
            zero in all fields for user-defined structs, see \Ref{Section}{Generics-and-Structs})}
    \myrule{\arabic{RuleCounter2}}{A \code{var} field whose type has-zero that lacks a field initializer,
        is implicitly added an zero initializer}
    }
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\label{Figure:Constraints}
\end{figure}


\subsection{Read and write order of fields}
final vs.\ non-final fields:
Inter-procedural data flow
vs.\
Intra-procedural data flow
todo

In Java it is legal...

\Ref{Figure}{Read-Write-Order} todo ...

\begin{figure}
\begin{lstlisting}
class A {
  val a:Int;
  def this() {
    m2();
    a = 1;
  }
  final def m2() {
    val x = a; //err
  }
}
class B {
  var i:Int; // implicitly initialized to 0
  var j:Int{self!=0};
  def this() {
    i++;
    j++; //err
  }
}
class C {
  var j:Int{self!=0};
  def this() {
    write();
    read();
  }
  final def write() {
    this.j = 1;
  }
  final def read() {
    val x = this.j;
  }
}
\end{lstlisting}
\caption{Read-Write order for fields examples.
    \myrule{\arabic{RuleCounter}}{A field can be read only after it was definitely written}
    \myrule{\arabic{RuleCounter2}}{A constructor must write to all fields}
    }
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\label{Figure:Read-Write-Order}
\end{figure}





We finally turn our attention to features that are unique to X10:
    concurrency, parallelism,
    and a sophisticated type system using constraints and properties.

\subsection{Concurrency}
Explain async+finish.
If the finish was removed, then it would be an error ...


\Ref{Figure}{Asynchronously-init} todo ...

\begin{figure}
\begin{lstlisting}
class A {
  val a:Int;
  val b:Int;
  def this() {
    finish {
      async a = 1;
    }
    async b = 2; //err
  }
}
\end{lstlisting}
\caption{Asynchronously assigned fields example.
    \myrule{\arabic{RuleCounter}}{All field assignments must finish when the constructor ends}
    }
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\label{Figure:Asynchronously-init}
\end{figure}


\subsection{Multiple Places}
Places require serialization and deserialization (both custom and automatic) across "at".

\Ref{Figure}{Multi-place} todo ...

\begin{figure}
\begin{lstlisting}
class A {
  val a:Int;
  def this() {
    // Execute at another place
    at (here.next())
      this.a = 1; //err
  }
}
\end{lstlisting}
\caption{Multi-place initialization example.
    \myrule{\arabic{RuleCounter}}{a raw \this cannot cross to another place}
    }
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\label{Figure:Multi-place}
\end{figure}


\subsection{Global references}
Special GlobalRef class: let \this escape and it creates a cycle.
We allow a raw \this to escape iff
* field is private with a field initializer.
* cannot be used with a raw \this receiver.


\Ref{Figure}{GlobalRef} todo ...

\begin{figure}
\begin{lstlisting}
class A {
  private val root =
   new GlobalRef(this);
  def me() = root();
}
class B extends A {
  def this() {
    val alias = me(); //err
  }
}
\end{lstlisting}
\caption{\code{GlobalRef} example.
    \myrule{\arabic{RuleCounter}}{A raw \this can only escape to a global ref constructor in a field initializer,
        provided the field is private and is not read via a raw \this receiver}
    }
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\label{Figure:GlobalRef}
\end{figure}

If \code{me()} was prefixed with
\code{@NonEscaping public final}
then accessing \code{root} would be an error.
%Cannot use 'root' because a GlobalRef[\ldots](this) cannot be used in a field initializer, constructor, or methods called from a constructor.



\subsection{Properties and the class invariant}
Properties are final values that can be used in constraints,
    e.g., \code{Array} has a \code{size} property,
    so an array of size 2 can be expressed as: \code{Array\lb self.size==2\rb}.

Properties are final fields that are initialized before all other fields.
% Should I talk about interface and abstract property methods? Doesn't relate to initialization...
The \emph{class invariant} may refer only to properties of the class,
    and it must be satisfied after the property call in every constructor.


\Ref{Figure}{Properties} todo ...

\begin{figure}
\begin{lstlisting}
class A(a:Int) {
  def this() {
    property(42);
  }
}
class B(b:Int) {b!=0} extends A {
  val f1 = a+b;
  val f2:Int;
  def this() {
    super();
    f2 = f1; //err
    property(3);
  }
}
\end{lstlisting}
\caption{Properties and class invariant example:
        properties (e.g., \code{a} and \code{b})
        are final fields that are initialized before all other fields
        using a property call (\code{property(\ldots);} statement).
    \myrule{\arabic{RuleCounter2}}{If a class does not define any properties, then
        an implicit \code{property()} is added
        after (the implicit or explicit) \code{super(\ldots)}}
    \myrule{\arabic{RuleCounter3}}{If a constructor does not call \code{this(\ldots)},
        then it must have exactly one
        property call, and it must be unconditionally executed
        (unless the constructor throws an exception);
        the class invariant must hold after the property call}
    \myrule{\arabic{RuleCounter4}}{Field initializers are executed in their declaration order
        after (the implicit or explicit) the property call}
    \myrule{\arabic{RuleCounter5}}{The super fields can only be accessed after \code{super(\ldots)},
        and the fields of \this can only be accessed after \code{property(\ldots)}}
    }
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\label{Figure:Properties}
\end{figure}




\subsection{Closures}



\Ref{Figure}{Closures} todo ...

\begin{figure}
\begin{lstlisting}
class A {
  val a = 3;
  def this() {
    val local = this.a;
    val closure1 = ()=>local;
    val closure2 = ()=>this.a; //err
    at (here.next())
      closure2();
  }
}
\end{lstlisting}
\caption{Closure capture \this example.
    \myrule{\arabic{RuleCounter}}{A closure cannot capture a raw \this}
    }
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\label{Figure:Closures}
\end{figure}



\subsection{Generics and Structs}
\label{Section:Generics-and-Structs}
Structs in X10 ...
Does not contain \code{null}, so \code{haszero} ...

Generics are not unique to X10,
    however the combination of generics and the lack of default values for all types
    lead to new pitfalls.
In addition, generics in X10 are \emph{not} erased as in Java
    in order to make instantiations over structs efficient.

for example, \code{Box[Byte]} and \code{Box[Int]}
    would have the same size in Java but different sizes in X10.

\Ref{Figure}{Constraints} showed that a \code{var} must be assigned if
    it does not contain the zero value.
For generics, we added a \code{haszero} type condition that requires a type parameter to have the zero value.


\Ref{Figure}{Generics} todo ...

\begin{figure}
\begin{lstlisting}
class A[T] {
  var a:T; //err
}
class B[T] {T haszero} {
  var a:T;
}
class Usage {
  var b1:B[Int];
  var b1:B[String];
  var b1:B[Int{self!=0}]; //err
}
\end{lstlisting}
\caption{\code{haszero} type condition.
    \myrule{\arabic{RuleCounter}}{statically checks a type has the zero value}
    }
\stepcounter{RuleCounter}\stepcounter{RuleCounter2}\stepcounter{RuleCounter3}\stepcounter{RuleCounter4}\stepcounter{RuleCounter5}\stepcounter{RuleCounter6}
\label{Figure:Generics}
\end{figure}


examples for \code{Array}

 \code{Zero.get[T]()}
