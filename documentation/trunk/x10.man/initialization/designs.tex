

\subsection{Default values design}

Java first initializes fields with either $0$, \texttt{false}, or \texttt{null}
(depending on the field type) and then running the constructor to initialize
the fields according to the programmer's wishes.  If every X10 type had a
default value that was statically known, then Java's object initialization
scheme could be used in X10.  This would have the advantage of familiarity for
Java programmers that are learning X10.  The disadvantages are that that it is
nonintuitive that final fields can be observed to change value, and that it is
prone to undetectable errors where the field is read before initialization.

Unfortunately it is hard to reconcile the notion of a default value with X10's
type system, because a programmer can define a type which does not contain the
default value.  In the X10 type system, one can define a type with no values at
all, by using a constraint that yields contradiction.

This could be addressed by extending the X10 type to require that the
programmer define a new constant value for any type that has been constrained
enough that the original default value is no longer a member of the type.  This
means every field can be initialized to the value defined in its type.  The
disadvantage of this is that the type system becomes more complex and more type
annotations are required.  We decided that this, in combination with the
disadvantages given above, was too problematic to justify the advantages of
Java-style object initialization.

\subsection{Proto Design}

If we want to allow some of the programs that the Hardhat design rejects, such
as immutable cycles in the object graph, but we do not want to burden the type
system with default value annotations, then one solution is to allow
\texttt{this} to escape in certain cases while still preventing reads from
uninitialized fields.  This can be achieved by annotating reference types with
a keyword \texttt{proto} to indicate that the referenced object is partially
constructed.  Reads of fields where the target object has \texttt{proto} type
are not allowed because a partially constructed object may not yet have
initialized its fields.  The advantage of this approach is that it allows a set
of partially constructed objects to establish themselves as a cycle of field
references.  The disadvantage is it requires an additional type annotations,
although this annotation is only required if one wants to create immutable
cyclic heap structures.  Also note that there are no additional space or
runtime overheads since these extra type system mechanisms are for static
checking only.

An example of an immutable cycle of two nodes is given
in fig.\ref{Figure:Cyclic}.  A more practical but less concise example would be
an immutable doubly-linked list.  Let us assume that we would like to optimize
away any null pointer checks, so we constrain all references to exclude the
null value.

\begin{figure}
\begin{lstlisting}
class C {
    public val next : C {self!=null};
    private def this (n:proto C{self!=null}) {
        // Console.OUT.println(n.next);
        // n.f();
        // s(n);
        this.next = n;
    }
    public def this () {
        // Console.OUT.println(this.next);
        // f();
        // s(this);
        this.next = new C(this);
    }
    public def f() {
        Console.OUT.println(this.next);
    }
    public static def s(C this_) {
        this_.f();
    }
}
val c:C{self!=null} = new C();
val c2:C{self!=null} = c.next;
\end{lstlisting}
\caption{An immutable cycle of heap references, using \texttt{proto}.}
\label{Figure:Cyclic}
\end{figure}

The commented out lines indicate code that would be rejected by the type
system.  In the public constructor, \texttt{this} is a pointer to a partially
constructed object.  If the type of \texttt{this} were to be explicit, it would
be \texttt{proto C\{self!=null\}}.  The \texttt{proto} element of the type
forbids any field reads, and permits writes to immutable fields.  It also
prevents the reference being leaked (e.g. into \texttt{f()}), except into
variables where the \texttt{proto} type is also present and therefore where
there is protection from uninitialized field reads.

The private constructor's \texttt{n} parameter takes a \texttt{proto} pointer
to the original \texttt{C} instance.  It is very limited in what it can do,
e.g. it cannot read \texttt{n.next}, but it can initialize its \texttt{next}
field with the passed-in value.  When the public constructor returns, both
objects are fully constructed with all fields initialized.  Thus, the type of
the variable \texttt{c} does not have a proto annotation and the field read
\texttt{c.next} is allowed.

If a type has the \texttt{proto} keyword, then the instance is definitely
partially constructed.  Likewise, the absence of \texttt{proto} means the
instance is definitely fully constructed.  Thus, there is no subtype
relationship between \texttt{proto C} and \texttt{C}.  It therefore makes no
sense to allow casting between the two types, and one may not extend a proto
type.  The only way to get an objedct of \texttt{proto} type is via the
\texttt{this} keyword in a constructor.

We also do not allow fields to have \texttt{proto} type.  This is because the
referenced object will eventually be fully-constructed and then there would be
a variable of \texttt{proto} type pointing to a fully constructed instance.
This admits the possibility of someone assigning a partially constructed object
to a field of the fully constructed object, just as was done in the private
constructor in fig.~\ref{Figure:Cyclic}.  Then, one could accidently read an
uninitialized field from the partially constructed object by going through the
fully constructed objcet.  Disallowing \texttt{proto} in fields avoids this
problem.  The same problem does not exist with local variables, as due to
lexical scoping, the variable will go out of scope before the constructor
returns and the object becomes fully constructed.

If one examines the state of the heap as this example executes, there can be
seen to be a subgraph of 2 partially-constructed objects, which is completely
isolated except for references from the stack of the thread which is executing
the constructors.  In general, we need for partially constructed objects to be
isolated from the rest of the heap, and this is enforced by disallowing
\texttt{proto} on fields.  The stack reference that causes the subgraph to
remain alive, is safe because it is annotated with \texttt{proto}.

We are not aware of any utility in throwing or catching \texttt{proto} types so
we avoid issues relating to partially constructed objects escaping via the
exception mechanism by simply disallowing the throwing and catching of
\texttt{proto} exceptions.

There would be an issue calling other instance methods on \texttt{this} from a
constructor, because the type of \texttt{this} in those methods would need to
be \texttt{proto} since the target is still partially constructed.  We support
this by allowing the \texttt{proto} keyword to also be used on a method as an
effect annotation, i.e. it must be preserved by inheritance.  Such methods can
only becalled on partially constructed objects, and the type of \texttt{this}
subjects them to the same restrictions as in constructor bodies.

While we believe this type system is correct and usable for writing real
programs in the X10 language, we had to decide whether the additional type
system complexity and annotations were a reasonable price to pay for the
additional expressiveness (i.e. the ability to construct immutable heap
cycles).  We ultimately decided that immutable heap cycles are too rare in
practice to justify including these extra mechanisms in the language.
