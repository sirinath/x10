



Example program:

class E extends Object {
  this() = new Object();
}
class Seq extends Object {
  this(a1:Object, a2:Object) = a2;
}
class C2 extends Object {
  val fVal:E;
  var fVar:E;
  this(a1:E, a2:E) =
    finish async this.fVal = a1; m(a2);
  R() SW() AW(fVar) m(a:E):E = 
    async this.fVar = a; new E();  
  escaping m2():Seq = new Seq(this,this.fVal);
}
class C3 extends Object {
  var fVar:E;
  this(a:E) =
    new Seq(fVar=a,fVar); // ok
}
class C4 extends Object {
  var fVar:E;
  this(a:E) =
    new Seq(fVar,fVar=a); // ERR
}


Helper methods: 
* R(m) - the fields that m can read (\bot means it can read anything)
* SW(m) - the fields that m must sequentially write to (it can write to more)
* AW(m) - the fields that m must asynchronously write to.

F is a set of fields of \this that was definitely-sync-assigned
* R(e,F) - the fields of \this that might be read in e.
* AW(e,F) - the fields of \this that are definitely async written to in e.
* SW(e,F) - the fields of \this that are definitely seq written to in e.
AF is a set of fields that may be asynchronously assigned.

Given a definition:
MM m(\ol{x:C}):C = e;
* Read(m) = 
\top  MM==escaping
\ol{f}  MM==read(\ol{f}) ...
(Regarding \top: we have that the set of all fields is a subset of \top)
* SyncWrite(m) = 
\emptyset  MM==escaping
\ol{f}  MM==... SW(\ol{f}) ...
Similarly, AsyncWrite(m).

The constructor of C cannot read anything and it must write to all fields directly declared in C:
R(this) = \emptyset
SW(this) = AW(this) = direct-fields(C)

R(e,F) - whether e does not escape \this ("this" can be used only as a field or method receiver)
	and only reads fields of \this that are in F or that have been previously written in e.
Examples:
R(this.f, {f}) = true
R( new Seq(this.f=new Object(), this.f), {} ) = true

R([e_1,...,e_n],F) = R(e_1,F) and R(e_2,F and SW(e_1)) ...
R(e,F) =
R([e"],F)			e == this.f = e"
R([e',e"],F)			e == e'.f = e"
R(e',F)				e == finish e'
R(e',F) and R(e",F)		e == async e';e"
f \in F				e == this.f
R(e',F)				e == e'.f
(Read(m,C) \subseteq F) and R([\ol{e"}],F \cup SyncWrite(m,C))		e == this.m(\ol{e"})
R([e_0,\ol{e}],F)		e == e_0.m(\ol{e})
R([\ol{e'}],F)			e == new C(\ol{e'})
false			e == this  (non-escaping)
true			e == l | e == x

SW(e) =
{f} \cup SW(e")			e == this.f = e"
SW(e') \cup SW(e")		e == e'.f = e"
AW(e')				e == finish e'
SW(e")				e == async e';e"
SW(e')				e == e'.f
SyncWrite(m) \cup SW(\ol{e"})	e == this.m(\ol{e"})
SW(e') \cup SW(\ol{e"})		e == e'.m(\ol{e"})
SW(\ol{e'})			e == new C(\ol{e'})
\emptyset			e == l | e == x

AW(e) =
AW(e") \cup AW(e')		e == async e';e"
AsyncWrite(m) \cup AW(\ol{e"})	e == this.m(\ol{e"})
...

ctor: ctor(x:C) { super(e1); e2; }    class C extends C'
R(e1,\emptyset) and  R(e2,SW(e1) \cup \Fields(C'))
vao([e1,e2],\emptyset)
SW([e1,e2]) = \Fields(C)\setminus\Fields(C')





Reduction:
The congruence rules for \async propogates it upward (but not crossing a \finish):

(async e1; l).m(e,...)  --->  async e1; ( l.m(e,...) )
l1.m(\ol{l},(async e1;l2),...)  --->  async e1; ( l1.m(\ol{l},l2,...) )
new C(\ol{l},(async e1;l2),...)  --->  async e1; ( new C(\ol{l},l2,...) )
(async e1; l).f  --->  async e1; ( l.f )

e,H--->e',H	
-----------------------------
async e;e" ---> async e';e"

e,H--->e',H	
-----------------------------
async e";e ---> async e";e'

...

