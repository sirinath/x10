\documentclass[a4paper]{article}

%% For typesetting theorems and some math symbols.
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{fullpage}

\title{Initialization in X10 - Technical Report}

\author{Yoav Zibin \texttt{yoav.zibin@gmail.com}}

\date{}




\input{commands}

%\mynewcommand{\hvar}{\code{var}}
%\mynewcommand{\hval}{\code{val}}

\mynewcommand{\async}{\code{async}}
\mynewcommand{\finish}{\code{finish}}
%\newcommand{\Ofn}[1]{\ensuremath{O(#1)}}
\mynewcommand{\nonescaping}{\code{nonescaping}}

\mynewcommand{\hasync}{\code{async}}
\mynewcommand{\hfinish}{\code{finish}}
\mynewcommand{\hR}{\code{R}}
\mynewcommand{\hreceiver}{\code{receiver}} % receiver for new
\mynewcommand{\hSW}{\code{SW}}
\mynewcommand{\hAW}{\code{AW}}
\mynewcommand{\hObject}{\code{Object}}

\mynewcommand{\hFM}{\code{FM}}
\mynewcommand{\hMM}{\code{MM}}
\mynewcommand{\hP}{\code{P}}

\mynewcommand{\hescaping}{\code{escaping}}
\mynewcommand{\hextends}{\code{extends}}



\begin{document}


\maketitle


\lstset{language=java,basicstyle=\ttfamily\small}

\section{Introduction}
This technical report formalizes the hardhat initialization rules in X10
    using \emph{Featherweight X10} (FX10).
Read first the paper ``Object Initialization in X10" to understand the motivation behind the hardhat rules.
    %the terminology (e.g., raw and cooked objects),
%    the initialization rules of X10,
%    and their connection with X10's concurrent and distributed constructs (\finish, \async, and \code{at}).

FX10 is similar to Featherweight Java (FJ), however it is both imperative (using a heap) and it
    models X10 specific constructs such as \finish and \async.
FX10 also models field initialization including the fact that one can read a field only after it was definitely assigned.
%    and that final (\code{val}) fields can be assigned exactly once (in \Ref{Section}{val}).
FX10 type-checking rules are similar to those in Masked Types~\cite{XinQi:2009},
    with two major differences:
    (i)~simplicity,
    (ii)~concurrency support.
FX10 is simpler than masked types, but also less expressive, e.g., FX10 cannot express cyclic initialization.
The simplicity stems from the fact that masked are not visible in the program itself.
Instead, masks are used only during type-checking to describe partially initialized objects.
In addition, FX10 models concurrency constructs such as \finish and \async (that do not exist in masked types).

FX10 does \emph{not} model other aspects of X10 such as:
\begin{description}
  \item[Places] X10 can run code in multiple places, and the \code{at} keyword is used to execute code in a different place.
    Because the only raw object is \this,
        and a raw \this cannot be captured by an \code{at},
        then only cooked objects can cross places.
    Therefore, there is no initialization issues with \code{at} and FX10 does not model it.
  \item[Inference]
    X10 uses inference in various places:
        (i)~it infers the type of a final field with an initializer,
        (ii)~it infers method return types,
        (iii)~using an inter-procedural dataflow analysis it infers
            3 sets for each non-escaping method: $\nonescaping(R,S,A)$.
            $R$ is the set of fields that can be read by the method,
                $S$ are the fields that must be definitely-assigned by the method,
                and $A$ are the fields that must be definitely-asynchronously-assigned by the method.

    FX10 does not model inference, and instead this information is explicitly presented.
  \item[null]
    Previous work on imperative variants of FJ used \hnull to initialize the object's fields.
    FX10 guarantees that all fields are assigned when the object becomes cooked,
        and that fields are read only after written to.
    Therefore, \hnull is no longer required in FX10.
    In the formalism, an object is represented as a mapping from initialized fields to their values
    (so initially the mapping is empty because no field is initialized).

  \item[Miscellaneous]
    Generics, constraints, casting, inner classes, overloading, co-variant return type, private/final,
    locals, field initializers, etc.
\end{description}


\paragraph{Overview}
\Ref{Section}{Syntax} presents the syntax of FX10.
\Ref{Section}{Typing} defines various helper functions and shows the typing rules
    (e.g., $\Gdash \he:\hC, \Delta$ denotes that expression~\he has type \hC in environment $\Gamma$, and $\Delta$ is the change to the environment after executing \he).
\Ref{Section}{Reduction} gives the reduction rules ($\he,H \reduce \he',H'$) and our soundness proof.
%Finally, \Ref{Section}{val} extends the formalism with \hval and \hvar fields.


\Section{Syntax}


\begin{figure}[htpb!]
\begin{center}
\begin{tabular}{|l|l|}
\hline

$\hP ::= \ol{\hL}$ & Program. \\

$\hL ::= \hclass ~ \hC~\hextends~\hD~\lb~\ol{\hF};~\ol{\hM}~\rb$
& cLass declaration. \\

$\hF ::= \hf:\hC$
& Field declaration. \\

$\hM ::= \hMM ~ \hm(\ol{\hx}:\ol{\hC}):\hC=\he;$
& Method declaration. \\

$\hMM ::= \hescaping ~~|~~ \nonescaping(\ol{\hf},\ol{\hf},\ol{\hf})$
& Method Modifier. \\

$\hp ::= \hl ~~|~~ \hx$
& Path (location or parameter). \\

$\he ::= \hl ~|~ \hx ~|~ \hp.\hf ~|~ \hp.\hf = \hp ~|~ \hp.\hm(\ol{\hp}) ~|~ \hnew{\hC}~|~ \hfinish~\he~|~ \hasync~\he;\he ~|~ \he;\he ~|~ \hval{\hx}{\he}$
& Expressions. \\ %: locations, parameters, field access\&assignment, invocation, \code{new}

\hline
\end{tabular}
\end{center}
\caption{FX10 Syntax.
    The terminals are locations (\hl), parameters and \this (\hx), field name (\hf), method name (\hm), class name (\hB,\hC,\hD,\hObject),
        and keywords/symbols (\super, \hescaping, \nonescaping, \hhnew, \finish, \async, \code{val}, \code{in}, $;$, $.$, $(\ldots)$).
    The program source code cannot contain locations (\hl), because locations are only created during execution/reduction in \RULE{R-New} of \Ref{Figure}{reduction}.
    }
\label{Figure:syntax}
\end{figure}


\Ref{Figure}{syntax} shows the syntax of FX10.
%(\Ref{Section}{val} will later add the \hval and \hvar field modifiers.)
Expression~$\he;\he'$ means to evaluate first \he then to evaluate and return~$\he'$.
Expression~$\hasync~\he;\he'$ means evaluate \he concurrently (in a different thread) while the result is the evaluation of $\he'$.

The syntax is similar to X10 real syntax with the following difference:
    instead of doing inference, we explicitly write the fields of \this that are initialized and read in
    every initializing method
    (using 3 sets: $\nonescaping(R,S,A)$).
Initializing methods (also called non-escaping methods) cannot leak \this and they can only read fields of \this that are in the $R$ set.
Non-initializing methods (whose receiver is always a cooked object) are marked with \hescaping
    because they can escape \this (e.g., pass \this as an argument to another method).

\Section{Typing}
The type of \code{val} locals is inferred because it might not be expressible in the above syntax.
For example, consider the program on line~1 and the expression on line~2:
\begin{xten}
class D extends Object { f:Object; }
val d = new D; d.f = new Object
\end{xten}
Then, the type of \code{d} is \code{D} where field \code{f} is uninitialized
    (which we formally write below as $\code{D}\myinit{\hf}{\hf}$).
Therefore, reading \code{d.f} would be illegal, but writing to \code{d.f} would update the type of \code{d}
    to be fully initialized (formally $\code{D}\mycooked$).

Therefore, types in FX10 are flow-sensitive, i.e., the type of a variable changes after its fields are assigned.
We follow the notation of Masked Types~\cite{XinQi:2009}, and include in the type all the
    fields that have not been synchronously and asynchronously initialized yet,
    i.e., a type~$\hT$ has the syntax~$\hC\myinit{\ol{\hf_s}}{\ol{\hf_a}}$,
        where~$\ol{\hf_s}$ and~$\ol{\hf_a}$ (where~$\ol{\hf_a} \subseteq \ol{\hf_s}$)
        are sets of fields that might
        be synchronously and asynchronously uninitialized, respectively.
For example, the type~$\hC\mycooked$ is a fully initialized type,
    whereas~$\hC\myinit{\hf}{\hf}$ have an uninitialized field \hf
    (more precisely, \hf might be uninitialized).

Consider the following class:
\begin{xten}
class A extends Object {
  f:A;
  f2:A;
  Read(f2) SyncWrite(f) AsyncWrite(f) build(a:A) =
    val x = this;
    val y =
      finish
        val z =
          async
            val w = this.f = a;
          this;
}
class B extends A { f3:A; }
\end{xten}
What are the types of \code{w,x,y,z}?
Because the method is marked with \code{Read(f2)} (line~4),
    we know that \code{f2} has been initialized,
    but \code{f} might not.
Also note that fields of subclasses of \code{A} might be uninitialized (e.g., \code{f3}),
    so we mark it in the type using \code{*} (meaning that some set of unknown fields might be uninitialized).
So the type of \code{x} and \this on line~5 is
    $\code{A}\myinit{\hf,\code{*}}{\hf,\code{*}}$.
In line~10, the type of \code{w} is
    $\code{A}\myinit{\code{*}}{\code{*}}$,
    because \code{f} has been initialized.
In line~8, the type of \code{z} is
    $\code{A}\myinit{\hf,\code{*}}{\code{*}}$
    because \code{f} has been asynchronously initialized
    (so it can be read only after we cross an enclosing \finish).
Finally, in line~6, the type of \code{y} is
    $\code{A}\myinit{\code{*}}{\code{*}}$
    because we cross a \finish.
We stress that the program does not include masked types;
    they only appear during type-checking.


%$\hs ::= \hf ~|~ *$
%& Mask. \\
%$\hT ::= \hC\myinit{\ol{\hs}}{\ol{\hs}}$
%& Masked types. \\


\emph{Subclassing} is exactly as in FJ:
    the transitive closure of the \hextends relation.
That is, $\hC \st \hD$ iff $\hC=\hD$ or \hC transitively extends $\hD$.
%\emph{Subtyping} is defined as follows:
%    $\hC\myinit{\ol{\hf_s}}{\ol{\hf_a}} \st \hC'\myinit{\ol{\hf'_s}}{\ol{\hf'_a}}$
%    iff
%    $\hC \st \hC'$ and~$\ol{\hf_s} \subseteq \ol{\hf'_s}$ and~$\ol{\hf_a} \subseteq \ol{\hf'_a}$.
%Therefore, a cooked object can be used anywhere a raw object is expected
%    (e.g., $\hC\mycooked \st \hC\myinit{{\hf}}{{\hf}}$).

A \emph{type environment}~$\Gamma$ maps variables and locations to types,
    and we write either~$\hx:\hT \in \Gamma$ or~$\Gamma(\hx)=\hT$.
The domain of a mapping is written as~$\dom(\Gamma)$.
We also write~$\Gamma[\hx:\hT]$ to represent an new environment that maps~$\hx$ to~$\hT$
    (regardless of whether~$\hx \in \dom(\Gamma)$ or not).

The process of type-checking an expression~\he produces a new environment
    where variables are mapped to new types that are more initialized,
    i.e., the sets~$\ol{\hf_s}$ and~$\ol{\hf_a}$ are decreasing (or unchanged).
Formally, we write~$\Gdash \he : \hT, \Gamma'$ to mean that the type of~\he
    is~\hT, and the new environment (after evaluating \he) is~$\Gamma'$.
The change in the environment is written as~$\Delta = \Gamma' - \Gamma$,
    and it maps variables to the change in their two uninitialized sets,
    i.e., which fields were assigned.
For example, if~$\Gamma(\hx)=\hC\myinit{\ol{\hf_s}}{\ol{\hf_a}}$
    and~$\Gamma'(\hx)=\hC\myinit{\ol{\hf'_s}}{\ol{\hf'_a}}$,
    then~$\Delta(\hx)=\initsets{\ol{\hf_s} \setminus \ol{\hf'_s}}{\ol{\hf_a} \setminus \ol{\hf'_a}}$.
We also define the reverse operator so that~$\Gamma' = \Gamma + \Delta$.
For an environment change~$\Delta$, we define two operators named
    $\finishG_\Delta$ and~$\asyncG_\Delta$ as follows,
    if~$\Delta(\hx)=\initsets{\ol{\hf_s}}{\ol{\hf_a}}$ then
\beqst
    \finishG_\Delta(\hx) &= \initsets{\ol{\hf_a}}{\ol{\hf_a}} \\
    \asyncG_\Delta(\hx) &= \initsets{\emptyset}{\ol{\hf_a}} \\
\eeq
Intuitively, after passing a \finish, all the asynchronous assignments become synchronous;
    and after passing an \async, all the synchronous assignments become void.

Similarly to FJ, we define:
(i)~$\fields(\hC)=\ol{\hD}~\ol{\hf}$ returns all fields of \hC (both those declared by \hC and recursively inherited from its superclass),
    and~$\ftype{}(\hf_i,\hC) =\hD_i$.
(ii)~$\mtype(\hm,\hC) = \ol{\hB}\mapsto\hD$ returns the type of method \hm in class \hC.
(iii)~$\mbody(\hm,\hC) = \ol{\hx}.\he$ returns the method body of \hm in class \hC.
Because methods have a modifier (\hMM) in FX10, we also define:
(iv)~$\mmodifier(\hm,\hC) = \hMM$ returns the method modifier of \hm in class \hC.



\begin{figure*}[t]
\begin{center}
\begin{tabular}{|c|}
\hline
$\typerule{
    \Gdash \he : \hT, \Gamma'
}{
  \Gdash \finish~\he~:~\hT, \Gamma + \finishG_{\Gamma'-\Gamma}
}$~\RULE{(T-Finish)}
\quad
$\typerule{
    \Gdash \he : \hT, \Gamma'
        \gap
    \Gdash \he' : \hT', \Gamma"
}{
  \Gdash \async{}~\he;~\he'~:~\hT', \Gamma" + \asyncG_{\Gamma'-\Gamma}
}$~\RULE{(T-Async)}
\\\\

$\typerule{
  \Gdash \he:\hT,\Gamma'
    \gap
  \Gamma" = \Gamma'[\hx:\hT]
}{
  \Gdash \hval{\hx}{\he} : \hT,\Gamma"
}$~\RULE{(T-Val)}
\\\\

$\typerule{
  \Gdash \he:\hT,\Gamma'
        \gap
  \Gamma' \vdash \he':\hT',\Gamma"
}{
  \Gdash \he;\he' : \hT',\Gamma"
}$~\RULE{(T-Seq)}
\\

$\typerule{
}{
  \Gdash \hl : \Gamma(\hl), \Gamma
}$~\RULE{(T-Location)}
\quad
$\typerule{
}{
  \Gdash \hx : \Gamma(\hx), \Gamma
}$~\RULE{(T-Parameter)}\\\\


$\typerule{
  \Gdash \hp_0:\hC_0\myinit{\ol{f_s}}{\ol{f_a}},\Gamma
    \gap
  \fields{}(\hC_0)=\ol{\hf}:\ol{\hC}
    \gap
  \hf_i \not \in \ol{f_s}
}{
  \Gdash \hp_0.\hf_i : \hC_i\mycooked,\Gamma
}$~\RULE{(T-Field-Access)}\\\\

$\typerule{
  \Gdash \hp_0:\hC_0\myinit{\ol{f_s}}{\ol{f_a}},\Gamma
    \gap
  \fields{}(\hC_0)=\ol{\hf}:\ol{\hC}
    \gap
  \Gdash \hp':\hC'\mycooked,\Gamma
    \gap
  \hC' \st \hC_i
    \\
  \Gamma' = \Gamma[\hp_0:\hC_0\myinit{\ol{f_s}\setminus\hf_i}{\ol{f_a}\setminus\hf_i}]
}{
  \Gdash \hp_0.\hf_i = \hp' : \hC'\mycooked,\Gamma'
}$~\RULE{(T-Field-Assign)}\\\\


$\typerule{
  \Gdash \hp_0:\hC_0\myinit{\ol{f_s}}{\ol{f_a}},\Gamma
    \gap
  \mtype{}(\hm,\hC_0)=\ol{\hD}\mapsto\hC
    \gap
  \Gdash \ol{\hp}:\ol{\hC\mycooked},\Gamma
    \gap
  \ol{\hC} \st \ol{\hD}
    \gap
  \mmodifier{}(\hm,\hC_0)=M
    \\
  \Gamma' =
        \begin{cases}
        \Gamma & M=\hescaping \hand \ol{f_s}=\emptyset \\
        \Gamma[\hp_0:\hC_0\myinit{\ol{f_s}\setminus S}{\ol{f_a}\setminus A}] & M=\nonescaping(R,S,A) \hand R \cap \ol{f_s} = \emptyset\\
        \end{cases}
    \gap
}{
  \Gdash \hp_0.\hm(\ol{\hp}) : \hC\mycooked,\Gamma'
}$~\RULE{(T-Invoke)}\\\\

$\typerule{
    F = \fields(\hC)
}{
  \Gdash \hnew{\hC} : \hC \myinit{F}{F}
}$~\RULE{(T-New)}\\\\


\hline
\end{tabular}
\end{center}
\caption{FX10 Expression Typing Rules ($\Gdash \he:\hC, \Gamma'$).
    Rules \RULE{(T-finish)} and \RULE{(T-async)} handle the new constructs in FX10,
        while the other rules are similar to those in FJ.}
\label{Figure:expression-typing}
\end{figure*}


We check that method declarations are ok (\RULE{T-Method})
    by ensuring that the type of the method body is a subtype
    of the return type, and that the signature matches the method modifier.
We also check that an overriding method (\RULE{T-Method-Override})
    has the same signature
    and the method modifier is stronger in the subclass. %(whether it is \hescaping or if it has the 3 sets specified).


\beqst %{method-ok}
\typerule{
  t  =
        \begin{cases}
        \hC\mycooked & \hMM=\hescaping \\
        \hC\myinit{A}{A}  & \hMM=\nonescaping(R,W_s,W_a) \qquad A = (\fields{}(\hC) \setminus R),* \\
        \end{cases}\\
  \Gamma = \{ \ol{\hx}:\ol{\hD\mycooked},\this:t \} \\
  \Gdash \he : \hD'\mycooked,\Gamma' \gap \Delta = \Gamma' - \Gamma \gap
    \hD' \st \hD \\
  \code{if }\hMM=\nonescaping(R,W_s,W_a)\\
  %todo
    ~~\code{then }  \Delta(\this) = \initsets{\ol{f_s}}{\ol{f_a}} \hand W_s \subseteq W_a  \hand \ol{f_s} \supseteq W_s \hand \ol{f_a} \supseteq W_a
}{
  \hMM ~ \hm(\ol{\hx}:\ol{\hD}):\hD=\he ~~\OK~\IN~\hC
}~\RULE{(T-Method)}
\eeq
\beqst %{method-ok}
\typerule{
  \hclass~\hC~\hextends~\hC'~\lb~\ldots~\rb\\
  \code{if }\mtype{}(\hm,\hC')=\ol{\hD'} \mapsto \hD'\\
    ~~\code{then } \ol{\hD'}\equiv\ol{\hD} \hand \hD'\equiv\hD \\
  \code{if }\mmodifier{}(\hm,\hC')=\hMM'\\
    ~~\code{then } \hMM=\hescaping \Rightarrow \hMM'=\hescaping \hand \\
    \gap \hMM=\nonescaping(R,W_s,W_a) \Rightarrow\\
        (\hMM'=\hescaping  \hor\\
        (\hMM'=\nonescaping(R',W'_s,W'_a) \hand
            (R \subseteq R' \hand W_s \supseteq W'_s \hand W_a \supseteq W'_a))
}{
  \hMM ~ \hm(\ol{\hx}:\ol{\hD}):\hD=\he ~~\code{Override-OK}~\IN~\hC
}~\RULE{(T-Method-Override)}
\eeq


As in FJ, a class is ok if all its methods satisfy both \RULE{T-Method} and \RULE{T-Method-Override}.


\Section{Reduction}

\begin{figure*}[t]
\begin{center}
\begin{tabular}{|c|}
\hline
$\typerule{
}{
  \finish~\hl,H \reduce \hl,H
}$~\RULE{(R-Finish)}
\quad
$\typerule{
}{
  \async~\hl;\he,H \reduce \he,H
}$~\RULE{(R-Async)}
\\\\

$\typerule{
    H(\hl)=\hC(\ol{\hf}\mapsto\ol{\hl'})
}{
  \hl.\hf_i,H \reduce \hl_i',H
}$~\RULE{(R-Field-Access)}
\quad
$\typerule{
    H(\hl)=\hC(F)
        \gap
    F' = F[ \hf \mapsto \hl"]
}{
  \hl.\hf=\hl",H \reduce \hl",H[ \hl \mapsto \hC(F')]
}$~\RULE{(R-Field-Assign)}
\\\\

$\typerule{
}{
  \hl;\he,H \reduce \he,H
}$~\RULE{(R-Seq)}
\\\\

$\typerule{
    \hl" \not \in \dom(H)
}{
  \hnew{\hC},H \reduce \hl",H[ \hl" \mapsto \hC()]
}$~\RULE{(R-New)}
\\\\
$\typerule{
    H(\hl')=\hC(\ldots)
        \gap
    \mbody{}(\hm,\hC)=\ol{x}.\he
}{
  \hl'.\hm(\ol{\hl}),H \reduce [\ol{\hl}/\ol{x},\hl'/\this]\he,H
}$~\RULE{(R-Invoke)}
\\\\

$\typerule{
    \he,H \reduce \he',H'
}{
  \he.\hm(\ol{\he}),H \reduce \he'.\hm(\ol{\he}),H'
}$~\RULE{(RC-Receiver)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \hl.\hm(\ol{\hl},\he,\ol{\he}),H \reduce \hl.\hm(\ol{\hl},\he',\ol{\he}),H'
}$~\RULE{(RC-Arguments)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \he;\he",H \reduce \he';\he",H'
}$~\RULE{(RC-Seq)}
\quad
$\typerule{
    \he,H \reduce \he',H'
}{
  \he.\hf,H \reduce \he'.\hf,H'
}$~\RULE{(RC-Field-Access)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \he.\hf=\he",H \reduce \he'.\hf=\he",H'
}$~\RULE{(RC-Field-Assign1)}
\qquad
$\typerule{
    \he,H \reduce \he',H'
}{
  \hl.\hf=\he,H \reduce \hl.\hf=\he',H'
}$~\RULE{(RC-Field-Assign2)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \async~\he;\he",H \reduce \async~\he';\he",H'
}$~\RULE{(RC-Async1)}
\qquad
$\typerule{
    \he,H \reduce \he',H'
}{
  \async~\he";\he,H \reduce \async~\he";\he',H'
}$~\RULE{(RC-Async2)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \finish~\he,H \reduce \finish~\he',H'
}$~\RULE{(RC-Finish)}
\\

$\typerule{
}{
  (\async~\he;\hl).\hm(\ol{\he}),H \reduce \async~\he; \hl.\hm(\ol{\he}),H
}$~\RULE{(RA-Receiver)}
\\
$\typerule{
}{
  \hl.\hm(\ol{\hl},(\async~\he;\hl'),\ol{\he}),H \reduce \async~\he; \hl.\hm(\ol{\hl},\hl',\ol{\he}),H
}$~\RULE{(RA-Arguments)}
\\
$\typerule{
}{
  (\async~\he;\hl).\hf,H \reduce \async~\he; \hl.\hf,H
}$~\RULE{(RA-Field-Access)}
\\
$\typerule{
}{
  (\async~\he;\hl).\hf=\he",H \reduce \async~\he; \hl.\hf=\he",H
}$~\RULE{(RA-Field-Assign1)}
\\
$\typerule{
}{
  \hl.\hf=(\async~\he;\hl'),H \reduce \async~\he; \hl.\hf=\hl',H
}$~\RULE{(RA-Field-Assign2)}
\\\\
%
% I don't need these two rules, because RC-Async1&2 handle these cases (we can progress on either e1 or e2 in async e1;e2
%$\typerule{
%}{
%  \async~(\async~\he;\hl);\he',H \reduce \async~\he; \he',H
%}$~\RULE{(RA-Async1)}
%\qquad
%$\typerule{
%}{
%  \async~\he';(\async~\he;\hl),H \reduce \async~\he; \async~\he';\he',H
%}$~\RULE{(RA-Async2)}
%\\\\
\hline
\end{tabular}
\end{center}
\caption{FX10 Reduction Rules ($H,\he \reducesto H',\he'$).
    Rules \RULE{(RC-*)} handle the congruence rules, and
    rules \RULE{(RA-*)} handle the concurrent nature of \hasync (bringing the async to the top-level).
    Note that we do not have an \RULE{(RA-Finish)} because an async cannot cross a finish.}
\label{Figure:reduction}
\end{figure*}

An object~$\ho = \code{C}(\ol{\hf}\mapsto\ol{\hl'})$ is an instance of some class~\hC
    where fields~$\ol{\hf}$ has been initialized to locations~$\ol{\hl'}$.
A heap~$H$ is a mapping from locations~\hl to objects~$\ho$.
A heap-typing~$\Gamma_H$ maps locations to their type,
    i.e., if~$H[\hl] = \code{C}(\ldots)$ then~$\Gamma_H[\hl] = \code{C}$.
A heap~$H$ is \emph{well-typed} iff
    each field location is a subtype (using~$\Gamma_H$) of the declared field type,
    i.e., for every location in the heap~$\hl \in \dom(H)$,
        where $H[\hl] = \code{C}(\ol{\hf}\mapsto\ol{\hl'})$
        and
        for every field~$\hf_i$, we have that~$H[\hl_i'] = \hC'(\ldots)$ and
        $\hC' \st \ftype{}(\hf_i,\hC)$.


An expression~\he is called \emph{closed} if it does not contain
    any free variables (i.e., it does not contain method parameters \hx nor~\this).


Consider a program \hP and a closed expression \he.
We always assume the program is well-typed.
Then in a well-typed heap, a closed expression can always be reduced to a location.
Because our reduction rules only allow reads from initialized fields,
    then a corollary is that a field can only be read after it was assigned.


\begin{Theorem}[preservation]
  \textbf{(Progress and Preservation)}
    For every closed expression~$\he \neq \hl$, and a well-typed heap~$H$,
        if $\Gamma_{H} \vdash \he : \hC$,
        then there exists~$H',\he',\hC'$ such that
        (i)~$H,\he \reducesto H',\he'$,
        (ii)~$\Gamma_{H'} \vdash \he':\hC'$,
        and~$\hC' \st \hC$,
        (iii)~$H'$ is well-typed,
        (iv)~$\he'$ is closed.
\end{Theorem}
\begin{proof}
We will break the proof into several lemmas, each proving points (i)--(iv).
\end{proof}

\begin{Lemma}[closed]
  \textbf{(Closed is preserved)}
    For every closed expression~$\grave{\he} \neq \hl$, and a well-typed heap~$H$,
        if $H,\grave{\he} \reducesto H',\acute{\he}$,
        then $\acute{\he}$ is closed.
\end{Lemma}
\begin{proof}
Let's consider all the possible reduction rules in \Ref{Figure}{reduction}.
We will prove by induction on the size of $\he$.

Consider \RULE{R-Async}, where~$\grave{\he} = \async~\hl;\acute{\he}$:
\[\typerule{
}{
  \async~\hl;\acute{\he},H \reduce \acute{\he},H
}
\]
Then, because $\grave{\he}$ is closed, then $\acute{\he}$ is closed.

Consider \RULE{RC-Receiver}, where~$\grave{\he} = \he.\hm(\ol{\he})$:
\[\typerule{
    \he,H \reduce \he',H'
}{
  \he.\hm(\ol{\he}),H \reduce \he'.\hm(\ol{\he}),H'
}
\]
By induction (the size of~$\he$ is smaller than the size of~$\grave{\he}$), we have that~$\he'$ is closed.
Therefore,~$\acute{\he} = \he'.\hm(\ol{\he})$ is closed.

The only remaining two interesting cases are~\RULE{R-New} and~\RULE{R-Invoke}.
Consider~\RULE{R-Invoke} (\RULE{R-New} is handled similarly), where~$\grave{\he} = \hl'.\hm(\ol{\hl})$:
\[
\typerule{
    H(\hl')=\hC(\ldots)
        \gap
    \mbody{}(\hm,\hC)=\ol{x}.\he
}{
  \hl'.\hm(\ol{\hl}),H \reduce [\ol{\hl}/\ol{x},\hl'/\this]\he,H
}
\]
Note that \he might not be closed, i.e., it may contain method parameters or \this.
However, because the program is well-typed and~$\mbody{}(\hm,\hC)=\ol{x}.\he$,
    then \he may only contain either~$\hx_i$ or \this,
    and these are substituted by locations in~$[\ol{\hl}/\ol{x},\hl'/\this]\he$,
    thus~$\grave{\he}$ is closed.
\end{proof}

\begin{Lemma}[well-typed]
  \textbf{(Heap is well-typed)}
    For every closed expression~$\grave{\he} \neq \hl$, and a well-typed heap~$H$,
        if $H,\grave{\he} \reducesto H',\acute{\he}$,
        then $H'$ is well-typed.
\end{Lemma}
\begin{proof}
Let's consider all the possible reduction rules in \Ref{Figure}{reduction}.
We will prove by induction on the size of $\he$.

For the following rules we have that~$H=H'$, thus $H'$ is well-typed:
\RULE{R-Finish}
\RULE{R-Async}
\RULE{R-Field-Access}


\RULE{R-Field-Assign}

\end{proof}

%\input{val}

\end{document}
