\chapter{Types}
\label{XtenTypes}\index{types}

\input{ReTypes}

{}\Xten{} is a {\em strongly typed} object-oriented language: every
variable and expression has a type that is known at compile-time.
Types limit the values that variables can hold.

{}\Xten{} supports four kinds of values, {\em objects}, {\em struct values},
{\em functions}, and \xcd`null`. Objects are in the grand tradition of
object-oriented languages, and the heart of most X10 computations. They are
instances of {\em classes} 
(\Sref{ReferenceClasses}); they hold zero or more data fields that may be
mutable. They respond to methods, and can inherit behavior from their
superclass.

Struct values are similar to objects, though more restricted in ways that make
them more efficient in space and time.  Their fields cannot be mutable, and,
although they respond to methods, they do not inherit behavior.  
They are instances of struct types (\Sref{XtenStructs}.

Together, objects and struct values are called {\em containers},
\index{container}
because they hold data.  

Functions, called closures, lambda-expressions, and blocks in other languages,
are 
instances of {\em function types} (\Sref{Functions}). 
A function has zero or more {\em formal parameters} (or {\em arguments}) and a
{\em body}, which is 
an expression that can reference the formal parameters and also other
variables in the surrounding block. For instance, \xcd`(x:Int)=>x*y`
is a unary integer function which multiplies its argument by the
variable \xcd`y` from the surrounding block.  Functions may be freely
copied from place to place and may be repeatedly applied. 

Finally, \xcd`null` is a constant, often found as the default value of
variables of object type. While it is not an object, it may be stored in
variables of class type -- except for types which have a constraint
(\Sref{ConstrainedTypes}) which specifically excludes \xcd`null`.

These runtime values are classified by {\em types}. Types are used in
variable declarations (\Sref{sect:LocalVarDecl}), coercions and  explicit
conversions (\Sref{sect:ConvAndCoerc}), object creation (\Sref{ClassCreation}),
static state and method accessors (\Sref{FieldAccess}), and
\xcd"instanceof" and \xcd`as` expressions (\Sref{instanceOf}).
\bard{check for completeness}

The basic relationship between values and types is the {\em is a value in}
relation: \xcd`e` is a value in \xcd`T`.  
We also often say ``\xcd`e` has type \xcd`T`'' to
 or ``\xcd`e` is an element of type \xcd`T`''.  
For example, \xcd`1` has type
\xcd`Int` (the type of all integers representible in 32 bits). It 
has the more general type \xcd`Any` (since all entitites have type \xcd`Any`).  
Furthermore, it has such types as 
``Nonzero integer'' and ``Integer equal to one'', and many others.  
These types are expressable in X10 using constrained types
(\Sref{ConstrainedTypes}).  \xcd`Int{self!=0}` is the type of \xcd`Int`s
\xcd`self`\footnote{X10 automatically uses the identifier \xcd`self` for the
element of the type being constrained.} which are not equal to zero, and 
\xcd`Int{self==1}` is the type of the \xcd`Int`s which are equal to one.  


The basic relationship between types is {\em subtyping}: \xcd`T <: U`
holds if every value in \xcd`T` is also a value ind \xcd`U`. Two
important kinds of subtyping are {\em subclassing} and {\em
strengthening}. Subclassing is a familiar notion from
object-oriented programming. Here we use it to refer to the
relationship between a class and another class it extends
or an interface (\Sref{XtenInterfaces}) it implements. For
instance, in a class hierarchy with classes \xcd`Animal` and \xcd`Cat`
such that \xcd`Cat` extends \xcd`Mammal` and \xcd`Mammal` extends
\xcd`Animal`, every instance of \xcd`Cat` is by definition an instance
of \xcd`Animal` (and \xcd`Mammal`). We say that \xcd`Cat` is a
subclass of \xcd`Animal`, or \xcd`Cat <: Animal` by subclassing. If
\xcd`Animal` implements \xcd`Thing`, then \xcd`Cat` also implements
\xcd`Thing`, and we say \xcd`Cat <: Thing` by subclassing.

Strengthening is an equally familiar notion from logic.  The instances
of \xcd`Int{self == 1}` are all elements of \xcd`Int{self != 0}` as well,
because \xcd`self == 1` logically implies \xcd`self != 0`; so 
\xcd`Int{self  == 1} <: Int{self !=0}` by strengthening.  X10 uses both notions
of subtyping.  See \Sref{DepType:Equivalence} for the full definition
of subtyping in X10.

\section{Type System}
\index{type system}

\bard{This section gets rewritten pretty much completely}
The types in X10 are as follows.  

These are the {\em elementary} types. Other
syntactic forms for types exist, but they are simply abbreviations for types
in the following system.  For example, \xcd`Array[Int](1)` is the type of
one-dimensional integer-valued arrays; it is an abbreviation for
\xcd`Array[Int]{rank==1}`.\\

% remove \refstepcounter{equation}
% snag the argument of \label{X}
% change the (\arabic{equation}) into (\ref{X})

%##(Type FunctionType ConstrainedType
\begin{bbgrammar}
%(FROM #(prod:Type)#)
                Type \: FunctionType & (\ref{prod:Type}) \\
                     \| ConstrainedType \\
                     \| VoidType \\
%(FROM #(prod:FunctionType)#)
        FunctionType \: TypeParams\opt \xcd"(" FormalList\opt \xcd")" Guard\opt Offers\opt \xcd"=>" Type & (\ref{prod:FunctionType}) \\
%(FROM #(prod:ConstrainedType)#)
     ConstrainedType \: NamedType & (\ref{prod:ConstrainedType}) \\
                     \| AnnotatedType \\
\end{bbgrammar}
%##)


Types may be given by name. 
For example, 
%~~type~~`~~`~~ ~~ ^^^ Types10
\xcd`Int`
is the type of 32-bit integers.
Given a class declaration 
%~~gen ^^^ Types20
%package Types.Core.TypeName; 
%~~vis
\begin{xten}
class Triple { /* ... */ }
\end{xten}
%~~siv
%
%~~neg
the identifier \xcd`Triple` may be used as a type.

The type {\em TypeName \xcd`[` Types{$^?$} \xcd`]`} is an instance of
a {\em generic} (or {\em parameterized}) type. 
 For example,
\xcd`Array[Int]` is the type of arrays of integers. 
\xcd`HashMap[String,Int]` is the type of hash maps from strings to
integers.

The type {\em Type \xcd`{` Constraint \xcd`}`} refers to a constrained type.
{\em Constraint} is a Boolean expression -- written in a limited
subset of X10 -- describing the acceptable values of the constrained type.
%~~stmt~~`~~`~~ ~~ ^^^ Types30
For example, \xcd`var n : Int{self != 0};` guarantees that \xcd`n` is always a
non-zero integer. 
%~~stmt~~`~~`~~ ~~class Triple{} ^^^ Types40
Similarly, \xcd`var x : Triple{x != null};` defines a \xcd`Triple`-valued
variable \xcd`x` whose value is never null.

The qualified type {\em Type \xcd`.` Type} refers to an instance of a {\em
nested} type; that is, a class or struct defined inside of another class or
struct, and holding an implicit reference to the outer.  For example, given
the type declaration 
%~~gen ^^^ Types50
% package Types.Core.Hardcore.Qualified;
%~~vis
\begin{xten}
class Outer {
  class Inner { /* ... */ }
}
\end{xten}
%~~siv
%
%~~neg
then 
%~~exp~~`~~`~~ ~~ NOTEST class Outer {class Inner { /* ... */ }} ^^^ Types60
\xcd`(new Outer()).new Inner()` creates a value of type 
%~~type~~`~~`~~ ~~class Outer {class Inner { /* ... */ }} ^^^ Types70
\xcd`Outer.Inner`.

Type variables, {\em TypeVar}, refer to types that are parameters.  For
example, the following class defines a cell in a linked list.  
%~~gen ^^^ Types80
% package Types.Core.Bore.Lore;
%~~vis
\begin{xten}
class LinkedList[X] {
  val head : X;
  val tail : LinkedList[X];
  def this(head:X, tail:LinkedList[X]) {
     this.head = head; this.tail = tail;
  }
}
\end{xten}
%~~siv
%
%~~neg
It doesn't
matter what type the cell's element is, but it has to have {\em some} type.
\xcd`LinkedList[Int]` is a linked list of integers.
\xcd`LinkedList[LinkedList[Byte]]` is a list of lists of bytes.
Note that \xcd`LinkedList` is {\em not} a usable type -- it is missing a type parameter.



The function type 
{\em \xcd`(` Formals{$^?$} \xcd`) =>`  Type} 
refers to functions taking the
listed formal parameters and returning a result of {\em Type}.  In
\XtenCurrVer, function types may not be generic.
The closely-related void function type 
{\em \xcd`(` Formals{$^?$} \xcd`) =>`  \xcd`void`}  takes the listed
parameters and returns no value.

\begin{ex}
\begin{xtenmath}
\xcd`(x:Int) => Int{self != x}` 
\end{xtenmath}
is the type of integer-valued functions which have no fixed points -- that is,
for which the output is an integer different from the input.
An example of such a function is \xcd`(x:Int) => x+1`.
\end{ex}

For fundamental reasons, X10 --- or any other computer program --- cannot
tell in general whether a function has any fixed points or not.  So, X10
programs using such types must prove to X10 that they are correct. Often this
will involve a run-time check, expressed as a cast, such as: 
%~~gen ^^^ Types3x7m
% package Types3x7m;
% class Example {
%~~vis
\begin{xten}
  val plus1 : (x:Int) => Int{self != x} = 
     (x:Int) => (x+1) as Int{self != x}; 
\end{xten}
%~~siv
%}
%~~neg



The names of the formal parameters are bound in the type; the scope of a
formal \xcdmath"x$i$" is its type \xcdmath"T$_i$", all \xcdmath"T$j$" with
$j>i$, the constraint \xcd`c`, and the result type \xcd`T`.  
For example, the type 
\xcd`(n:Int)=>Int{self!=n}`
describes integer-valued functions that have no fixed point


For example, \\
\xcd`(a:Int, b:Int{self!=a})=>Int{self!=a, self!=b}` 
and \\
\xcd`(c:Int, d:Int{self!=c})=>Int{self!=c, self!=d}` \\
are equivalent types.  



\section{Classes, Structs,  and interfaces}
\label{ReferenceTypes}

\subsection{Class types}

\index{type!class}
\index{class}
\index{class declaration}
\index{declaration!class declaration}
\index{declaration!reference class declaration}

A {\em class declaration} (\Sref{XtenClasses}) declares a {\em class type},
giving its name, behavior, data, and relationships to other classes and
interfaces. 

\begin{ex}
The \xcd`Position` class below could describe the position of a slider
control: 
%~~gen ^^^ Types100
% package Types.By.Cripes.Classes;
%~~vis
\begin{xten}
class Position {
  private var x : Int = 0;
  public def move(dx:Int) { x += dx; }
  public def pos() : Int = x;
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}
Class instances, also called objects, are created by constructor calls, 
such as \xcd`new Position()`
Class
instances have fields and methods, type members, and value properties bound at
construction time. In addition, classes have static members: static \xcd`val` fields,
methods, type definitions, and member classes and member interfaces.

Classes may be {\em generic}, \ie, defined with one or more type
parameters (\Sref{TypeParameters}).  

%~~gen ^^^ Types110
%~~vis
\begin{xten}
class Cell[T] {
  var contents : T;
  public def this(t:T) { contents = t;  }
  public def putIn(t:T) { contents = t; }
  public def get() = contents;
  }
\end{xten}
%~~siv
%~~neg



\index{\Xcd{Object}}
\index{\Xcd{x10.lang.Object}}

Classes are structured in a single-inheritance hierarchy. All classes extend
the class \xcd"x10.lang.Object", directly or indirectly. Each class other than
\xcd`Object` extends a single parent class.  \xcd`Object` provides no behaviors
of its own, beyond those required by \xcd`Any`.

\index{class!reference class}
\index{reference class type}
\index{\Xcd{Object}}
\index{\Xcd{x10.lang.Object}}


\index{null}


The null value, represented by the literal
\xcd"null", is a value of every class type \xcd`C`. The type whose values are
all instances of \xcd`C` except 
\xcd`null` can be defined as \xcd`C{self != null}`.

\subsection{Struct Types}

A {\em struct declaration} (\Sref{XtenStructs}) introduces a {\em struct type}
containing all instances of the struct.  The \xcd`Coords` struct below gives
an immutable position in 3-space: 
%~~gen ^^^ Types120
% package Types.Structs.Coords;
%~~vis
\begin{xten}
struct Position {
  public val x:Double, y:Double, z:Double; 
  def this(x:Double, y:Double, z:Double) {
     this.x = x; this.y = y; this.z = z;
  }
}
\end{xten}
%~~siv
%
%~~neg



\subsection{Interface types}
\label{InterfaceTypes}

\index{type!interface}
\index{interface}
\index{interface declaration}
\index{declaration!interface declaration}

An {\em interface declaration} (\Sref{XtenInterfaces}) defines an {\em
interface type}, specifying a set of methods 
%type members, 
and properties which must be provided by any class declared to implement the
interface. 


Interfaces can also have static members: static fields, type
definitions, and member classes, structs and interfaces.  However,
interfaces cannot specify that implementing classes must provide
static members or constructors.

\begin{ex}
In the following interface, \xcd`PI` is a static field, 
\xcd`Vec` a static type definition, 
\xcd`Pair` a static member class.
It can't insist that implementations provide a static method 
like \xcd`meth`, or a nullary constructor.
%~~gen ^^^ Types2y3i
% 
% package Types2y3i;
% // NOTEST-stupid-packaging-issue
%~~vis
\begin{xten}
interface Stat {
  static val PI = 3.14159; 
  static type R = Double;
  static class Pair(x:R, y:R) {}
  // ERROR: static def meth():Int;
  // ERROR: static def this();
}
class Example {
  static def example() {
     val p : Stat.Pair = new Stat.Pair(Stat.PI, Stat.PI);
  }
}
\end{xten}
%~~siv
%
%~~neg

\end{ex}

An interface may extend multiple interfaces.  
%~~gen ^^^ Types130
%package Types.For.Snipes.Interfaces;
%~~vis
\begin{xten}
interface Named {
  def name():String;
}
interface Mobile {
  def move(howFar:Int):void;
}
interface Person extends Named, Mobile {}
interface NamedPoint extends Named, Mobile {} 
\end{xten}
%~~siv
%
%~~neg


Classes and structs may be declared to implement multiple interfaces. Semantically, the
interface type is the set of all objects that are instances of classes
or structs that
implement the interface. A class or struct implements an interface if it is declared to
and if it concretely or abstractly implements all the methods and properties
defined in the interface. For example, \xcd`Kim` implements
\xcd`Person`, and hence \xcd`Named` and \xcd`Mobile`. It would be a static
error if \xcd`Kim` had no \xcd`name` method, unless \xcd`Kim` were also
declared \xcd`abstract`.

%~~gen ^^^ Types140
%interface Named {
%   def name():String;
% }
% interface Mobile {
%   def move(howFar:Int):void;
% }
% interface Person extends Named, Mobile {}
% interface NamedPoint extends Named, Mobile{} 
%~~vis
\begin{xten}
class Kim implements Person {
   var pos : Int = 0;
   public def name() = "Kim (" + pos + ")";
   public def move(dPos:Int) { pos += dPos; }
}
\end{xten}
%~~siv
%
%~~neg


\subsection{Properties}
\index{property}
\label{properties}

Classes, interfaces, and structs may have {\em properties}, specified in
parentheses after the type name. Properties are much like public \xcd`val`
instance fields. They have certain restrictions on their use, however, which
allows the compiler to understand them much better than other public \xcd`val`
fields. In particular, they can be used in types.  \Eg, the number of elements
in an array is a property of the array, and an X10 program can specify that
two arrays have the same number of elements.

\begin{ex}
The
following code declares a class named \xcd"Coords" with properties
\xcd"x" and \xcd"y" and a \xcd"move" method. The properties are bound
using the \xcd"property" statement in the constructor.

%~~gen ^^^ Types150
%package not.x10.lang;
%~~vis
\begin{xten}
class Coords(x: Int, y: Int) { 
  def this(x: Int, y: Int) :
    Coords{self.x==x, self.y==y} = { 
    property(x, y); 
  } 

  def move(dx: Int, dy: Int) = new Coords(x+dx, y+dy); 
}
\end{xten}
%~~siv
%~~neg
\end{ex}
\bard{Replace this by something that is actually true}
Properties, unlike other public \xcd`val` fields, can be used  
at compile time in {constraints}. This allows us
to specify subtypes based on properties, by appending a boolean expression to
the type. For example, the type \xcd"Coords{x==0}" is the set of all points
whose \xcd"x" property is \xcd"0".  Details of this substantial topic are
found in \Sref{ConstrainedTypes}.



\section{Type Parameters and Generic Types}
\label{TypeParameters}

\index{type!parameter}
\index{method!parametrized}
\index{constructor!parametrized}
\index{closure!parametrized}
\label{Generics}
\index{type!generic}

A class, interface, method, or type definition  may have type
parameters.  Type parameters can be used as types, and will be bound to types
on instantiation.  
For example, a generic stack class may be defined as 
\xcd`Stack[T]{...}`.  Stacks can hold values of any type; \eg, 
%~~type~~`~~`~~ ~~class Stack[T]{} ^^^ Types160
\xcd`Stack[Int]` is a stack of integers, and 
%~~type~~`~~`~~ ~~class Stack[T]{} ^^^ Types170
\xcd`Stack[Point {self!=null}]` is a stack of non-null \xcd`Point`s.
Generics {\em must} be instantiated when they are used: \xcd`Stack`, by
itself, is not a valid type.
Type parameters may be constrained by a guard on the declaration
(\Sref{TypeDefGuard},
\Sref{MethodGuard},\Sref{ClosureGuard}).

\index{type!concrete}
\index{concrete type}
A {\em generic class} (or struct, interface, or type definition) 
is a class (resp. struct, interface, or type definition) 
declared with $k \geq 1$ type parameters. 
A generic class (or struct, interface, or type definition) 
can be used to form a type by supplying $k$ types as type arguments within
\xcd`[` \ldots \xcd`]`.
%%When instantiated,
%%with concrete (\viz, non-generic) types for its parameters, 
%%a generic type becomes a concrete type and can be
%%used like any other type. 
For example,
\xcd`Stack` is a generic class, 
%~~type~~`~~`~~ ~~class Stack[T]{} ^^^ Types180
\xcd`Stack[Int]` is a type, and can be used as one: 
%~~stmt~~`~~`~~ ~~class Stack[T]{} ^^^ Types190
\xcd`var stack : Stack[Int];`

\begin{ex}A \xcd`Cell[T]` is a generic object, capable of holding a value of type
\xcd`T`.  For example, a \xcd`Cell[Int]` can hold an \xcd`Int`, and a
\xcd`Cell[Cell[Int{self!=0}]]` can hold a \xcd`Cell` which in turn can
only hold non-zero numbers. 
%% vj: Dont know what this saying: bound immutably... but mutable?
%% \xcd`Cell`s are actually useful in situations
%%where values must be bound immutably for one reason, but need to be mutable.
%~~gen ^^^ Types200
% package ch4;
%~~vis
\begin{xten}
class Cell[T] {
    var x: T;
    def this(x: T) { this.x = x; }
    def get(): T = x;
    def set(x: T) = { this.x = x; }
}
\end{xten}
%~~siv
%~~neg


\xcd"Cell[Int]" is the type of \xcd`Int`-holding cells.  
The \xcd"get" method on a \xcd`Cell[Int]` returns an \xcd"Int"; the
\xcd"set" method takes an \xcd"Int" as argument.  Note that
\xcd"Cell" alone is not a legal type because the parameter is
not bound.
\end{ex}

A class (whether generic or not) may have generic methods.

\begin{ex}
\xcd`NonGeneric` has a generic method 
\xcd`first[T](x:List[T])`. An invocation of such a method may supply
the type parameters explicitly (\eg, \xcd`first[Int](z)`).
 In certain cases (\eg, \xcd`first(z)`)
type parameters may
be omitted and are inferred by the compiler (\Sref{TypeInference}).

%~~gen ^^^ Types210
% package Types.For.Cripes.Sake.Generic.Methods;
% import x10.util.*;
%~~vis
\begin{xten}
class NonGeneric {
  static def first[T](x:List[T]):T = x(0);
  def m(z:List[Int]) {
    val f = first[Int](z);
    val g = first(z);
    return f == g;
  }
}
\end{xten}
%~~siv
%
%~~neg


\end{ex}


\limitation{ \XtenCurrVer{}'s C++ back end requires generic methods to be
static or final; the Java back end can accomodate generic instance methods as well. }

%%yes-they-can%% Unlike other kinds of variables, type parameters may {\em not} be shadowed.  
%%yes-they-can%% If name \xcd`X` is in scope as a type, \xcd`X` may not be rebound as a type
%%yes-they-can%% variable.  
%%yes-they-can%% 
%%yes-they-can%% \begin{ex}
%%yes-they-can%% Neither \xcd`class B` nor \xcd`class C[B]` are allowed in the
%%yes-they-can%% following code, because they both shadow the type variable \xcd`B`.
%%yes-they-can%% %~~gen ^^^ TypesNoShadow
%%yes-they-can%% % package TypesNoShadow;
%%yes-they-can%% % KNOWNFAIL-https://jira.codehaus.org/browse/XTENLANG-2621
%%yes-they-can%% %~~vis
%%yes-they-can%% \begin{xten}
%%yes-they-can%% class A[B] {
%%yes-they-can%%   //ERROR: class B{} 
%%yes-they-can%%   //ERROR: class C[B]{} 
%%yes-they-can%% }
%%yes-they-can%% \end{xten}
%%yes-they-can%% %~~siv
%%yes-they-can%% %
%%yes-they-can%% %~~neg
%%yes-they-can%% \end{ex}
%%yes-they-can%% 
\subsection{Use of Generics}

An unconstrained type variable \Xcd{X} can be instantiated by any type. All
the operations of \Xcd{Any} are available on a 
variable of type \Xcd{X}. Additionally, variables of type
\Xcd{X} may be used with \Xcd{==, !=}, in \Xcd{instanceof}, and casts.  

If a type variable is constrained, the operations implied by its constraint
are available as well.

\begin{ex}
The interface \xcd`Named` describes entities which know their own name.  The
class \xcd`NameMap[T]` is a specialized map which stores and retrieves
\xcd`Named` entities by name.  The call \xcd`t.name()` in \xcd`put()` is only
valid because the constraint \xcd`{T <: Named}` implies that \xcd`T` is a
subtype of \xcd`Named`, and hence provides all the operations of \xcd`Named`. 
%~~gen ^^^ Types6e6x
% package Types6e6x;
% import x10.util.*;
%~~vis
\begin{xten}
interface Named { def name():String; }
class NameMap[T]{T <: Named} {
   val m = new HashMap[String, T]();
   def put(t:T) { m.put(t.name(), t); }
   def get(s:String):T = m.getOrThrow(s);
}
\end{xten}
%~~siv
%
%~~neg


\end{ex}


%%NO-VARIANCE%% \subsection{Variance of Type Parameters}
%%NO-VARIANCE%% \index{covariant}
%%NO-VARIANCE%% \index{contravariant}
%%NO-VARIANCE%% \index{invariant}
%%NO-VARIANCE%% \index{type parameter!covariant}
%%NO-VARIANCE%% \index{type parameter!contravariant}
%%NO-VARIANCE%% \index{type parameter!invariant}
%%NO-VARIANCE%% 
%%NO-VARIANCE%% % Uncomment this when the language implementation properly supports variance.
%%NO-VARIANCE%% %\input{Variance}
%%NO-VARIANCE%% 
%%NO-VARIANCE%% Class, struct and interface definitions are permitted to specify a {\em
%%NO-VARIANCE%%   variance} 
%%NO-VARIANCE%% for each type parameter. 
%%NO-VARIANCE%% There are three variance specifications: 
%%NO-VARIANCE%% \xcd`+` indicates {\em co-variance},  \xcd`-` indicates {\em
%%NO-VARIANCE%%   contravariance} and the absence of  \xcd`+` and 
%%NO-VARIANCE%%  \xcd`-` indicates {\em invariance}. For a class (or struct or
%%NO-VARIANCE%%  interface) \xcd`S` specifying that a particular parameter position
%%NO-VARIANCE%%  (say, \xcd`i`) is covariant means that 
%%NO-VARIANCE%% if \xcd`Si <: Ti` then
%%NO-VARIANCE%% \xcdmath"S[S1,$\ldots$,Sn] <: S[S1,$\ldots$, Si-1,Ti,Si+1,$\ldots$ Sn]".
%%NO-VARIANCE%% Similarly, saying that position \xcd`i` is is contravariant means
%%NO-VARIANCE%% that 
%%NO-VARIANCE%% if \xcd`Si <: Ti` then
%%NO-VARIANCE%% \xcdmath"S[S1,$\ldots$, Si-1,Ti,Si+1,$\ldots$ Sn] <: S[S1,$\ldots$,Sn]". If the
%%NO-VARIANCE%% position is invariant, then no such relationship is asserted between
%%NO-VARIANCE%% \xcd`Si <: Ti` 
%%NO-VARIANCE%% and
%%NO-VARIANCE%% \xcdmath"S[S1,$\ldots$, Si-1,Ti,Si+1,$\ldots$ Sn]". The compiler must perform
%%NO-VARIANCE%% several checks on the body of the class (or struct or interface) to
%%NO-VARIANCE%% establish that type parameters with a variance are used in a manner
%%NO-VARIANCE%% that is consistent with their semantics.
%%NO-VARIANCE%% 
%%NO-VARIANCE%% \limitation{} The implementation of variance specifications  suffers from
%%NO-VARIANCE%% various limitations in \XtenCurrVer. Users are strongly encouraged not
%%NO-VARIANCE%% to use variance. (Some classes, structs, and interfaces in the standard
%%NO-VARIANCE%% libraries use variance specifications in a careful way that
%%NO-VARIANCE%% circumvents these limitations.)
%%NO-VARIANCE%% 

\section{Type definitions}
\label{TypeDefs}

\index{type!definitions}
\index{declaration!type}
A type definition can be thought of as a type-valued function,
mapping type parameters and value parameters to a concrete type.

%##(TypeDefDecl TypeParams Formals Guard
\begin{bbgrammar}
%(FROM #(prod:TypeDefDecl)#)
         TypeDefDecl \: Mods\opt \xcd"type" Id TypeParams\opt Guard\opt \xcd"=" Type \xcd";" & (\ref{prod:TypeDefDecl}) \\
                     \| Mods\opt \xcd"type" Id TypeParams\opt \xcd"(" FormalList \xcd")" Guard\opt \xcd"=" Type \xcd";" \\
%(FROM #(prod:TypeParams)#)
          TypeParams \: \xcd"[" TypeParamList \xcd"]" & (\ref{prod:TypeParams}) \\
%(FROM #(prod:Formals)#)
             Formals \: \xcd"(" FormalList\opt \xcd")" & (\ref{prod:Formals}) \\
%(FROM #(prod:Guard)#)
               Guard \: DepParams & (\ref{prod:Guard}) \\
\end{bbgrammar}
%##)

\noindent 
During type-checking the compiler replaces the use of such a defined
type with its body, substituting the actual type and value parameters
in the call for the formals. This replacement is performed recursively
until the type no longer contains a defined type or a predetermined
compiler limit is reached (in which case the compiler declares an
error). Thus, recursive type definitions are not permitted.

Type definitions are considered applicative and not generative --
they do not define new types, only aliases for existing types.

\label{TypeDefGuard}
Type definitions may have guards: an invocation of a type definition
is illegal unless the guard is satisified when formal types and values
are replaced by the actual parameters.

Type definitions may be overloaded: two type definitions with
the same name are permitted provided that they have a different number
of type parameters or different number or type of value parameters.  The rules
for type definition resolution are identical to those for method resolution.

However, \xcd`T()` is not allowed. If there is an argument list, it must be
nonempty.  This avoids a possible confusion between 
\xcd`type T = ...` and \xcd`type T() = ...`.  

A type definition for a type \xcd`T` can appear: 
\begin{itemize}
\item As a top-level definition in a file named \xcd`T.x10`; or
\item As a static member in a container definition; or
\item In a block statement. \bard{check this}
\end{itemize}


\paragraph{Use of type definitions in constructor invocations}

\bard{Vijay asks, ``what about interface and anonymous class/structs?''}
If a type definition has no type parameters and no value
parameters and is an alias for a container type, a \xcd"new"
expression may be used to create an instance of the class using
the type definition's name.
Given the following type definition:
%TODO: Yoav says ``I just opened a jira on it: [1918].  I don't think you
% should be able to have {c} on the typedef A if you want to use it in a 'new'
% expression. If we do allow it, then we should allow: new
% Array[Int]{rank==1}(0..2) and new Array[Int](1)(0..2).
\begin{xtenmath}
type A = C[T$_1$, $\dots$, T$_k$]{c};
\end{xtenmath}
where 
\xcdmath"C[T$_1$, $\dots$, T$_k$]" is a
class type, a constructor of \xcdmath"C" may be invoked with
\xcdmath"new A(e$_1$, $\dots$, e$_n$)", if the
invocation
\xcdmath"new C[T$_1$, $\dots$, T$_k$](e$_1$, $\dots$, e$_n$)" is
legal and if the constructor return type is a subtype of
\xcd"A".

\paragraph{Automatically imported type definitions}
\index{import,type definitions}
\label{X10LangUnderscore}

The collection of type definitions in
\xcdmath"x10.lang._" is automatically imported in every compilation unit.


\subsection{Motivation and use}
The primary purpose of type definitions is to provide a succinct,
meaningful name for complex types
and combinations of types. 
With value arguments, type arguments, and constraints, the syntax for \Xten{}
types can often be verbose. 
For example, a non-null list of non-null strings is \\
%~~type~~`~~`~~ ~~import x10.util.*; ^^^ Types220
\xcd`List[String{self!=null}]{self!=null}`.

We could name that type: 
%~~gen ^^^ Types230
% package TypeDefs.glip.first;
% import x10.util.*;
% class LnSn {
% 
%~~vis
\begin{xten}
static type LnSn = List[String{self!=null}]{self!=null};
\end{xten}
%~~siv
%}
%~~neg
Or, we could abstract it somewhat, defining a type constructor
\xcd`Nonnull[T]` for the type of \xcd`T`'s which are not null:
%~~gen ^^^ Types240
% package TypeDefs.glip.second;
% import x10.util.*;
% 
%~~vis
\begin{xten}
class Example {
  static type Nonnull[T]{T <: Object}  = T{self!=null};
  var example : Nonnull[Example] = new Example();
}
\end{xten}
%~~siv
%
%~~neg

Type definitions can also refer to values, in particular, inside 
constraints.  The type of \xcd`n`-element \xcd`Array[Int](1)`s  is 
%~~type~~`~~`~~n:Int ~~ ^^^ Types250
\xcd`Array[Int]{self.rank==1 && self.size == n}`
but it is often convenient to give a shorter name: 
%~~gen ^^^ Types260
% package TypeDefs.glip.third;
% class Xmpl {
% def example() {
%~~vis
\begin{xten}
type Vec(n:Int) = Array[Int]{self.rank==1, self.size == n}; 
var example : Vec(78); 
\end{xten}
%~~siv
%}}
%~~neg

%
The following examples are legal type definitions, 
%~~gen ^^^ Types270
% package Types.TypeDef.Examples;
% 
%~~vis
\begin{xten}
import x10.util.*;
class TypeExamples {
  static type StringSet = Set[String];
  static type MapToList[K,V] = Map[K,List[V]];
  static type Int(x: Int) = Int{self==x};
  static type Dist(r: Int) = Dist{self.rank==r};
  static type Dist(r: Region) = Dist{self.region==r};
  static type Redund(n:Int, r:Region){r.rank==n} 
      = Dist{rank==n && region==r};
}
\end{xten}
%~~siv
% 
%~~neg

The following code illustrates that type definitions are applicative rather
than generative.  \xcd`B` and \xcd`C` are both aliases for \xcd`String`,
rather than new types, and so are interchangeable with each other and with
\xcd`String`. Similarly, \xcd`A` and \xcd`Int` are equivalent.
%~~gen ^^^ Types280
% package Types.TypeDef.Example.NonGenerative;
% import x10.util.*;
% class TypeDefNonGenerative {
%~~vis
\begin{xten}
def someTypeDefs () {
  type A = Int;
  type B = String;
  type C = String;
  a: A = 3;
  b: B = new C("Hi");
  c: C = b + ", Mom!";
  }
\end{xten}
%~~siv
% }
%~~neg
% An instance of a defined type with no type parameters and no
% value parameters may 


%%MEMBERSHIP%% All type definitions are members of their enclosing package or
%%MEMBERSHIP%% class.  A compilation unit may have one or more type definitions
%%MEMBERSHIP%% or class or interface declarations with the same name, as long
%%MEMBERSHIP%% as the definitions have distinct parameters according to the
%%MEMBERSHIP%% method overloading rules (\Sref{MethodOverload}).


\section{Constrained types}
\label{ConstrainedTypes}
\label{DepType:DepType}
\label{DepTypes}

\index{dependent type}
\index{type!dependent}
\index{constrained type}
\index{generic type}
\index{type!constrained}
\index{type!generic}


Basic types, like \xcd`Int` and \xcd`List[String]`, provide useful
descriptions of data.  

However, one frequently wants to say more.  One might want to know
that a \xcd`String` variable is not \xcd`null`, or that a matrix is
square, or that one matrix has the same number of columns as another
has rows (so they can be multiplied).  In the multicore setting, one
might wish to know that two values are located at the same processor,
or that one is located at the same place as the current computation.

In most languages, there is simply no way to say and check these things
statically.  Programmers must made do with comments, \xcd`assert`
statements, and dynamic tests.  X10 programs can do better, with {\em
  constraints} on types, and guards on class, method and type
definitions.

\bard{Vijay said we neet distinguish between a {\bf constraint expression}
(which can appear in places like a property method definition or a guard), 
and a {\bf constrained type} like \xcd`T{c}`.  That is, a constraint doesn't
need to be {\bf attached}.
}
A constraint is a boolean expression \xcd`e` attached to a basic type \xcd`T`,
written \xcd`T{e}`.  (Only a limited selection of boolean expressions is
available.)  The values of type \xcd`T{e}` are the values of \xcd`T` for which
\xcd`e` is true.  

\index{self}When constraining a value of type \xcd`T`, \xcd`self` refers to the object of
type \xcd`T` which is being constrained.  For example, \xcd`Int{self == 4}` is
the type of \xcd`Int`s which are equal to 4 -- the best possible description
of \xcd`4`, and a very difficult type to express without using \xcd`self`.  

\bard{The following section of examples got moved and recombined, and needs to
be checked for consistency, sensibility, non-duplication, and libel.}

\begin{ex}

\begin{itemize}
%~~type~~`~~`~~ ~~ ^^^ Types290
\item \xcd`String{self != null}` is the type of non-null strings. 
\item Suppose that \xcd`Matrix` is a matrix class with  properties \xcd`rows`
      and \xcd`cols`.  
%~~type~~`~~`~~ ~~class Matrix(rows:Int,cols:Int){} ^^^ Types300
      \xcd`Matrix{self.rows == self.cols}` is the type of square matrices.
\item One way to say that \xcd`a` has the same number of columns that \xcd`b`
      has rows (so that \xcd`a*b` is a valid matrix product), one could say: 
%~~gen ^^^ Types310
% package Types.cripes.whered.you.get.those.gripes;
% class Matrix(rows:Int, cols:Int){
% public static def someMatrix(): Matrix = null;
% public static def example(){
%~~vis
\begin{xten}
  val a : Matrix = someMatrix() ;
  var b : Matrix{b.rows == a.cols} ;
\end{xten}
%~~siv
%}}
%~~neg
\end{itemize}
\end{ex}



\xcd"T{e}" is a {\em dependent type}, that is, a type dependent on values. The
type \xcd"T" is called the {\em base type} and \xcd"e" is called the {\em
  constraint}. If the constraint is omitted, it is \xcd`true`---that is, the
  base type is unconstrained.

Constraints may refer to immutable values in the local environment: 
%~~gen ^^^ Types320
% class ConstraintsMayReferToValues {
% def thoseValues() {
%~~vis
\begin{xten}
     val n = 1;
     var p : Point{rank == n};
\end{xten}
%~~siv
%}}
%~~neg
In a \xcd`val` variable declaration, the variable itself is in scope in its
type, and can be used in constraints.

\begin{ex}
For example, \xcd`val nz: Int{nz != 0} = 1;` declares a
non-zero variable \xcd`nz`.
In this case, \xcd`nz` could have been declared as
\xcd`val nz: Int{self != 0} = 1`.  
%%FAILY-jira-XTENLANG-2779%%  However, some variables can have types that cannot otherwise be expressed in
%%FAILY-jira-XTENLANG-2779%%  X10 v2.2's type system. \Eg, 
%%FAILY-jira-XTENLANG-2779%%  %~~gen ^^^ Types6z9j
%%FAILY-jira-XTENLANG-2779%%  % package Types6z9j;
%%FAILY-jira-XTENLANG-2779%%  % class Example {
%%FAILY-jira-XTENLANG-2779%%  %   public static def example() {
%%FAILY-jira-XTENLANG-2779%%  %~~vis
%%FAILY-jira-XTENLANG-2779%%  \begin{xten}
%%FAILY-jira-XTENLANG-2779%%      val a : Array[Int{self!=a.rank}] = null;
%%FAILY-jira-XTENLANG-2779%%  \end{xten}
%%FAILY-jira-XTENLANG-2779%%  %~~siv
%%FAILY-jira-XTENLANG-2779%%  %} } 
%%FAILY-jira-XTENLANG-2779%%  %~~neg
\end{ex}

\subsection{Examples of Constraints}
\label{ConstraintExamples}

Example of entailment and subtyping involving constraints.
\begin{itemize}
\item \xcd`Int{self == 3} <: Int{self != 14}`.  The only value of
      \xcd`Int{self ==3}` is $3$.  All integers but $14$ are members of
      \xcd`Int{self != 14}`, and in particular $3$ is.  
\item Suppose we have classes \xcd`Child <: Person`, and \xcd`Person` has a
      \xcd`ssn:Long` property.  If \xcd`rhys : Child{ssn == 123456789}`, then
      \xcd`rhys` is also a \xcd`Person`.  
      \xcd`rhys`'s \xcd`ssn` field is the same, \xcd`123456789`, whether 
      \xcd`rhys` is regarded as a \xcd`Child` or a \xcd`Person`.  
      Thus, 
      \xcd`rhys : Person{ssn==123456789}` as well.  
      So, 
\begin{xtenmath}
Child{ssn == 123456789} <: Person{ssn == 123456789}.
\end{xtenmath}
\item Furthermore, since \xcd`123456789 != 555555555`, 
      is is clear that 
      \xcd`rhys : Person{ssn != 555555555}`.  
      So, 
\begin{xtenmath}
Child{ssn == 123456789} <: Person{ssn != 555555555}.  
\end{xtenmath}
\item \xcd`T{e} <: T` for any type \xcd`T`.  That is, if you have a value
      \xcd`v` of some base type \xcd`T` which satisfied \xcd`e`, then \xcd`v`
      is of that base type \xcd`T` (with the constraint ignored).
\item If \xcd`A <: B`, then \xcd`A{c} <: B{c}` for every constraint \xcd`{c}`
      for which \xcd`A{c}` and \xcd`B{c}` are defined.  That is, if every
      \xcd`A` is also a \xcd`B`, and \xcd`a : A{c}`, then 
      \xcd`a` is an \xcd`A` and \xcd`c` is true of it. So \xcd`a` is also a
      \xcd`B` (and \xcd`c` is still true of 
      it), so \xcd`a : B{c}`.  
\end{itemize}

Constraints can be used to express simple relationships between objects,
enforcing some class invariants statically.  For example, in geometry, a line
is determined by two {\em distinct} points; a \xcd`Line` struct can specify the
distinctness in a type constraint:\footnote{We call them
\xcd`Position` to avoid confusion with the built-in class \xcd`Point`. 
Also, \xcd`Position` is a struct rather than a class so that the non-equality
test \xcd`start != end` compares the coordinates.  If \xcd`Position` were a
class, \xcd`start != end` would check for different \xcd`Position` objects,
which might have the same coordinates.
}


%~~gen ^^^ Types340
% package triangleExample.partOne;
%~~vis
\begin{xten}
struct Position(x: Int, y: Int) {}
struct Line(start: Position, end: Position){start != end}
  {}
\end{xten}

%~~siv
%~~neg

Extending this concept, a \xcd`Triangle` can be defined as a figure with three
line segments which match up end-to-end.  Note that the degenerate case in
which two or three of the triangle's vertices coincide is excluded by the
constraint on \xcd`Line`.  However, not all degenerate cases can be excluded
by the type system; in particular, it is impossible to check that the three
vertices are not collinear. 

%~~gen ^^^ Types350
%package triangleExample.partTwo;
% struct Position(x: Int, y: Int) {
%    def this(x:Int,y:Int){property(x,y);}
%    }
% class Line(start: Position, 
%            end: Position{self != start}) {}
% 
%~~vis
\begin{xten}
struct Triangle 
 (a: Line, 
  b: Line{a.end == b.start}, 
  c: Line{b.end == c.start && c.end == a.start})  
 {}
\end{xten}
%~~siv
%
%~~neg

The \xcd`Triangle` class automatically gets a ternary constructor which takes
suitably constrained \xcd`a`, \xcd`b`, and \xcd`c` and produces a new
triangle. 



%%TYPES-CONSTR-EXP%% We permit variable declarations \xcd"v: T" where \xcd"T" is obtained
%%TYPES-CONSTR-EXP%% from a dependent type \xcd"C{c}" by replacing one or more occurrences
%%TYPES-CONSTR-EXP%% of \xcd"self" in \xcd"c" by \xcd"v". (If such a declaration \xcd"v: T"
%%TYPES-CONSTR-EXP%% is type-correct, it must be the case that the variable \xcd"v" is not
%%TYPES-CONSTR-EXP%% visible at the type \xcd"T". Hence we can always recover the
%%TYPES-CONSTR-EXP%% underlying dependent type \xcd"C{c}" by replacing all occurrences of \xcd"v"
%%TYPES-CONSTR-EXP%% in the constraint of \xcd"T" by \xcd"self".)
%%TYPES-CONSTR-EXP%% 
%%TYPES-CONSTR-EXP%% For instance, \xcd"v: Int{v == 0}" is shorthand for \xcd"v: Int{self == 0}".
%%TYPES-CONSTR-EXP%% 
%%TYPES-CONSTR-EXP%% 
%%TYPES-CONSTR-EXP%% A variable occurring in the constraint \xcd"c" of a dependent type, other than
%%TYPES-CONSTR-EXP%% \xcd"self" or a property of \xcd"self", is said to be a {\em
%%TYPES-CONSTR-EXP%% parameter} of \xcd"c".\label{DepType:Parameter} \index{parameter}

A constrained type may be constrained further: the type \xcd`S{c}{d}`
is the same as the type \xcd`S{c,d}`.  Multiple constraints are equivalent to
conjoined constraints: \xcd`S{c,d}` in turn is the same as \xcd`S{c && d}`.

\subsection{Syntax of constraints}
\index{constraint!permitted}
\index{constraint!syntax}
\label{PermittedConstraints}
\index{constraint}
\index{expression!allowed in constraint}
\index{expression!constraint}

\forvijay{You wrote ``self vs. this in super type, interfaces, class
invariant''.  I think we decided that self could appear there and this
couldn't, and we'd write a polite error message explaining that?  Since the
restriction on it in those places is the same as the restriction on self.  
If you confirm this (or deny it), I'll write a JIRA about it.
}

Only a few kinds of expressions can appear in constraints.  For fundamental
reasons of mathematical logic, the more kinds of expressions that can appear
in constraints, the harder it is to compute the essential properties of
constrained type -- in particular, the harder it is to compute 
\xcd`A{c} <: B{d}` or even \xcd`E : T{c}`.  It doesn't take much to make this
basic fact undecidable. 
In order to make sure that it stays decidable, X10 places stringent restrictions on
constraints.  

Only the following forms of expression are allowed in constraints.  

{\bf Value expressions in constraints} may be: 
\begin{enumerate}
\item Literal constants, like \xcd`3` and \xcd`true`;
% \item Expressions computable at compile time, like \Xcd{3*4+5};
\item Accessible, immutable (\xcd`val`) variables and parameters;
% \item Accessible and immutable fields of objects;
% \item Properties of the type being constrained;
\item \xcd`this`, if the constraint is at a point in the program where \xcd`this` is defined;
\item \xcd`here`, if the constraint is at a point in the program where \xcd`here` is defined;
\item \xcd`self`;
\item A field selection expression \xcd`t.f`, where \xcd`t` is a value
      expression allowed in constraints, and \xcd`f` is a field of \xcd`t`'s
      type.   
\bard{Vijay wrote ``However, self can be the receiver only for properties and
prop methods} 
 \item Invocations of property methods,  \xcd`p(a,b,...,c)` or
      \xcd`a.p(b,c,...d)`, where the receiver and arguments must be
       value expressions acceptable in constraints, as long as the expansion
       (\viz, the expression obtained by taking the body of the definition of
       \xcd`p`, and replacing the formal parameters by the actual parameters)
       of the invocation is allowed as a value expression in constraints.  
\end{enumerate}
For an expression \xcd`self.p` to be legal in a constraint, 
\xcd`p` must be 
a property. However terms \xcd`t.f` may be
used in constraints (where \xcd`t` is a term other than \xcd`self` and
\xcd`f` is an immutable field.)

{\bf Constraints}  may be any of
the following, where 
all value expressions are of the forms which may appear in constraints: 
\begin{enumerate}
\item Equalities \xcd`e == f`;
\item Inequalities of the form \xcd`e != f`;\footnote{Currently inequalities
      of the form \xcd`e < f` are not supported.}
\item Conjunctions of Boolean expressions that may appear in constraints (but
      only in top-level constraints, not in Boolean expressions in constraints);
\item Subtyping and supertyping expressions: \xcd`T <: U` and \xcd`T :> U`; 
\item Type equalities and inequalities: \xcd`T == U` and \xcd`T != U`; 
\item Invocations of a property method, \xcd`p(a,b,...,c)` or
      \xcd`a.p(b,c,...d)`, where the receiver and arguments must be value
      expressions acceptable in constraints, as long as the expansion of the
      invocation is allowed as a constraint.
\item Testing a type for a default: \Xcd{T haszero}.
\end{enumerate}

\forvijay{You wrote ``not true'' by this.  What, then, is true?}
All variables appearing in a constraint expression must be visible wherever
that expression can used.  \Eg, properties and public fields of an object are
always permitted, but private fields of an object can only constrain private
members.  (Consider a class \xcd`PriVio` with a private field \xcd`p` and a
public method \xcd`m(x: Int{self != p})`, and a call \xcd`ob.m(10)` made
outside of the class. Since \xcd`p` is only visible inside the class, there is
no way to tell if \xcd`10` is of type \xcd`Int{self != p}` at the call site.)

{\bf Note:} Constraints may not contain casts.   In particular, comparisons of
values of incompatible types are not allowed.  If \xcd`i:Int`, then \xcd`i==0`
is allowed as a constraint, but \xcd`i==0L` is an error, and 
\xcd`i as Long==0L` is outside of the constraint language.


\subsubsection{Semantics of constraints}
\index{constraint!semantics}
\label{SemanticsOfConstraints}

%%ENT%% An assignment of values to variables is said to be a {\em solution} for a
%%ENT%% constraint \xcd`c` if under this assignment \xcd`c` evaluates to
%%ENT%% \xcd`true`. For instance, the assignment that maps 
%%ENT%% the variables \xcd`a` and \xcd`b` to a value \xcd`t` is a solution for
%%ENT%% the constraint \xcd`a==b`. An assignment that maps \xcd`a` to 
%%ENT%% \xcd`s` and \xcd`b` to a distinct value \xcd`t` is a solution for 
%%ENT%% \xcd`a != b`. 
%%ENT%% 
%%ENT%% An instance \xcd"o" of \xcd"C" is said to be of type \xcd"C{c}" (or {\em
%%ENT%% belong to} \xcd"C{c}") if the constraint \xcd"c" evaluates to \xcd"true" in
%%ENT%% the current lexical environment augmented with the binding \xcd"self"
%%ENT%% $\mapsto$ \xcd"o".
%%ENT%% 
%%ENT%% A constraint \xcd`c` is said to {\em entail} a
%%ENT%% constraint \xcd`d` if every solution for \xcd`c` is also a solution
%%ENT%% for \xcd`d`. For instance the constraint
%%ENT%% \xcd`x==y && y==z && z !=a` entails \xcd`x != a`.
%%ENT%% 
%%ENT%% The constraint solver considers the assignment \xcd`a` to \xcd`null`
%%ENT%% to satisfy any constraint of the form \xcd`a.f==t`. 
%%ENT%% Thus, the declaration 
%%ENT%% \xcd`var x:Tree{self.r==p}=null` does not
%%ENT%% produce an error, since \xcd`self==null` satisfies the constraint
%%ENT%% \xcd`self.r==p`.  
%%ENT%% (This only applies in constraints, not in expression evaluation.  
%%ENT%% \xcd`if(a.f==t)...` will throw an exception if \xcd`a==null`.)
%%ENT%% If \xcd`null` is not an acceptable value for some class \xcd`Tree`, 
%%ENT%% add \xcd`self!=null` as a constraint: 
%%ENT%% \xcd`Tree{self!=null}` is the class of non-\xcd`null` \xcd`Tree`s.

The logic of constraints is designed to allow a common and important X10
idiom: 
%~~gen ^^^ Types9l9q
% package Types9l9q;
% class Example {
%~~vis
\begin{xten}
class Thing(p:Int){}
static def example(){
   var x : Thing{x.p==3} = null;
}
\end{xten}
%~~siv
%}
% class Hook{ def run() {Example.example(); return true;}}
%~~neg
That is, \xcd`null` must be an instance of \xcd`Thing{x.p==3}`.  
Of course, it cannot be the case that \xcd`null.p==3` --- nor can it equal
anything else.  When evaluated at runtime, \xcd`null.p` must throw a
\xcd`NullPointerException` rather than returning any value at all.

So, X10's logic of constraints --- {\em unlike} the logic of runtime ---
allows \xcdmath"x$=$null" to satisfy \xcd`x.p==3`.  Building this logic
requires a few definitions.

The property graph, at an instant in an X10 execution, is the graph
whose nodes are all objects in existence at that instance, plus \xcd`null`,
with an edge from 
{$x$} to {$y$} if {$x$} is an object with a property whose value is {$y$}. 
The rules for constructors guarantee that property graphs are acyclic, which
is crucial for decidability.

As is standard in mathematical logic, we introduce the concept of a
{\em valuation} {$v$}, which is a mapping from variable names to their values
-- in our case, nodes of an X10 property graph.  A valuation {$v$} can be
extended to values to all constraint formulas.  The crucial definitions are: 
\begin{xtenmath}
$v($ a.b$\ldots$.l.m == n.o$\ldots$.y.z$) = $
  a$=$null $\vee$ a.b$=$null $\vee$ $\ldots$ a.b$\ldots$.l$=$null 
  $\vee$ n$=$null $\vee$ n.o$=$null $\vee$ $\ldots$ n.o$\ldots$.y$=$null 
  $\vee$ $v($a$)$.b$\ldots$.l.m $=$ $v($n$)$.o$\ldots$.y.

$v($ a.b$\ldots$.l.m != n.o$\ldots$.y.z$) = $
  a$=$null $\vee$ a.b$=$null $\vee$ $\ldots$ a.b$\ldots$.l$=$null 
  $\vee$ n$=$null $\vee$ n.o$=$null $\vee$ $\ldots$ n.o$\ldots$.y$=$null 
  $\vee$ $v($a$)$.b$\ldots$.l.m $\ne$ $v($n$)$.o$\ldots$.y.
\end{xtenmath}
For example, \xcdmath"$v($a.b==1$)$" is true if either \xcdmath"$v($a$)=$null"
or if \xcdmath"$v($a$)$" is a container whose \xcd`b`-field is equal to {$1$}.
While such a valuation is perfectly well-defined, it has properties that need
to be understood in light of the fact that \xcd`==` is {\em not} mathematical
equality.\footnote{No experienced programmer should actually think that
\xcd`==` is mathematical equality in any case.  It is quite common for two
objects to appear identical but not be \xcd`==`.  X10's discrepancy between the
two concepts is orthogonal to the familiar one.}  
Given any valuation in which \xcdmath"$v($a$)=$null", both 
\xcdmath"$v($a.b==1 && a.b==2$)$" 
and
\xcdmath"$v($a.b==1 && a.b!=1$)$" 
are true.  
This does not contradict logic and mathematics, 
it does not imply that \xcdmath"$v($false$)$" is true (it's not), 
and it does not
assert that in X10 there is a number which is both 1 and 2.
It simply reflects the fact that, while \xcd`==` is similar to mathematical equality in
many respects, it is ultimately a different operation, and in constraints it
is given a \xcd`null`-safe interpretation.




From this definition of valuation, we define {\em entailment} in the standard
way.  Given constraints \xcd`c` and \xcd`d`, we define {\em \xcd`c` entails
\xcd`d`}, sometimes written \xcdmath"c $\models$ d", if for all valuations
{$v$} such that \xcdmath"$v($c$)$" is true, \xcdmath"$v($d$)$" is also true. 

\limitationx{} Although nearly-contradictory conjunctions 
like \xcd`x.a==1 && x.a==2` entail \xcd`x==null`, X10's constraint solver does
not currently use this rule.  If you want \xcd`x==null`, write \xcd`x==null`.  

Subtyping of constrained types is defined in terms of entailment. 
\xcdmath"S[S1,$\ldots$, Sm]{c}" 
is a subtype of 
\xcdmath"T[T1,$\ldots$, Tn]{d}" 
if \xcdmath"S[S1,$\ldots$,Sm]" is a subtype of \xcdmath"T[T1,$\ldots$,Tn]" and
\xcd"c" entails \xcd"d".

For examples of constraints and entailment, see (\Sref{ConstraintExamples})
%%TYPES-CONSTR-EXP%% 
%%TYPES-CONSTR-EXP%% \begin{grammar}
%%TYPES-CONSTR-EXP%% Constraint \: ValueArguments     Guard\opt \\
%%TYPES-CONSTR-EXP%%            \| ValueArguments\opt Guard     \\
%%TYPES-CONSTR-EXP%%            \\
%%TYPES-CONSTR-EXP%% ValueArguments   \:  \xcd"(" ArgumentList\opt \xcd")" \\
%%TYPES-CONSTR-EXP%% ArgumentList     \:  Expression ( \xcd"," Expression )\star \\
%%TYPES-CONSTR-EXP%% Guard            \: \xcd"{" DepExpression \xcd"}" \\
%%TYPES-CONSTR-EXP%% DepExpression    \: ( Formal \xcd";" )\star ArgumentList \\
%%TYPES-CONSTR-EXP%% \end{grammar}
%%TYPES-CONSTR-EXP%% 
%%TYPES-CONSTR-EXP%% In \XtenCurrVer{} value constraints may be equalities (\xcd"=="),
%%TYPES-CONSTR-EXP%% disequalities (\xcd"!=") and conjunctions thereof.  The terms over
%%TYPES-CONSTR-EXP%% which these constraints are specified include literals and
%%TYPES-CONSTR-EXP%% (accessible, immutable) variables and fields, property methods, and the special
%%TYPES-CONSTR-EXP%% constants {\tt here}, {\tt self}, and {\tt this}. Additionally, place
%%TYPES-CONSTR-EXP%% types are permitted (\Sref{PlaceTypes}).
%%TYPES-CONSTR-EXP%% 
%%TYPES-CONSTR-EXP%% \index{self}

%%TYPES-CONSTR-EXP%% Type constraints may be subtyping and supertyping (\xcd"<:" and
%%TYPES-CONSTR-EXP%% \xcd":>") expressions over types.

\subsection{Constraint solver: incompleteness and approximation}
\index{constraint solver!incompleteness}
\index{constraint!entailment}
\index{constraint!subtyping}



The constraint solver is sound in that if it claims that \xcd`c` entails \xcd`d`
then in fact it is the case that every valuation that satisfies \xcd`c`
satisfies \xcd`d`. 

\limitationx{}
X10's constraint solver is incomplete. There are situations
in which \xcd`c` entails \xcd`d` but the solver cannot establish it. For
instance it cannot establish that \xcd`a != b && a != c && b != c`
entails \xcd`false` if \xcd`a`, \xcd`b`, and \xcd`c` are of type
\xcd`Boolean`.
Similarly, although \xcd`a.b==1 && a.b==2` entails \xcd`a==null`, the
constraint solver does not deduce this fact. 

\forvijay{You wrote ``Need discussion of acyclicity''.  Could I have a bit
more detail?}

%%NOW-GONE%% Certain other constraint entailments are prohibitively expensive to calculate.  The issues
%%NOW-GONE%% concern constraints that connect different levels of recursively-defined
%%NOW-GONE%% types, such as the following.  
%%NOW-GONE%% %~~gen ^^^ Types330
%%NOW-GONE%% % package Types.Entailment.EntailFail;
%%NOW-GONE%% %~~vis
%%NOW-GONE%% \begin{xten}
%%NOW-GONE%% class Listlike(x:Int) {
%%NOW-GONE%%   val kid : Listlike{self.x == this.x};
%%NOW-GONE%%   def this(x:Int, kid:Listlike) { 
%%NOW-GONE%%      property(x); 
%%NOW-GONE%%      this.kid = kid as Listlike{self.x == this.x};}
%%NOW-GONE%% }
%%NOW-GONE%% \end{xten}
%%NOW-GONE%% %~~siv
%%NOW-GONE%% %
%%NOW-GONE%% %~~neg
%%NOW-GONE%% There is nothing wrong with \xcd`Listlike` itself, or with most uses of it;
%%NOW-GONE%% however, a sufficiently complicated use of it could, in principle, cause X10's
%%NOW-GONE%% typechecker to fail. 
%%NOW-GONE%% It is hard to give a plausible example of when X10's algorithm fails, as we
%%NOW-GONE%% have not yet observed such a failure in practice for a correct program.  
%%NOW-GONE%% 
%%NOW-GONE%% 
%%NOW-GONE%% \limitation{ Support for comparisons of generic type variables is
%%NOW-GONE%%   limited. This will be fixed in future releases.}
%%NOW-GONE%% % //, and existential quantification over typed variables.
%%NOW-GONE%% 
%%TYPES-CONSTR-EXP%% \emph{
%%TYPES-CONSTR-EXP%% Subsequent implementations are intended to support boolean algebra,
%%TYPES-CONSTR-EXP%% arithmetic, relational algebra, etc., to permit types over regions and
%%TYPES-CONSTR-EXP%% distributions. We envision this as a major step towards removing most,
%%TYPES-CONSTR-EXP%% if not all, dynamic array bounds and place checks from \Xten{}.
%%TYPES-CONSTR-EXP%% }




%%PLACE%%\subsection{Place constraints}
%%PLACE%%\label{PlaceTypes}
%%PLACE%%\label{PlaceType}
%%PLACE%%\index{place types}
%%PLACE%%\label{DepType:PlaceType}\index{placetype}
%%PLACE%%
%%PLACE%%An \Xten{} computation spans multiple places (\Sref{XtenPlaces}). Much data
%%PLACE%%can only be accessed from the proper place, and often it is preferable to
%%PLACE%%determine this statically. So, X10 has special syntax for working with places.
%%PLACE%%\xcd`T!` is a value of type \xcd`T` located at the right place for the current
%%PLACE%%computation, and \xcd`T!p` is one located at place \xcd`p`.
%%PLACE%%
%%PLACE%%\begin{grammar}
%%PLACE%%PlaceConstraint     \: \xcd"!" Place\opt \\
%%PLACE%%Place              \:   Expression \\
%%PLACE%%\end{grammar}
%%PLACE%%
%%PLACE%%More specifically, All \Xten{} classes extend the class \xcd"x10.lang.Object",
%%PLACE%%which defines a property \xcd"home" of type \xcd"Place".  \xcd`T!p`, when
%%PLACE%%\xcd`T` is a class, is \xcd`T{self.home==p}`.  If \xcd`p` is omitted, it
%%PLACE%%defaults to \xcd`here`.   \xcd`T!` is far and away the most common usage of
%%PLACE%%\xcd`!`. 
%%PLACE%%
%%PLACE%%Structs don't have \xcd`home`; they are available everywhere.  For structs, 
%%PLACE%%\xcd`T!` and \xcd`T!p` are synonyms for \xcd`T`. Since \xcd`T` is available
%%PLACE%%everywhere, it is available \xcd`here` and at \xcd`p`. 
%%PLACE%%
%%PLACE%%\xcd`!` may be combined with other constraints.  \xcd`T{c}!` is the type of
%%PLACE%%values of \xcd`T!` which satisfy \xcd`c`; it is \xcd`T{c && self.home==here}`
%%PLACE%%for an object type and \xcd`T{c}` for a struct type.  
%%PLACE%%\xcd`T{c}!p` is the type of
%%PLACE%%values of \xcd`T!p` which satisfy \xcd`c`; it is \xcd`T{c && self.home==p}`
%%PLACE%%for an object type and \xcd`T{c}` for a struct type.  
%%PLACE%%
%%PLACE%%
%%PLACE%%
%%PLACE%%% The place specifier \xcd"any" specifies that the object can be
%%PLACE%%% located anywhere.  Thus, the location is unconstrained; that is,
%%PLACE%%% \xcd"C{c}!any" is equivalent to \xcd"C{c}".
%%PLACE%%
%%PLACE%%% XXX ARRAY
%%PLACE%%%The place specifier \xcd"current" on an array base type
%%PLACE%%%specifies that an object with that type at point \xcd"p"
%%PLACE%%%in the array 
%%PLACE%%%is located at \xcd"dist(p)".  The \xcd"current" specifier can be
%%PLACE%%%used only with array types.
%%PLACE%%
%%PLACE%%

\subsection{Limitation: Generics and Constraints at Runtime}
\label{sect:RuntimeConstraintErasure}
\index{cast!to generic type}

%%OLD%% \bard{
%%OLD%% This subsection is trying to explain why X10 doesn't maintain a runtime rep of
%%OLD%% constraints.  The intended message, which got kinda lost: There are a few possibilities for doing so.  Even if we did one
%%OLD%% of them, it still wouldn't suffice.
%%OLD%% }

The X10 runtime does not maintain a representation of constraints as part of
the runtime representation of a type.  While there various approaches which
could be used,  they would require far higher prices in space or time than
they are worth.  A representation suitable for one use of types
(such as keeping a closure for testing membership in the type) is unsuitable
for others (such as determining if one type is a subtype of another).
Furthermore, it would be necessary to compute entailment at runtime, which is
currently impractical.  













%%OLD%% In many cases, it does not need to.
%%OLD%% If X10 has an object \xcd`x` of some type \xcd`T` around, it can check at
%%OLD%% runtime whether or not \xcd`x` satisfies some constraint \xcd`c`, and hence
%%OLD%% tell if \xcd`x` is a member of \xcd`T{c}`. 
%%OLD%% 
%%OLD%% \begin{ex}
%%OLD%% Although there is no runtime representation of the constrained type 
%%OLD%% \xcd`Int{self==1}`, X10 can generate a (correct) test for membership in it,
%%OLD%% anyhow: 
%%OLD%% %~~gen ^^^ Types3u5w
%%OLD%% % package Types3u5w;
%%OLD%% % class Example {
%%OLD%% %~~vis
%%OLD%% \begin{xten}
%%OLD%% static def example(n:Int) {
%%OLD%%   val b = (n instanceof Int{self == 1});
%%OLD%%   assert b == (n == 1); 
%%OLD%% }
%%OLD%% \end{xten}
%%OLD%% %~~siv
%%OLD%% % }
%%OLD%% % class Hook{ def run() {Example.example(0); Example.example(1);
%%OLD%% % Example.example(2); return true; } }
%%OLD%% %~~neg
%%OLD%% \end{ex}
%%OLD%% 
%%OLD%% However, in cases where there is no object of type \xcd`T` around, there's
%%OLD%% nothing that can be checked. For example, X10 cannot tell -- and in fact no
%%OLD%% computer program can tell --  whether an
%%OLD%% instance of a function type 
%%OLD%% \begin{xtenmath}
%%OLD%% (Int)=>Int
%%OLD%% \end{xtenmath}
%%OLD%% (unary functions returning
%%OLD%% integers) is actually an instance of a more specific type
%%OLD%% \begin{xtenmath}
%%OLD%% (Int)=>Int{self!=0}
%%OLD%% \end{xtenmath}
%%OLD%% (unary functions returning non-zero integers).
%%OLD%% 
%%OLD%% In other cases, there might or might not be an object of type \xcd`T`, and X10
%%OLD%% cannot tell until runtime.  Consider an array \xcd`a:Array[T]`.  If \xcd`a` is
%%OLD%% nonempty, there is an instance of \xcd`T` at hand, and testing it for
%%OLD%% constraints would be possible though potentially quite expensive. 
%%OLD%% But \xcd`a` might be an
%%OLD%% empty array, and testing its element type would be impossible. 
%%OLD%% 
%%OLD%% \bard{
%%OLD%% If you had an Array[Any] and asked if it instanceof Array[Int] -- even if it
%%OLD%% was currently full of integers -- you'd get a wrong answer.  You'd expect in
%%OLD%% general: 
%%OLD%% if (x instanceof T) 
%%OLD%%   val xt :T = x as T
%%OLD%%   ...
%%OLD%% to work. But it won't, if you cast an x:Array[Any] into an xt:Array[Int],
%%OLD%% store Booleans into it through x, and take them out via xt and expect them to
%%OLD%% be Ints.  
%%OLD%% Ultimately, being a value of a parameterized type is a definitional matter,
%%OLD%% not a computational one.  
%%OLD%% }
%%OLD%% 

Rather than pay the runtime costs for keeping and manipulating constraints
(which can be considerable), X10 omits them.
However, this renders certain type checks uncertain: X10 needs some
information at runtime, but does not have it.    In particular, {\bf casts to
instances of generic types, and to type variables, are potentially troublesome.}


\begin{ex}
The following code illustrates the dangers of casting to generic types. 
It constructs an array \xcd`a` of \xcd`Int{self==3}`'s -- integers
which 
are statically known to be 3. 
The only number that can be stored into \xcd`a` is \xcd`3`.  
Then it tricks the ocmpiler into 
thinking that it is an array of \xcd`Int`, without restriction on the
elements, giving it the name \xcd`b` at that type.  
The cast \xcd`aa as Array[Int]` is a cast to an instance of a generic type,
which is the problem. 

But, itc an store any \xcd`Int` into the elements of 
\xcd`b`, thereby violating 
the invariant that all the elements of the array are 3.  
This could lead to program failures, as illustrated by the failing assertion.  

With the \xcd`-VERBOSE` compiler option, X10 prints a warning about the
declaration of \xcd`b`.  
\begin{xten}
  val a = new Array[Int{self==3}](0..10, 3);
  // a(0) = 1; would be illegal
  a(0) = 3; // LEGAL
  val aa = a as Any;
  val b = aa as Array[Int](1); // WARNED with -VERBOSE
  b(0) = 1;
  val x : Int{self==3} = a(0);
  assert x == 3 : "This fails at runtime.";
\end{xten}
\end{ex}

\label{sect:StrippedGenericCasts}

Since constraints are not preserved at runtime, \xcd`instanceof` and \xcd`as`
cannot pay attention to them.  When types are used generically,
they may not behave as one would expect were one to imagine that their
constraints were kept.  Specifically, constraints at runtime are, in effect,
simply replaced by \xcd`true`.

\begin{ex}
The following code defines generic methods \xcd`inst` and \xcd`cast`, which
look like generic versions of \xcd`instanceof` and \xcd`as`.  The
\xcd`example()` code shows that \xcd`inst` and \xcd`cast` behave quite
differently from \xcd`instanceof` and \xcd`as`, due to the loss of constraint
information.  

The first section of \xcd`assert`s shows the behavior of \xcd`instanceof` and
\xcd`at`.  We have a value \xcd`pea`, such that \xcd`pea.p==1`.
It behaves as if its \xcd`p` field were \xcd`1`: it answers \xcd`true` to 
\xcd`self.p==1`, and \xcd`false` to \xcd`self.p==2`.  This is entirely as
desired.

The following section of \xcd`assert` and \xcd`val` statements does the
analogous thing, but using the generic methods \xcd`inst` and \xcd`cast`
rather than the built-in operations \xcd`instanceof` and \xcd`cast`.
\xcd`pea` answers \xcd`true` to \xcd`inst` checks concerning both
\xcd`Pea{p==1}` and \xcd`Pea{p==2}`, and can be \xcd`cast()` into both these
types.  This behavior is not what one would expect from runtime types that
keep constraint information.  It is, however, precisely what one would expect
from runtime types that have their constraints replaced by \xcd`true`.  

The \xcd`cast2` line shows how to use this fact to violate the constraint
system at runtime.   This dynamic cast produces an object of type
\xcd`Pea{p==2}` for which \xcd`p!=2`.  

Note that the \xcd`-VERBOSE` compiler flag will produce a warning that 
\xcd`cast` is unsound.  

%~~gen ^^^ Types9j6e
% package Types9j6e;
%~~vis
\begin{xten}
class Generic {
  public static def inst[T](x:Any):Boolean = x instanceof T;
  // With -VERBOSE, the following line gets a warning
  public static def cast[T](x:Any):T       = x as T;
}
class Pea(p:Int) {}
class Example{
  static def example() {
     val pea : Pea = new Pea(1);
     // These are what you'd expect: 
     assert (pea instanceof Pea{p==1});
     assert (pea as Pea{p==1}).p == 1;
     assert ! (pea instanceof Pea{p==2}); 
     // 'val x = pea as Pea{p==2};' 
     // throws a FailedDynamicCheckException.

     // But the genericized versions don't do the same thing:
     assert Generic.inst[Pea{p==1}](pea);
     assert Generic.inst[Pea{p==2}](pea);
     // No exception here!
     val cast1: Pea{p==1} = Generic.cast[Pea{p==1}](pea);
     val cast2: Pea{p==2} = Generic.cast[Pea{p==2}](pea);
     assert cast2.p == 1;
     assert !(cast2 instanceof Pea{p==2});
  }
}

\end{xten}
%~~siv
%class Hook{ def run() {Example.example(); return true;}}
%~~neg
\end{ex}

While in some cases it would be possible to keep constraints around at runtime
and operate efficiently on them, in other cases it would not.  





\section{Default Values}
\index{default value}
\index{type!default value}
\label{DefaultValues}

Some types have default values, and some do not. Default values are used in
situations where variables can legitimately be used without having been
initialized; types without default values cannot be used in such situations.
For example, a field of an object \xcd`var x:T` can be left uninitialized if
\xcd`T` has a default value; it cannot be if \xcd`T` does not. Similarly, a
transient (\Sref{TransientFields}) field \xcd`transient val x:T` is only
allowed if \xcd`T` has a default value.

Default values, or lack of them, is defined thus:
\begin{itemize}
\item The fundamental numeric types (\xcd`Int`, \xcd`UInt`,
      \xcd`Long`, \xcd`ULong`, 
  \xcd`Short`, \xcd`UShort`, \xcd`Byte`,
   \xcd`UByte`, 
      \xcd`Float`, \xcd`Double`) all have default value 0.
\item \xcd`Boolean` has default value \xcd`false`.
\item \xcd`Char` has default value \xcd`'\0'`.
\item If every field of a struct type \xcd`T` has a default value, then
      \xcd`T` has a default value.  If any field of \xcd`T` has no default
      value, then \xcd`T` does not.  (\Sref{sect:DefaultValuesOfStructs})
\item A function type has a default value of \xcd`null`.
\item A class type has a default value of \xcd`null`.
\item The constrained type \xcd`T{c}` has the same default value as \xcd`T` if
      that default value satisfies \xcd`c`.  If the default value of \xcd`T`
      doesn't satisfy \xcd`c`, then \xcd`T{c}` has no default value.
\end{itemize}

\begin{ex}
\xcd`var x: Int{x != 4}` has default value 0, which is allowed
because \xcd`0 != 4` satisfies the constraint on \xcd`x`. 
\xcd`var y : Int{y==4}` has no default value, because \xcd`0` does not satisfy \xcd`y==4`.
The fact that \xcd`Int{y==4}` has precisely one value, \viz{} 4, doesn't
matter; the only candidate for its default value, as for any subtype of
\xcd`Int`, is 0. \xcd`y` must be initialized before it is used.
\end{ex}

The predicate \xcd`T haszero` tells if the type \xcd`T` has a default value.
\xcd`haszero` may be used in constraints. 

\begin{ex}
The following code defines a sort of cell holding a single value of type
\xcd`T`. The cell is initially empty -- that is, has \xcd`T`'s zero value --
but may be filled later. 
%~~gen ^^^ TypesHaszero10
% package TypesHaszero10;
%~~vis
\begin{xten}
class Cell0[T]{T haszero} {
  public var contents : T;
  public def put(t:T) { contents = t; }
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}

The built-in type \xcd`Zero` has the method \xcd`get[T]()` which
returns the default value of type \xcd`T`.  

\begin{ex}
As a variation on a theme of \xcd`Cell0`, we define a class \xcd`Cell1[T]` which can be initialized with a value of an arbitrary
type
\xcd`T`, or, if \xcd`T` has a default value, can be created with the default
value.  Note that \xcd`T haszero` is a constraint on one of
the constructors, not the whole type:  
%~~gen ^^^ TypesHaszero20
% package TypesHaszero20;
%~~vis
\begin{xten}
class Cell1[T] {
  public var contents: T;
  def this(t:T) { contents = t; }
  def this(){T haszero} { contents = Zero.get[T](); }
  public def put(t:T) {contents = t;}
}
\end{xten}
%~~siv
%
%~~neg

\end{ex}

\section{Function types}
\label{FunctionTypes}
\label{FunctionType}
\index{function!types}
\index{type!function}

%##(FunctionType
\begin{bbgrammar}
%(FROM #(prod:FunctionType)#)
        FunctionType \: TypeParams\opt \xcd"(" FormalList\opt \xcd")" Guard\opt Offers\opt \xcd"=>" Type & (\ref{prod:FunctionType}) \\
\end{bbgrammar}
%##)


For every sequence of types \xcd"T1,..., Tn,T", and \xcd"n" distinct variables
\xcd"x1,...,xn" and constraint \xcd"c", the expression
\xcd"(x1:T1,...,xn:Tn){c}=>T" is a \emph{function type}. It stands for
 the set of all functions \xcd"f" which can be applied to a
 list of values \xcd"(v1,...,vn)" provided that the constraint
 \xcd"c[v1,...,vn,p/x1,...,xn]" is true, and which returns a value of
 type \xcd"T[v1,...vn/x1,...,xn]". When \xcd"c" is true, the clause \xcd"{c}" can be
 omitted. When \xcd"x1,...,xn" do not occur in \xcd"c" or \xcd"T", they can be
 omitted. Thus the type \xcd"(T1,...,Tn)=>T" is actually shorthand for
 \xcd"(x1:T1,...,xn:Tn){true}=>T", for some variables \xcd"x1,...,xn".

\limitationx{}
Constraints on closures are not supported.  They parse, but are not checked.

X10 functions, like mathematical functions, take some arguments and produce a
result.  X10 functions, like other X10 code, can change mutable state and
throw exceptions.  Closures (\Sref{Closures})  are of function type -- and so
are arrays.


\begin{ex}Typical functions are the reciprocal function: 
%~~gen ^^^ Types360
% package Types.Functions;
% class RecipEx {
% static 
%~~vis
\begin{xten}
val recip = (x : Double) => 1/x;
\end{xten}
%~~siv
%}
%~~neg
and a function which increments  element \xcd`i` of an array \xcd`r`, or throws an exception
if there is no such element, where, for the sake of example, we constrain the
type of \xcd`i` to avoid one of the many integers which are not possible subscripts:  
%~~gen ^^^ Types_constraint_b
% package Types_constraint_b;
% //NOTEST-inner-class-foo.
% /*NONSTATIC*/class IncrElEx {
%  def example()  {
%~~vis
\begin{xten}
val inc = (r:Array[Int](1), i: Int{i != r.size}) => {
  if (i < 0 || i >= r.size) throw new DoomExn();
  r(i)++;
};
\end{xten}
%~~siv
%}}
%class DoomExn extends Exception{}
%~~neg
\end{ex}

In general, a function type needs to list the types 
\xcdmath"T$_i$"
of all the formal parameters,
and their distinct names \xcdmath"x$_i$" in case other types refer to them; a
constraint 
\xcd"c" on the
function as a whole; a return type \xcd"T".

\begin{xtenmath}
(x$_1$: T$_1$, $\dots$, x$_n$: T$_n$){c} => T
\end{xtenmath}


The names \xcdmath"x$_i$" of the formal parameters are not relevant.  Types
which differ only in the names of formals (following the usual rules for
renaming of variables, as in {$\alpha$}-renaming in the {$\lambda$} calculus
\bard{cite something}) are considered equal.  \Eg, the two function types
%~~type~~`~~`~~ ~~ ^^^ Types370
\xcd`(a:Int, b:Array[String](1){b.size==a}) => Boolean`
and \\
%~~type~~`~~`~~ ~~ ^^^ Types380
\xcd`(b:Int, a:Array[String](1){a.size==b}) => Boolean`
are equivalent.

\limitation{
Function types differing only in the names of bound variables may wind up being
considered different in X10 v2.2, especially if the variables appear in
constraints.  
}

The formal parameter names are in scope from the point of definition to the
end of the function type---they may be used in the types of other formal parameters
and in the return type. 
Value parameters names may be
omitted if they are not used; the type of the reciprocal function can be
written as
%~~type~~`~~`~~ ~~ ^^^ Types390
\xcd`(Double)=>Double`. 

A function type is covariant in its result type and contravariant in
each of its argument types. That is, let 
\xcd"S1,...,Sn,S,T1,...Tn,T" be any
types satisfying \xcd"Si <: Ti" and \xcd"S <: T". Then
\xcd"(x1:T1,...,xn:Tn){c}=>S" is a subtype of
\xcd"(x1:S1,...,xn:Sn){c}=>T".

A class or struct definition may use a function type 
\begin{xtenmath}
F = (x1:T1,...,xn:Tn){c}=>T
\end{xtenmath}
in its 
implements clause; 
this is equivalent to implementing an interface requiring the single operator
\begin{xtenmath}
public operator this(x1:T1,...,xn:Tn){c}:T
\end{xtenmath}
Similarly, an interface
definition may specify a function type \xcd"F" in its \xcd"extends" clause.
Values of a class or struct implementing \xcd`F` 
can be used as functions of type \xcd`F` in all ways.  
In particular, applying one to suitable arguments calls the \xcd`apply`
method. 

\limitationx{} A class or struct may not implement two different
instantiations of a generic interface. In particular, a class or
struct can implement only one function type.


A function type \xcd"F" is not a class type in that it does not extend any
type or implement any interfaces, or support equality tests. 
\xcd`F` may be implemented, but not extended, by a class or function type. 
Nor is it a struct type, for it has no predefined notion of equality.


\section{Annotated types}
\label{AnnotatedTypes}

\index{type!annotated}
\index{annotations!type annotations}

        Any \Xten{} type may be annotated with zero or more
        user-defined \emph{type annotations}
        (\Sref{XtenAnnotations}).  

        Annotations are defined as (constrained) interface types and are
        processed by compiler plugins, which may interpret the
        annotation symbolically.

        A type \xcd"T" is annotated by interface types
        \xcdmath"A$_1$", \dots,
        \xcdmath"A$_n$"
        using the syntax
        \xcdmath"@A$_1$ $\dots$ @A$_n$ T".

\section{Subtyping and type equivalence}\label{DepType:Equivalence}
\index{type equivalence}
\index{subtyping}

Intuitively, type \xcdmath"T$_1$" is a subtype of type \xcdmath"T$_2$", 
written \xcdmath"T$_1$ <: T$_2$", 
if
every instance of \xcdmath"T$_1$" is also an instance of \xcdmath"T$_2$".  For
example, \xcd`Child` is a subtype of \xcd`Person` (assuming a suitably defined
class hierarchy): every child is a person.  Similarly, \xcd`Int{self != 0}`
is a subtype of \xcd`Int` -- every non-zero integer is an integer.  

This section formalizes the concept of subtyping. Subtyping of types depends
on a {\em type context}, \viz. a set of constraints on type parameters
and variables that occur in the type.
For example: 

%~~gen ^^^ Types400
% package Types.subtyping.cons;
% NOCOMPILE
%~~vis
\begin{xten}
class ConsTy[T,U] {
   def upcast(t:T){T <: U} :U = t;
}
\end{xten}
%~~siv
%
%~~neg
\noindent
Inside \xcd`upcast`, \xcd`T` is constrained to be a subtype of \xcd`U`, and so
\xcd`T <: U` is true, and \xcd`t` can be treated as a value of type \xcd`U`.  
Outside of \xcd`upcast`, there is no reason to expect any relationship between
them, and \xcd`T <: U` may be false.
However, subtyping of types that have no free variables does not depend
on the context.    \xcd`Int{self != 0} <: Int` is always
true.

\limitation{Subtyping of type variables does not work under all circumstances
in the X10 2.2 implementation.}


\begin{itemize}
\item {\bf Reflexivity:} Every type \xcd`T` is a subtype of itself: \xcd`T <: T`.

\item {\bf Transitivity:} If \xcd`T <: U` and \xcd`U <: V`, then \xcd`T <: V`. 

\iffalse
{\bf Class types:}  
Given the definition 
\xcd`class C[$\vec{X}$] extends D[$\vec{Y}$]{d} implements I1, ..., In {...}`
where {$\vec{X}$} is a vector of type variables, and 
{$\vec{Y$} a vector of types possibly involving variables from {$\vec{X}$}, 
and {$\vec{T$} an instantiation of {$\vec{X$} and {$\vec{U$} the corresponding
instantiation of {$\vec{Y$}, 
then 
\xcdmath"C[$\vec{T}$]`"is a subtype of \xcd`D[$\vec{U}$]{d}`, \xcd`I1`, ..., \xcd`In`. 

\item
{\bf Interface types:}  
Given the definition 
\xcdmath"interface I[$\vec{X}$] extends I1, ... In {...}`"
then \xcdmath"I` is a subtype of \xcd`"1`, ..., \xcd`In`.

\item 
{\bf Struct types:} 
Given the definition 
\xcdmath"struct S implements I1, ..., In {...}`"then \xcd`S` is a 
subtype of \xcd`I1`, ..., \xcd`In`. 
\fi

\item {\bf Direct Subclassing:} 
Let {$\vec{X}$} be a (possibly empty) vector of type variables, and
{$\vec{Y}$}, {$\vec{Y_i}$} be vectors of type terms over {$\vec{X}$}.
Let {$\vec{T}$} be an instantiation of {$\vec{X}$}, 
and {$\vec{U}$}, {$\vec{U_i}$} the corresponding instantiation of 
{$\vec{Y}$}, {$\vec{Y_i}$}.  Let \xcd`c` be a constraint, and \xcdmath"c$'$"
be the corresponding instantiation.
We elide properties, and interpret empty vectors as absence of the relevant
clauses. 
Suppose that \xcd`C` is declared by one of the
forms: 
\begin{enumerate}
\item \xcdmath"class C[$\vec{X}$]{c} extends D[$\vec{Y}$]{d}"\\
\xcdmath"implements I$_1[\vec{Y_1}]${i$_1$},...,I$_n[\vec{Y_n}]${i$_n$}{"
\item \xcdmath"interface C[$\vec{X}$]{c} extends I$_1[\vec{Y_1}]${i$_1$},...,I$_n[\vec{Y_n}]${i$_n$}{"
\item \xcdmath"struct C[$\vec{X}$]{c} implements I$_1[\vec{Y_1}]${i$_1$},...,I$_n[\vec{Y_n}]${i$_n$}{"
\end{enumerate}
Then: 
\begin{enumerate}
\item \xcdmath"C[$\vec{T}$] <: D[$\vec{U}$]{d}" for a class
\item \xcdmath"C[$\vec{T}$] <: I$_i$[$\vec{U_i}$]{i$_i$}" for all cases.
\item \xcdmath"C[$\vec{T}$] <: C[$\vec{T}$]{c$'$}" for all cases.
\end{enumerate}


\item
{\bf Function types:}
\begin{xtenmath}
(x$_1$: T$_1$, $\dots$, x$_n$: T$_n$){c} => T
\end{xtenmath}
is a  subtype of 
\begin{xtenmath}
(x$'_1$: T$'_1$, $\dots$, x$'_n$: T$'_n$){c$'$} => T$'$
\end{xtenmath}
if: 
\begin{enumerate}
\item Each \xcdmath"T$_i$ <: T$'_i$";
\item \xcdmath"c[x$'_1$, $\ldots$, x$'_n$ / x$_1$, $\ldots$, x$_n$]" entails \xcdmath"c$'$";
\item \xcdmath"T$'$ <: T";
\end{enumerate}

\item
{\bf Constrained types:}
\xcd`T{c}` is a subtype of \xcd`T{d}` if \xcd`c` entails \xcd`d`. 

\item {\bf Any:} 
Every type \xcd`T` is a subtype of \xcd`x10.lang.Any`.

\item 
{\bf Type Variables:}
Inside the scope of a constraint \xcd`c` which entails \xcd`A <: B`, we have
\xcd`A <: B`.  \eg, \xcd`upcast` above.


%%NO-VARIANCE%% \item 
%%NO-VARIANCE%% {\bf Covariant Generic Types:} 
%%NO-VARIANCE%% If \xcd`C` is a generic type whose {$i$}th type parameter is covariant, 
%%NO-VARIANCE%% and {\xcdmath"T$'_i$ <: T$_i$"}
%%NO-VARIANCE%% and  {\xcdmath"T$'_j$ == T$_j$"} for all {$j \ne i$}, 
%%NO-VARIANCE%% then {\xcdmath"C[T$'_1$, $\ldots$, T$'_n$] <: C[T$'_1$, $\ldots$, T$'_n$]"}.
%%NO-VARIANCE%% \Eg, \xcd`class C[T1, +T2, T3]` with {$i=2$}, and \xcd"U2 <: T2", then
%%NO-VARIANCE%% \xcd`C[T1,U2,T3] <: C[T1,T2,T3]`.
%%NO-VARIANCE%% 
%%NO-VARIANCE%% \item 
%%NO-VARIANCE%% {\bf Contravariant Generic Types:} 
%%NO-VARIANCE%% If \xcd`C` is a generic type whose {$i$}th type parameter is contravariant, 
%%NO-VARIANCE%% and \xcdmath"T$'_i$ <: T$_i$"
%%NO-VARIANCE%% and  \xcdmath"T$'_j$ == T$_j$" for all {$j \ne i$}, 
%%NO-VARIANCE%% then \xcdmath"C[T$'_1$, $\ldots$, T$'_n$] :> C[T$'_1$, $\ldots$, T$'_n$]".
%%NO-VARIANCE%% \Eg, \xcd`class C[T1, -T2, T3]` with {$i=2$}, and \xcdmath"U2 <: T2", then
%%NO-VARIANCE%% \xcd`C[T1,U2,T3] :> C[T1,T2,T3]`.
%%NO-VARIANCE%% 

\end{itemize}


Two types are {\em equivalent}, \xcd`T == U`, if \xcd`T <: U` and \xcd`U <: T`. 


\section{Common ancestors of types}
\label{LCA}

There are several situations where X10 must find a type \xcd`T` that describes
values of two or more different types.  This arises when X10 is trying to find
a good type for: 
\begin{itemize}
%~~exp~~`~~`~~test:Boolean ~~ ^^^ Types410
\item Conditional expressions, like \xcd`test ? 0 : "non-zero"` or even \\
%~~exp~~`~~`~~test:Boolean ~~ ^^^ Types420
      \xcd`test ? 0 : 1`;
%~~exp~~`~~`~~ ~~ ^^^ Types430
\item Array construction, like \xcd`[0, "non-zero"]` and 
%~~exp~~`~~`~~ ~~ ^^^ Types440
      \xcd`[0,1]`;
\item Functions with multiple returns, like
%~~gen ^^^ Types450
% package Types_odd_inferred_return_type;
% class Examplerator {
%~~vis
\begin{xten}
def f(a:Int) {
  if (a == 0) return 0;
  else return "non-zero";
}
\end{xten}
%~~siv
%}
%~~neg
\end{itemize}

In some cases, there is a unique best type describing the expression.  For
example, if \xcd`B` and \xcd`C` are direct subclasses of \xcd`A`, \xcd`pick`
will have return type \xcd`A`: 
%~~gen ^^^ Types_uniq
% package Types.For.Gripes.About.Pipes.Full.Of.Wipes;
%  class A {} class B extends A{} class C extends A{}
% class D {
%~~vis
\begin{xten}
static def pick(t:Boolean, b:B, c:C) = t ? b : c;  
\end{xten}
%~~siv
%}
%~~neg

However, in many common cases, there is no unique best type describing the
expression.  For example, consider the expression {$E$} 
\begin{xtenmath}
b ? 0 : 1   // Call this expression $E$
\end{xtenmath}
The
best type of \xcd`0` 
is \xcd`Int{self==0}`, and the best type of 1 is \xcd`Int{self==1}`.
Certainly {$E$} could be given the type \xcd`Int`, or even \xcd`Any`, and that
would describe all possible results.  However, we actually know more.
\xcd`Int{self != 2}` is a better description of the type of {$E$}---certainly
the result of {$E$} can never be \xcd`2`.   \xcd`Int{self != 2, self != 3}` is
an even better description; {$E$} can't be \xcd`3` either.  We can continue
this process forever, adding integers which {$E$} will definitely not return
and getting better and better approximations. (If the constraint
sublanguage had \xcd`||`, we could give it the type 
\xcd`Int{self == 0 || self == 1`, which would be nearly perfect.  But 
\xcd`||` makes typechecking far more expensive, so it is excluded.)
No X10 type is the best description of {$E$}; there is always a better one.

Similarly, consider two unrelated interfaces: 
%~~gen ^^^ Types460
% package Types.For.Gripes.About.Snipes;
%~~vis
\begin{xten}
interface I1 {}
interface I2 {}
class A implements I1, I2 {}
class B implements I1, I2 {}
class C {
  static def example(t:Boolean, a:A, b:B) = t ? a : b;
}
\end{xten}
%~~siv
%
%~~neg
\xcd`I1` and \xcd`I2` are both perfectly good descriptions of \xcd`t ? a : b`, 
but neither one is better than the other, and there is no single X10 type
which is better than both. (Some languages have {\em conjunctive
    types}, and could say that the return type of \xcd`example` was 
\xcd`I1 && I2`.  This, too, complicates typechecking.)


So, when confronted with expressions like this, X10 computes {\em some}
satisfactory type for the expression, but not necessarily the {\em best} type.  
X10 provides certain guarantees about the common type \xcd`V{v}` computed for 
\xcd`T{t}` and \xcd`U{u}`: 
\begin{itemize}
\item If \xcd`T{t} == U{u}`, then \xcd`V{v} == T{t} == U{u}`.  So, if X10's
      algorithm produces an utterly untenable type for \xcd`a ? b : c`, and
      you want the result to have type \xcd`T{t}`, you can 
      (in the worst case) rewrite it to 
\begin{xtenmath}
a ? b as T{t} : c as T{t}
\end{xtenmath}
\item If \xcd`T == U`, then \xcd`V == T == U`.  For example, 
      X10 will compute the type of \xcd`b ? 0 : 1` as 
      \xcd`Int{c}` for some constraint \xcd`c`---perhaps simply 
      picking \xcd`Int{true}`, \viz, \xcd`Int`. 
\item X10 preserves place information about \xcd`GlobalRef`s, because it is so important. If both
      \xcd`t` and \xcd`u` entail \xcd`self.home==p`, then  
      \xcd`v` will also entail \xcd`self.home==p`.  
\item X10 similarly preserves nullity information.  If \xcd`t` and \xcd`u`
      both entail \xcd`x == null` or \xcd`x != null` for some variable
      \xcd`x`, then \xcd`v` will also entail it as well.

\item The computed upper bound of function types with the {\em same} argument
      types is found by computing the upper bound of the result types.  
      If 
      \xcdmath"T = (T$_1$, $\ldots$, T$_n$) => T'"
      and 
      \xcdmath"U = (T$_1$, $\ldots$, T$_n$) => U'", 
      and \xcd`V'` is the computed upper bound of \xcd`T'` and \xcd`U'`, 
      then the computed upper bound of \xcd`T` and \xcd`U` is 
      \xcdmath"U = (T$_1$, $\ldots$, T$_n$) => V'".
      (But, if the argument types are different, the computed upper bound may
      be \xcd`Any`.)

\end{itemize}

%\subsection{Syntactic abbreviations}\label{DepType:SyntaxAbbrev}

\section{Fundamental types}

Certain types are used in fundamental ways by X10.  

\subsection{The interface {\tt Any}}

It is quite convenient to have a type which all values are instances of; that
is, a supertype of all types.\footnote{Java, for one, suffers a number of
  inconveniences because some built-in types like \xcd`int` and \xcd`char`
  aren't subtypes of anything else.}  X10's universal supertype is the
  interface \xcd`Any`. 

\begin{xten}
package x10.lang;
public interface Any {
  def toString():String;
  def typeName():String;
  def equals(Any):Boolean;
  def hashCode():Int;
}
\end{xten}

\xcd`Any` provides a handful of essential methods that make sense and are
useful for everything. \xcd`a.toString()` produces a
string representation of \xcd`a`, and \xcd`a.typeName()` the string
representation of its type; both are useful for debugging.  \xcd`a.equals(b)`
is the programmer-overridable equality test, and \xcd`a.hashCode()` an integer
useful for hashing.  


\subsection{The class {\tt Object}}
\label{Object}
\index{\Xcd{Object}}
\index{\Xcd{x10.lang.Object}}

The class \xcd"x10.lang.Object" is the supertype of all classes.
A variable of this type can hold a reference to any object.
\xcd`Object` implements \xcd`Any`.



\section{Type inference}
\label{TypeInference}
\index{type!inference}
\index{type inference}

\XtenCurrVer{} supports limited local type inference, permitting
certain variable types and return types to be elided.
It is a static error if an omitted type cannot be inferred or
uniquely determined. Type inference does not consider coercions.

\subsection{Variable declarations}

The type of a \xcd`val` variable declaration can be omitted if the
declaration has an initializer.  The inferred type of the
variable is the computed type of the initializer.
For example, 
%~~stmt~~`~~`~~ ~~ ^^^ Types470
\xcd`val seven = 7;`
is identical to 
\begin{xtenmath}
val seven: Int{self==7} = 7;
\end{xtenmath}
Note that type inference gives the most precise X10 type, which might be more
specific than the type that a programmer would write.



\limitation{At the moment,  \xcd`var` declarations may not have their types
elided in this way.  
}

\subsection{Return types}

The return type of a method can be omitted if the method has a body (\ie, is
not \xcd"abstract" or \xcd"native"). The inferred return type is the computed
type of the body.  In the following example, the return type inferred for
\xcd`isTriangle` is 
%~~type~~`~~`~~ ~~ ^^^ Types490
\xcd`Boolean{self==false}`
%~~gen ^^^ Types500
% package Types.Inferred.Return;
%~~vis
\begin{xten}
class Shape {
  def isTriangle() = false; 
}  
\end{xten}
%~~siv
%
%~~neg
Note that, as with other type inference, methods are given the most specific
type.  In many cases, this interferes with subtyping.  For example, if one
tried to write: 
\begin{xten}
class Triangle extends Shape {
  def isTriangle() = true;
}
\end{xten}
\noindent
the compiler would reject this program for attempting to override
\xcd`isTriangle()` by a method with the wrong type, \viz,
\xcd`Boolean{self==true}`.  In this case, supply the type that is actually
intended for \xcd`isTriangle`: 
\begin{xtenmath}
def isTriangle() : Boolean =false;
\end{xtenmath}

The return type of a closure can be omitted.
The inferred return type is the computed type of the body.

The return type of a constructor can be omitted if the
constructor has a body.
The inferred return type is the enclosing class type with
properties bound to the arguments in the constructor's \xcd"property"
statement, if any, or to the unconstrained class type.
For example, the \xcd`Spot` class has two constructors, the first of which has
inferred return type \xcd`Spot{x==0}` and the second of which has 
inferred return type \xcd`Spot{x==xx}`. 
%~~gen ^^^ Types510
% package Types.Inferred.By.Phone;
%~~vis
\begin{xten}
class Spot(x:Int) {
  def this() {property(0);}
  def this(xx: Int) { property(xx); }
}
\end{xten}
%~~siv
%class Confirm{ 
% static val s0 : Spot{x==0} = new Spot();
% static val s1 : Spot{x==1} = new Spot(1);
%}
%~~neg


\index{void}

A method or closure that has expression-free \xcd`return` statements
(\xcd`return;` rather than \xcd`return e;`) is said to return \xcd`void`.
\xcd`void` is not a type; there are no \xcd`void` values, nor can \xcd`void`
be used as the argument of a generic type. However, \xcd`void` takes the
syntactic place of a type in a few contexts. A method returning \xcd`void` can be specified by
\xcd`def m():void`, and similarly for a closure: 

%~~gen ^^^ Types520
% package Types.voidd;
% class voidddd {
% static 
%~~vis
\begin{xten}
def m():void {return;}
val f : () => void = () => {return;};
\end{xten}
%~~siv
%}
%~~neg

By a convenient abuse of language, \xcd`void` is sometimes
lumped in with types; \eg, we may say ``return type of a method'' rather than
the formally correct but rather more awkward ``return type of a method, or
\xcd`void`''.   Despite this informal usage, \xcd`void` is not a type.  For
example, given 
%~~gen ^^^ Types530
% package Types.void_is_not_a_type;
% class EEEEVil {
%~~vis
\begin{xten}
  static def eval[T] (f:()=>T):T = f();
\end{xten}
%~~siv
% }
%~~neg
\noindent
The call \xcd`eval[void](f)` does {\em not} typecheck; \xcd`void` is not a
type and thus cannot be used as a type argument.  There is no way in X10 to
write a generic function which works with both functions which return a value
and functions which do not.  In most cases, functions which have no sensible
return value can be provided with a dummy return value.

\subsection{Inferring Type Arguments}
\label{TypeParamInfer}


A call to a polymorphic method %, closure, or constructor 
may omit the
explicit type arguments.  
X10 will compute a type from the types of the actual arguments. 

(As an exception of sorts, it is an error if the method call provides no information about
a type parameter that must be inferred.  For example, given the method
definition \xcd`def m[T](){...}`, an invocation \xcd`m()` is considered a
static error.  The compiler has no idea what \xcd`T` the programmer intends.)



\begin{ex}Consider the following method, which chooses one of its arguments.  (A more
sophisticated one might sometimes choose the second argument, but that does
not matter for the sake of this example.)
\begin{xten}
static def choose[T](a: T, b: T): T = a; 
\end{xten}


The type argument \xcd`T` can always be supplied: 
\xcd`choose[Int](1, 2)` picks an integer, 
and \xcd`choose[Any](1, "yes")` picks a value that might be an integer or a
string.  
However, the type argument can be elided.  Suppose that \xcd`Sub <: Super`;
then the following compiles: 

%~~gen ^^^ Types540
% package Types.GenericInference;
% class Exampllll{ 
%~~vis
\begin{xten}
  static def choose[T](a: T, b: T): T = a; 
  static val j : Any = choose("string", 1);
  static val k : Super = choose(new Sub(), new Super());
\end{xten}
%~~siv
%}
% class Super {}
% class Sub extends Super {}
%~~neg
\end{ex}

The type parameter doesn't need to be the type of a variable. It can be found
inside of the type of a variable; X10 can extract it.

\begin{ex}
The \xcd`first` method below returns the first element of a one-dimensional
array.  The type parameter \xcd`T` represents the type of the array's
elements. There is no parameter of type \xcd`T`. There is one of type
\xcd`Array[T]{c}`.  When doing type inference, 
X10 strips off the constraint \xcd`{c}` and the
\xcd`Array[...]` type to get at the \xcd`T` inside.
%~~gen ^^^ Types3d5j
% package Types3d5j;
% class Example {
%~~vis
\begin{xten}
static def first[T](x:Array[T](1)) = x(0);
static def example() {
  val ss <: Array[String] = ["X10", "Scala", "Thorn"];
  val s1 = first(ss);
  assert s1.equals("X10");
}
\end{xten}
%~~siv
%}
% class Hook{ def run() {Example.example(); return true;}}
%~~neg

\end{ex}


\subsubsection{Sketch of X10 Type Inference for Method Calls}

When the X10 compiler sees a method call 
\begin{xtenmath}
a.m(b$_1$, $\ldots$,b$_n$)
\end{xtenmath}
and attempts to infer type parameters to
see if it could be a use of a
method 
\begin{xtenmath}
def m[X$_1$, $\ldots$, X$_t$](y$_1$: S$_1$, $\ldots$, y$_n$:S$_n$),
\end{xtenmath}
it reasons as follows. 



% Suppose that \xcdmath"b$_i$" has type \xcdmath"T$_i$".  
Let 
\begin{xtenmath}
T$_i \mbox{\rm ~be the type of }$ b$_i$
\end{xtenmath}
Then, X10 is seeking a
set {$B$}  of type 
bindings 
\begin{xtenmath}
$B = \{$ X$_1$ = U$_1, \ldots, $ X$_t$=U$_t\}$
\end{xtenmath}
such that 
\xcdmath"T$_i$ <: S$^*_i$" for {$1 \le i \le n$}, where \xcdmath"S$^*$" is
\xcd`S` with each type variable \xcdmath"X$_j$" replaced by the corresponding
\xcdmath"U$_j$".  If it can find such a {$B$}, it has a usable choice of type
arguments and can do the type inference.  If it cannot find {$B$}, then it
cannot do type inference.    (Note that X10's type inference algorithm is
incomplete -- there may {\em be} such a {$B$} that X10 cannot find.  If this
occurs in your program, you will have to write down the type arguments
explicitly.) 

Let $B_0$ be the set {$\{ T_i \subtype S_i | 1 \le i \le n\}$}.  Let
{$B_{n+1}$} be {$B_n$} with one element {$F \subtype G$} or 
{$F = G$} removed, and
{$\mbox{\it Strip}(F \subtype G)$} 
or {$\mbox{\it Strip}(F = G)$}, where     {\em Strip} is defined below, added.  Repeat this until 
{$B_n$} consists entirely of comparisons with type variables (\viz, 
\xcdmath"Y$_j$ = U", 
\xcdmath"Y$_j$ <: U", and
\xcdmath"Y$_j$ :> U"), 
or until some {$n$} exceeds a predefined compiler limit. 

The candidate inferred types may be read off of {$B_n$}.  The guessed binding
for \xcdmath"X$_j$" is: 
\begin{itemize}
\item If there is an equality \xcdmath"X$_j$=W" in {$B_n$}, then guess the
      binding \xcdmath"X$_j$=W".  Note that there may be several such
      equalities with different choices of \xcd`W`; pick any one.  If the
      chosen binding does not equal the others, the candidate binding will be
      rejected later and type inference will fail. 
\item Otherwise, if there is one or more upper bounds 
\xcdmath"X$_j$ <: V$_k$" in {$B_n$}, guess the binding 
\xcdmath"X$_j$ = V$_+$", where 
\xcdmath"V$_+$" is the computed lower bound of all the \xcdmath"V$_k$"'s.
\item Otherwise, if there is one or more lower bounds 
\xcdmath"R$_k$ <: X$_j$", guess that
\xcdmath"X$_j$ = R$_+$", where 
\xcdmath"R$_+$" is the computed upper bound of all the \xcdmath"R$_k$"'s.
\end{itemize}
If this does not yield a binding for some variable \xcdmath"X$_j$", then type
inference fails.  Furthermore, if every variable \xcdmath"X$_j$" is given a
binding \xcdmath"U$_j$", but the 
bindings do not work --- 
that is, if 
\xcdmath"a.m[U$_1$, $\ldots$, U$_t$](b$_1$, $\ldots$,b$_n$)"
is not a well-typed call of 
the original method 
\xcdmath"def m[X$_1$, $\ldots$, X$_t$](y$_1$: S$_1$, $\ldots$, y$_n$:S$_n$)"
--- then type inference also fails.

\paragraph{Computation of the Replacement Elements}

Given a type relation
{$r$} of the form {$F \subtype G$}
or {$F = G$}, we compute the set {$\mbox{\it Strip}(r)$} of
replacement constraints.  There are a number of cases; we present only the
interesting ones. 

\begin{itemize}
\item If $F$ has the form \xcdmath"$F'${c}", then  
\xcdmath"$\mbox{\it Strip}(r)$" is defined to be
 \xcdmath"$F'$ = $G$" if $r$ is an equality, or 
 \xcdmath"$F'$ <: $G$" if {$r$} is a subtyping.
That is, we erase type constraints.  
Validity is not an issue at this point in the algorithm, as 
we check at the end that the result is valid.
Note that, if the equation had the form \xcdmath"Z{c} = A", it could be
solved by either \xcd`Z=A` or by \xcd`Z = A{c}`.  By dropping constraints in this
rule, we choose the former solution, which tends to give more general types in
results. 

\item Similarly, we drop constraints on {$G$} as well.

\item If {$F$} has the form \xcdmath"K[F$_1$, $\ldots$, F$_k$]"
and 
{$G$}
has the form \xcdmath"K[G$_1$, $\ldots$, G$_k$]", 
then {$\mbox{\it Strip}(r)$} has one type relation comparing each parameter of 
{$F$} with the corresponding one of {$G$}: 
\[\mbox{\it Strip}(r) = \{ F_l = G_l | 1 \le l \le k \} \]

For example, the constraint \xcdmath"List[X] = List[Y]" induces the
constraint \xcd`X=Y`.  
\xcd`List[X] <: List[Y]` also induces the same constraint.  The only way that
\xcd`List[X]` could be a subtype of \xcd`List[Y]` in X10 is if \xcd`X=Y`.
List of different types are incomparable.\footnote{The situation would be more
complex if X10 had covariant and contravariant types.}

\item Other cases are fairly routine.  \Eg, if {$F$} is a \xcd`type`-defined
      abbreviation, it is expanded.

\end{itemize}

\begin{ex}
Consider the program: 
%~~gen ^^^ Types1s4y
% package Types1s4y;
%~~vis
\begin{xten}
import x10.util.*;
class Cl[C1, C2, C3]{}
class Example {
  static def me[X1, X2](Cl[Int, X1, X2]) = 
     new Cl[X1, X2, Point]();
  static def example() {
    val a = new Cl[Int, Boolean, String]();
    val b : Cl[Boolean, String, Point] 
          = me[Boolean, String](a);
    val c : Cl[Boolean, String, Point] 
          = me(a);
  }
}
\end{xten}
%~~siv
%
%~~neg
The method call for \xcd`b` has explicit type parameters.  
The call for \xcd`c` infers the parameters.  The computation 
starts with one equation, saying that the formal parameter of 
\xcd`me` has to be able to accept the actual parameter \xcd`a`:
\begin{xtenmath}
 Cl[Int, Boolean, String] <: Cl[Int, X1, X2] 
\end{xtenmath}
Note that both terms are \xcd`Cl` of three things. 
This is broken into three equations: 
\begin{xtenmath}
Int = Int
\end{xtenmath}
which is easy to satisfy,
\begin{xtenmath}
X1 = Boolean
\end{xtenmath}
which suggests a possible value for \xcd`X1`,  and 
\begin{xtenmath}
X2 = String
\end{xtenmath}
which suggests a value for \xcd`X2`.  
All of these equations are simple enough, so the algorithm terminates. 

Then, X10 confirms that the binding \xcd`X1=Boolean`, \xcd`X2=String`
actually generates a correct call, which it does.  
\end{ex}


\begin{ex}
When there is no way to infer types correctly, the type inference algorithm
will fail.   Consider the program: 
\begin{xten}
public class Failsome {
  static def fail[X](a:Array[X], b:Array[X]):void {}
  public static def main(argv:Array[String](1)) {
    val aint  : Array[Int]     = [1,2,3];
    val abool : Array[Boolean] = [true, false];
    fail(aint, abool);    // THIS IS WRONG
  }
}
\end{xten}
The type inference computation starts, as always, by insisting that the types
of the formals to \xcd`fail` are capable of accepting the actuals: 
\begin{xtenmath}
$B_0=\{$Array[Int] <: Array[X]$,$ Array[Boolean] <: Array[X]$\}$
\end{xtenmath}
Arbitrarily picking the first relation to {\it Strip} first, we get:
\begin{xtenmath}
$B_1=\{$Int = X$,$ Array[Boolean] <: Array[X] $\}$
\end{xtenmath}
and then 
\begin{xtenmath}
$B_2=\{$Int = X$,$ Boolean = X $\}$
\end{xtenmath}
(At this point it is clear to a human that $B$ is inconsistent, but the
algorithm's check comes a bit later.)
{$B_2$} consists entirely of comparisons with type variables, so the loop is
over.  Arbitrarily picking the first equality, it guesses the binding 
\begin{xtenmath}
$B=\{$X = Int$\}$.
\end{xtenmath}
In the validation step, it checks that 
\begin{xtenmath}
fail[Int](aint, abool)
\end{xtenmath}
is a well-typed call to \xcd`fail`.  Of course it is not; \xcd`abool` would
have to be a value of type \xcd`Array[Int]`, which it is not.  So type
inference fails at this point.  In this case it is correct: there is no way to
give a proper type to this program.\footnote{
In particular, \xcd`X=Any` doesn't work either.  An \xcd`Array[Int]` is not an
\xcd`Array[Any]` --- and it must not be, for you can put a boolean value into
an \xcd`Array[Any]`, but you cannot put a boolean value into an
\xcd`Array[Int]`.  However, if the types of the arguments had simply been 
\xcd`X` rather than \xcd`Array[X]`, then type inference would correctly infer
\xcd`X=Any`.
}
\end{ex}

\section{Type Dependencies}

Type definitions may not be circular, in the sense that no type may be its own
supertype, nor may it be a container for a supertype. This forbids interfaces
like \xcd`interface Loop extends Loop`, and indirect self-references such as
\xcd`interface A extends B.C` where \xcd`interface B extends A`.  
The formal definition of this is based on Java's.  

An {\em entity type} is a class, interface, or struct type.   

Entity type $E$ {\em directly depends on} entity type $F$ if $F$ is mentioned
in the \xcd`extends` or \xcd`implements` clause of $E$, either by itself or as
a qualifier within a super-entity-type name.  

\begin{ex}
In the following, \xcd`A` directly depends on \xcd`B`, \xcd`C`, \xcd`D`, 
\xcd`E`, and \xcd`F`.    It does not directly depend on \xcd`G`.
%~~gen ^^^ Types6a9m
% package Types6a9m;
% // NOzzTEST
% class B{ static class C{}}
% class D{ static interface E{}}
% interface F[X]{}
% class G{}
%~~vis
\begin{xten}
class A extends B.C implements D.E, F[G] {}
\end{xten}
%~~siv
%
%~~neg

It is an ordinary programming idiom to use \xcd`A` as an argument to a generic
interface that \xcd`A` implements.  For example, \xcd`ComparableTo[T]`
describes things which can be compared to a value of type \xcd`T`. Saying that
\xcd`A` implements \xcd`ComparableTo[A]` means that one \xcd`A` can be
compared to another, which is reasonable and useful: 
%~~gen ^^^ Types2x6d
% package Types2x6d;
%~~vis
\begin{xten}
interface ComparableTo[T] {
  def eq(T):Boolean;
}
class A implements ComparableTo[A] {
  public def eq(other:A) = this.equals(other);
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}

Entity type $E$ {\em depends on} entity type $F$ if
either $E$ directly depends on $F$, or $E$ directly depends on an entity type
that depends on $F$.   That is, the relation ``depends on'' is the transitive
closure of the relation ``directly depends on''.  

It is a static error if any entity type $E$ depends on itself.

\section{Typing of Variables and Expressions}


Variable declarations, field declarations, and some other expressions
introduce constraints on their types.  These extra constraints represent
information that is known at the point of declaration.  They are used in
deductions and type inference later on -- as indeed all constraints are, but
the automatically-added constraints are added because they are particularly
useful.  

Any variable declaration of the form 
\begin{xtenmath}
val x : A ...
\end{xtenmath}
results in declaring \xcd`x` to have the type \xcd`A{self==x}`, rather than
simply \xcd`A`.  (\xcd`var` declarations get no such addition, because
\xcd`var`s cannot appear in constraints.)

A field or property declaration of the form: 
\begin{xtenmath}
class A {
   ... 
   val f : B ...
   ...
}
\end{xtenmath}
results in declaring \xcd`f` to be of type \xcd`B{self==this.f}`.
And, if \xcd`y` has type \xcd`A{c}`, then the type 
for \xcd`y.f` has a constraint \xcd`self==y.f`, and, additionally, 
preserves the information from \xcd`c`.  


\begin{ex}

The following code uses a method \xcd`typeIs[T](x)` to confirm, statically,
that the type of \xcd`x` is \xcd`T` (or a subtype of \xcd`T`).  

On line \xcd`(A)` we confirm that the type of \xcd`x` has 
a \xcd`self==x` constraint.  The error line \xcd`(!A)` confirms
that a {\em different} variable {\em doesn't} have the \xcd`self==x`
constraint. \xcd`(B)` shows the extra information carried by a field's type.

\xcd`(C)` shows the extra information carried by a field's type when the
object's type is constrained. Note that the constraint
\xcd`ExtraConstraint{self.n==8}` on the type of \xcd`y` has to be rewritten
for \xcd`y.f`, since the constraint \xcd`Long{self.n==8}` is not correct or
even well-typed. In this case, the \xcd`ExtraConstraint` whose \xcd`n`-field
is \xcd`8` has the name \xcd`y`, so we can write the desired type with a
conjunct \xcd`y.n==8`.\footnote{If \xcd`y` were an expression rather than a
variable, there would be no good way to express its type in X10's type system. 
(The compiler has a more elaborate internal representation of types, not all
of which are expressible in X10 version 2.2.)}

Note that we use one of the extra constraints here -- this reasoning requires
the information that the type of \xcd`y` has the constraint \xcd`self==y`, so
X10 can infer \xcd`y.n==8` from \xcd`self.n==8`. This sort of inference is the
reason why X10 adds these constraints in the first place: without them, even
the simplest data flows would be beyond the ability of the type system to detect.

%~~gen ^^^ Types6m9z
% package Types6m9z;
%~~vis
\begin{xten}
class Extra(n:Int) {
  val f : Long;
  def this(n:Int, f:Long) { property(n); this.f = f; }
  static def typeIs[T](val x:T) {}
  public static def main(argv:Array[String](1)) {
     val x : Extra = new Extra(1,2L);
     typeIs[ Extra{self==x} ]   (x);    //(A)
     val nx: Extra = new Extra(1,2L);
     // ERROR: typeIs[ Extra{self==x} ]   (nx); //(!A)
     typeIs[ Long{self == x.f} ]          (x.f);  //(B)
     val y : Extra{self.n==8} = new Extra(8, 4L);
     typeIs[ Long{self == y.f, y.n == 8}] (y.f);  //(C)
  }
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}

Once in a while, the additional information will interfere with other
typechecking or type inference.  In this case, use \xcd`as`
(\Sref{XtenConversions}) to erase it, using expressions like \xcd`x as A`.

\begin{ex}
The following code creates a one-element array (\Sref{sect:ArrayCtors})
containing \xcd`x`.  

If  the \xcd`ERROR` line were to be used, 
X10 would infer that the type of this array were \xcd`Array[T]`,
where \xcd`T` is the type of \xcd`x` --- that is, 
\xcd`Array[Extra{self==x}]`.  \xcd`[x]` is an array of \xcd`x`'s, not an array
of \xcd`Extra`s.  Since \xcd`Array[Extra{self==x}]` is not a subtype of 
\xcd`Array[Extra]`, the array \xcd`[x]` cannot be used in a place where an 
\xcd`Array[Extra]` is called for.

The expression \xcd`[x as Extra]` uses a type cast to erase the
automatically-added extra information about \xcd`x`.  \xcd`x as Extra` simply
has type \xcd`Extra`, and thus \xcd`[x as Extra]` is an \xcd`Array[Extra]` as
desired. 


%~~gen ^^^ Types1l5a
% package Types1l5a;
%~~vis
\begin{xten}
class Extra {
  static def useArray(Array[Extra]) {} 
  public static def main(argv:Array[String](1)) {
     val x : Extra = new Extra();
     //ERROR: useArray([x]);
     useArray([x as Extra]);
  }
}
\end{xten}
%~~siv
%
%~~neg


\end{ex}

\section{Limitations of Strict Typing}

X10's type checking provides substantial guarantees.  In most cases, a program
that passes the X10 type checker will not have any runtime type errors.
However, there are a modest number of compromises with practicality in the
type system: places where a program can pass the typechecker and still have a
type error.

\begin{enumerate}

\item As seen in \Sref{sect:StrippedGenericCasts}, generic types do not have
      constraint information at runtime.  This allows one to write code which
      violates constraints at runtime, as seen in the example in that section. 


\item The library type \xcd`x10.util.IndexedMemoryChunk` provides a low-level interface
      to blocks of memory.  A few methods on that class are not type-safe. See
      the API if you must.

\item Custom serialization (\Sref{sect:ser+deser}) allows user code to
      construct new objects in ways that can subvert the type system.

\item Code written to use the underlying Java or C++ (\Sref{NativeCode}) can
      break X10's guarantees.

\end{enumerate}

