%%NO-VARIANCE%% %%\subsection{Variance of Type Parameters}
%%NO-VARIANCE%% %%\index{covariant}
%%NO-VARIANCE%% %%\index{contravariant}
%%NO-VARIANCE%% %%\index{invariant}
%%NO-VARIANCE%% %%\index{type parameter!covariant}
%%NO-VARIANCE%% %%\index{type parameter!contravariant}
%%NO-VARIANCE%% %%\index{type parameter!invariant}
%%NO-VARIANCE%% 
%%NO-VARIANCE%% %TODO - examples courtesy of Nate
%%NO-VARIANCE%% % 
%%NO-VARIANCE%% % class OutputStream[-A] {
%%NO-VARIANCE%% %    def write(a: A) = /* implementation left as an exercise for the reader */
%%NO-VARIANCE%% % }
%%NO-VARIANCE%% % 
%%NO-VARIANCE%% % Also:
%%NO-VARIANCE%% % 
%%NO-VARIANCE%% % interface Comparator[-A] {
%%NO-VARIANCE%% %    def compare(A): Int;
%%NO-VARIANCE%% % }
%%NO-VARIANCE%% % 
%%NO-VARIANCE%% % and:
%%NO-VARIANCE%% % 
%%NO-VARIANCE%% % class HashMap[-K,+V] { ... }
%%NO-VARIANCE%% % 
%%NO-VARIANCE%% % 
%%NO-VARIANCE%% 
%%NO-VARIANCE%% Type parameters of classes (though not of methods) can be {\em variant}.
%%NO-VARIANCE%% 
%%NO-VARIANCE%% Consider classes \xcd`Person :> Child`.  Every child is a person, but there
%%NO-VARIANCE%% are people who are not children.  What is the relationship between
%%NO-VARIANCE%% \xcd`Cell[Person]` and \xcd`Cell[Child]`?  
%%NO-VARIANCE%% 
%%NO-VARIANCE%% \subsubsection{Why Variance Is Necessary}
%%NO-VARIANCE%% 
%%NO-VARIANCE%% In this case, \xcd`Cell[Person]` and \xcd`Cell[Child]` should be unrelated.  
%%NO-VARIANCE%% If we had \xcd`Cell[Person] :> Cell[Child]`, the following code would let us
%%NO-VARIANCE%% assign a \xcd`old` (a \xcd`Person` but not a \xcd`Child`) to a
%%NO-VARIANCE%% variable \xcd`young` of type \xcd`Child`, thereby breaking the type system: 
%%NO-VARIANCE%% \begin{xten}
%%NO-VARIANCE%% // INCORRECTLY assuming Cell[Person] :> Cell[Child]
%%NO-VARIANCE%% val cc : Cell[Child] = new Cell[Child]();
%%NO-VARIANCE%% val cp : Cell[Person] = cc; // legal upcast
%%NO-VARIANCE%% cp.set(old);       // legal since old : Person
%%NO-VARIANCE%% val young : Child = cc.get(); 
%%NO-VARIANCE%% \end{xten}
%%NO-VARIANCE%% 
%%NO-VARIANCE%% Similarly, if \xcd`Cell[Person] <: Cell[Child]`: 
%%NO-VARIANCE%% \begin{xten}
%%NO-VARIANCE%% // INCORRECTLY assuming Cell[Person] <: Cell[Child]
%%NO-VARIANCE%% val cp : Cell[Person] = new Cell[Person];
%%NO-VARIANCE%% val cc : Cell[Child] = cp; // legal upcast
%%NO-VARIANCE%% val cp.set(old); 
%%NO-VARIANCE%% val young : Child = cc.get();
%%NO-VARIANCE%% \end{xten}
%%NO-VARIANCE%% 
%%NO-VARIANCE%% So, there cannot be a subtyping relationship in either direction between the
%%NO-VARIANCE%% two. And indeed, neither of these programs passes the X10 typechecker.
%%NO-VARIANCE%% 
%%NO-VARIANCE%% 
%%NO-VARIANCE%% \subsubsection{Legitimate Variance}
%%NO-VARIANCE%% 
%%NO-VARIANCE%% The \xcd`Cell[Person]`-vs-\xcd`Cell[Child]` problems occur because it is
%%NO-VARIANCE%% possible to both store and retrieve values from the same object. However,
%%NO-VARIANCE%% entities with only one of the two capabilities {\em can} sensibly have some
%%NO-VARIANCE%% subtyping relations. Furthermore, both sorts of entity are useful. An entity
%%NO-VARIANCE%% which can store values but not retrieve them can nonetheless summarize them.
%%NO-VARIANCE%% An object which can retrieve values but not store values can be constructed
%%NO-VARIANCE%% with an initial value, providing a read-only cell.
%%NO-VARIANCE%% 
%%NO-VARIANCE%% So, X10 provides {\em variance} to support these options.  Type parameters
%%NO-VARIANCE%% may be defined in one of three forms.  
%%NO-VARIANCE%% \begin{enumerate}
%%NO-VARIANCE%% \item {\em invariant}: Given a definition \xcd`class C[T]{...}`, \xcd`C[Person]` and
%%NO-VARIANCE%%       \xcd`C[Child]` are unrelated classes; neither is a subclass of the
%%NO-VARIANCE%%       other.
%%NO-VARIANCE%% \item {\em covariant}: Given a definition \xcd`class C[+T]{...}` (the \xcd`+` indicates
%%NO-VARIANCE%%       covariance), \xcd`C[Person] :> C[Child]`.  This is appropriate when
%%NO-VARIANCE%%       \xcd`C` allows retrieving values but not setting them.
%%NO-VARIANCE%% \item {\em contravariant}: Given a definition \xcd`class C[-T]{...}` (the \xcd`-` indicates
%%NO-VARIANCE%%       contravariance), \xcd`C[Person] <: C[Child]`.  This is appropriate when
%%NO-VARIANCE%%       \xcd`C` allows storing values but not retrieving them.
%%NO-VARIANCE%% \end{enumerate}
%%NO-VARIANCE%% 
%%NO-VARIANCE%% 
%%NO-VARIANCE%% The \xcd"T" parameter of \xcd"Cell" above is
%%NO-VARIANCE%% invariant.  
%%NO-VARIANCE%% 
%%NO-VARIANCE%% A typical example of covariance is \xcd`Get`.  As the \xcd`example()` method
%%NO-VARIANCE%% shows, a \xcd`Get[T]` must be constructed with its value, and will return that
%%NO-VARIANCE%% value whenever desired.  \xcd`Get[T]` is only moderately useful as a class; it
%%NO-VARIANCE%% is more useful as an interface for providing a limited (read) access to a more
%%NO-VARIANCE%% powerful data structure.
%%NO-VARIANCE%% %~~gen ^^^ Variance10
%%NO-VARIANCE%% % package Variance_gone;
%%NO-VARIANCE%% %~~vis
%%NO-VARIANCE%% \begin{xten}
%%NO-VARIANCE%% class Get[+T] {
%%NO-VARIANCE%%   val x: T;
%%NO-VARIANCE%%   def this(x: T) { this.x = x; }
%%NO-VARIANCE%%   def get(): T = x;
%%NO-VARIANCE%%   static def example() {
%%NO-VARIANCE%%      val g : Get[Int] = new Get[Int](31);
%%NO-VARIANCE%%      val n : Int = g.get();
%%NO-VARIANCE%%      x10.io.Console.OUT.print("It's " + n);
%%NO-VARIANCE%%      x10.io.Console.OUT.print("It's still " + g.get());
%%NO-VARIANCE%%   }
%%NO-VARIANCE%% }
%%NO-VARIANCE%% \end{xten}
%%NO-VARIANCE%% %~~siv
%%NO-VARIANCE%% %~~neg
%%NO-VARIANCE%% 
%%NO-VARIANCE%% There are few if any {\em classes} with contravariant type parameters.
%%NO-VARIANCE%% (Covariant type parameters are only moderately more common.)  
%%NO-VARIANCE%% However, it is frequently useful to have {\em interfaces} with contravariant
%%NO-VARIANCE%% type parameters.  For example: 
%%NO-VARIANCE%% %~~gen ^^^ Variance20
%%NO-VARIANCE%% % package Types_contravariance_a;
%%NO-VARIANCE%% %~~vis
%%NO-VARIANCE%% \begin{xten}
%%NO-VARIANCE%% interface OutputStream[-T] {
%%NO-VARIANCE%%    def write(T) : void;
%%NO-VARIANCE%% }
%%NO-VARIANCE%% interface ComparableTo[-T] {
%%NO-VARIANCE%%    def compare(T) : Int;
%%NO-VARIANCE%% }
%%NO-VARIANCE%% \end{xten}
%%NO-VARIANCE%% %~~siv
%%NO-VARIANCE%% %
%%NO-VARIANCE%% %~~neg
%%NO-VARIANCE%% Clearly, \xcd`Int <: Any`. 
%%NO-VARIANCE%% An \xcd`OutputStream[Int]` is only capable of writing \xcd`Int`s.  
%%NO-VARIANCE%% An \xcd`OutputStream[Any]` is capable of writing anything.  In particular, it
%%NO-VARIANCE%% can write \xcd`Int`s. Thus, an \xcd`OutputStream[Any]` can be used in place of
%%NO-VARIANCE%% an \xcd`OutputStream[Int]`, and hence \xcd`OutputStream[Any] <: OutputStream[Int]`.
%%NO-VARIANCE%% Similarly, a \xcd`ComparableTo[Int]` can be compared to an integer. A
%%NO-VARIANCE%% \xcd`ComparableTo[Any]` can be compared to anything, and, in particular, to an
%%NO-VARIANCE%% integer.  Thus \xcd`ComparableTo[Any] <: ComparableTo[Int]`.
%%NO-VARIANCE%% So, both of these interfaces are contravariant.
%%NO-VARIANCE%% 
%%NO-VARIANCE%% 
%%NO-VARIANCE%% Given types \xcd"S" and \xcd"T": 
%%NO-VARIANCE%% \begin{itemize}
%%NO-VARIANCE%% \item
%%NO-VARIANCE%% If the parameter of \xcd"Get" is covariant, then
%%NO-VARIANCE%% \xcd"Get[S]" is a subtype of \xcd"Get[T]" if
%%NO-VARIANCE%% \xcd"S" is a {\em subtype} of \xcd"T".
%%NO-VARIANCE%% 
%%NO-VARIANCE%% \item
%%NO-VARIANCE%% If the parameter of \xcd"Set" is contravariant, then
%%NO-VARIANCE%% \xcd"OutputStream[S]" is a subtype of \xcd"OutputStream[T]" if
%%NO-VARIANCE%% \xcd"S" is a {\em supertype} of \xcd"T".
%%NO-VARIANCE%% 
%%NO-VARIANCE%% \item
%%NO-VARIANCE%% If the parameter of \xcd"Cell" is invariant, then
%%NO-VARIANCE%% \xcd"Cell[S]" is a subtype of \xcd"Cell[T]" if
%%NO-VARIANCE%% \xcd"S" is a {\em equal} to \xcd"T".
%%NO-VARIANCE%% \end{itemize}
%%NO-VARIANCE%% 
%%NO-VARIANCE%% 
%%NO-VARIANCE%% In order to make types marked as covariant and contravariant semantically
%%NO-VARIANCE%% sound, X10 performs extra checks.  
%%NO-VARIANCE%% A covariant type parameter is permitted to appear only in covariant type positions,
%%NO-VARIANCE%% and a contravariant type parameter in contravariant positions. 
%%NO-VARIANCE%% \begin{itemize}
%%NO-VARIANCE%% \item The return type of a method is a covariant position.
%%NO-VARIANCE%% \item The argument types of a method are contravariant positions.
%%NO-VARIANCE%% \item Whether a type argument position of a generic class, interface or struct type \Xcd{C}
%%NO-VARIANCE%% is covariant or contravariant is determined by the \Xcd{+} or \Xcd{-} annotation
%%NO-VARIANCE%% at that position in the declaration of \Xcd{C}.
%%NO-VARIANCE%% \end{itemize}
%%NO-VARIANCE%% 
%%NO-VARIANCE%% 
%%NO-VARIANCE%% There are similar restrictions on use of covariant and contravariant variables.
%%NO-VARIANCE%% 
%%NO-VARIANCE%% \limitationx{} Full checking of covariance and contravariance is not yet
%%NO-VARIANCE%% implemented.  Covariant and contravariant classes and structs should be used
%%NO-VARIANCE%% with great caution.
%%NO-VARIANCE%% 
%%NO-VARIANCE%% %TODO: Yoav says ``There are other rules, not implemented or specified,
%%NO-VARIANCE%% %involving fields, inheritance, etc.  There are several JIRAs on it. No idea
%%NO-VARIANCE%% %what is the work around -- maybe just say ``limitation''?'''
]
