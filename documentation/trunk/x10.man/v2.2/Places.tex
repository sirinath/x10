
\chapter{Places}
\label{XtenPlaces}
\index{place}

An \Xten{} place is a repository for data and activities, corresponding
loosely to a process or a processor. Places induce a concept of ``local''. The
activities running in a place may access data items located at that place with
the efficiency of on-chip access. Accesses to remote places may take orders of
magnitude longer. X10's system of places is designed to make this obvious.
Programmers are aware of the places of their data, and know when they are
incurring communication costs, but the actual operation to do so is easy. It's
not hard to use non-local data; it's simply hard to to do so accidentally.

The set of places available to a computation is determined at the time that
the program is started, and remains fixed through the run of the program. See
the {\tt README} documentation on how to set command line and configuration
options to set the number of places.

Places are first-class values in X10, as instances 
\xcd"x10.lang.Place".   \xcd`Place` provides a number of useful ways to
query places, such as \xcd`Place.places`, which is a  \xcd`Sequence[Place]` of 
the places
available to the current run of the program.

Objects and structs (with one exception) are created in a single place -- the
place that the constructor call was running in. They cannot change places.
They can be {\em copied} to other places, and the special library struct
\Xcd{GlobalRef} allows values at one place to point to values at another.  

\section{The Structure of Places}
\index{place!MAX\_PLACES}
\index{place!FIRST\_PLACES}
\index{MAX\_PLACES}
\index{FIRST\_PLACE}

%~~exp~~`~~`~~ ~~ ^^^ Places10
Places are numbered 0 through \xcd`Place.MAX_PLACES-1`; the number is stored
in the field 
\xcd`pl.id`.  The \xcd`Sequence[Place]` \xcd`Place.places()` contains the places of the
program, in numeric order. 
The program starts by executing a \xcd`main` method at
%~~exp~~`~~`~~ ~~ ^^^ Places20
\xcd`Place.FIRST_PLACE`, which is 
%~~exp~~`~~`~~ ~~ ^^^ Placesoik
\xcd`Place.places()(0)`; see
\Sref{initial-computation}. 

Operations on places include \xcd`pl.next()`, which gives the next entry
(looping around) in \xcd`Place.places` and its opposite \xcd`pl.prev()`. 
In multi-place executions, 
\xcd`here.next()` is a convenient way to express ``a place other than \xcd`here`''.
%~~exp~~`~~`~~pl:Place~~ ^^^ Placesoif
There are also a number of tests, like \xcd`pl.isSPE()` and 
%~~exp~~`~~`~~pl:Place ~~ ^^^ Placesoid
\xcd`pl.isCUDA()`, which test for particular kinds of processors.




\section{{\tt here}}\index{here}\label{Here}

The variable \xcd"here" is always bound to the place at which the current
computation is running, in the same way that \xcd`this` is always bound to the
instance of the current class (for non-static code), or \xcd`self` is bound to
the instance of the type currently being constrained.  
\xcd`here` may denote different places in the same method body or even the
same expression, due to
place-shifting operations.


This is not unusual for automatic variables:  \Xcd{self} denotes 
two different values (one \xcd`List`, one \xcd`Int`) 
when one describes a non-null list of non-zero numbers as
\xcd`List[Int{self!=0}]{self!=null}`. In the following 
code, \xcd`here` has one value at 
\xcd`h0`, and a different one at \xcd`h1` (unless there is only one place).
%~~gen ^^^ Placesoijo
% package places.are.For.Graces;
% class Example {
% def example() {
%~~vis
\begin{xten}
val h0 = here;
at (here.next()) {
  val h1 = here; 
  assert (h0 != h1);
}
\end{xten}
%~~siv
%} } 
% 
%~~neg
\noindent
(Similar examples show that \xcd`self` and \xcd`this` have the same behavior:
\xcd`self` can be shadowed by constrained types appearing inside of type
constraints, and \xcd`this` by inner classes.)



The following example looks through a list of references to \Xcd{Thing}s.  
It finds those references to things that are \Xcd{here}, and deals with them.  
%~~gen ^^^ Places70
%package Places.Are.For.Graces.2;
%import x10.util.*;
%abstract class Thing {}
%class DoMine {
%  static def dealWith(Thing) {}	
%~~vis
\begin{xten}
  public static def deal(things: List[GlobalRef[Thing]]) {
     for(gr in things) {
        if (gr.home == here) {
           val grHere = 
               gr as GlobalRef[Thing]{gr.home == here};
           val thing <: Thing = grHere();
           dealWith(thing);
        }
     }
  }
\end{xten}
%~~siv
%}
% 
%~~neg

\section{ {\tt at}: Place Changing}\label{AtStatement}
\index{at}
\index{place!changing}

An activity may change place synchronously using the \xcd"at" statement or
\xcd"at" expression. Like any parallel operation, it is 
potentially expensive, as it requires, at a minimum, two messages
and the copying of all data used in the operation, and must be used with care
-- but it provides the basis for multicore programming in X10.

%##(AtStatement AtExp
\begin{bbgrammar}
%(FROM #(prod:AtStatement)#)
         AtStatement \: \xcd"at" PlaceExpSingleList Statement & (\ref{prod:AtStatement}) \\
%(FROM #(prod:AtExp)#)
               AtExp \: \xcd"at" PlaceExpSingleList ClosureBody & (\ref{prod:AtExp}) \\
\end{bbgrammar}
%##)

The {\it PlaceExp} must be an expression of type \xcd`Place` or some subtype.

%%AT-COPY%% The \xcd`at`-statment \xcd`at(p;F)S` first evaluates \xcd`p` to a place, then
%%AT-COPY%% copies information to that place as determined by \xcd`F`, and then executes
%%AT-COPY%% \xcd`S` using the resulting copies.  The \xcd`at`-{\em expression}
%%AT-COPY%% \xcd`at(p;F)E` is similar, but it copies the result of the expression \xcd`E`
%%AT-COPY%% and returns the copy as its result.
%%AT-COPY%% 
%%AT-COPY%% The clause \xcd`F` in \xcd`at(p;F)S` is a list of zero or more {\em copy
%%AT-COPY%% specifiers}, explaining what values are to be copied to the place \xcd`p`, and
%%AT-COPY%% how they are to be referred to at \xcd`p`.  
%%AT-COPY%% 

%%AT-COPY%% \begin{ex}
%%AT-COPY%% The following example creates an array \xcd`a` located \xcd`here`, and copies
%%AT-COPY%% it to another place, giving the copy the name \xcd`a2` there.  The copy is
%%AT-COPY%% modified and examined.  After the \xcd`at` finishes, the original is also
%%AT-COPY%% examined, and (since only the copy, not the original, was modified) is observed
%%AT-COPY%% to be unchanged. 
%%AT-COPY%% %~x~gen ^^^ Places6e1o
%%AT-COPY%% % package Places6e1o;
%%AT-COPY%% % KNOWNFAIL-at
%%AT-COPY%% % class Example { static def example() { 
%%AT-COPY%% %~x~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% val a = [1,2,3];
%%AT-COPY%% at(here.next(); a2 = a) {
%%AT-COPY%%   a2(1) = 4;
%%AT-COPY%%   assert a2(0)==1 && a2(1)==4 && a2(2)==3; 
%%AT-COPY%%   // 'a' is not accessible here
%%AT-COPY%% }
%%AT-COPY%% assert  a(0)==1 && a(1)==2 && a(2)==3; 
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~x~siv
%%AT-COPY%% %} } 
%%AT-COPY%% % class Hook { def run() { Example.example(); return true; }}
%%AT-COPY%% %~x~neg
%%AT-COPY%% \end{ex}
%%AT-COPY%% 

\begin{ex}
The following example creates an array \xcd`a` located \xcd`here`, and copies
it to another place.  \xcd`a` in the second place (\xcd`here.next()`) refers
to the copy.  The copy is
modified and examined.  After the \xcd`at` finishes, the original is also
examined, and (since only the copy, not the original, was modified) is observed
to be unchanged. 
%~~gen ^^^ Places6e1o
% package Places6e1o;
% KNOWNFAIL-at
% class Example { static def example() { 
%~~vis
\begin{xten}
val a = [1,2,3];
at(here.next()) {
  a(1) = 4;
  assert a(0)==1 && a(1)==4 && a(2)==3; 
}
assert  a(0)==1 && a(1)==2 && a(2)==3; 
\end{xten}
%~~siv
%} } 
% class Hook { def run() { Example.example(); return true; }}
%~~neg
\end{ex}

%%AT-COPY%% \subsection{Copy Specifiers}
%%AT-COPY%% \label{sect:copy-spec}
%%AT-COPY%% \index{copy specifier}
%%AT-COPY%% \index{at!copy specifier}
%%AT-COPY%% 
%%AT-COPY%% A single copy specifier can be one of the following forms.   
%%AT-COPY%% Each copy specifier determines an {\em original-expression}, saying what value
%%AT-COPY%% will be copied, and a {\em target variable}, saying what it will be called.
%%AT-COPY%% 
%%AT-COPY%% \begin{itemize}
%%AT-COPY%% 
%%AT-COPY%% \item \xcd`val x = E`, and its usual variants \xcd`val x:T = E`, 
%%AT-COPY%%       \xcd`x : T = E`, and 
%%AT-COPY%%       \xcd`val x <: T = E`, evaluate the expression \xcd`E` at the initial
%%AT-COPY%%       place, copy it to \xcd`p`, and bind \xcd`x` to the copy, as normal for a
%%AT-COPY%%       local \xcd`val` binding.  If a type is supplied, it is checked
%%AT-COPY%%       statically in the usual way.  
%%AT-COPY%%       The original-expression is \xcd`E`, and the target variable is \xcd`x`.
%%AT-COPY%% 
%%AT-COPY%% \begin{ex}
%%AT-COPY%% The following code copies a variable \xcd`a` located \xcd`here` to a variable
%%AT-COPY%% \xcd`d` located \xcd`there`.  
%%AT-COPY%% Note that, while the copy \xcd`d` is available \xcd`there` inside of the \xcd`at`-block,
%%AT-COPY%% the original \xcd`a` is not.  (\xcd`a` could not be available in the block in
%%AT-COPY%% any case; it is not located \xcd`there`.)
%%AT-COPY%% %~~gen ^^^ Places9v2e1
%%AT-COPY%% % package Places9v2e1;
%%AT-COPY%% % KNOWNFAIL-at
%%AT-COPY%% % class Example{ 
%%AT-COPY%% % static def use(Any) = 1;
%%AT-COPY%% % static def example() { 
%%AT-COPY%% %  val there = here.next();
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% var a : Int = 1;
%%AT-COPY%% at(there; val d = a) {
%%AT-COPY%%    assert d == 1;
%%AT-COPY%%    // ERROR: assert a == 1;
%%AT-COPY%% }
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% % } } 
%%AT-COPY%% % class Hook{ def run() {Example.example(); return true;}}
%%AT-COPY%% %~~neg
%%AT-COPY%% \end{ex}
%%AT-COPY%% 
%%AT-COPY%% \item \xcd`var x : T = E` evaluates \xcd`E` at the initial place, copies it to
%%AT-COPY%%       \xcd`p`, and binds \xcd`x` to a new \xcd`var` whose initial value is the
%%AT-COPY%%       copy, as normal for a local \xcd`var` binding.
%%AT-COPY%%       If a type is supplied, it is checked
%%AT-COPY%%       statically in the usual way.
%%AT-COPY%%       The original-expression is \xcd`E`, and the target variable is \xcd`x`.
%%AT-COPY%%       Note that, like a \xcd`var` parameter to a method, \xcd`x` is a local
%%AT-COPY%%       variable.  Changes to \xcd`x` will not change anything else. In
%%AT-COPY%%       particular, even if \xcd`x` has the same name as a \xcd`var` variable
%%AT-COPY%%       outside, the two \xcd`var`s are unconnected.  
%%AT-COPY%%       See \Sref{sect:athome} for the way to modify a variable from the
%%AT-COPY%%       surrounding scope.
%%AT-COPY%% 
%%AT-COPY%% \begin{ex}
%%AT-COPY%% The following code copies \xcd`a` to a \xcd`var` named \xcd`e`.  Changing
%%AT-COPY%% \xcd`e` does not change \xcd`a`; the two \xcd`var`s have no ongoing relationship.
%%AT-COPY%% %~~gen ^^^ Places9v2e2
%%AT-COPY%% % package Places9v2e2;
%%AT-COPY%% % KNOWNFAIL-at
%%AT-COPY%% % class Example{ 
%%AT-COPY%% % static def use(Any) = 1;
%%AT-COPY%% % static def example() { 
%%AT-COPY%% %  val there = here.next();
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% var a : Int = 1;
%%AT-COPY%% assert a == 1;
%%AT-COPY%% at(there; var e = a) { 
%%AT-COPY%%    assert e == 1;
%%AT-COPY%%    e += 1;
%%AT-COPY%%    assert e == 2;
%%AT-COPY%% }
%%AT-COPY%% assert a == 1; 
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% % 
%%AT-COPY%% % }  } 
%%AT-COPY%% % class Hook{ def run() {Example.example(); return true;}}
%%AT-COPY%% %~~neg
%%AT-COPY%% \end{ex}
%%AT-COPY%% 
%%AT-COPY%% \item \xcd`x = E`, as a copy specifier, is equivalent to \xcd`val x = E`.
%%AT-COPY%%       Note that this abbreviated form is not available as a local variable
%%AT-COPY%%       definition, (because it is used as an assignment statement), but in a
%%AT-COPY%%       copy specifier there are no assignment statements and so the
%%AT-COPY%%       abbreviation is allowed.
%%AT-COPY%%       The original-expression is \xcd`E`, and the target variable is \xcd`x`.
%%AT-COPY%% 
%%AT-COPY%% \begin{ex}
%%AT-COPY%% The following code evaluates an expression \xcd`a+b(0)`.  The result of this
%%AT-COPY%% expression is stored \xcd`there`, in the \xcd`val` variable \xcd`f`, but is
%%AT-COPY%% not stored \xcd`here`. 
%%AT-COPY%% %~~gen ^^^ Places9v2e3
%%AT-COPY%% % package Places9v2e3;
%%AT-COPY%% % KNOWNFAIL-at
%%AT-COPY%% % class Example{ 
%%AT-COPY%% % static def use(Any) = 1;
%%AT-COPY%% % static def example() { 
%%AT-COPY%% %  val there = here.next();
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% var a : Int = 1;
%%AT-COPY%% var b : Array[Int] = [2,3,4];
%%AT-COPY%% at(there; f = a + b(0)) {
%%AT-COPY%%    assert f == 3;
%%AT-COPY%% }
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% % }  } 
%%AT-COPY%% % class Hook{ def run() {Example.example(); return true;}}
%%AT-COPY%% % 
%%AT-COPY%% %~~neg
%%AT-COPY%% 
%%AT-COPY%% 
%%AT-COPY%% \end{ex}
%%AT-COPY%% 
%%AT-COPY%% \item \xcd`x` alone, as a copy specifier, is equivalent to \xcd`val x = x`.
%%AT-COPY%%       It says that the variable \xcd`x` will be copied, and the copy will also
%%AT-COPY%%       be named \xcd`x`.  
%%AT-COPY%%       The original-expression is \xcd`x`, and the target variable is \xcd`x`.
%%AT-COPY%% 
%%AT-COPY%% \begin{ex}
%%AT-COPY%% The following code copies \xcd`b` to \xcd`there`.  The copy is also called
%%AT-COPY%% \xcd`b`.  The two \xcd`b`'s are not connected; \eg, changing one does not
%%AT-COPY%% change the other.
%%AT-COPY%% %~~gen ^^^ Places9v2e4
%%AT-COPY%% % package Places9v2e4;
%%AT-COPY%% % KNOWNFAIL-at
%%AT-COPY%% % class Example{ 
%%AT-COPY%% % static def use(Any) = 1;
%%AT-COPY%% % static def example() { 
%%AT-COPY%% %  val there = here.next();
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% var b : Array[Int] = [2,3,4];
%%AT-COPY%% assert b(0) == 2;
%%AT-COPY%% at(there; b) {
%%AT-COPY%%   b(0) = 200;  // Modify copy of b.
%%AT-COPY%%   assert b(0) == 200;
%%AT-COPY%% }
%%AT-COPY%% assert b(0) == 2; 
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% % 
%%AT-COPY%% % }  } 
%%AT-COPY%% % class Hook{ def run() {Example.example(); return true;}}
%%AT-COPY%% %~~neg
%%AT-COPY%% \end{ex}
%%AT-COPY%% 
%%AT-COPY%% \item A field assignment statements \xcdmath"a.fld = $E_2$", evaluates 
%%AT-COPY%%       \xcd`a` and $E_2$ on the sending side to values $v_1$ and {$v_2$}.  
%%AT-COPY%%       {$v_1$} must be an object with a mutable field \xcd`fld`.  {$v_1$} and
%%AT-COPY%%       {$v_2$} are sent to place \xcd`p`, and the field assignment is performed
%%AT-COPY%%       there.  The modified version of {$v_1$} is available as a \xcd`val`
%%AT-COPY%%       variable \xcd`a`.   The compiler may optimize this, \eg, by neglecting to
%%AT-COPY%%       deserialize \xcdmath"$v_1$.fld", and deserializing {$v_2$} directly into
%%AT-COPY%%       that field rather than into a separate buffer.
%%AT-COPY%% 
%%AT-COPY%% \begin{ex}
%%AT-COPY%% %~~gen ^^^ Places9v2e5
%%AT-COPY%% % package Places9v2e5;
%%AT-COPY%% % KNOWNFAIL
%%AT-COPY%% % class Example {
%%AT-COPY%% % static def use(Any) = 1;
%%AT-COPY%% % static def example() { 
%%AT-COPY%% %  val there = here.next();
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% class Example{ 
%%AT-COPY%%    var f : Int = 1;
%%AT-COPY%%    var g : Int = 2;
%%AT-COPY%%    static def example() { 
%%AT-COPY%%       val there = here.next();
%%AT-COPY%%       val e : Example = new Example();
%%AT-COPY%%       assert e.f == 1 && e.g == 2;
%%AT-COPY%%       at(there; e.f = 3) {
%%AT-COPY%%           assert e.f == 3; && e.g == 2;
%%AT-COPY%%       }
%%AT-COPY%%       assert e.f == 1 && e.g == 2;
%%AT-COPY%%    }
%%AT-COPY%% }
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% % class Hook{ def run() {Example.example(); return true;}}
%%AT-COPY%% %~~neg
%%AT-COPY%% %
%%AT-COPY%% \end{ex}
%%AT-COPY%% 
%%AT-COPY%% \item An array-element assignment 
%%AT-COPY%%       \xcdmath"a($E_1$, $\ldots$, $E_n$) = $E_+$".
%%AT-COPY%%       This copies and transmits \xcd`a` as normal for an array.  In addition,
%%AT-COPY%%       and 
%%AT-COPY%%       much like a field assignment, it also evaluates all the expressions $E_i$
%%AT-COPY%%       at the sending side to values $v_i$, and transmits them.  \xcd`a`'s value must
%%AT-COPY%%       admit a suitably-typed $n$-ary subscripting operation.  That operation
%%AT-COPY%%       is applied after the values are deserialized at \xcd`p`.  The compiler
%%AT-COPY%%       may optimize this, \eg, by neglecting to deserialize one element of the
%%AT-COPY%%       array $v_0$, and deserializing $v_+$ directly into that location.  
%%AT-COPY%% 
%%AT-COPY%% 
%%AT-COPY%% \begin{ex}
%%AT-COPY%% The following code sends a modified \xcd`b` to \xcd`there`, while (as always)
%%AT-COPY%% keeping an unmodified version \xcd`here`.   X10 may perform optimizations to
%%AT-COPY%% avoid transmitting the original value of \xcd`b(1)`, since it will be
%%AT-COPY%% overwritten immediately in any case.
%%AT-COPY%% %~~gen ^^^ Places9v2e6
%%AT-COPY%% % package Places9v2e6;
%%AT-COPY%% % KNOWNFAIL
%%AT-COPY%% % class Example{ 
%%AT-COPY%% % static def use(Any) = 1;
%%AT-COPY%% % static def example() { 
%%AT-COPY%% %  val there = here.next();
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% var b = [2,3,4];
%%AT-COPY%% assert b(0) == 2 && b(1) == 3;
%%AT-COPY%% at(there; b(1) = 300) {
%%AT-COPY%%   assert b(0) == 2 && b(1) == 300;
%%AT-COPY%% }
%%AT-COPY%% assert b(0) == 2 && b(1) == 3;
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% % 
%%AT-COPY%% %~~neg
%%AT-COPY%% % }  }
%%AT-COPY%% % class Hook{ def run() {Example.example(); return true;}}
%%AT-COPY%% \end{ex}
%%AT-COPY%% 
%%AT-COPY%% \item \xcd`*` may appear as the last copy specifier in the list, indicating
%%AT-COPY%%       that all \xcd`val` variables from outside \xcd`S` which are used in
%%AT-COPY%%       \xcd`S` should be copied. Specifically, let 
%%AT-COPY%%       \xcdmath"x$_1, \ldots, $x$_n$" be all the \xcd`val` variables defined
%%AT-COPY%%       outside of \xcd`S` 
%%AT-COPY%%       mentioned in \xcd`S`. The \xcd`*` copy specifier is equivalent to 
%%AT-COPY%%       the list of variables 
%%AT-COPY%%       \xcdmath"x$_1, \ldots, $x$_n$".
%%AT-COPY%% 
%%AT-COPY%% \begin{ex}
%%AT-COPY%% %~~gen ^^^ Places9v2e7
%%AT-COPY%% % package Places9v2e7;
%%AT-COPY%% % KNOWNFAIL-at
%%AT-COPY%% % class Example{ 
%%AT-COPY%% % static def use(Any) = 1;
%%AT-COPY%% % static def example() { 
%%AT-COPY%% %  val there = here.next();
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% var a : Int = 1;
%%AT-COPY%% val b = [2,3,4];
%%AT-COPY%% at(there; *) {
%%AT-COPY%%   assert a + b(0) == b(1);
%%AT-COPY%% }
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% % }  }
%%AT-COPY%% % class Hook{ def run() {Example.example(); return true;}}
%%AT-COPY%% %~~neg
%%AT-COPY%% 
%%AT-COPY%% \end{ex}
%%AT-COPY%% 
%%AT-COPY%% \end{itemize}
%%AT-COPY%% 
%%AT-COPY%% As an important special case, \xcd`at(p;)S` copies {\em nothing} to \xcd`S`.
%%AT-COPY%% This must not be confused with \xcd`at(p)S`, which copies {\em everything}.
%%AT-COPY%% 
%%AT-COPY%% 
%%AT-COPY%% 
%%AT-COPY%% Note that \xcd`at(p;x,*)use(x,y);` is equivalent to \xcd`at(p;*)use(x,y);`.
%%AT-COPY%% In both statements, the \xcd`*` indicates that all variables used in the body
%%AT-COPY%% are to be copied in.  The former makes clear that \xcd`x` is one of the things
%%AT-COPY%% being copied, but, from the \xcd`*`, there may be others. 
%%AT-COPY%% 
%%AT-COPY%% However, other copy specifiers may be used to compute
%%AT-COPY%% values in \xcd`S` which are not available (and thus need not be stored)
%%AT-COPY%% outside of it.  
%%AT-COPY%% 
%%AT-COPY%% \begin{ex}The following code may end up with a large object \xcd`c` in
%%AT-COPY%% memory at \xcd`p` but not at the initial place: 
%%AT-COPY%% %~~gen ^^^ Places3q9u
%%AT-COPY%% % package Places3q9u;
%%AT-COPY%% % KNOWNFAIL-at
%%AT-COPY%% % class Example { 
%%AT-COPY%% % def use(Example, Example, Example) = 1;
%%AT-COPY%% % def Elephant(Example) = 1;
%%AT-COPY%% % static def example(a: Example, b:Example, p:Place) { 
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% at(p; c = a.Elephant(b), *) {
%%AT-COPY%%   use(a,b,c);
%%AT-COPY%% }
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% %} } 
%%AT-COPY%% %~~neg
%%AT-COPY%% \end{ex}
%%AT-COPY%% 
%%AT-COPY%% The blanket \xcd`at`-statement \xcd`at(p)S` copies everything.  It is an
%%AT-COPY%% abbreviation for \xcd`at(p;*)S`.  
%%AT-COPY%% When this manual refers to a generic \xcd`at`-statement as \xcd`at(p;F)S`, it
%%AT-COPY%% should be understood as including the blanket \xcd`at` statement \xcd`at(p)S`
%%AT-COPY%% with this interpretation.
%%AT-COPY%% 


\subsection{Copying Values}
%%AT-COPY%% An activity executing statement \xcd"at (q;F) S" at a place \xcd`p`
%%AT-COPY%% evaluates \xcd`q` at \xcd`p` and then moves to \xcd`q` to execute
%%AT-COPY%% \xcd`S`.  
%%AT-COPY%% The original-expressions of \xcd`F` are evaluated at \xcd`p`.
%%AT-COPY%% Their values are copied (\Sref{sect:at-init-val}) to \xcd`q`, and bound to 
%%AT-COPY%% names there, as specified by \xcd`F`.  
%%AT-COPY%% \xcd`S` is evaluated in an environment containing the target variables of
%%AT-COPY%% \xcd`F`, and \xcd`here` and {\em no} other variables.  (In particular, if this
%%AT-COPY%% statement appears in an instance method body and \xcd`this` is not copied,
%%AT-COPY%% \xcd`this` is not accessible.  This fact is important: it allows the
%%AT-COPY%% programmer to control when \xcd`this` is copied, which may be expensive for
%%AT-COPY%% large containers.)

An activity executing \xcd`at(q)S` at a place \xcd`p` evaluates \xcd`q` at
place \xcd`p`, which should be a \xcd`Place`.  It then moves to place \xcd`q`
to execute \xcd`S`.  The values variables that \xcd`S` refers to are copied
(\Sref{sect:at-init-val}) to \xcd`q`, and bound to the variables of the same
name.   If the \xcd`at` is inside of an instance method and \xcd`S` uses
\xcd`this`, \xcd`this` is copied as well.  Note that a field reference
\xcd`this.fld` or a method call \xcd`this.meth()` will cause \xcd`this` to be
copied --- as will their abbreviated forms \xcd`fld` and \xcd`meth()`, despite
the lack of a visible \xcd`this`.  


Note that the value obtained by evaluating \xcd`q`
is not necessarily distinct from \xcd`p` (\eg, \xcd`q` may be
\xcd`here`). 
This does not alter the behavior of \xcd`at`.  
%%AT-COPY%%  \xcd`at(here;F)S` will copy all the values specified by \xcd`F`, 
%%AT-COPY%% even though there is no actual change of place, and even though the original
%%AT-COPY%% values already exist there.
\xcd`at(here)S` will copy all the values mentioned in \xcd`S`, even though
there is no actual change of place, and even though the original values
already exist there. 

On normal termination of \xcd`S` control returns to \xcd`p` and
execution is continued with the statement following 
%%AT-COPY%% \xcd`at (q;F) S`. 
\xcd`at (q) S`. 
If
\xcd`S` terminates abruptly with exception \xcd`E`, \xcd`E` is
serialized into a buffer, the buffer is communicated to \xcd`p` where
it is deserialized into an exception \xcd`E1` and \xcd`at (p) S`
throws \xcd`E1`.

Since 
%%AT-COPY%% \xcd`at(p;F) S` 
\xcd`at(p) S` 
is a synchronous construct, usual control-flow
constructs such as \xcd`break`, \xcd`continue`, \xcd`return` and 
\xcd`throw` are permitted in \xcd`S`.  All concurrency related
constructs -- \xcd`async`, \xcd`finish`, \xcd`atomic`, \xcd`when` are
also permitted.

The \xcd`at`-expression 
%%AT-COPY%% \xcd`at(p;F)E` 
\xcd`at(p)E` 
is similar, except that, in the case of
normal termination of \xcd`E`, the value that \xcd`E` produces is serialized
into a buffer, transported to the starting place, and deserialized, and the
value of the \xcd`at`-expression is the result of deserialization.

\limitation{
X10 does not currently allow {\tt break}, {\tt continue}, or {\tt return}
to exit from an {\tt at}.
}



\subsection{How {\tt at} Copies Values}
\label{sect:at-init-val}

%%AT-COPY%% The values of the original-expressions  specified by \xcd`F` in 
%%AT-COPY%% \xcd`at (p;F)S` are copied to \xcd`p`, as follows.

The values mentioned in \xcd`S` are copied to place \xcd`p` by \xcd`at(p)S` as follows.

First, the original-expressions are evaluated to give a vector of X10 values.
Consider the graph of all values reachable from these values (except for 
\xcd`transient` fields 
(\Sref{sect:transient}, \xcd`GlobalRef`s (\Sref{GlobalRef}); also custom
serialization (\Sref{sect:ser+deser} may alter this behavior)). 

Second this graph is {\em
serialized} into a buffer and transmitted to place \xcd`q`.  Third,
the vector of X10 values is 
re-created at \xcd`q` 
by deserializing the buffer at
\xcd`q`. Fourth, \xcd`S` is executed at \xcd`q`, in an environment in
which each variable \xcd`v` declared in \xcd`F` 
refers to the corresponding deserialized value.  

Note that since values accessed across an \xcd`at` boundary are
copied, the programmer may wish to adopt the discipline that either
variables accessed across an \xcd`at` boundary  contain only structs 
or stateless objects, or the methods invoked on them do not access any
mutable state on the objects. Otherwise the programmer has to ensure
that side effects are made to the correct copy of the object. For this
the struct \xcd`x10.lang.GlobalRef[T]` is often useful.


\subsubsection{Serialization and deserialization.}
\label{sect:ser+deser}
\index{transient}
\index{field!transient}
The X10 runtime provides a default mechanism for
serializing/deserializing an object graph with a given set of roots.
This mechanism may be overridden by the programmer on a per class or
struct basis as described in the API documentation for
\xcd`x10.io.CustomSerialization`.  
The default mechanism performs a
deep copy of the object graph (that is, it copies the object or struct
and, recursively, the values contained in its fields), but does not
traverse \xcd`transient` fields. Instead on serialization the default
value \Sref{DefaultValues} for the type of the field is used.

A struct \xcd`s` of type \xcd`x10.lang.GlobalRef[T]` \ref{GlobalRef}
is serialized as a unique global reference to its contained object
\xcd`o` (of type \xcd`T`).  Please see the documentation
of \xcd`x10.lang.GlobalRef[T]` for more details.



\subsection{{\tt at} and Activities}
%%AT-COPY%% \xcd`at(p;F)S` 
\xcd`at(p)S` 
does {\em not} start a new activity.  It should be thought of as
transporting the current activity to \xcd`p`, running \xcd`S` there, and then
transporting it back.  \xcd`async` is the only construct in the
language that starts a new activity. In different contexts, each one
of the following makes sense:
%%AT-COPY%% (1)~\xcd`async at(p;F) S` 
(1)~\xcd`async at(p) S` 
(spawn an activity locally to execute \xcd`S` at
\xcd`p`; here \xcd`p` is evaluated by the spawned activity) , 
%%AT-COPY%% (2)~\xcd`at(p;F) async S` 
(2)~\xcd`at(p) async S` 
(evaluate \xcd`p` and then at \xcd`p` spawn an
activity to execute \xcd`S`), and,
%%AT-COPY%% (3)~\xcd`async at(p;F) async S`. 
(3)~\xcd`async at(p) async S`. 
%%AT-COPY%% In most cases, \xcd`async at(p;F) S` is preferred to \xcd`at(p;F) async S`, since
In most cases, \xcd`async at(p) S` is preferred to \xcd`at(p) async S`, since
the former returns instantly, but the latter blocks waiting for the remote
activity to be spawned. 

Since 
%%AT-COPY%% \Xcd{at(p;F) S} 
\Xcd{at(p) S} 
does not start a new activity, 
\xcd`S` may contain constructs which only make sense
within a single activity.  
For example, 
\begin{xten}
    for(x in globalRefsToThings) 
      if (at(x.home) x().isNice()) 
        return x();
\end{xten}
returns the first nice thing in a collection.   If we had used 
\xcd`async at(x.home)`, this would not be allowed; 
you can't \xcd`return` from an
\xcd`async`. 

\limitation{
X10 does not currently allow {\tt break}, {\tt continue}, or {\tt return}
to exit from an {\tt at}.
}



\subsection{Copying from {\tt at} }
\index{at!copying}

%%AT-COPY%% \xcd`at(p;F)S` copies data as specified by \xcd`F`, and sends it
\xcd`at(p)S` copies data required in \xcd`S`, and sends it
to place \xcd`p`, before executing \xcd`S` there. The only things that are not
copied are values only reachable through \xcd`GlobalRef`s and \xcd`transient`
fields, and data omitted by custom serialization.    
%%AT-COPY%% Several choices of copy specifier use the same identifier for the original
%%AT-COPY%% variable outside of 
%%AT-COPY%% \xcd`at(p)S` 
%%AT-COPY%% and its copy inside of \xcd`S`.  
%%AT-COPY%% 

\begin{ex}
%%AT-COPY%% 
%%AT-COPY%% %~~gen ^^^ Places_implicit_copy_from_at_example_1
%%AT-COPY%% % package Places.implicitcopyfromat;
%%AT-COPY%% % class Example {
%%AT-COPY%% % static def example() {
%%AT-COPY%% % 
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% val c = new Cell[Int](9); // (1)
%%AT-COPY%% at (here;c) {             // (2)
%%AT-COPY%%    assert(c() == 9);      // (3)
%%AT-COPY%%    c.set(8);              // (4)
%%AT-COPY%%    assert(c() == 8);      // (5)
%%AT-COPY%% }
%%AT-COPY%% assert(c() == 9);         // (6)
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% %}}
%%AT-COPY%% % class Hook{ def run() { Example.example(); return true; } }
%%AT-COPY%% %~~neg
%%AT-COPY%% 

%~~gen ^^^ Places_implicit_copy_from_at_example_1
% package Places.implicitcopyfromat;
% class Example {
% static def example() {
% 
%~~vis
\begin{xten}
val c = new Cell[Int](9); // (1)
at (here) {               // (2) 
   assert(c() == 9);      // (3)
   c.set(8);              // (4)
   assert(c() == 8);      // (5)
}
assert(c() == 9);         // (6)
\end{xten}
%~~siv
%}}
% class Hook{ def run() { Example.example(); return true; } }
%~~neg


The \xcd`at` statement copies the \xcd`Cell` and its contents.  
After \xcd`(1)`, \xcd`c` is a \xcd`Cell` containing 9; call that cell {$c_1$}
At \xcd`(2)`, that cell is copied, resulting in another cell {$c_2$} whose
contents are also 9, as tested at \xcd`(3)`.
(Note that the copying behavior of \xcd`at` happens {\em even when the
destination place is the same as the starting place}--- even with
\xcd`at(here)`.)
At \xcd`(4)`, the contents of {$c_2$} are changed to 8, as confirmed at \xcd`(5)`; the contents of
{$c_1$} are of course untouched.    Finally, at \xcd`(c)`, outside the scope
of the \xcd`at` started at line \xcd`(2)`, \xcd`c` refers to its original
value {$c_1$} rather than the copy {$c_2$}.  
\end{ex}

The \xcd`at` statement induces a {\em deep copy}.  Not only does it copy the
values of variables, it copies values that they refer to through zero or more
levels of reference.  Structures are preserved as well: if two fields
\xcd`x.f` and \xcd`x.g` refer to the same object {$o_1$} in the original, then
\xcd`x.f` and \xcd`x.g` will both refer to the same object {$o_2$} in the
copy.  

\begin{ex}
In the following variation of the preceding example,
\xcd`a`'s original value {$a_1$} is an array with two references to the same
\xcd`Cell[Int]` {$c_1$}.  The fact that {$a_1(0)$} and {$a_1(1)$} are both
identical to {$c_1$} is demonstrated in \xcd`(A)`-\xcd`(C)`, as {$a_1(0)$} is modified
and {$a_1(1)$} is observed to change.  In \xcd`(D)`-\xcd`(F)`, the copy
{$a_2$} is tested in the same way, showing that {$a_2(0)$} and {$a_2(1)$} both
refer to the same \xcd`Cell[Int]` {$c_2$}.  However, the test at \xcd`(G)`
shows that {$c_2$} is a different cell from {$c_1$}, because changes to
{$c_2$} did not propagate to {$c_1$}.  

%%AT-COPY%% %~~gen ^^^ PlacesAtCopy
%%AT-COPY%% %package Places.AtCopy2;
%%AT-COPY%% %class example {
%%AT-COPY%% %static def Example() {
%%AT-COPY%% %
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% val c = new Cell[Int](5);
%%AT-COPY%% val a : Array[Cell[Int]](1) = [c,c as Cell[Int]];
%%AT-COPY%% assert(a(0)() == 5 && a(1)() == 5);     // (A)
%%AT-COPY%% c.set(6);                               // (B)
%%AT-COPY%% assert(a(0)() == 6 && a(1)() == 6);     // (C)
%%AT-COPY%% at(here;a) {
%%AT-COPY%%   assert(a(0)() == 6 && a(1)() == 6);   // (D)
%%AT-COPY%%   c.set(7);                             // (E)
%%AT-COPY%%   assert(a(0)() == 7 && a(1)() == 7);   // (F)
%%AT-COPY%% }
%%AT-COPY%% assert(a(0)() == 6 && a(1)() == 6);     // (G)
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% %}}
%%AT-COPY%% %class Hook{ def run() { example.Example(); return true; } }
%%AT-COPY%% %~~neg

%~~gen ^^^ PlacesAtCopy
%package Places.AtCopy2;
%class example {
%static def Example() {
%
%~~vis
\begin{xten}
val c = new Cell[Int](5);
val a : Array[Cell[Int]](1) = [c,c as Cell[Int]];
assert(a(0)() == 5 && a(1)() == 5);     // (A)
c.set(6);                               // (B)
assert(a(0)() == 6 && a(1)() == 6);     // (C)
at(here) {
  assert(a(0)() == 6 && a(1)() == 6);   // (D)
  c.set(7);                             // (E)
  assert(a(0)() == 7 && a(1)() == 7);   // (F)
}
assert(a(0)() == 6 && a(1)() == 6);     // (G)
\end{xten}
%~~siv
%}}
%class Hook{ def run() { example.Example(); return true; } }
%~~neg


\end{ex}

\subsection{Copying and Transient Fields}
\label{sect:transient}
\index{at!transient fields and}
\index{transient}
\index{field!transient}

Recall that fields of classes and structs marked \xcd`transient` are not copied by
\xcd`at`.  Instead, they are set to the default values for their types. Types
that do not have default values cannot be used in \xcd`transient` fields.

\begin{ex}
Every \xcd`Trans` object has an \xcd`a`-field equal
to 1.  However, despite the initializer on the \xcd`b` field, it is not the
case that every \xcd`Trans` has \xcd`b==2`.  Since \xcd`b` is \xcd`transient`,
when the \xcd`Trans` value \xcd`this` is copied at \xcd`at(here){...}` in
\xcd`example()`, its \xcd`b` field is not copied, and the default value for an
\xcd`Int`, 0, is used instead.  
Note that we could not make a transient field \xcd`c : Int{c != 0}`, since the
type has no default value, and copying would in fact set it to zero.

%%AT-COPY%% %~~gen ^^^ Places40
%%AT-COPY%% %package Places_transient_a;
%%AT-COPY%% % 
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% class Trans {
%%AT-COPY%%    val a : Int = 1;
%%AT-COPY%%    transient val b : Int = 2;
%%AT-COPY%%    //ERROR transient val c : Int{c != 0} = 3;
%%AT-COPY%%    def example() {
%%AT-COPY%%      assert(a == 1 && b == 2);
%%AT-COPY%%      at(here;a) {
%%AT-COPY%%         assert(a == 1 && b == 0);
%%AT-COPY%%      }
%%AT-COPY%%    }
%%AT-COPY%% }
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% %class Hook{ def run() { (new Trans()).example(); return true; } }
%%AT-COPY%% %~~neg

%~~gen ^^^ Places40
%package Places_transient_a;
% 
%~~vis
\begin{xten}
class Trans {
   val a : Int = 1;
   transient val b : Int = 2;
   //ERROR transient val c : Int{c != 0} = 3;
   def example() {
     assert(a == 1 && b == 2);
     at(here) {
        assert(a == 1 && b == 0);
     }
   }
}
\end{xten}
%~~siv
%class Hook{ def run() { (new Trans()).example(); return true; } }
%~~neg



\end{ex}

\subsection{Copying and GlobalRef}
\label{GlobalRef}
\index{at!GlobalRef}
\index{at!blocking copying}

%%The other barrier to the potentially copious copying behavior of \xcd`at`
%%is the \xcd`GlobalRef` struct.  
A \xcd`GlobalRef[T]` (say \xcd`g`) contains a reference to
a value \xcd`v` of type \xcd`T`, in a form which can be transmitted, and a \xcd`Place`
\xcd`g.home` indicating where the value lives. When a 
\xcd`GlobalRef` is serialized an opaque, globally unique handle to
\xcd`v` is created.  

\begin{ex}The following example does not copy the value \xcd`huge`.  However, \xcd`huge`
would have been copied if it had been put into a \xcd`Cell`, or simply used
directly. 

%%AT-COPY%% %~~gen ^^^ Places50
%%AT-COPY%% %package Places.copyingblockingwithglobref;
%%AT-COPY%% % class GR {
%%AT-COPY%% %  static def use(Any){}
%%AT-COPY%% %  static def example() {
%%AT-COPY%% % 
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% val huge = "A potentially big thing";
%%AT-COPY%% val href = GlobalRef(huge);
%%AT-COPY%% at (here;href) {
%%AT-COPY%%    use(href);
%%AT-COPY%%   }
%%AT-COPY%% }
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% %}
%%AT-COPY%% % class Hook{ def run() { GR.example(); return true; } }
%%AT-COPY%% %~~neg

%~~gen ^^^ Places50
%package Places.copyingblockingwithglobref;
% class GR {
%  static def use(Any){}
%  static def example() {
% 
%~~vis
\begin{xten}
val huge = "A potentially big thing";
val href = GlobalRef(huge);
at (here) {
   use(href);
  }
}
\end{xten}
%~~siv
%}
% class Hook{ def run() { GR.example(); return true; } }
%~~neg


\end{ex}

Values protected in \xcd`GlobalRef`s can be retrieved by the application
%~~exp~~`~~`~~ g:GlobalRef[Object]{here == g.home}~~ ^^^Places4e7q
operation \xcd`g()`.  \xcd`g()` is guarded; it can 
only be called when \xcd`g.home == here`.  If you  want to do anything other
than pass a global reference around or compare two of them for equality, you
need to placeshift back to the home place of the reference, often with
\xcd`at(g.home)`.   

\begin{ex}The following program, for reasons best known to the programmer,
modifies the 
command-line argument array.

%%AT-COPY%% 
%%AT-COPY%% %~~gen ^^^ Places60
%%AT-COPY%% % package Places.Atsome.Globref2;
%%AT-COPY%% % class GR2 {
%%AT-COPY%% % 
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%%   public static def main(argv: Array[String](1)) {
%%AT-COPY%%     val argref = GlobalRef[Array[String](1)](argv);
%%AT-COPY%%     at(here.next(); argref) 
%%AT-COPY%%         use(argref);
%%AT-COPY%%   }
%%AT-COPY%%   static def use(argref : GlobalRef[Array[String](1)]) {
%%AT-COPY%%     at(argref.home; argref) {
%%AT-COPY%%       val argv = argref();
%%AT-COPY%%       argv(0) = "Hi!";
%%AT-COPY%%     }
%%AT-COPY%%   }
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% %} 
%%AT-COPY%% % class Hook{ def run() { GR2.main(["what, me weasel?" as String]); return true; }}
%%AT-COPY%% %~~neg
%%AT-COPY%% 

%~~gen ^^^ Places60
% package Places.Atsome.Globref2;
% class GR2 {
% 
%~~vis
\begin{xten}
  public static def main(argv: Array[String](1)) {
    val argref = GlobalRef[Array[String](1)](argv);
    at(here.next()) 
        use(argref);
  }
  static def use(argref : GlobalRef[Array[String](1)]) {
    at(argref) {
      val argv = argref();
      argv(0) = "Hi!";
    }
  }
\end{xten}
%~~siv
%} 
% class Hook{ def run() { GR2.main(["what, me weasel?" as String]); return true; }}
%~~neg

\end{ex}

There is an implicit coercion from \xcd`GlobalRef[T]` to \xcd`Place`, so
\xcd`at(argref)S` goes to \xcd`argref.home`.  


\subsection{Warnings about \xcd`at`}
There are two dangers involved with \xcd`at`: 
\begin{itemize}
\item Careless use of \xcd`at` can result in copying and transmission
of very large data structures.  
%%AT-COPY%% This is particularly an issue with the blanket
%%AT-COPY%% \xcd`at` statement, \xcd`at(p)S`, where everything used in \xcd`S` is copied.  
In particular, it is very easy to capture
\xcd`this` -- a field reference will do it -- and accidentally copy everything
that \xcd`this` refers to, which can be very large.  A disciplined use of copy
specifiers to make explicit just what gets copied can ameliorate this issue.

\item As seen in the examples above, a local variable reference
  \xcd`x` may refer to different objects in different nested \xcd`at`
  scopes. The programmer must either ensure that a variable accessed
  across an \xcd`at` boundary has no mutable state or be prepared to
  reason about which copy gets modified.   A disciplined use of copy specifiers to give
  different names to variables can ameliorate this concern.
\end{itemize}


%%AT-COPY%% \section{{\tt athome}: Returning Values from {\tt at}-Blocks}
%%AT-COPY%% \label{sect:athome}
%%AT-COPY%% \index{athome}
%%AT-COPY%% 
%%AT-COPY%% The 
%%AT-COPY%% \xcd`at(p;F)S` 
%%AT-COPY%% construct renders external variables unavailable within
%%AT-COPY%% \xcd`S`.  However, it is often useful to transmit values back from \xcd`S`,
%%AT-COPY%% and store them in external variables. 
%%AT-COPY%% 
%%AT-COPY%% The \xcd`athome(V;F)S` construct provides
%%AT-COPY%% this ability.  \xcd`V` is a list of variables, which must all be defined at
%%AT-COPY%% the same place.  \xcd`athome(V;F)S` goes to the place where the variables are
%%AT-COPY%% defined, copying \xcd`F` as for \xcd`at(p;F)S`, and executes \xcd`S` ---
%%AT-COPY%% allowing reading, assignment and initialization of the listed variables in
%%AT-COPY%% \xcd`V`. 
%%AT-COPY%% 
%%AT-COPY%% \xcd`V`, the list of variables, may include one or more variables.  It is a
%%AT-COPY%% static error if X10 cannot determine that all the variables in the list are
%%AT-COPY%% defined at the same place.
%%AT-COPY%% 
%%AT-COPY%% 
%%AT-COPY%% 
%%AT-COPY%% 
%%AT-COPY%% \begin{ex}
%%AT-COPY%% \xcd`athome` allows returning multiple pieces of information from an
%%AT-COPY%% \xcd`at`-statement.  In the following example, we return two data: 
%%AT-COPY%% one as a \xcd`val` named \xcd`square`, and the other as an addition in to a
%%AT-COPY%% partially-computed polynomial named \xcd`poly`.  
%%AT-COPY%% %~~gen ^^^ Places5f9g
%%AT-COPY%% % package Places5f9g;
%%AT-COPY%% % % KNOWNFAIL-at
%%AT-COPY%% % class Example { 
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% static def example(a: Int, mathProc: Place) { 
%%AT-COPY%%   val square : Int;
%%AT-COPY%%   var poly : Int = 1 + a; // will be 1+a+a*a
%%AT-COPY%%   at(mathProc; a) {
%%AT-COPY%%     val sq = a*a; 
%%AT-COPY%%     athome(square, poly; sq) {
%%AT-COPY%%        square = sq;  // initialization
%%AT-COPY%%        poly += sq;   // read and update
%%AT-COPY%%     }
%%AT-COPY%%   return [square, poly];
%%AT-COPY%%   }
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% %}}
%%AT-COPY%% % class Hook { def run() { 
%%AT-COPY%% %   val e = example(2, here);
%%AT-COPY%% %   assert e(0) == 4 && e(1) == 7;
%%AT-COPY%% %   return true;
%%AT-COPY%% % }} 
%%AT-COPY%% %~~neg
%%AT-COPY%% \end{ex}
%%AT-COPY%% 
%%AT-COPY%% The abbreviated forms 
%%AT-COPY%% \xcd`athome (*) S` and 
%%AT-COPY%% \xcd`athome S` 
%%AT-COPY%% allow a block of assignments without specifying the variables being assigned
%%AT-COPY%% to, which is convenient for a small set of assignments. 
%%AT-COPY%% They 
%%AT-COPY%% are both equivalent to \xcd`athome(V;F)S`,
%%AT-COPY%% where: 
%%AT-COPY%% \begin{itemize}
%%AT-COPY%% \item \xcd`V` is the list of all variables appearing on the left-hand side of
%%AT-COPY%%       an assignment or update statement in \xcd`S`, excluding those which
%%AT-COPY%%       appear inside the body of an \xcd`at` or \xcd`athome` statement in \xcd`S`;
%%AT-COPY%% \item \xcd`F` is the same as for \xcd`at(p)S` (\Sref{sect:copy-spec})
%%AT-COPY%% \end{itemize}
%%AT-COPY%% 
%%AT-COPY%% 
%%AT-COPY%% \begin{ex}
%%AT-COPY%% 
%%AT-COPY%% Much as the blanket \xcd`at` construct \xcd`at(p)S` is convenient for
%%AT-COPY%% executing a small code body at another place, the blanket \xcd`athome`
%%AT-COPY%% construct \xcd`athome(*) S` 
%%AT-COPY%% (which may be written as simply \xcd`athome S`)
%%AT-COPY%% is convenient for returning a result or two.   The
%%AT-COPY%% preceding example could have been written using blanket statements.
%%AT-COPY%% 
%%AT-COPY%% %~~gen ^^^ Places5f9gblanket
%%AT-COPY%% % package Places5f9gblanket;
%%AT-COPY%% % class Example { 
%%AT-COPY%% % KNOWNFAIL-at
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% static def example(a: Int, mathProc: Place) { 
%%AT-COPY%%   val square : Int;
%%AT-COPY%%   var poly : Int = 1 + a; // will be 1+a+a*a
%%AT-COPY%%   at(mathProc) {
%%AT-COPY%%     val sq = a*a; 
%%AT-COPY%%     athome {
%%AT-COPY%%        square = sq;  // initialization
%%AT-COPY%%        poly += sq;   // read and update
%%AT-COPY%%     }
%%AT-COPY%%   return [square, poly];
%%AT-COPY%%   }
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% %}}
%%AT-COPY%% % class Hook { def run() { 
%%AT-COPY%% %   val e = example(2, here);
%%AT-COPY%% %   assert e(0) == 4 && e(1) == 7;
%%AT-COPY%% %   return true;
%%AT-COPY%% % }} 
%%AT-COPY%% %~~neg
%%AT-COPY%% \end{ex}
%%AT-COPY%% 
%%AT-COPY%% {\bf Design:} It is not fundamentally essential to distinguish \xcd`at` from
%%AT-COPY%% \xcd`athome`.  \xcd`at(p;F)S` could allow writing to variables whose homes are
%%AT-COPY%% known at compile-time to be equal to \xcd`p`.  Indeed, in earlier versions of
%%AT-COPY%% X10, it did so.    This required an idiom in which programmers had to manage
%%AT-COPY%% the home locations of variables directly, and keep track of which home
%%AT-COPY%% location corresponded to which variable.  The \xcd`athome` construct makes
%%AT-COPY%% this idiom more convenient. 
