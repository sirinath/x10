 \chapter{Expressions}\label{XtenExpressions}\index{expression}

\Xten{} has a rich expression language.
Evaluating an expression produces a value, or, in a few cases, no value. 
Expression evaluation may have side effects, such as change of the value of a 
\xcd`var` variable or a data structure, allocation of new values, or throwing
an exception. 



\section{Literals}
\index{literal}

Literals denote fixed values of built-in types. 
The syntax for literals is given in \Sref{Literals}. 

The type that \Xten{} gives a literal often includes its value. \Eg, \xcd`1`
is of type \xcd`Int{self==1}`, and \xcd`true` is of type
\xcd`Boolean{self==true}`.

\section{{\tt this}}
\index{this}
\index{\Xcd{this}}

\begin{bbgrammar}
%(FROM #(prod:Primary)#)
             Primary \: \xcd"this" (\ref{prod:Primary}) \\
                    \| \xcd"this" \\
                    \| ClassName \xcd"." \xcd"this" \\
\end{bbgrammar}


The expression \xcd"this" is a  local \xcd`val` containing a reference
to an instance of the lexically enclosing class.
It may be used only within the body of an instance method, a
constructor, or in the initializer of a instance field -- that is, the places
where there is an instance of the class under consideration.

Within an inner class, \xcd"this" may be qualified with the
name of a lexically enclosing class.  In this case, it
represents an instance of that enclosing class.  


\begin{ex}
\xcd`Outer` is a class containing \xcd`Inner`.  Each instance of
\xcd`Inner` has a reference \xcd`Outer.this` to the \xcd`Outer` involved in its
creation.  \xcd`Inner` has access to the fields of \xcd`Outer.this`, as seen
in the \xcd`outerThree` and \xcd`alwaysTrue` methods.  Note that \xcd`Inner`
has its own \xcd`three` field, which is different from and not even the same
type as \xcd`Outer.this.three`. 
%~~gen ^^^ Expressions10
% package exp.vexp.pexp.lexp.shexp; 
% NOTEST
%~~vis 
\begin{xten}
class Outer {
  val three = 3;
  class Inner {
     val three = "THREE";
     def outerThree() = Outer.this.three;
     def alwaysTrue() = outerThree() == 3;
  }
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}

The type of a \xcd"this" expression is the
innermost enclosing class, or the qualifying class,
constrained by the class invariant and the
method guard, if any.

The \xcd"this" expression may also be used within constraints in
a class or interface header (the class invariant and
\xcd"extends" and \xcd"implements" clauses).  Here, the type of
\xcd"this" is restricted so that only properties declared in the
class header itself, and specifically not any members declared in the class
body or in supertypes, are accessible through \xcd"this".

\section{Local variables}

%##(Id
\begin{bbgrammar}
%(FROM #(prod:Id)#)
                  Id \: identifier & (\ref{prod:Id}) \\
\end{bbgrammar}
%##)

A local variable expression consists simply of the name of the local variable,
field of the current object, formal parameter in scope, etc. It evaluates to
the value of the local variable. 


\begin{ex}
\xcd`n` in the second line below is a local
variable expression.  The \xcd`n` in the first line is not; it is part of a
local variable declaration.
%~~gen  ^^^ Expressions20
% package exp.loc.al.varia.ble; 
% class Example {
% def example() { 
%~~vis
\begin{xten}
val n = 22;
val m = n + 56;
\end{xten}
%~~siv
%} }
%~~neg

\end{ex}

\section{Field access}
\label{FieldAccess}
\index{field!access to}

%##(FieldAccess
\begin{bbgrammar}
%(FROM #(prod:FieldAccess)#)
         FieldAccess \: Primary \xcd"." Id & (\ref{prod:FieldAccess}) \\
                    \| \xcd"super" \xcd"." Id \\
                    \| ClassName \xcd"." \xcd"super"  \xcd"." Id \\
                    \| Primary \xcd"." \xcd"class"  \\
                    \| \xcd"super" \xcd"." \xcd"class"  \\
                    \| ClassName \xcd"." \xcd"super"  \xcd"." \xcd"class"  \\
\end{bbgrammar}
%##)

A field of an object instance may be  accessed
with a field access expression.

The type of the access is the declared type of the field with the
actual target substituted for \xcd"this" in the type. 

\begin{ex}
The declaration of \xcd`b` below has a constraint involving \xcd`this`.  
The use of an instance of it, \xcd`f.b`, has the same constraint involving
\xcd`f` instead of \xcd`this`, as required.
%~~gen ^^^ Expressions5s7v
% package Expressions5s7v;
%~~vis
\begin{xten}
class Fielded {
  public val a : Int = 1;
  public val b : Int{this.a == b} = this.a;
  static def example() {
    val f : Fielded = new Fielded();
    assert f.a == 1 && f.b == 1;
    val fb : Int{fb == f.a} = f.b;
    assert fb == 1;
  }
}
\end{xten}
%~~siv
%class Hook{ def run() {Fielded.example(); return true;}}
%~~neg

\end{ex}
% If the actual
%target is not a final access path (\Sref{FinalAccessPath}),
%an anonymous path is substituted for \xcd"this".

The field accessed is selected from the fields and value properties
of the static type of the target and its superclasses.

If the field target is given by the keyword \xcd"super", the target's type is
the superclass of the enclosing class.  This form is used to access fields of
the parent class shadowed by same-named fields of the current class.

If the field target is \xcd`Cls.super`, then the target's type is \xcd`Cls`,
which must be an  enclosing class.  This (admittedly
obscure) form is used to access fields of an ancestor class which are shadowed
by same-named fields of some more recent ancestor.  

\begin{ex}
This illustrates all four cases of field access.
%~~gen ^^^ Expressions30
% package exp.re.ssio.ns.fiel.dacc.ess;
% NOTEST
%~~vis
\begin{xten}
class Uncle {
  public static val f = 1;
}
class Parent {
  public val f = 2;
}
class Ego extends Parent {
  public val f = 3;
  class Child extends Ego {
     public val f = 4;
     def example() { 
        assert Uncle.f == 1; 
        assert Ego.super.f == 2;
        assert super.f == 3;
        assert this.f == 4;
        assert f == 4;
     }
  }
}
\end{xten}
%~~siv
%class Hook{ def run() {
%  val ego = new Ego();
%  val child = ego.new Child();
%  child.example();
%  return true;
% } }
%~~neg
\end{ex}

If the field target is \xcd"null", a \xcd"NullPointerException"
is thrown.
If the field target is a class name, a static field is selected.
It is illegal to access  a field that is not visible from
the current context.
It is illegal to access a non-static field
through a static field access expression.  However, it is legal to access a
static field through a non-static reference.

\section{Function Literals}
Function literals are described in \Sref{Functions}.

\section{Calls}
\label{Call}
\label{MethodInvocation}
\label{MethodInvocationSubstitution}
\index{invocation}
\index{call}
\index{invocation!method}
\index{call!method}
\index{invocation!function}
\index{call!function}
\index{method!calling}
\index{method!invoking}

%##(MethodInvocation ArgumentList
\begin{bbgrammar}
%(FROM #(prod:MethodInvocation)#)
    MethodInvocation \: MethodPrimaryPrefix \xcd"(" ArgumentList\opt \xcd")" & (\ref{prod:MethodInvocation}) \\
                    \| MethodSuperPrefix \xcd"(" ArgumentList\opt \xcd")" \\
                    \| MethodClassNameSuperPrefix \xcd"(" ArgumentList\opt \xcd")" \\
                    \| MethodName TypeArguments\opt \xcd"(" ArgumentList\opt \xcd")" \\
                    \| Primary \xcd"." Id TypeArguments\opt \xcd"(" ArgumentList\opt \xcd")" \\
                    \| \xcd"super" \xcd"." Id TypeArguments\opt \xcd"(" ArgumentList\opt \xcd")" \\
                    \| ClassName \xcd"." \xcd"super"  \xcd"." Id TypeArguments\opt \xcd"(" ArgumentList\opt \xcd")" \\
                    \| Primary TypeArguments\opt \xcd"(" ArgumentList\opt \xcd")" \\
%(FROM #(prod:ArgumentList)#)
        ArgumentList \: Exp & (\ref{prod:ArgumentList}) \\
                    \| ArgumentList \xcd"," Exp \\
\end{bbgrammar}
%##)


A \grammarrule{MethodInvocation} may be to either a \xcd"static" method, an
instance method, or a closure.


The syntax for method invocations is ambiguous. \xcd`ob.m()` could either be
the invocation of a method named \xcd`m` on object \xcd`ob`, or the
application of a function held in a field \xcd`ob.m`.   If both are defined on
the same class, X10 resolves \xcd`ob.m()` to the invocation of the 
method.  If the application of a function in a field is desired, use
an alternate syntax which makes the intent clear to X10, such as
\xcd`(ob.m)()`. 

\begin{ex}
%~~gen ^^^ Expressions40
% package expres.sio.nsca.lls;
%~~vis
\begin{xten}
class Callsome {
  static val closure : () => Int = () => 1;
  static def method()            = 2;
  static def example() {
     assert Callsome.closure() == 1;
     assert Callsome.method()  == 2;
  } 
}
\end{xten}
%~~siv
% class Hook{ def run() { Callsome.example(); return true; } }
%~~neg
However, adding a static method [mis]named \xcd`closure` makes
\xcd`Callsome.closure()` 
refer to the method, rather than the closure
%~~gen ^^^ Expressions50
% package expres.sio.nsca.lls.twoooo;
% class Callsome {static val closure = () => 1; static def method () = 2; static val methodEvaluated = Callsome.method();
%~~vis
\begin{xten}
  static def closure () = 3;
  static def example() {
     assert Callsome.closure() == 3;
     assert (Callsome.closure)() == 1;
  }
\end{xten}
%~~siv
% }
% class Hook{ def run() { Callsome.example(); return true; }} 
%~~neg
\end{ex}

The application form \xcd`e(f,g)`, when \xcd`e` evaluates to an object or
struct, invokes the application \xcd`operator`, 
defined in the form 
%~~gen ^^^ Expressions2x1f
% package Expressions2x1f;
% class Example[F,G] {
%~~vis
\begin{xten}
public operator this(f:F, g:G) = "value";
\end{xten}
%~~siv
%  }
%~~neg


Method selection rules are given in \Sref{sect:MethodResolution}.

Guard satisfaction depends on the \xcd`STATIC_CHECKS` compiler flag. 
With the flag on,
it is a static error if a method's \grammarrule{Guard} is not statically
satisfied by the 
caller.  
With \xcd`STATIC_CHECKS` off, the guard will be checked at runtime if
necessary. 

\begin{ex}
In this example, a \xcd`DivideBy` object provides the service of dividing
numbers by \xcd`denom` --- so long as \xcd`denom` is not zero. 
X10's strictness of checking this is under control of the \xcd`STATIC_CHECKS`
compiler option (\Sref{sect:Callstyle}).  

With \xcd`STATIC_CHECKS` turned on,  the \xcd`example` method will not
compile.  The call \xcd`this.div(100)`  is not allowed; there is no
guarantee that \xcd`denom != 0`.  Casting \xcd`this` to a type 
whose constraint implies \xcd`denom != 0` permits the method call.

With \xcd`STATIC_CHECKS` turned off, the call will compile.
X10 will insert a dynamic check that the denominator is non-zero, and will
fail at runtime if it is zero.

%~~gen ^^^ Expressions60
%package Expressions.Calls.Guarded.By.Walls;
% // OPTIONS: -STATIC_CALLS
%~~vis
\begin{xten}
class DivideBy(denom:Int) {
  def div(numer:Int){denom != 0} = numer / denom;
  def example() {
     val thisCast = (this as DivideBy{self.denom != 0});
     thisCast.div(100);
     //ERROR (with STATIC_CALLS): this.div(100);  
  }
}
\end{xten}
%~~siv
% class Hook{ def run() { (new DivideBy(1)).example(); return true; } }
%~~neg



\end{ex}


\subsection{{\tt super} calls}
\index{supercall}
\index{call!super}

The expression \xcd`super.f(e1...en)` may appear in an instance method
definition.   This causes the method invocation to be a \xcd`super`
invocation, as described in \Sref{sect:MethodResolution}.  

Informally, suppose the invocation appears in class \xcd`Cl`, which extends
class \xcd`Sup`. An invocation \xcd`this.f()` will call a nullary method named
\xcd`f` that appears in class \xcd`Cl` itself, if there is one.  An invocation
\xcd`super.f()` will call the nullary  \xcd`f` method in \xcd`Sup` or an
ancestor thereof, but not one in \xcd`Cl`.  Note that \xcd`super.f()` may be
used to invoke an \xcd`f` method in \xcd`Sup` which has been shadowed by one
appearing in \xcd`Cl`.  


\section{Assignment}\index{assignment}\label{AssignmentStatement}

%##(Assignment LeftHandSide AssignmentOperator
\begin{bbgrammar}
%(FROM #(prod:Assignment)#)
          Assignment \: LeftHandSide AssignmentOperator AssignmentExp & (\ref{prod:Assignment}) \\
                    \| ExpName  \xcd"(" ArgumentList\opt \xcd")" AssignmentOperator AssignmentExp \\
                    \| Primary  \xcd"(" ArgumentList\opt \xcd")" AssignmentOperator AssignmentExp \\
%(FROM #(prod:LeftHandSide)#)
        LeftHandSide \: ExpName & (\ref{prod:LeftHandSide}) \\
                    \| FieldAccess \\
%(FROM #(prod:AssignmentOperator)#)
  AssignmentOperator \: \xcd"=" & (\ref{prod:AssignmentOperator}) \\
                    \| \xcd"*=" \\
                    \| \xcd"/=" \\
                    \| \xcd"%=" \\
                    \| \xcd"+=" \\
                    \| \xcd"-=" \\
                    \| \xcd"<<=" \\
                    \| \xcd">>=" \\
                    \| \xcd">>>=" \\
                    \| \xcd"&=" \\
                    \| \xcd"^=" \\
                    \| \xcd"|=" \\
\end{bbgrammar}
%##)



The assignment expression \xcd"x = e" assigns a value given by
expression \xcd"e"
to a variable \xcd"x".  
Most often, \xcd`x` is mutable, a \xcd`var` variable.  The same syntax is
used for delayed initialization of a \xcd`val`, but \xcd`val`s can only be
initialized once.
%~~gen ^^^ Expressions70
% package express.ions.ass.ignment;
% class Example {
% static def exasmple() {
%~~vis
\begin{xten}
  var x : Int;
  val y : Int;
  x = 1;
  y = 2; // Correct; initializes y
  x = 3; 
  // ERROR: y = 4;
\end{xten}
%~~siv
% } } 
%~~neg


There are three syntactic forms of
assignment: 
\begin{enumerate}
\item \xcd`x = e;`, assigning to a local variable, formal parameter, field of
      \xcd`this`, etc. 
\item \xcd`x.f = e;`, assigning to a field of an object.
\item \xcdmath`a(i$_1$,$\ldots$,i$_n$) = v;`, where {$n \ge 0$}, assigning to
      an element of an array or some other such structure. This is an operator
      call (\Sref{sect:operators}).  For well-behaved classes it works like
      array assignment, mutatis mutandis, but there is no actual guarantee,
      and the compiler makes no assumptions about how this works for arbitrary \xcd`a`.
      Naturally, it is a static error if no suitable assignment operator
      for \xcd`a`.
\end{enumerate}

For a binary operator $\diamond$, the $\diamond$-assignment expression
\xcdmath"x $\diamond$= e" combines the current value of \xcd`x` with the value
of \xcd`e` by {$\diamond$}, and stores the result back into \xcd`x`.  
\xcd`i += 2`, for example, adds 2 to \xcd`i`. For variables and fields, 
\begin{xtenmath}
x $\diamond$= e 
\end{xtenmath}
behaves just like 
\begin{xtenmath}
x = x $\diamond$ e.
\end{xtenmath}

The subscripting forms of \xcdmath"a(i) $\diamond$= b" are slightly subtle.
Subexpressions of \xcd`a` and \xcd`i` are only evaluated once.  However,
\xcd`a(i)` and \xcd`a(i)=c` are each executed once---in particular, there is
one call to the application operator, and one to the assignment operator.
If subscripting is implemented strangely for
the class of \xcd`a`, the behavior is {\em not} necessarily updating a single
storage location. Specifically, \xcd`A()(I()) += B()` is tantamount to: 
%~~gen ^^^ Expressions80
% package expressions.stupid.addab;
% class Example {
% def example(A:()=>Rail[Int], I: () => Int, B: () => Int ) {
%~~vis
\begin{xten}
{
  val aa = A();  // Evaluate A() once
  val ii = I();  // Evaluate I() once
  val bb = B();  // Evaluate B() once
  val tmp = aa(ii) + bb; // read aa(ii)
  aa(ii) = tmp;  // write sum back to aa(ii)
}
\end{xten}
%~~siv
%}}
%~~neg

\section{Increment and decrement}
\index{increment}
\index{decrement}
\index{\Xcd{++}}
\index{\Xcd{--}}


The operators \xcd"++" and \xcd"--" increment and decrement
a variable, respectively.  
\xcd`x++` and \xcd`++x` both increment \xcd`x`, just as the statement 
\xcd`x += (1 as T)` would (where \xcd`x:T`), and similarly for \xcd`--`.  

The difference between the two is the return value.  
\xcd`++x` and \xcd`--x` return the {\em new} value of \xcd`x`, after
incrementing or decrementing.
\xcd`x++` and \xcd`x--` return the {\em old} value of \xcd`x`, before
incrementing or decrementing.

These operators work for any \xcd`x` for which \xcd`1 as T` is defined, where
\xcd`T` is the type of \xcd`x`.  


\section{Numeric Operations}
\label{XtenPromotions}
\index{promotion}
\index{numeric promotion}
\index{numeric operations}
\index{operation!numeric}

Numeric types (\xcd`Byte`, \xcd`Short`, \xcd`Int`, \xcd`Long`, \xcd`Float`,
\xcd`Double`, \xcd`Complex`, and unsigned variants of fixed-point types) are normal X10
structs, though most of their methods are implemented via native code. They
obey the same general rules as other X10 structs. For example, numeric
operations, coercions, and conversions are defined by \xcd`operator` definitions, the same way you could
for any struct.

Promoting a numeric value to a longer numeric type preserves the sign of the
value.  For example, \xcd`(255 as UByte) as UInt` is 255. 

Most of these operations can be defined on user-defined types as well.  While
it is good practice to keep such operations consistent with the numeric
operations whenever possible, the compiler neither enforces nor assumes any
particular semantics of user-defined operations. 

\subsection{Conversions and coercions}

Specifically, each numeric type can be converted or coerced into each other
numeric type, perhaps with loss of accuracy.
%~~gen ^^^ Expressions90
% package exp.ress.io.ns.numeric.conversions;
% class ExampleOfConversionAndStuff {
% def example() {
%~~vis
\begin{xten}
val n : Byte = 123 as Byte; // explicit 
val f : (Int)=>Boolean = (Int) => true; 
val ok = f(n); // implicit
\end{xten}
%~~siv
% } }
%~~neg



\subsection{Unary plus and unary minus}

The unary \xcd`+` operation on numbers is an identity function.
The unary \xcd`-` operation on numbers is a negation function.
On unsigned numbers, these are two's-complement.  For example, 
\xcd`-(0x0F as UByte)` is 
\xcd`(0xF1 as UByte)`.
\bard{UInts and such are closed under negation -- the negative of a UInt is
done binarily.  }



\section{Bitwise complement}

The unary \xcd"~" operator, only defined on integral types, complements each
bit in its operand.  

\section{Binary arithmetic operations} 

The binary arithmetic operators perform the familiar binary arithmetic
operations: \xcd`+` adds, \xcd`-` subtracts, \xcd`*` multiplies, 
\xcd`/` divides, and \xcd`%`
computes remainder.

On integers, the operands are coerced to the longer of their two types, and
then operated upon.  
Floating point operations are determined by the IEEE 754
standard. 
The integer \xcd"/" and \xcd"%" throw an exception 
if the right operand is zero.



\section{Binary shift operations}

The operands of the binary shift operations must be of integral type.
The type of the result is the type of the left operand.
The right operand, describing a number of bits, must be unsigned: 
%~~exp~~`~~`~~ x:Int ~~ ^^^Expressions1l4m
\xcd`x << 1U`.  


If the promoted type of the left operand is \xcd"Int",
the right operand is masked with \xcd"0x1f" using the bitwise
AND (\xcd"&") operator, giving a number at most the number of bits in an
\xcd`Int`. 
If the promoted type of the left operand is \xcd"Long",
the right operand is masked with \xcd"0x3f" using the bitwise
AND (\xcd"&") operator, giving a number at most the number of bits in a
\xcd`Long`. 

The \xcd"<<" operator left-shifts the left operand by the number of
bits given by the right operand.
The \xcd">>" operator right-shifts the left operand by the number of
bits given by the right operand.  The result is sign extended;
that is, if the right operand is $k$,
the most significant $k$ bits of the result are set to the most
significant bit of the operand.

The \xcd">>>" operator right-shifts the left operand by the number of
bits given by the right operand.  The result is not sign extended;
that is, if the right operand is $k$,
the most significant $k$ bits of the result are set to \xcd"0".
This operation is deprecated, and may be removed in a later version of the
language. 


\section{Binary bitwise operations}

The binary bitwise operations operate on integral types, which are promoted to
the longer of the two types.
The \xcd"&" operator  performs the bitwise AND of the promoted operands.
The \xcd"|" operator  performs the bitwise inclusive OR of the promoted operands.
The \xcd"^" operator  performs the bitwise exclusive OR of the promoted operands.

\section{String concatenation}
\index{string!concatenation}

The \xcd"+"  operator is used for string concatenation 
 as well as addition.
If either operand is of static type \xcd"x10.lang.String",
 the other operand is converted to a \xcd"String" , if needed,
  and  the two strings  are concatenated.
 String conversion of a non-\xcd"null" value is  performed by invoking the
 \xcd"toString()" method of the value.
  If the value is \xcd"null", the value is converted to 
  \xcd'"null"'.

The type of the result is \xcd"String".

 For example, 
%~~exp~~`~~`~~ ~~ ^^^ Expressions100
      \xcd`"one " + 2 + here` 
      evaluates to  \xcd`one 2(Place 0)`.  

\section{Logical negation}

The operand of the  unary \xcd"!" operator 
must be of type \xcd"x10.lang.Boolean".
The type of the result is \xcd"Boolean".
If the value of the operand is \xcd"true", the result is \xcd"false"; if
if the value of the operand  is \xcd"false", the result is \xcd"true".

\section{Boolean logical operations}

Operands of the binary boolean logical operators must be of type \xcd"Boolean".
The type of the result is \xcd"Boolean"

The \xcd"&" operator  evaluates to \xcd"true" if both of its
operands evaluate to \xcd"true"; otherwise, the operator
evaluates to \xcd"false".

The \xcd"|" operator  evaluates to \xcd"false" if both of its
operands evaluate to \xcd"false"; otherwise, the operator
evaluates to \xcd"true".

\section{Boolean conditional operations}

Operands of the binary boolean conditional operators must be of type
\xcd"Boolean". 
The type of the result is \xcd"Boolean"

The \xcd"&&" operator  evaluates to \xcd"true" if both of its
operands evaluate to \xcd"true"; otherwise, the operator
evaluates to \xcd"false".
Unlike the logical operator \xcd"&",
if the first operand is \xcd"false",
the second operand is not evaluated.

The \xcd"||" operator  evaluates to \xcd"false" if both of its
operands evaluate to \xcd"false"; otherwise, the operator
evaluates to \xcd"true".
Unlike the logical operator \xcd"||",
if the first operand is \xcd"true",
the second operand is not evaluated.

\section{Relational operations} 

The relational operations on numeric types compare numbers, producing
\xcd`Boolean` results.

The \xcd"<" operator evaluates to \xcd"true" if the left operand is
less than the right.
The \xcd"<=" operator evaluates to \xcd"true" if the left operand is
less than or equal to the right.
The \xcd">" operator evaluates to \xcd"true" if the left operand is
greater than the right.
The \xcd">=" operator evaluates to \xcd"true" if the left operand is
greater than or equal to the right.

Floating point comparison is determined by the IEEE 754
standard.  Thus,
if either operand is NaN, the result is \xcd"false".
Negative zero and positive zero are considered to be equal.
All finite values are less than positive infinity and greater
than negative infinity.



\section{Conditional expressions}
\index{\Xcd{? :}}
\index{conditional expression}
\index{expression!conditional}
\label{Conditional}

%##(ConditionalExp
\begin{bbgrammar}
%(FROM #(prod:ConditionalExp)#)
      ConditionalExp \: ConditionalOrExp & (\ref{prod:ConditionalExp}) \\
                    \| ClosureExp \\
                    \| AtExp \\
                    \| FinishExp \\
                    \| ConditionalOrExp \xcd"?" Exp \xcd":" ConditionalExp \\
\end{bbgrammar}
%##)

A conditional expression evaluates its first subexpression (the
condition); if \xcd"true"
the second subexpression (the consequent) is evaluated; otherwise,
the third subexpression (the alternative) is evaluated.

The type of the condition must be \xcd"Boolean".
The type of the conditional expression is some common 
ancestor (as constrained by \Sref{LCA}) of the types of the consequent and the
alternative. 

\begin{ex}
%~~exp~~`~~`~~a:Int,b:Int ~~ ^^^ Expressions110
\xcd`a == b ? 1 : 2`
evaluates to \xcd`1` if \xcd`a` and \xcd`b` are the same, and \xcd`2` if they
are different.   As the type of \xcd`1` is \xcd`Int{self==1}` and of \xcd`2`
is \xcd`Int{self==2}`, the type of the conditional expression has the form
\xcd`Int{c}`, where \xcd`self==1` and \xcd`self==2` both imply \xcd`c`.  For
example, it might be \xcd`Int{true}` -- or perhaps it might be 
\xcd`Int{self != 8}`. Note that this term has no most accurate type in the X10
type system.
\end{ex}

The subexpression not selected is not evaluated.

\begin{ex}
The following use of the conditional expression prevents division by zero.  If
\xcd`den==0`, the division is not performed at all.
%~~gen ^^^ Expressions4t3m
% package Expressions4t3m;
% class Hook {
% static def example(num:Int, den:Int ) =
%~~vis
\begin{xten}
(den == 0) ? 0 : num/den
\end{xten}
%~~siv
%; 
% def run() { 
%   return example(1,0) == 0 && example(6,3) == 2;
% } }
%~~neg

Similarly, the following code performs a method call if \xcd`op` is non-null,
and avoids the null pointer error if it is null.  Defensive coding like this
is quite common when working with possibly-null objects.
%~~gen ^^^ Expressions6o2b
% package Expressions6o2b;
% class Hook { 
% static def example(ob:Object) = 
%~~vis
\begin{xten}
(ob == null) ? null : ob.toString();
\end{xten}
%~~siv
%def run() {
%  return example(null) == null && example("yes").equals("yes"); 
% } } 
%~~neg



\end{ex}

\section{Stable equality}
\label{StableEquality}
\index{\Xcd{==}}
\index{equality}

\begin{bbgrammar}
 EqualityExp    \: RelationalExp & (\ref{prod:EqualityExp})\\
%<FROM #(prod:EqualityExp)#
    \| EqualityExp \xcd"==" RelationalExp\\
    \| EqualityExp \xcd"!=" RelationalExp\\
    \| Type  \xcd"==" Type \\
\end{bbgrammar}


The \xcd"==" and \xcd"!=" operators provide a fundamental, though
non-abstract, notion of equality.  \xcd`a==b` is true if the values of \xcd`a`
and \xcd`b` are extremely identical.

\begin{itemize}
\item If \xcd`a` and \xcd`b` are values of object type, then \xcd`a==b` holds
      if \xcd`a` and \xcd`b` are the same object.
\item If one operand is \xcd`null`, then \xcd`a==b` holds iff the other is
      also \xcd`null`.
\item If the operands both have struct type and are not in \xcd`x10.lang`, then they must be structurally equal;
that is, they must be instances of the same struct
and all their fields or components must be \xcd"==".   



\item The definition of equality for function types is specified in
      \Sref{FunctionEquality}.
\item No implicit coercions are performed by \xcd`==`.  
\item It is a static error to have an expression \xcd`a == b` if the types of
      \xcd`a` and \xcd`b` are disjoint.  

\item The structs in \xcd`x10.lang` have unsurprising concepts of \xcd`==`: 
     \begin{itemize}
     \item In \xcd`Boolean`, \xcd`true == true` and \xcd`false == false`. 
     \item In \xcd`Char`, \xcd`c == d` iff \xcd`c.ord() == d.ord()`.
     \item Equality in \xcd`Double` and \xcd`Float` is IEEE floating-point
           equality. 
     \item Two \xcd`GlobalRef`s are \xcd`==` if they refer to the same object.
     \item The integral types, \xcd`Byte`, \xcd`Short`, \xcd`Int`, \xcd`Long`,
           and their unsigned versions, use binary equality.
     \end{itemize}

\end{itemize}

\xcd`a != b`
is true iff \xcd`a==b` is false.

The predicates \xcd"==" and \xcd"!=" may not be overridden by the programmer.

\xcd`==` provides a {\em stable} notion of equality.  If two values are
\xcd`==` at any time, they remain \xcd`==` forevermore, regardless of what
happens to the mutable state of the program. 

\begin{ex}
Regardless of the values and types of \xcd`a` and \xcd`b`, 
or the behavior of \xcd`any_code_at_all` (which may, indeed, be
any code at all---not just a method call), the value of 
\xcd`a==b` does not change: 
%~~gen ^^^ Expressions1i5k
% package Expressions1i5k;
% class Example{ 
% def example( something: ()=>Int, something_else: ()=>Int,
%   any_code_at_all: () => Int) {
%~~vis
\begin{xten}
val a = something();
val b = something_else();
val eq1 = (a == b);
any_code_at_all();
val eq2 = (a == b);
assert eq1 == eq2;
\end{xten}
%~~siv
%} } 
%~~neg
\end{ex}



\subsection{No Implicit Coercions}
\label{sect:eqeq-no-coerce}

\xcd`==` is a primitive operation in X10 -- one of very few. Most operations,
like \xcd`+` and \xcd`<=`, are defined as \xcd`operator`s. \xcd`==` and
\xcd`!=` are not. As non-\xcd`operator`s, they need not and do not follow the
general method resolution procedure of \Sref{sect:MethodResolution}. In
particular, while \xcd`operator`s perform implicit conversions on their
arguments, \xcd`==` and \xcd`!=` do not.

The advantage of this restriction is that \xcd`==`'s behavior is as simple and
efficient as possible.  It never runs user-defined code, and the compiler can
analyze and understand it in detail -- and guarantee that it is efficient.

The disadvantage is that certain straightforward-looking idioms do not work.
One may not test that a \xcd`Long` variable is \xcd`==` to an integer like
\xcd`0`: 
%~~gen ^^^ Expressions6q7k
% package Expressions6q7k;
% // NOTEST-https://jira.codehaus.org/browse/XTENLANG-2624
% class Example{ static def example() { 
%~~vis
\begin{xten}
//ERROR: for(var i : Long = 0; i != 100; i++)  {}
\end{xten}
%~~siv
%} } 
%~~neg





A \xcd`Long` like \xcd`i` can never \xcd`==` an \xcd`Int` like \xcd`100`.

We can write \xcd`i = i + 1;`, adding an \xcd`Int` to \xcd`i`. This works 
because the expression uses \xcd`+`,  an ordinary \xcd`operator`.
There is an implicit coercion from \xcd`Int` to \xcd`Long`, so the
\xcd`1` can be converted to \xcd`1L`, which can be added to \xcd`i`.  

However, \xcd`==` does not permit implicit coercions, and so the \xcd`100`
stays an \xcd`Int`.  The loop must be written with a comparison of two
\xcd`Long`s: 
%~~gen ^^^ Expressions4u6l
% package Expressions4u6l;
% class Example{ def example() { 
%~~vis
\begin{xten}
for(var i : Long = 0; i != 100L; i++) {}
\end{xten}
%~~siv
%} }
%~~neg




Incidentally, it could also be written 
%~~gen ^^^ Expressions5l5l5
% package Expressions5l5l5;
% class Example{ def example() { 
%~~vis
\begin{xten}
for(var i : Long = 0; i <= 100; i++) {}
\end{xten}
%~~siv
%} }
%~~neg

\begin{xten}

\end{xten}
The operation \xcd`<=` is a regular operator, and thus uses coercions in its
arguments, so \xcd`100` gets coerced to \xcd`100L`.  

\subsection{Non-Disjointness Requirement}

It is a static error to have an expression \xcd`a==b` where \xcd`a` and
\xcd`b` could not possibly be equal, based on their types.  This is a
practical codicil to \Sref{sect:eqeq-no-coerce}.  Consider the illegal code 
\begin{xten}
// NOT ALLOWED
for(var i : Long = 0; i != 100; i++) 
\end{xten}

\xcd`100` and \xcd`100L` are different values; they are not \xcd`==`. A
coercion could make them equal, but \xcd`==` does not allow coercions. So, if
\xcd`100 == 100L` were going to return anything, it would have to return
\xcd`false`. This would have the unfortunate effect of making the \xcd`for`
loop run forever.

Since this and related idioms are so common, and since so many programmers are
used to languages which are less precise about their numeric types, X10 avoids
the mistake by declaring it a static error in most cases.  Specifically,
\xcd`a==b` is not allowed if, by inspection of the types, \xcd`a` and \xcd`b`
could not possibly be equal.

\begin{ex}
Nonetheless, it is possible to wind up comparing values of different numeric
types.   Even though, say, \xcd`0` and \xcd`0L` represent the same number,
they are different values and of different types, and hence, \xcd`0 != 0L`.  
The expression \xcd`0 == 0L` does not compile.  However, if you hide type
information from X10, you can get a similar expression to compile: 

%~~gen ^^^ Expressions1x7i
% package Expressions1x7i;
% class Example { static def example() { 
%~~vis
\begin{xten}
   val a : Any = 0;
   val b : Any = 0L;
   assert a != b;
\end{xten}
%~~siv
% } } 
% class Hook{ def run() { Example.example(); return true; } } 
%~~neg


\end{ex}


\begin{itemize}

\item Numbers of different base types cannot be equal, and thus cannot compared for equality.  
\xcd`100==100L` is a static error.  To compare numbers, explicitly cast them
%~~exp~~`~~`~~ ~~ ^^^Expressions2g6f
to the same type: \xcd`100 as Long == 100L`.

\item Indeed, structs of different types cannot be equal, and so they cannot be
compared for equality.  

\item For objects, the story is different. Unconstrained object types can
      always be compared for equality. Given objects of unrelated classes
      \xcd`a:Person` and 
      \xcd`b:Theory`, \xcd`a==b` could be true if \xcd`a==null` and
      \xcd`b==null`. 

\item Constrained object types may or may not be comparable.  For example,  
      if \xcd`Person` and \xcd`Theory` are both direct subclasses of
      \xcd`Object`, and \xcd`a:Person` and \xcd`b:Theory{self!=null}`, then
      \xcd`a==b` is not allowed, since the two could not possibly be equal.

\item Explicit casts erase type information.  If you wanted
      to have a comparison \xcd`a==b` for \xcd`a:Person{self!=null}` and
      \xcd`b:Theory`, you could write it as \xcd`a as Object == b as Object`.
      It would, of course, return \xcd`false`, but it would not be a compiler
      error.\footnote{Code generators often find this trick too be useful.}
      A struct and an object may both be cast to \xcd`Any` and compared for
      equality, though they, too, will always be different.

\end{itemize}





\section{Allocation}
\label{ClassCreation}
\index{new}
\index{allocation}
\index{class!instantation}
\index{class!construction}
\index{struct!instantation}
\index{struct!construction}
\index{instantation}

%##(ClassInstCreationExp
\begin{bbgrammar}
%(FROM #(prod:ClassInstCreationExp)#)
ClassInstCreationExp \: \xcd"new" TypeName TypeArguments\opt \xcd"(" ArgumentList\opt \xcd")" ClassBody\opt & (\ref{prod:ClassInstCreationExp}) \\
                    \| \xcd"new" TypeName \xcd"[" Type \xcd"]" \xcd"[" ArgumentList\opt \xcd"]" \\
                    \| Primary \xcd"." \xcd"new" Id TypeArguments\opt \xcd"(" ArgumentList\opt \xcd")" ClassBody\opt \\
                    \| AmbiguousName \xcd"." \xcd"new" Id TypeArguments\opt \xcd"(" ArgumentList\opt \xcd")" ClassBody\opt \\
\end{bbgrammar}
%##)

An allocation expression creates a new instance of a class and
invokes a constructor of the class.
The expression designates the class name and passes
type and value arguments to the constructor.

The allocation expression may have an optional class body.
In this case, an anonymous subclass of the given class is
allocated.   An anonymous class allocation may also specify a
single super-interface rather than a superclass; the superclass
of the anonymous class is \xcd"x10.lang.Object".

If the class is anonymous---that is, if a class body is
provided---then the constructor is selected from the superclass.
The constructor to invoke is selected using the same rules as
for method invocation (\Sref{MethodInvocation}).

The type of an allocation expression
is the return type of the constructor invoked, with appropriate
substitutions  of actual arguments for formal parameters, as
specified in \Sref{MethodInvocationSubstitution}.

It is illegal to allocate an instance of an \xcd"abstract" class.
The usual visibility rules apply to allocations: 
it is illegal to allocate an instance of a class or to invoke a
constructor that is not visible at
the allocation expression.

Note that instantiating a struct type can use function application syntax; 
\xcd`new` is optional.  As structs do not have subclassing, there is no need or
possibility of a {\em ClassBody}.


\section{Casts and Conversions}\label{ClassCast}\index{cast}
\index{type conversion}


%##(CastExp
\begin{bbgrammar}
%(FROM #(prod:CastExp)#)
             CastExp \: Primary & (\ref{prod:CastExp}) \\
                    \| ExpName \\
                    \| CastExp \xcd"as" Type \\
\end{bbgrammar}
%##)


The cast and conversion  operation \xcd`e as T` may be used to force an
expression into a given type \xcd`T`, 
if is permissible at run time, and either a compile-time error or a runtime
exception 
(\xcd`x10.lang.TypeCastException`) if it is not.  


The \xcd`e as T` operation comes in two forms.  Which form applies depends on
both the source type (the type of \xcd`e`) and the target type \xcd`T`.
\begin{itemize}
\item {\bf Cast:} A cast makes a value have a different type, without changing
      the value's identity.  For example, \xcd`"a String" as Object` simply
      reconsiders the \xcd`String` object as an \xcd`Object`.  
      This cast does not need to do any 
      run-time computation, since every \xcd`String` is an \xcd`Object`; a
      cast in the reverse direction, from \xcd`Object` to \xcd`String`, would
      need a run-time check that the \xcd`Object`
      was in fact a \xcd`String`.
      Casts are all system-defined, following from the
      X10 type system.
\item {\bf Conversions:} A conversion takes a value of one type and produces
      one of a different type which, conceptually, means the same thing.  
      For example, \xcd`1 as Float` is a conversion.  It performs some
      computation on \xcd`1`  to come up with a \xcd`Float` value.
      Conversions are all library- or user-defined.  
\end{itemize}

\subsection{Casts}

A cast \xcd`v as T2` re-imagines a value \xcd`v` of one type \xcd`T1` as being
a value of another 
type \xcd`T2`.  The
value itself does not change, nor is a new value computed.  The only
run-time computation that happens is to check that \xcd`v` is indeed a value
of type \xcd`T2` (which, in many cases, is unnecessary), and auto-boxing (\Sref{auto-boxing}).

There are two forms of casts.  {\em Upcasts} happen when \xcd`T1 <: T2`, that
is, when a value is being cast to a more general type.  Upcasts often don't require
any runtime computation at all, since, if \xcd`T1 <: T2 <: Object`, every value of type
\xcd`T1` is automatically one of type \xcd`T2`.   For example, 
\xcd`"A String" as Object` is an upcast: every \xcd`String` is already an
\xcd`Object`, and no work need be done to make it one.  Other upcasts may
require auto-boxing, such as \xcd`1 as Any`.  

{\em Downcasts} are casts which are not upcasts.  Often they are recasting
something from a more general to a more specific type: 
%~~gen ^^^ Expressions3e9h
% package Expressions3e9h;
% class Example { static def example() { 
%~~vis
\begin{xten}
   val ob : Object = "a String" as Object; // upcast
   val st : String = ob as String;         // downcast
   assert st == ob;
\end{xten}
%~~siv
% } } 
% class Hook{ def run() { Example.example(); return true;} } 
%~~neg
 
Casts that cross the type hierarchy laterally are also called downcasts.  In
the following example, \xcd`Snack` and \xcd`Crunchy` are unrelated interfaces:
neither inherits from the other.  Some objects are both; some are one but not
the other.  Casting from a \xcd`Crunchy` to a \xcd`Snack` requires confirming
that the value being cast is indeed a \xcd`Snack`.  
%~~gen ^^^ Expressions3g5x
% package Expressions3g5x;
%~~vis
\begin{xten}
interface Snack {}
interface Crunchy {} 
class Pretzel implements Snack, Crunchy{}
class Apricot implements Snack{}
class Gravel  implements Crunchy{}
class Example{
  def example(crunchy : Crunchy) { 
    if (crunchy instanceof Snack) { 
       val snack = crunchy as Snack; 
    } } } 
\end{xten}
%~~siv
%
%~~neg

An upcast \xcd`v as T2` requires no computation.  
A downcast \xcd`v as T2` requires testing that \xcd`v` really is a value of
type \xcd`T2`.  In either case, the cast returns the value \xcd`v`; casts do
not change value identity.


When evaluating \xcd`E as T{c}`, first the value of \xcd`E` is converted to
type \xcd`T` (which may fail), and then the constraint \xcd`{c}` is checked
(which may also fail). 



\begin{itemize}
      
\item If \xcd`T` is a class, then the first half of the cast succeeds if the
      run-time value of \xcd`E` is an instance of class \xcd`T`, or of a
      subclass. 

\item If \xcd`T` is an interface, then the first half of the cast succeeds if
      the run-time value of \xcd`E` is an instance of a class or struct
      implementing 
      \xcd`T`. 

\item If \xcd`T` is a struct type, then the first half of the cast succeeds if
      the run-time value of \xcd`E` is an instance of \xcd`T`.  

\item If \xcd`T` is a function type, then the first half of the cast succeeds
      if the run-time value of \xcd`X` is a function of that type, or an
      object or struct which implements it.
\end{itemize}

If the first half of the cast succeeds, the second half -- the constraint
\xcd`{c}` -- must be checked.  In general this will be done at runtime, though
in special cases it can be checked at compile time.   For example, 
\xcd`n as Int{self != w}` succeeds if \xcd`n != w` --- even if \xcd`w` is a value
read from input, and thus not determined at compile time.

The compiler may forbid casts that it knows cannot possibly work. If there is
no way for the value of \xcd`E` to be of type \xcd`T{c}`, then 
\xcd`E as T{c}` can result in a static error, rather than a runtime error.  
For example, \xcd`1 as Int{self==2}` may fail to compile, because the compiler
knows that \xcd`1`, which has type \xcd`Int{self==1}`, cannot possibly be of
type \xcd`Int{self==2}`. 

\subsection{Explicit Conversions}

Explicit conversions are written with the same syntax as casts: \xcd`v as T2`.  
Explicit conversions transform a value of one type \xcd`T1` to an unrelated
type \xcd`T2`.  Unlike casts, conversions {\em do} execute code, and {\em may}
(and generally do) return new values.  

Explicit conversions do not arise spontaneously, as casts do. They may be
programmed directly, using the \xcd`operator` syntax of \Sref{sect:type-conv}.  
Implicit coercions can also be called explicitly as conversions.  (The reverse
is not true -- explicit conversions cannot be used as implicit conversions.) 

The numeric types in \xcd`x10.lang` have explicit conversions, as described in
\Sref{sec:effects-of-explicit-numeric-coercions}.  These conversions enable 
\xcd`1 as Float` and the like.  

\begin{ex}
\xcd`Knot`s have an explicit conversion operator to \xcd`String`, and an
implicit coercion to \xcd`Int`.  Note that the implicit coercion can be used
explicitly, with \xcd`k as Int`, as well as implicitly in \xcd`Math.abs(k)`. 
%~~gen ^^^ Expressions7e1e
% package Expressions7e1e;
%KNOWNFAIL
%~~vis
\begin{xten}
class Knot(s:String) { 
  // explicit conversion
  public static operator (x:Knot) as String = x.s + "!";
  // implicit coercion
  public static operator (x:Knot) : Int = x.s.length();
  public static def example() {
     val k = new Knot("frayed");
     assert "frayed!".equals(k as String);
     assert (k as Int) == 6;
     assert Math.abs(k) == 6; 
  }
}
\end{xten}
%~~siv
% class Hook{ def run() { Knot.example(); return true; } } 
%~~neg

\end{ex}




\subsection{Resolving Ambiguity}
\label{sect:ambig-cast}

If \xcd`v as T` could either be a cast or an explicit coercion, X10 treats its
as a cast.  If the explicit conversion is desired, use the unambiguous syntax
for the explicit conversion (\Sref{sect:type-conv}).

\begin{ex}
The \xcd`Thing` class provides an explicit conversion to \xcd`Object`.
However, since \xcd`Thing` is a subclass of \xcd`Object`, 
using the \xcd`as` operator invokes the upcast, rather than the explicit
conversion.  
%~~gen ^^^ Expressions7s3n
% package Expressions7s3n;
%~~vis
\begin{xten}
class Thing {
  public static operator (x:Thing) as Object = "different";
  public static def example() {
    val t = new Thing();
    val o = t as Object;
    assert o instanceof Thing;
  }
}
\end{xten}
%~~siv
% //    val p = Thing.operator as[Object](t);
% //    assert p.equals("very different");
% class Hook{ def run() { Thing.example(); return true; } }
%~~neg
The definition of an explicit conversion in this case is of little value,
since any use of it in the \xcd`t as Object` syntax will invoke the upcast.  
\end{ex}

\section{\Xcd{instanceof}}
\label{instanceOf}
\index{\Xcd{instanceof}}
\index{instanceof}

\Xten{} permits types to be used in an in instanceof expression
to determine whether an object is an instance of the given type:

%##(RelationalExp
\begin{bbgrammar}
%(FROM #(prod:RelationalExp)#)
       RelationalExp \: RangeExp & (\ref{prod:RelationalExp}) \\
                    \| SubtypeConstraint \\
                    \| RelationalExp \xcd"<" RangeExp \\
                    \| RelationalExp \xcd">" RangeExp \\
                    \| RelationalExp \xcd"<=" RangeExp \\
                    \| RelationalExp \xcd">=" RangeExp \\
                    \| RelationalExp \xcd"instanceof" Type \\
\end{bbgrammar}
%##)

In the above expression, \grammarrule{Type} is any type. At run time, the
result of \xcd`e instanceof T`
is \xcd"true" if the
value of \xcd`e` is an instance of type \xcd`T`.
Otherwise the result is \xcd"false". This determination may involve checking
that the constraint, if any, associated with the type is true for the given
expression.

%~~exp~~`~~`~~x:Int~~ ^^^ Expressions120
For example, \xcd`3 instanceof Int{self==x}` is an overly-complicated way of
saying \xcd`3==x`.


However, it is a static error if \xcd`e` cannot possibly be an instance of
\xcd`C{c}`; the compiler will reject \xcd`1 instanceof Int{self == 2}` because
\xcd`1` can never satisfy \xcd`Int{self == 2}`. Similarly, \Xcd{1 instanceof
String} is a static error, rather than an expression always returning false. 

\limitationx
X10 does not currently handle \xcd`instanceof` of generics in the way you
%~NO~exp~~`~~`~~r:Array[Int](1) ~~
might expect.  For example, \xcd`r instanceof Array[Int{self != 0}]` does
not test that every element of \xcd`r` is non-zero; instead, the compiler
rejects it.


\section{Subtyping expressions}
\index{\Xcd{<:}}
\index{\Xcd{:>}}
\index{subtype!test}


%##(SubtypeConstraint
\begin{bbgrammar}
%(FROM #(prod:SubtypeConstraint)#)
   SubtypeConstraint \: Type  \xcd"<:" Type  & (\ref{prod:SubtypeConstraint}) \\
                    \| Type  \xcd":>" Type  \\
\end{bbgrammar}
%##)

The subtyping expression \xcdmath"T$_1$ <: T$_2$" evaluates to \xcd"true" if
\xcdmath"T$_1$" is a subtype of \xcdmath"T$_2$".

The expression \xcdmath"T$_1$ :> T$_2$" evaluates to \xcd"true" if
\xcdmath"T$_2$" is a subtype of \xcdmath"T$_1$".

The expression \xcdmath"T$_1$ == T$_2$"
evaluates to  \xcd"true" if 
\xcdmath"T$_1$" is a subtype of \xcdmath"T$_2$" and
if \xcdmath"T$_2$" is a subtype of \xcdmath"T$_1$".

\begin{ex}
Subtyping expressions are particularly useful in giving constraints on generic
types.  \xcd`x10.util.Ordered[T]` is an interface whose values can be compared
with values of type \xcd`T`. 
In particular, \xcd`T <: x10.util.Ordered[T]` is
true if values of type \xcd`T` can be compared to other values of type
\xcd`T`.  So, if we wish to define a generic class \xcd`OrderedList[T]`, of
lists whose elements are kept in the right order, we need the elements to be
ordered.  This is phrased as a constraint on \xcd`T`: 
%~~gen ^^^ Expressions130
% package expre.ssi.onsfgua.rde.dq.uantification;
%~~vis
\begin{xten}
class OrderedList[T]{T <: x10.util.Ordered[T]} {
  // ...
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}


%%NOIN%% \section{Contains expressions}
%%NOIN%% \index{in}
%%NOIN%% 
%%NOIN%% \begin{bbgrammar}
%%NOIN%%        RelationalExp \:RelationalExp \xcd"in" ShiftExp & (\ref{prod:RelationalExp}) \\
%%NOIN%% \end{bbgrammar}
%%NOIN%% 
%%NOIN%% \xcd`in` is a binary operator, definable in \Sref{sect:operators}.  It is
%%NOIN%% conventionally used for checking containment.
%%NOIN%% 
%%NOIN%% \begin{ex}
%%NOIN%% The built-in type \xcd`Region` provides \xcd`in`, testing whether a
%%NOIN%% \xcd`Point` is in the region: 
%%NOIN%% %~x~gen ^^^ Expressions6d2z
%%NOIN%% % package Expressions6d2z;
%%NOIN%% % class Hook { def run() {
%%NOIN%% %~x~vis
%%NOIN%% \begin{xten}
%%NOIN%% assert 3 in 1..10;
%%NOIN%% assert !(10 in 1..3);
%%NOIN%% \end{xten}
%%NOIN%% %~x~siv
%%NOIN%% % return true;
%%NOIN%% %}}
%%NOIN%% %~x~neg
%%NOIN%% 
%%NOIN%% Other types can provide them as well:
%%NOIN%% %~x~gen ^^^ Expressions3c4m
%%NOIN%% % package Expressions3c4m;
%%NOIN%% %~x~vis
%%NOIN%% \begin{xten}
%%NOIN%% class Cont {
%%NOIN%%    operator this in (Int) = true;
%%NOIN%%    operator (String) in this = false;
%%NOIN%%    static operator (Cont) in (b:Boolean) = b;
%%NOIN%%    static def example() {
%%NOIN%%       val c:Cont = new Cont();
%%NOIN%%       assert c in 4 && !("odd" in c) && (c in true);
%%NOIN%%    }
%%NOIN%% }
%%NOIN%% \end{xten}
%%NOIN%% %~x~siv
%%NOIN%% %class Hook{ def run() { Cont.example(); return true; } }
%%NOIN%% %~x~neg
%%NOIN%% 
%%NOIN%% 
%%NOIN%% \end{ex}
%%NOIN%% 

\section{Array Constructors}
\label{sect:ArrayCtors}
\index{array!construction}
\index{array!literal}


\begin{bbgrammar}
             Primary \: 
                    \xcd"[" ArgumentList\opt \xcd"]" 
\end{bbgrammar}
%##)

X10 includes short syntactic forms for constructing one-dimensional arrays.
The shortest form is to enclose some expressions in brackets: 
%~~gen ^^^ Expressions140
% package Expressions.ArrayCtor.Primo;
% class Example {
% def example() {
%~~vis
\begin{xten}
val ints <: Array[Int](1) = [1,3,7,21];
\end{xten}
%~~siv
%}}
%~~neg

The expression \xcdmath"[e$_1$, $\ldots$, e$_n$]" produces an \Xcd{n}-element
\xcd`Array[T](1)`, where \xcd`T` is the computed common supertype (\Sref{LCA}) of the {\bf
base types} of the expressions  \xcdmath"e$_i$". 

\begin{ex}
The type of
\xcd`[0,1,2]` is \Xcd{Array[Int](1)}.    
More importantly, the type of 
\xcd`[0]` is also \xcd`Array[Int](1)`.  It is {\em not} 
\xcd`Array[Int{self==0}](1)`, even though all the elements are all 
of type \xcd`Int{self==0}`.  This is subtle but important. There are many
functions that take \xcd`Array[Int](1)`s, such as conversions to \xcd`Point`.
These functions do {\em not} take
\xcd`Array[Int{self==0}]`'s.

(Suppose that the function took \xcd`a:Array[Int](1)` and 
performed 
the operation \xcd`a(i)=100`.   This operation is fine for
an \xcd`Array[Int](1)`, which is all the compiler knows about \xcd`a`.  
However, it is wrong for an \xcd`Array[Int{self==0}](1)`, because it assigns
a non-zero value to an element of the array, violating the type constraint
which says that all the elements are zero.  So, \xcd`Array[Int{self==0}](1)`
is not and must not be a subtype of \xcd`Array[Int](1)` --- the two types are simply unrelated.
%~~type~~`~~`~~ ~~ ^^^ Expressions150
\xcd`Array[Int](1)` is far more useful than 
%~~type~~`~~`~~ ~~ ^^^ Expressions160
\xcd`Array[Int{self==0}](1)`, and so the compiler produces the former.)
\end{ex}



\begin{ex}
Occasionally one does actually need \xcd`Array[Int{self==0}](1)`, 
or, say, \xcd`Array[Eel{self != null}](1)`, an array of non-null \xcd`Eel`s.  
For these cases, cast one or more of the elements of the array to the desired type,
and the array constructor will do the right thing.  
%~~gen ^^^ Expressions170
%package Expressions.ArrayCtor.Details;
%class Eel{}
%class Example{
%def example(){
%~~vis
\begin{xten}
val zero <: Array[Int{self == 0}](1) 
          = [0];
val non1 <: Array[Int{self != 1}](1) 
          = [0 as Int{self != 1}];
val eels <: Array[Eel{self != null}](1) 
          = [new Eel() as Eel{self != null}, 
             new Eel(), new Eel()];
\end{xten}
%~~siv
%}}
%~~neg
\end{ex}


\section{Coercions and conversions}
\label{XtenConversions}
\label{User-definedCoercions}
\index{conversion}\index{coercion}
\index{type!conversion}\index{type!coercion}


A {\em coercion} does not change object identity; a coerced object may
be explicitly coerced back to its original type through a cast. A {\em
  conversion} may change object identity if the type being converted
to is not the same as the type converted from. \Xten{} permits both 
user-defined coercions and conversions (\Sref{sec:user-defined-conversions}).


\subsection{Coercions}

%##(CastExp
\begin{bbgrammar}
%(FROM #(prod:CastExp)#)
             CastExp \: CastExp \xcd"as" Type \\
\end{bbgrammar}
%##)


\paragraph{Subsumption coercion.}
A value of a subtype may be implicitly coerced to any supertype.  
\index{coercion!subsumption}

\begin{ex}
If \xcd`Child <: Person` and \xcd`val rhys:Child`, then \xcd`rhys` may be used
in any context that expects a \xcd`Person`.  For example, 
%~~gen ^^^ Expressions7f1h
% package Expressions7f1h;
% class Person{}
% class Child extends Person {}
%~~vis
\begin{xten}
class Example {
  def greet(Person) = "Hi!";
  def example(rhys: Child) {
     greet(rhys);
  }
}
\end{xten}
%~~siv
%
%~~neg

Similarly, \xcd`2` (whose innate type is \xcd`Int{self==2}`)
is usable in a context requiring a non-zero integer
(\xcd`Int{self != 0}`).  
\end{ex}

\paragraph{Explicit Coercion (Casting with \xcd"as")}

All classes and interfaces allow the use of the \xcd`as` operator for explicit
type coercion.  
Any class or
interface may be cast to any interface.  
Any interface may be cast to
any class.  Also, any interface can be cast to a struct that implements
(directly or indirectly) that interface.

\begin{ex}
In the following code, a \xcd`Person` is cast to \xcd`Childlike`.  There is
nothing in the class definition of \xcd`Person` that suggests that a
\xcd`Person` can be \xcd`Childlike`.  However, the \xcd`Person` in question,
\xcd`p`, is actually a \xcd`HappyChild` --- a subclass of \xcd`Person` --- and
is, in fact, \xcd`Childlike`.  

Similarly, the \xcd`Childlike` value \xcd`cl` is cast to \xcd`Happy`.  Though
these two interfaces are unrelated, the value of \xcd`cl` is, in fact,
\xcd`Happy`.  And the \xcd`Happy` value \xcd`hc` is cast to the class
\xcd`Child`, though there is no relationship between the two, but the actual
value is a \xcd`HappyChild`, and thus the cast is correct at runtime.

\xcd`Cyborg` is a struct rather than a class.  So, it cannot have substructs,
and all the interfaces of all \xcd`Cyborg`s are known: a \xcd`Cyborg` is
\xcd`Personable`, but not \xcd`Childlike` or \xcd`Happy`.  So, it is correct
and meaningful to cast \xcd`r` to \xcd`Personable`.  There is no way that a
cast to \xcd`Childlike` could succeed, so \xcd`r as Childlike` is a static error.

%~~gen ^^^ Expressions180
% package Types.Coercions;
% // NOTEST https://jira.codehaus.org/browse/XTENLANG-2623;
%~~vis
\begin{xten}
interface Personable {}
class Person implements Personable {}
interface Childlike extends Personable {}
class Child extends Person implements Childlike {}
struct Cyborg implements Personable {}
interface Happy {}
class HappyChild extends Child implements Happy {}
class Example {
  static def example() {
    var p : Person = new HappyChild();
    // class -> interface
    val cl : Childlike = p as Childlike; 
    // interface -> interface
    val hc : Happy = cl as Happy; 
    // interface -> class
    val ch : Child = hc as Child; 
    var r : Cyborg = Cyborg();
    val rl : Personable = r as Personable; 
    // ERROR: val no = r as Childlike;
  }
}
\end{xten}
%~~siv
% class Hook{ def run(){ Example.example(); return true; } }
%~~neg




\end{ex}


If the value coerced is not an instance of the target type,
and no coercion operators that can convert it to that type are defined, 
a \xcd"ClassCastException" is thrown.  Casting to a constrained
type may require a run-time check that the constraint is
satisfied.
\index{coercion!explicit}
\index{cast}
\index{\Xcd{as}}

\limitation{It is currently a static error, rather than a 
\xcd`ClassCastException`, when the cast is statically determinable to be
impossible.}



\paragraph{Effects of explicit numeric coercion}
\label{sec:effects-of-explicit-numeric-coercions}

Coercing a number of one type to another type gives the best approximation of
the number in the result type, or a suitable disaster value if no
approximation is good enough.  

\begin{itemize}
\item Casting a number to a {\em wider} numeric type is safe and effective,
      and can be done by an implicit conversion as well as an explicit
%~~exp~~`~~`~~ ~~ ^^^ Expressions190
      coercion.  For example, \xcd`4 as Long` produces the \xcd`Long` value of
      4. 
\item Casting a floating-point value to an integer value truncates the digits
      after the decimal point, thereby rounding the number towards zero.  
%~~exp~~`~~`~~ ^^^ Expressions200
      \xcd`54.321 as Int` is \xcd`54`, and 
%~~exp~~`~~`~~ ~~ ^^^ Expressions210
      \xcd`-54.321 as Int` is \xcd`-54`.
      If the floating-point value is too large to represent as that kind of
      integer, the coercion returns the largest or smallest value of that type
      instead: \xcd`1e110 as Int` is 
      \xcd`Int.MAX_VALUE`, \viz{} \xcd`2147483647`. 

\item Casting a \xcd`Double` to a \xcd`Float` normally truncates binary digits: \\
%~~exp~~`~~`~~ ~~ ^^^ Expressions220
      \xcd`0.12345678901234567890 as Float` is approximately \xcd`0.12345679f`.  This can
      turn a nonzero \xcd`Double` into \xcd`0.0f`, the zero of type
      \xcd`Float`: 
%~~exp~~`~~`~~ ~~ ^^^ Expressions230
      \xcd`1e-100 as Float` is \xcd`0.0f`.  Since 
      \xcd`Double`s can be as large as about \xcd`1.79E308` and \xcd`Float`s
      can only be as large as about \xcd`3.4E38f`, a large \xcd`Double` will
      be converted to the special \xcd`Float` value of \xcd`Infinity`: 
%~~exp~~`~~`~~ ~~ ^^^ Expressions240
      \xcd`1e100 as Float` is \xcd`Infinity`.
\item Integers are coerced to smaller integer types by truncating the
      high-order bits. If the value of the large integer fits into the smaller
      integer's range, this gives the same number in the smaller type: 
%~~exp~~`~~`~~ ~~ ^^^ Expressions250
      \xcd`12 as Byte` is the \xcd`Byte`-sized 12, 
%~~exp~~`~~`~~ ~~ ^^^ Expressions260
      \xcd`-12 as Byte` is -12. 
      However, if the larger integer {\em doesn't} fit in the smaller type,
%~~exp~~`~~`~~ ~~ ^^^ Expressions270
      the numeric value and even the sign can change: \xcd`254 as Byte` is
      the \xcd`Byte`sized \xcd`-2y`.  

\item Casting an unsigned integer type to a signed integer type of the same
      size (\eg, \xcd`UInt` to \xcd`Int`) preserves 2's-complement bit pattern
      (\eg,  \\
      \xcd`UInt.MAX_VALUE as Int == -1`.   Casting an unsigned integer type to
      a signed integer type of a different size is equivalent to first casting
      to an unsigned integer type of the target size, and then casting to a
      signed integer type.

\item Casting a signed integer type to an unsigned one is similar.  

\end{itemize}

\subsubsection{User-defined Coercions}
\index{coercion!user-defined}

Users may define coercions from arbitrary types into the container type
\xcd`B`, and coercions from \xcd`B` to arbitrary types, by providing
\xcd`static operator` definitions for the \xcd`as` operator in the definition of
\xcd`B`.  

\begin{ex}

%~~gen ^^^ Expressions2j7z
% package Expressions2j7z;
% KNOWNFAIL
%~~vis
\begin{xten}
class Bee {
  public static operator (x:Bee) as Int = 1;
  public static operator (x:Int) as Bee = new Bee();
  def example() {
    val b:Bee = 2 as Bee; 
    assert (b as Int) == 1;
  }
}
\end{xten}
%~~siv
%
%~~neg


\end{ex}



\subsection{Conversions}
\index{conversion}
\index{type!conversion}

\paragraph{Widening numeric conversion.}
\label{WideningConversions}
A numeric type may be implicitly converted to a wider numeric type. In
particular, an implicit conversion may be performed between a numeric
type and a type to its right, below:

\begin{xten}
Byte < Short < Int < Long < Float < Double
UByte < UShort < UInt < ULong
\end{xten}

Furthermore, an unsigned integer type may be implicitly coerced a signed type
large 
enough to hold any value of the type: \xcd`UByte` to \xcd`Short`, \xcd`UShort`
to \xcd`Int`, \xcd`UInt` to \xcd`Long`.  There are no implicit conversions
from signed to unsigned numbers, since they cannot treat negatives properly.

There are no implicit conversions in cases when overflow is possible.  For
example, there is no implicit conversion between \xcd`Int` and \xcd`UInt`.  If
it is necessary to convert between these types, use \xcd`n as Int` or 
\xcd`n as UInt`, generally with a test to ensure that the value will fit and
code to handle the case in which it does not.  


\index{conversion!widening}
\index{conversion!numeric}

\paragraph{String conversion.}
Any value that is an operand of the binary
\xcd"+" operator may
be converted to \xcd"String" if the other operand is a \xcd"String".
A conversion to \xcd"String" is performed by invoking the \xcd"toString()"
method.

\index{conversion!string}

\paragraph{User defined conversions.}\label{sec:user-defined-conversions}
\index{conversion!user-defined}

The user may define implicit conversion operators from type \Xcd{A} {\em to} a
container type \Xcd{B} by specifying an operator in \Xcd{B}'s definition of the form:

\begin{xten}
  public static operator (r: A): T = ... 
\end{xten}

The return type \Xcd{T} should be a subtype of \Xcd{B}. The return
type need not be specified explicitly; it will be computed in the
usual fashion if it is not. However, it is good practice for the
programmer to specify the return type for such operators explicitly.
The return type can be more specific than simply \xcd`B`, for cases when there
is more information available.


\begin{ex}
The code for \Xcd{x10.lang.Point} contains a conversion from 
one-dimensional \xcd`Array`s of integers to \xcd`Point`s of the same length: 
\begin{xten}
  public operator (r: Array[Int](1)): Point(r.length) 
         = make(r);
\end{xten}
This conversion is used whenever an array of integers appears in a 
context that requires a \xcd`Point`, such as subscripting. Note 
that \xcd`a` requires a \xcd`Point` of rank 2 as a subscript, and that 
a two-element \xcd`Array` (like \xcd`[2,4]`) is converted to a 
\xcd`Point(2)`.
%~~gen ^^^ Expressions4f4y
% package Expressions4f4y;
% class Example { def example() {
% 
%~~vis
\begin{xten}
val a = new Array[String]((2..3) * (4..5), "hi!");
a([2,4]) = "converted!";
\end{xten}
%~~siv
%} } 
%~~neg


\end{ex}

\section{Parenthesized Expressions}

If \xcd`E` is any expression, \xcd`(E)` is an expression which, when
evaluated, produces the same result as \xcd`E`.   

\begin{ex}
The main use of parentheses is to write complex expressions for which the 
standard precedence order of operations is not appropriate: \xcd`1+2*3` is 7,
but \xcd`(1+2)*3` is 9.  

Similarly, but perhaps less familiarly, 
parentheses can disambiguate other expressions.  In the following code, 
\xcd`funny.f` is a field-selection expression, and so \xcd`(funny.f)()` means
``select the \xcd`f` field from \xcd`funny`, and evaluate it''.  However, 
\xcd`funny.f()` means ``evaluate the \xcd`f` method on object \xcd`funny`.''  
%~~gen ^^^ Expressions3f6f
% package Expressions3f6f;
%~~vis
\begin{xten}
class Funny {
  def f () = 1;
  val f = () => 2;
  static def example() {
    val funny = new Funny();
    assert funny.f() == 1;
    assert (funny.f)() == 2;
  }
}
\end{xten}
%~~siv
% class Hook{ def run() { Funny.example(); return true; }}
%~~neg


\end{ex}

Note that this does {\em
not} mean that \xcd`E` and \xcd`(E)` are identical in all respects; for
example, if \xcd`i` is an \xcd`Int` variable, \xcd`i++` increments \xcd`i`,
but \xcd`(i)++` is not allowed.    \xcd`++` is an assignment; it operates on
variables, not merely values, and \xcd`(i)` is simply an expression whose {\em
value} is the same as that of \xcd`i`. 
