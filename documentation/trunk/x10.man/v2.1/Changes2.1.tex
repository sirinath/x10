%%OLD%% \chapter{Changes, Version 1 (Oct 4 2010)}
%%OLD%% 
%%OLD%% This document summarizes the main changes between X10 2.0.6 and X10 2.1.  The
%%OLD%% descriptions are intended to be suggestive rather than definitive; see the
%%OLD%% language specification -- when it is finished -- for full details.
%%OLD%% 
%%OLD%% \subsection{Object Model}
%%OLD%% 
%%OLD%% \begin{enumerate}
%%OLD%% \item Objects are now local rather than global.
%%OLD%%    
%%OLD%%     \begin{enumerate}
%%OLD%%     \item The \Xcd{home} property is gone.
%%OLD%%     \item \Xcd{at(P)S} produces deep copies of all objects located \Xcd{here}
%%OLD%%           when it executes \Xcd{S}.  ({\bf Warning:} They are copied even in 
%%OLD%%           \Xcd{at(here)S}.)
%%OLD%%     \end{enumerate}
%%OLD%% 
%%OLD%% \item The \Xcd{GlobalRef[T]} struct is the only way to produce or manipulate
%%OLD%%       cross-place references.
%%OLD%%     \begin{enumerate}
%%OLD%%     \item \Xcd{GlobalRef}'s have a \Xcd{home} property.
%%OLD%%     \item Use \Xcd{GlobalRef[Foo](foo)} to make a new global reference.
%%OLD%%     \item Use \Xcd{myGlobalRef()} to access the object referenced; this
%%OLD%%           requires \Xcd{here == myGlobalRef.home}. 
%%OLD%%     \end{enumerate}
%%OLD%% 
%%OLD%% 
%%OLD%% \item  The \xcd`!` type modifier is no longer needed or present.
%%OLD%% 
%%OLD%% \item \Xcd{global} modifiers are now gone:
%%OLD%%     
%%OLD%%     \begin{enumerate}
%%OLD%%     \item \Xcd{global} methods in {\em interfaces} are now the default. 
%%OLD%%     \item \Xcd{global} {\em fields} are gone.  In some cases object copying
%%OLD%%           will produce the same effect as global fields.  In other cases code
%%OLD%%           must be rewritten.  It may be desirable to mark nonglobal fields
%%OLD%%           \Xcd{transient} in many cases.
%%OLD%%     \item \Xcd{global} {\em methods} are now marked \Xcd{@Global} instead.  
%%OLD%%           Methods intended to be non-global may be marked \Xcd{@Pinned}.
%%OLD%%     \end{enumerate}
%%OLD%% 
%%OLD%% 
%%OLD%% \end{enumerate}
%%OLD%% 
%%OLD%% \subsection{Constructors}
%%OLD%% 
%%OLD%% 
%%OLD%% \begin{enumerate}
%%OLD%% \item \Xcd{proto} types are gone.
%%OLD%% \item Constructors and the methods they call must satisfy a number of static
%%OLD%%       checks.  
%%OLD%%     
%%OLD%%     \begin{enumerate}
%%OLD%%     \item Constructors can only invoke \Xcd{private} or \Xcd{final} methods, 
%%OLD%%           or methods annotated \xcd`@NonEscaping("v1,v2")`.  
%%OLD%%     \item Methods invoked by constructors cannot read fields before they are
%%OLD%%           written. 
%%OLD%%     \item The compiler ensures this with a detailed protocol. 
%%OLD%%     \end{enumerate}
%%OLD%% 
%%OLD%% \item It is still impossible for X10 constructors to leak references to
%%OLD%%       \Xcd{this} or observe uninitialized fields of an object.  Now, however,
%%OLD%%       the mechanisms enforcing this are less obtrusive than in 2.0.6; the
%%OLD%%       burden is largely on the compiler, not the programmer.
%%OLD%% \end{enumerate}
%%OLD%% 
%%OLD%% 
%%OLD%% 
%%OLD%% 
%%OLD%% %REF> \subsection{Call by Reference}
%%OLD%% %REF> 
%%OLD%% %REF> A very limited form of call-by-reference is now available.
%%OLD%% %REF> 
%%OLD%% %REF> 
%%OLD%% %REF> \begin{enumerate}
%%OLD%% %REF> 
%%OLD%% %REF> \item Formal parameters to functions and methods may be \Xcd{ref} rather than
%%OLD%% %REF>       \Xcd{var} or \Xcd{val}.  
%%OLD%% %REF> \item Assignment to a \Xcd{ref} parameter \Xcd{x} changes the original
%%OLD%% %REF>       location that the \Xcd{ref} refers to.  \eg, 
%%OLD%% %REF>       \xcd`def inc(ref x:Int) { x ++; }`
%%OLD%% %REF>       allows a call \Xcd{inc(n)} to increment a local \Xcd{var} \Xcd{n}.
%%OLD%% %REF> \item Only local variables or \Xcd{ref} parameters can be passed as actual
%%OLD%% %REF>       \Xcd{ref} parameters.  Fields, array elements, and other variable-like
%%OLD%% %REF>       items cannot be. 
%%OLD%% %REF> \item External \Xcd{ref} variables cannot be captured in closures. However,
%%OLD%% %REF>       closures may have \Xcd{ref} parameters.
%%OLD%% %REF> \item \Xcd{ref}s are {\em not} first-class objects in X10. They cannot be
%%OLD%% %REF>       returned from functions, stored in data structures, etc.
%%OLD%% %REF> \item These restrictions limit the possibilities of aliasing and the need for
%%OLD%% %REF>       boxing of \Xcd{ref} parameters.  \Xcd{ref}s to stack locations cannot,
%%OLD%% %REF>       with these restrictions, live past the death of the location's
%%OLD%% %REF>       containing stack frame.      
%%OLD%% %REF> \item This allows the implementation of many core constructs as syntactic
%%OLD%% %REF>       sugar on library calls.   Programmers may use it, but mutability should
%%OLD%% %REF>       generally be encapsulated inside objects rather than \Xcd{ref}
%%OLD%% %REF>       parameters. 
%%OLD%% %REF> \end{enumerate}
%%OLD%% %REF> 
%%OLD%% 
%%OLD%% %ACC> \subsection{Accumulator Variables}
%%OLD%% %ACC> 
%%OLD%% %ACC> Accumulator variables generalize and make explicit collecting \Xcd{finish} in
%%OLD%% %ACC> X10 2.0.6.  An \Xcd{acc} variable is declared: 
%%OLD%% %ACC> \begin{xten}
%%OLD%% %ACC> acc(r) A;
%%OLD%% %ACC> \end{xten}
%%OLD%% %ACC> where \Xcd{r} is a {\em reducer} (much as in 2.0.6): 
%%OLD%% %ACC> \begin{xten}
%%OLD%% %ACC> struct Reducer[T](zero:T, apply:global (T,T)=>T){}
%%OLD%% %ACC> \end{xten}
%%OLD%% %ACC> 
%%OLD%% %ACC> Usage of \Xcd{A} is restricted in ways that make it determinate in the
%%OLD%% %ACC> intended case of a pure, associative, commutative \Xcd{apply} with unit
%%OLD%% %ACC> element \Xcd{zero}.  
%%OLD%% %ACC> 
%%OLD%% %ACC> \begin{enumerate}
%%OLD%% %ACC> \item \Xcd{A} is initialized to \Xcd{r.zero}.  
%%OLD%% %ACC> \item Multiple activities can {\em write} into \Xcd{A}.  In particular, the
%%OLD%% %ACC>       ``assignment'' \Xcd{A = v} is approximately interpreted as 
%%OLD%% %ACC>       \xcd`atomic{A = r.apply(A, v)}` --- that is, it accumulates \Xcd{v} into
%%OLD%% %ACC>       \Xcd{A} using \Xcd{r.apply.}
%%OLD%% %ACC> \item {\em Reading} of \Xcd{A} is restricted to situations where it makes
%%OLD%% %ACC>       sense.  Specifically, only the activity in which \Xcd{A} is declared can
%%OLD%% %ACC>       read from it, and it can only do so when all asyncs which it has spawned
%%OLD%% %ACC>       have terminated -- \eg, outside of the scope of all \Xcd{async}s and
%%OLD%% %ACC>       \Xcd{finish}es.  
%%OLD%% %ACC> \item Formal parameters of functions may be marked \Xcd{acc x:T}.  The reducer
%%OLD%% %ACC>       \Xcd{r} must not be specified; it is passed as an implicit parameter
%%OLD%% %ACC>       going with the actual \Xcd{acc} variable.  
%%OLD%% %ACC> \item X10 provides protocols for indexed collections of \Xcd{acc} variables,
%%OLD%% %ACC>       presented as objects.
%%OLD%% %ACC> \end{enumerate}
%%OLD%% %ACC> 
%%OLD%% 
%%OLD%% 
%%OLD%% \subsection{Implicit clocks for each finish}
%%OLD%% 
%%OLD%% 
%%OLD%% Most clock operations can be accomplished using the new implicit clocks.
%%OLD%% 
%%OLD%% \begin{enumerate}
%%OLD%% \item A \Xcd{finish} may be qualified with \Xcd{clocked}, which gives it a
%%OLD%%       clock.
%%OLD%% \item An \Xcd{async} in a \Xcd{clocked finish} may be marked \Xcd{clocked}.
%%OLD%%       This registers it on the same clock as the enclosing \Xcd{finish}.  
%%OLD%% \item \xcd`clocked async S` and \xcd`clocked finish S` may use \xcd`next` in
%%OLD%%       the body of \Xcd{S} to advance the clock.
%%OLD%% \item When the body of a \Xcd{clocked finish} completes, the \Xcd{clocked
%%OLD%%       finish} is dropped form the clock.  It will still wait for spawned
%%OLD%%       asyncs to terminate, but such asyncs need to wait for it.
%%OLD%% \end{enumerate}
%%OLD%% 
%%OLD%% 
%%OLD%% %CLOCAL>\subsection{Clocked local variables}
%%OLD%% %CLOCAL>
%%OLD%% %CLOCAL>Local \Xcd{val} and \Xcd{acc} variables may be \Xcd{clocked}.  They are
%%OLD%% %CLOCAL>associated with the clock of the surrounding \Xcd{clocked finish}.  
%%OLD%% %CLOCAL>Clocked variables have a {\em current} value and an {\em upcoming} value.  The
%%OLD%% %CLOCAL>current value may be read at suitable times; the upcoming value may be
%%OLD%% %CLOCAL>updated.  The \Xcd{next} phase makes the upcoming value current.
%%OLD%% 
%%OLD%% \subsection{Asynchronous initialization of val}
%%OLD%% 
%%OLD%% \Xcd{val}s can be initialized asynchronously.   As always with \Xcd{val}s,
%%OLD%% they can only be read after is guaranteed that they have been initialized.
%%OLD%% For example, both of the \Xcd{print}s below are good.  However, the
%%OLD%% commented-out \Xcd{print} in the \Xcd{async} is bad, since it is possible that
%%OLD%% it will be executed before the initialization of \Xcd{a}. 
%%OLD%% \begin{xten}
%%OLD%% val a:Int;
%%OLD%% finish {
%%OLD%%   async {
%%OLD%%      a = 1; 
%%OLD%%      print("a=" + a);
%%OLD%%   }
%%OLD%%   async {
%%OLD%%      // WRONG: print("a=" + a);
%%OLD%%   }
%%OLD%% }
%%OLD%% print("a=" + a);
%%OLD%% \end{xten}
%%OLD%% 
%%OLD%% 
%%OLD%% 
%%OLD%% \subsection{Main Method}
%%OLD%% 
%%OLD%% The signature for the \Xcd{main} method is now: 
%%OLD%% \begin{xten}
%%OLD%%            def main(Array[String]) {..}
%%OLD%% \end{xten}
%%OLD%% or, if the arguments are actually used, 
%%OLD%% \begin{xten}
%%OLD%%            def main(argv: Array[String](1)) {..}
%%OLD%% \end{xten}
%%OLD%% 
%%OLD%% \subsection{Assorted Changes}
%%OLD%% 
%%OLD%% 
%%OLD%% \begin{enumerate}
%%OLD%% \item The syntax for destructuring a point now uses brackets rather than
%%OLD%%       braces: \Xcd{for( [i] in 1..10 )}, rather than the prior \Xcd{(i)}.  
%%OLD%% \end{enumerate}
%%OLD%% 
%%OLD%% \subsection{Safety of atomic and when blocks}
%%OLD%% 
%%OLD%% 
%%OLD%% \begin{enumerate}
%%OLD%% \item Static effect annotations (\Xcd{safe}, \Xcd{sequential},
%%OLD%%       \Xcd{nonblocking}, \Xcd{pinned}) are no longer used. They have been
%%OLD%%       replaced by dynamic checks.
%%OLD%% \item Using an inappropriate operation in the scope of an \Xcd{atomic} or
%%OLD%%       \Xcd{when} construct will throw \Xcd{IllegalOperationException}.  
%%OLD%%       The following are inappropriate:      
%%OLD%%       \begin{itemize}
%%OLD%%       \item \Xcd{when}
%%OLD%%       \item \Xcd{resume()} or \Xcd{next} on clocks
%%OLD%%       \item async
%%OLD%%       \item \Xcd{Future.make()}, or \Xcd{Future.force()}.
%%OLD%%       \item \Xcd{at}
%%OLD%%       \end{itemize}
%%OLD%% 
%%OLD%% \end{enumerate}
%%OLD%% 
%%OLD%% 
%%OLD%% \subsection{Removed Topics}
%%OLD%% 
%%OLD%% The following are gone: 
%%OLD%% 
%%OLD%% \begin{enumerate}
%%OLD%% \item \Xcd{foreach} is gone.
%%OLD%% \item All \Xcd{var}s are effectively \Xcd{shared}, so \Xcd{shared} is gone.
%%OLD%% \item The place clause on \Xcd{async} is gone.  \Xcd{async (P) S} should be
%%OLD%%       written \Xcd{at(P) async S}.
%%OLD%% \item Checked exceptions are gone.
%%OLD%% \item \Xcd{future} is gone.
%%OLD%% \item \Xcd{await ... or ... } is gone.
%%OLD%% \item \Xcd{const} is gone.
%%OLD%% 
%%OLD%% \end{enumerate}
%%OLD%% 
%%OLD%% \subsection{Deprecated}
%%OLD%% 
%%OLD%% The following constructs are still available, but are likely to be replaced in
%%OLD%% a future version: 
%%OLD%% 
%%OLD%% 
%%OLD%% \begin{enumerate}
%%OLD%% \item \Xcd{ValRail}.
%%OLD%% \item \Xcd{Rail}.
%%OLD%% \item \xcd`ateach`
%%OLD%% \end{enumerate}
