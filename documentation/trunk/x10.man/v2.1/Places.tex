
\chapter{Places}
\label{XtenPlaces}
\index{place}

An \Xten{} place is a repository for data and activities, corresponding
loosely to a process or a processor. Places induce a concept of ``local''. The
activities running in a place may access data items located at that place with
the efficiency of on-chip access. Accesses to remote places may take orders of
magnitude longer. X10's system of places is designed to make this obvious.
Programmers are aware of the places of their data, and know when they are
incurring communication costs, but the actual operation to do so is easy. It's
not hard to use non-local data; it's simply hard to to do so accidentally.

The set of places available to a computation is determined at the time that
the program is started, and remains fixed through the run of the program. See
the {\tt README} documentation on how to set command line and configuration
options to set the number of places.

Places are first-class values in X10, as instances of the built-in struct,
\xcd"x10.lang.Place".   \xcd`Place` provides a number of useful ways to
query places, such as \xcd`Place.places`, a \xcd`Sequence[Place]` of 
the places
available to the current run of the program.

Objects and structs (with one exception) are created in a single place -- the
place that the constructor call was running in. They cannot change places.
They can be {\em copied} to other places, and the special library struct
\Xcd{GlobalRef} allows values at one place to point to values at another.  

\section{The Structure of Places}
\index{place!MAX\_PLACES}
\index{place!FIRST\_PLACES}
\index{MAX\_PLACES}
\index{FIRST\_PLACE}

%~~exp~~`~~`~~ ~~ ^^^ Places10
Places are numbered 0 through \xcd`Place.MAX_PLACES-1`; the number is stored
in the field 
\xcd`pl.id`.  The \xcd`Sequence[Place]` \xcd`Place.places()` contains the places of the
program, in numeric order. 
The program starts by executing a \xcd`main` method at
%~~exp~~`~~`~~ ~~ ^^^ Places20
\xcd`Place.FIRST_PLACE`, which is 
%~~exp~~`~~`~~ ~~ ^^^ Places30
\xcd`Place.places()(0)`; see
\Sref{initial-computation}. 

Operations on places include \xcd`pl.next()`, which gives the next entry
(looping around) in \xcd`Place.places` and its opposite \xcd`pl.prev()`. In
particular, \xcd`here.next()` means ``a place other than \xcd`here`'', except
in single-place executions.
%~~exp~~`~~`~~pl:Place~~ ^^^ Places40
There are also a number of tests, like \xcd`pl.isSPE()` and 
%~~exp~~`~~`~~pl:Place ~~ ^^^ Places50
\xcd`pl.isCUDA()`, which test for particular kinds of processors.




\section{{\tt here}}\index{here}\label{Here}

The variable \xcd"here" is always bound to the place at which the current
computation is running, in the same way that \xcd`this` is always bound to the
instance of the current class (for non-static code), or \xcd`self` is bound to
the instance of the type currently being constrained.  
\xcd`here` may denote different places in the same method body or even the
same expression, due to
place-shifting operations.


This is not unusual for automatic variables:  \Xcd{self} denotes 
two different values (one \xcd`List`, one \xcd`Int`) in
\xcd`List[Int{self!=0}]{self!=null}`. In the following 
code, \xcd`here` has one value at 
\xcd`h0`, and a different one at \xcd`h1` (unless there is only one place).
%~~gen ^^^ Places60
% package places.are.For.Graces;
% class Example {
% def example() {
%~~vis
\begin{xten}
val h0 = here;
at (here.next()) {
  val h1 = here; 
  assert (h0 != h1);
}
\end{xten}
%~~siv
%} } 
%~~neg
\noindent
(Similar examples show that \xcd`self` and \xcd`this` have the same behavior:
\xcd`self` can be modified by constrained types appearing inside of type
constraints, and \xcd`this` by inner classes.)



The following example looks through a list of references to \Xcd{Thing}s.  
It finds those references to things that are \Xcd{here}, and deals with them.  
%~~gen ^^^ Places70
%package Places.Are.For.Graces.2;
%import x10.util.*;
%abstract class Thing {}
%class DoMine {
%  static def dealWith(Thing) {}	
%~~vis
\begin{xten}
  public static def deal(things: List[GlobalRef[Thing]]) {
     for(gr in things) {
        if (gr.home == here) {
           val grHere = 
               gr as GlobalRef[Thing]{gr.home == here};
           val thing <: Thing = grHere();
           dealWith(thing);
        }
     }
  }
\end{xten}
%~~siv
%}
%~~neg

\section{ {\tt at}: Place Changing}\label{AtStatement}
\index{at}
\index{place!changing}

An activity may change place synchronously using the \xcd"at" statement or
\xcd"at" expression. This is an expensive operation and must be used
with care.

%##(AtStatement AtExp
\begin{bbgrammar}
%(FROM #(prod:AtStatement)#)
         AtStatement \: \xcd"at" PlaceExpSingleList Statement & (\ref{prod:AtStatement}) \\
%(FROM #(prod:AtExp)#)
               AtExp \: \xcd"at" PlaceExpSingleList ClosureBody & (\ref{prod:AtExp}) \\
\end{bbgrammar}
%##)

The {\it PlaceExp} must be an expression of type \xcd`Place` or some subtype.

An activity executing statement \xcd"at (q) S" at a place \xcd`p`
evaluates \xcd`q` at \xcd`p` and then moves to \xcd`q` to execute
\xcd`S`.  Initialized \xcd`val` variables appearing in \xcd`S` are given {\em
copies} of their values outside (\Sref{sect:at-init-val}).  
Uninitialized \xcd`val` variables in \xcd`S` may be initialized at the place
that they were declared (\Sref{sect:at-uninit-val}).  
\xcd`var` variables may be read and set at the place that they were declared,
but are unavailable at other places (\Sref{sect:at-and-var}).  

Note that the value obtained by evaluating \xcd`q`
is not necessarily distinct from \xcd`p` (\eg, \xcd`q` may be
\xcd`here`); \xcd`at(here)S` will copy all \xcd`val` values used in \xcd`S`,
even though there is no actual change of place.


On normal termination of \xcd`S` control returns to \xcd`p` and
execution is continued with the statement following \xcd`at (q) S`. If
\xcd`S` terminates abruptly with exception \xcd`E`, \xcd`E` is
serialized into a buffer, the buffer is communicated to \xcd`p` where
it is deserialized into an exception \xcd`E1` and \xcd`at (e) S`
throws \xcd`E1`.

Since \xcd`at(e) S` is a synchronous construct, usual control-flow
constructs such as \xcd`break`, \xcd`continue`, \xcd`return` and 
\xcd`throw` are permitted in \xcd`S`.  All concurrency related
constructs -- \xcd`async`, \xcd`finish`, \xcd`atomic`, \xcd`when` are
also permitted.

The \xcd`at`-expression \xcd`at(p)E` is similar, except that, in the case of
normal termination of \xcd`E`, the value that \xcd`E` produces is serialized
into a buffer, transported to the starting place, and deserialized, and the
value of the \xcd`at`-expression is the result of deserialization.

\limitation{
X10 does not currently allow {\tt break}, {\tt continue}, or {\tt return}
to exit from an {\tt at}.
}



\subsection{{\tt at} and Initialized {\tt val} Variables}
\label{sect:at-init-val}

Initialized \xcd`val` variables are copied to \xcd`S`. The initialized
\xcd`val` variable \xcd`x` appearing in \xcd`S` will have as its value a copy
of the value of \xcd`x` outside.  

First, the runtime identifies the object graph at \xcd`p` reachable
from lexically scoped initialized \xcd`val` variables (say, \xcd`v1`,\ldots, 
\xcd`vn`) referenced in \xcd`S`.  Second this graph is {\em
  serialized} into a buffer and transmitted to place \xcd`q`.  Third,
the variables \xcd`v1`,\ldots, \xcd`vn` are re-created at \xcd`q` and
initialized with the objects obtained by deserializing the buffer at
\xcd`q`. Fourth, \xcd`S` is executed at \xcd`q` (in an environment in
which the variable \xcd`vi` refers to the re-created variable at
\xcd`q`).  (For the treatment of \xcd`var`s, see \Sref{sect:at-and-var}.)


Note that since values accessed across an \xcd`at` boundary are
copied, the programmer may wish to adopt the discipline that either
variables accessed across an \xcd`at` boundary  contain only structs 
or stateless objects, or the methods invoked on them do not access any
mutable state on the objects. Otherwise the programmer has to ensure
that side effects are made to the correct copy of the object. For this
the struct \xcd`x10.lang.GlobalRef[T]` is often useful.


\subsection{{\tt at} and Uninitialized {\tt val} Variables}
\label{sect:at-uninit-val}


An uninitialized \xcd`val` variable may be initialized in \xcd`S`, but only at
places that are statically determinable to be equal to the place that the
variable was defined.  Uninitialized \xcd`val`s cannot be read, of course.

\begin{ex}
This allows a straightforward way to transmit several
pieces of information back from an \xcd`at(somewhereElse)`, as shown by the
following example which computes the roots of the quadratic equation 
{$ax^2 + bx + c = 0$}.  
For the sake of the example, we assume that 
{\tt mathProcessor()} returns a Place suitable for calculation.  In practice
it would rarely if ever make sense to send such a small calculation to another
place. 

The starting place has local \xcd`val`s \Xcd{r} and \Xcd{s}, which will hold
the roots.  
The computation at the math processor evaluates the roots of the equation.
These roots are bound to math processor local \xcd`val` variables \xcd`rr` and
\xcd`ss`.  An inner place-shifting \xcd`at(h)` moves the computation back to
the initial place, stored for that purpose in \xcd`h`, at which values can be
assigned to the variables \xcd`r` 
and \xcd`s` at the starting place.  Note that we take care to send only the
minimal information across \xcd`at` boundaries; in particular we do not 
send the discriminant back to \xcd`h`.  When the intermediate results are
large and the desired data small, the savings can be substantial.

%~~gen ^^^ Activities70
% package Activities.AtAndVariables; 
% abstract class Example {
% abstract def mathProcessor() : Place;
% KNOWNFAIL
%~~vis
\begin{xten}
def printRootsOfQuadratic(a:Complex, b:Complex, c:Complex) {
  val r : Complex;
  val s : Complex;
  val start = here;
  at(mathProcessor()) {
    val disc = Math.sqrt(b*b - 4*a*c);
    val rr = (-b + disc) / (2*a);
    val ss = (-b - disc) / (2*a);
    at(start) {
      r = rr; s = ss;
    }
  }
  Console.OUT.println("r = " + r + "; s = " + s);
}
\end{xten}
%~~siv
%} 
%~~neg


\end{ex}

\subsection{{\tt at} and {\tt var} Variables}
\label{sect:at-and-var}
\index{at!variables and}

\xcd`var` variables can be read and set at a place statically known to be the
place that they are declared, but not from other places.  

\xcd`var` variables
cannot be accessed from any other place.  As always, a \xcd`var` cannot be
read before it is definitely initialized.  

\begin{ex}
This allows a straightforward way to accumulate results from multiple places.
In the following example, some code is run at each place to produce an integer
\xcd`partialResult`, and the \xcd`partialResult`s are summed to give a
\xcd`result`. 

%~~gen ^^^ Activities4q6g
% package Activities4q6g;
% class Example {
%~~vis
\begin{xten}
def example() {
  var result : Int = 0;
  val start = here; 
  finish {
    for(p in Place.places()) {
       async at(p) {
          val partialResult = here.id();
          at(start) {
            atomic { result += partialResult; }
          }
       }
    }
  }
  return result; 
}
\end{xten}
%~~siv
% }
%~~neg


\end{ex}



\paragraph{Serialization and deserialization.}
\index{transient}
\index{field!transient}
The X10 runtime provides a default mechanism for
serializing/deserializing an object graph with a given set of roots.
This mechanism may be overridden by the programmer on a per class or
struct basiss as described in \xcd`x10.io.CustomSerialization`. 
The default mechanism performs a
deep copy of the object graph (that is, it copies the object or struct
and, recursively, the values contained in its fields), but does not
traverse \xcd`transient` fields. Instead on serialization the default
value \Sref{DefaultValues} for the type of the field is used.

A struct \xcd`s` of type \xcd`x10.lang.GlobalRef[T]` \ref{GlobalRef}
is serialized as a unique global reference to its contained object
\xcd`o` (of type \xcd`T`).  Please see the documentation
of \xcd`x10.lang.GlobalRef[T]` for more details.



\subsection{{\tt at} and Activities}
\xcd`at(p)S` does {\em not} start a new activity.  It should be thought of as
transporting the current activity to \xcd`p`, running \xcd`S` there, and then
transporting it back.  \xcd`async` is the only construct in the
language that starts a new activity. In different contexts, each one
of the following makes sense:
(1)~\xcd`async at(p) S` (spawn an activity locally to execute \xcd`S` at
\xcd`p`; here \xcd`p` is evaluated by the spawned activity) , 
(2)~\xcd`at(p) async S` (evaluate \xcd`p` and then at \xcd`p` spawn an
activity to execute \xcd`S`), and,
(3)~\xcd`async at(p) async S`. 
In most cases, \xcd`async at(p) S` is preferred to \xcd`at(p) async S`, since
the former returns instantly, but the latter blocks waiting for the remote
activity to be spawned. 

Since \Xcd{at(p) S} does not start a new activity, 
\xcd`S` may contain constructs which only make sense
within a single activity.  
For example, 
\begin{xten}
    for(x in globalRefsToThings) 
      if (at(x.home) x().isNice()) 
        return x();
\end{xten}
returns the first nice thing in a collection.   If we had used 
\xcd`async at(x.home)`, this would not be allowed; 
you can't \xcd`return` from an
\xcd`async`. 

\limitation{
X10 does not currently allow {\tt break}, {\tt continue}, or {\tt return}
to exit from an {\tt at}.
}



\subsection{Implicit copying from {\tt at} }
\index{at!copying}

\xcd`at(p)S` copies nearly all data that \xcd`S` might reference, and sends it
to place \xcd`p`, before executing \xcd`S` there. The only things that are not
copied are values only reachable through \xcd`GlobalRef`s and \xcd`transient`
fields, and data omitted by custom serialization.    If \xcd`x` is a
variable name referring to some object \xcd`ob` outside of \xcd`S`, then the
same variable name \xcd`x` refers to a deep copy of \xcd`ob`
inside of \xcd`S`.  In this way the body \xcd`S` is in a separate block with
different variable bindings.

For example, consider the following program.
%~~gen ^^^ Activities_implicit_copy_from_at_example_1
% package Activities.implicitcopyfromat;
% class Example {
% static def example() {
%~~vis
\begin{xten}
val c = new Cell[Int](9); // (1)
at (here) {               // (2)
   assert(c() == 9);      // (3)
   c.set(8);              // (4)
   assert(c() == 8);      // (5)
}
assert(c() == 9);         // (6)
\end{xten}
%~~siv
%}}
% class Hook{ def run() { Example.example(); return true; } }
%~~neg
The \xcd`at` statement implicitly copies the \xcd`Cell` and its contents.  
After \xcd`(1)`, \xcd`c` is a \xcd`Cell` containing 9; call that cell {$c_1$}
At \xcd`(2)`, that cell is copied, resulting in another cell {$c_2$} whose
contents are also 9, as tested at \xcd`(3)`.
(Note that the copying behavior of \xcd`at` happens {\em even when the
destination place is the same as the starting place}--- even with
\xcd`at(here)`.)
At \xcd`(4)`, the contents of {$c_2$} are changed to 8, as confirmed at \xcd`(5)`; the contents of
{$c_1$} are of course untouched.    Finally, at \xcd`(c)`, outside the scope
of the \xcd`at` started at line \xcd`(2)`, \xcd`c` refers to its original
value {$c_1$} rather than the copy {$c_2$}.  

The \xcd`at` statement induces a {\em deep copy}.  Not only does it copy the
values of variables, it copies values that they refer to through zero or more
levels of reference.  Structures are preserved as well: if two fields
\xcd`x.f` and \xcd`x.g` refer to the same object {$o_1$} in the original, then
\xcd`x.f` and \xcd`x.g` will both refer to the same object {$o_2$} in the
copy.  

For example, in the following variation of the preceding example,
\xcd`a`'s original value {$a_1$} is an array with two references to the same
\xcd`Cell[Int]` {$c_1$}.  The fact that {$a_1(0)$} and {$a_1(1)$} are both
identical to {$c_1$} is demonstrated in \xcd`(A)`-\xcd`(C)`, as {$a_1(0)$} is modified
and {$a_1(1)$} is observed to change.  In \xcd`(D)`-\xcd`(F)`, the copy
{$a_2$} is tested in the same way, showing that {$a_2(0)$} and {$a_2(1)$} both
refer to the same \xcd`Cell[Int]` {$c_2$}.  However, the test at \xcd`(G)`
shows that {$c_2$} is a different cell from {$c_1$}, because changes to
{$c_2$} did not propagate to {$c_1$}.  
%~~gen ^^^ Activities30
%package Activities.AtCopy2;
%class example {
%static def Example() {
%~~vis
\begin{xten}
val c = new Cell[Int](5);
val a = new Array[Cell[Int]][c,c];
assert(a(0)() == 5 && a(1)() == 5);     // (A)
c.set(6);                               // (B)
assert(a(0)() == 6 && a(1)() == 6);     // (C)
at(here) {
  assert(a(0)() == 6 && a(1)() == 6);   // (D)
  c.set(7);                             // (E)
  assert(a(0)() == 7 && a(1)() == 7);   // (F)
}
assert(a(0)() == 6 && a(1)() == 6);     // (G)
\end{xten}
%~~siv
%}}
%class Hook{ def run() { example.Example(); return true; } }
%~~neg

\subsection{Copying and Transient Fields}
\index{at!transient fields and}
\index{transient}
\index{field!transient}

Recall that fields of classes and structs marked \xcd`transient` are not copied by
\xcd`at`.  Instead, they are set to the default values for their types. Types
that do not have default values cannot be used in \xcd`transient` fields.

In the following example, every \xcd`Trans` object has an \xcd`a`-field equal
to 1.  However, despite the initializer on the \xcd`b` field, it is not the
case that every \xcd`Trans` has \xcd`b==2`.  Since \xcd`b` is \xcd`transient`,
when the \xcd`Trans` value \xcd`this` is copied at \xcd`at(here){...}` in
\xcd`example()`, its \xcd`b` field is not copied, and the default value for an
\xcd`Int`, 0, is used instead.  
Note that we could not make a transient field \xcd`c : Int{c != 0}`, since the
type has no default value, and copying would in fact set it to zero.
%~~gen ^^^ Activities40
%package Activities_transient_a;
%~~vis
\begin{xten}
class Trans {
   val a : Int = 1;
   transient val b : Int = 2;
   //ERROR transient val c : Int{c != 0} = 3;
   def example() {
     assert(a == 1 && b == 2);
     at(here) {
        assert(a == 1 && b == 0);
     }
   }
}
\end{xten}
%~~siv
%class Hook{ def run() { (new Trans()).example(); return true; } }
%~~neg



\subsection{Copying and GlobalRef}
\label{GlobalRef}
\index{at!GlobalRef}
\index{at!blocking copying}

%%The other barrier to the potentially copious copying behavior of \xcd`at`
%%is the \xcd`GlobalRef` struct.  
A \xcd`GlobalRef[T]` (say \xcd`g`) contains a reference to
a value of type \xcd`T`, in a form which can be transmitted, and a \xcd`Place`
\xcd`g.home` indicating where the value lives. When a 
\xcd`GlobalRef` is serialized an opaque, globally unique handle to
the enclosed value \xcd`o` is passed. 

The following example does not copy the value \xcd`huge`.  However, \xcd`huge`
would have been copied if it had been put into a \xcd`Cell`, or simply used
directly. 
%~~gen ^^^ Activities50
%package Activities.copyingblockingwithglobref;
% class GR {
%  static def use(Any){}
%  static def example() {
%~~vis
\begin{xten}
val huge = "A potentially big thing";
val href = GlobalRef(huge);
at (here) {
   use(href);
  }
}
\end{xten}
%~~siv
%}
% class Hook{ def run() { GR.example(); return true; } }
%~~neg


Values protected in \xcd`GlobalRef`s can be retrieved by the application
%~~exp~~`~~`~~ g:GlobalRef[Object]{here == g.home}~~ ^^^Activities4e7q
operation \xcd`g()`.  \xcd`g()` is guarded; it can 
only be called when \xcd`g.home == here`.  If you  want to do anything other
than pass a global reference around or compare two of them for equality, you
need to placeshift back to the home place of the reference, often with
\xcd`at(g.home)`.   For example, the following  program modifies the
command-line argument array.

%~~gen ^^^ Activities60
% package Activities.Atsome.Globref2;
% class GR2 {
%~~vis
\begin{xten}
  public static def main(argv: Array[String](1)) {
    val argref = GlobalRef[Array[String](1)](argv);
    at(here.next()) use(argref);
  }
  static def use(argref : GlobalRef[Array[String](1)]) {
    at(argref.home) {
      val argv = argref();
      argv(0) = "Hi!";
    }
  }
\end{xten}
%~~siv
%} 
% class Hook{ def run() { GR2.main(["what, me weasel?"]); return true; }}
%~~neg





\subsection{Warnings about \xcd`at`}
There are two dangers involved with \xcd`at`: 
\begin{itemize}
\item Careless use of \xcd`at` can result in copying and transmission
of very large data structures.  In particular, it is very easy to capture
\xcd`this` -- a field reference will do it -- and accidentally copy everything
that \xcd`this` refers to, which can be very large.

\item As seen in the examples above, a local variable reference
  \xcd`x` may refer to different objects in different nested \xcd`at`
  scopes The programmer must either ensure that a variable accessed
  across an \xcd`at` boundary has no mutable state or be prepared to
  reason about which copy gets modified. 
\end{itemize}


