\subsection{X10}

The X10 construct \code{async S} spawns a new activity to execute
\code{S}. This activity can access variables in the lexical
environment. The construct \code{finish S} executes \code{S} and waits
for all asyncs spawned within \code{S} to terminate. 

X10 2.2 introduces {\em clocked} versions of \code{async} and
\code{finish}. This design (which is the one we will consider in this
paper) is a simplification of the original design and has the nice
property that clocks are not present as data objects in the source
program, thus removing a potential source of error. 

Clocks are motivated by the desire to support barrier computations in
which all threads in a given group must reach a point in the code (a
barrier) before all of them can progress past it. X10 permits many
clocks to exist at the same time, permits an activity to operate on
multiple clocks at the same time, and permits newly created activities
to operate on existing clocks.
 
X10 2.2 permits \code{async S} and \code{finish S} to be optionally
modified with a \code{clocked} qualifier.  When an activity executes
\code{clocked finish S} it creates a new clock \code{c}, registers
itself on it, and executes \code{finish S} with \code{c} as the {\em
  current clock}.  The clock object is implicit in that it cannot be
referred to in the code.  Within \code{S}, the \code{clocked async S}
construct can be used to spawn an async registered on the current
clock; \code{async S} should be used to spawn an async that is {\em
  not} registered on the current clock.

Note that \code{finish} blocks can be arbitarily nested, so an
activity may at any given time be registered on a stack of clocks. The
current clock is always the one most recently pushed on to the stack. 
No support is provided to register an activity on an ancestor
clock. 

When a clocked async terminates it automatically de-registers from the
clock; when the parent activity that entered the \code{clocked finish}
block reaches the end of the block it also automatically de-registers
from the clock. 

The special statement \code{advance} can be used to advance the
current clock.  Whenever an activity hits \code{advance} it blocks on
the current clock it is registered with. (It is illegal for an
un-clocked \code{async} to execute \code{advance}.) Once all
activities registered on the clock have reached an advance, all of
them can progress. 

Additionally, X10 permits computations to be run on multiple places. A
place consists of data as well as activities that operate on
it. Typically a place is realized as  an operating system process in a
cluster or multi-node computer. The \code{at (p) S} construct is used
to cause the current activity to shift to place \code{p} and execute
\code{S}. 

\code{at} blocks and (\code{clocked}) \code{async}, \code{finish}
blocks can be arbitrarily nested and arbitrarily combined with
recursion. That is, method invocations can return having spawned
\code{async}s that have not terminated. The body \code{S} of a
\code{clocked finish S} may spawn an \code{async} that is not
clocked, or may spawn a nested \code{clocked finish S}.
This flexibility makes X10 a very succinct and elegant
language for expressing many patterns of communication and
concurrency.

\subsection{Accumulators}
%% Compare with OpenMP reduction clause.
%% DOMP has arbitrary reduction types.

The class \code{Acc[T]} implements the notion of an accumulator. To
construct an instance of this class a binary associative and
commutative operator  \code{f} over \code{T} (the {\em reduction operator}) must be supplied,
together with the zero for the operator, \code{z} (satisfying
  \code{f(z)=z}), and an initial value from \code{T}. The accumulator
  provides the following operations. For \code{a} such a value, the
  operator \code{a() <- v} accumulates the value \code{v} into
  \code{a}. The operator \code{a()} returns the current value. The
  operator \code{a() = v} sets the value of the accumulator to
  \code{v}. 

There are no restrictions on storing accumulators into heap
data-structures, or aliasing them.  However, each accumulator is {\em
  registered} with the activity that created it. This registration is
automatically inherited by all activities spawned (transitively) by
this activity. It is an error for an activity to operate on an
accumulator it is not registered with.  Thus one can use the
flexibility of the heap to arrange for complex data-dependent
transmission pathways for the accumulator from point of creation to
point of use, e.g.{} arrays of accumulators, hash-maps, etc. In
particular, accumulators can be passed into arbitrary method
invocations, returned from methods etc, transmitted to other places
with no restrictions. The only restriction is that the accumulator can
only be used by the activity that created it or its children.

There are no restrictions on the use of the accumulate operation
\code{a()<- v}. 

However, the read operation \code{a()} and the update operation
\code{a()=v} are subject to a dynamic restriction. (1)~They may only
be performed by the activity that created \code{a}. (2)~Say that an
activity \code{A} is in {\em synchronous mode}) if all asyncs spawned
by \code{A} have terminated or stopped at a next on a clock registered
on \code{A}.  In such a situation there is no concurrent mutator of
\code{a} (an activity not in the subtree of \code{A} that may have
acquired a reference to \code{a} through the heap is unable to perform
any operation on it). Hence it is safe to read \code{a}. Similarly for
update. Therefore the semantics of these operations require that the
operation {\em suspend} until such time as the synchronous condition
is true. 

Intuitively, this does not introduce any deadlocks since the
spawned activities cannot be waiting for any operation by the parent
(other than an \code{advance}) in order to progress. A more detailed
treatment is provided in Section~\ref{semantics}.



Accumulators come with some dynamically-checked restrictions.

Each async (dynamically) has a set of registered \code{@Sync} accumulators
  and \code{@Async} accumulators.
  \begin{itemize}
  \item The registered \code{@Async} accumulators for an activity are
    the registered \code{@Sync} and \code{@Async} accumulators of its
    parent activity.

  \item The registered \code{@Sync} accumulators for an activity are
    the ones it has created.
  \end{itemize}

This permits computations to be determinate even though accumulators
can be stored in heaps, since no async other the async that created
the accumulator or one of its progeny can actually operate on them.


The method
\begin{lstlisting}
Runtime.isRegistered[T](x:Acc[T]):Int
\end{lstlisting}

\noindent returns \code{0} if \code{x} is not registered with the
current activity, \code{1} if it is \code{@Sync} registered, and \code{2} if
it is \code{@Async} registered.

%%  * Note: Runtime.isRegistered(Clock):Boolean should also be provided
%%    for symmetry.

An invocation \code{e.m(e1,...,en)} of an \code{@Sync} method on an \code{Acc} is
  translated to:
\begin{lstlisting}
{
  val x = e;
  if (Runtime.isRegistered(x) !=1)
    throw new IllegalAccAccess(x);
  Runtime.sync();
  x.m(e1,...,en)
}
\end{lstlisting}
The \code{@Sync} methods on an \code{Acc} are ones that return its
current value (\code{@Read}) and ones that reset it (\code{@Write}).

An invocation \code{e.m(e1,...,en)} of an \code{@Async} method on an
\code{Acc} is translated to:
\begin{lstlisting}
{
  val x = e;
  if (Runtime.isRegistered(x)==0)
    throw new IllegalAccAccess(x);
  x.m(e1,...,en);
}
\end{lstlisting}

The only \code{@Async} method on an \code{Acc} is the one that offers an
update to its value (\code{@Write}).

In many cases the compiler can statically evaluate whether
\code{Runtime.isRegistered(x) > 0} and/or whether a call to
\code{Runtime.sync()}  will suspend.

It may then appropriately simplify the above code. e.g.{}~in the code below
\begin{lstlisting}
val x:Acc[Int] = new Acc[Int](0, Int.+);
finish for (i in 0..100000) async
   x <- i;
Console.OUT.println("x is " + x());
\end{lstlisting}
\noindent the compiler can infer that \code{x()} wont suspend, due to
the \code{finish}. Hence it may eliminate the run-time suspension
check. Further it can establish that \code{x} is \code{@Sync}
registered with the current activity, hence it can eliminate the
access check.

Accs are first-class values. There are no restrictions in storing
   them in data-structures, reading them, passing them as arguments to
   methods, returning them from methods etc.

   However, any attempt to use it will fail unless the Acc is
   registered with the current activity.


The runtime checks in \code{Runtime.sync()} and
\code{Runtime.registered(..)}  ensure that the operations on an
\code{Acc} are determinate.


\begin{proposition}
\code{Acc}'s are determinate under arbitrary usage.
\end{proposition}


\subsection{Clocked types}

The central idea behind clocked data-structures is that read/write
conflicts are avoided using ``double buffering.'' Two versions of the
data-structure are kept, the {\em current} and the {\em next}
versions. Reads can be performed simultaneously by multiple activities
-- they are performed on the current version of the
data-structure. Writes are performed on the next version of the
data-structure. On detection of termination of the current phase --
when all involved activities are quiescent -- the current and the next
versions are switched.

\code{Clocked[T]} and \code{ClockedAcc[T]} are distinguished in that
unlike the former the latter permits accumulation operations.

Clocked objects are registered with activities, just like
accumulators.  This permits computations to be determinate even though
objects can be stored in heaps, since no async other than a child of
the async that creates the clocked object can actually operate on
them.

Each async (dynamically) has a set of registered clocked values. The
registered clocked values for an activity are the clocked values it
has created, and the ones registered to its parent activity.

\code{Clocked[T]}  has a constructor that takes two \code{T} arguments, these are
used to initialize the now and next fields. These arguments should be
``new'' (that is, no other data-structure should have a reference to
these arguments).

For \code{x:Clocked[T]} the following operations available to any activity on which \code{x}
is registered:
\begin{itemize}
\item \code{x()} -- this returns the value of the current field.

\item \code{x() = t} -- This is translated to x.next()=t. That is, the
  value of the next field is set. Note:
     write-write conflicts are possible since multiple activities may
     try to set the value at the same time.
\item\code{x.finalized()} -- this returns the value of the now field
  but modifies the internal state so that any subsequent attempt to
  use \code{x()=t} will result in a runtime exception.
\end{itemize}

\code{ClockedAcc[T]} has a constructor that takes two \code{T} values and a
\code{Reducer[T]} as argument. The two \code{T} values are used to initialize the
current and next fields. These arguments should be ``new'' (that is, no
other data-structure should have a reference to these arguments). The
reducer is used to perform accumulate operations.

Operations for \code{x:ClockedAcc[T]}:
\begin{itemize}
\item \code{x()} -- this returns the value of the now field.
\item\code{x() <- t} -- this accumulates \code{t} into the next field. Note: No
     write-write conflicts are possible.
\item\code{x() = t} -- this resets the value of the next field to \code{t}. To avoid
     read/write and write/write conflics, this operation should be
     invoked only by the closure argument of
     \code{Clock.advanceAll(closure)}. (See below.)
\item \code{x.finalized()} -- this returns the value of the now field but
     modifies the internal state so that any attempt to use  \code{x()=t}
     or \code{x() <- t} will result in a runtime exception.
\end{itemize}

We add the following method on Clock:
\begin{lstlisting}
public static def advanceAll(x:()=>void) {...}
\end{lstlisting}

If all activities registered on the clock invoke \code{advanceAll(f)}
(for the same value \code{f}), then \code{f} is guaranteed to be
invoked by some activity A registered on the clock at a point in time
when all other activities have entered the \code{advanceAll(f)} call
and the current/next swap has been performed for all registered
clocked values.  At this point -- also called the {\em clock quiescent
point} -- it is guaranteed that none of the other activities are
performing a read or write operation on user-accessible memory.

(A possible implementation of \code{Clocked[T]} and
\code{ClockedAcc[T]} is that a system-synthesized closure (that
performs the current/next swap) is run at the clock quiescent point
before the user specified closure is run.)



