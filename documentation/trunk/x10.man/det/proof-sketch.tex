The formalism with clocked types is too complicated, so I'll start by focusing just on accumulators.

Examples why accumulators need these two dynamic checks:
1) that a read is done in the same block the accumulator was defined,
2) that a write is done only in children blocks.

1) This check is done in rule R-Acc-R,
when reading from "a()" we check that "a" was created in the same block.
For example, the following is disallowed:
\begin{lstlisting}
val a = new Acc(0);
async { val z = a(); } // allowing this read will lead to indeterminacy (returns either 0 or 1), because the second async might or might not have executed.
async { a<-1; }
\end{lstlisting}

2) This check is done in rule R-Acc-W,
when writing to "a" we check that "a" is in $\pi$ (the permissions of the current block).
If we assume that we do allow field assignment,
then the reason for this check is that non-children activities might gain access to the accumulator,
and the wait done at the read won't wait for those activities thus leading to indeterminacy.
For example:
\begin{lstlisting}
val acc1 = new Acc(0);
val cell = new Cell(acc1);
async { 
	val a = cell.value; // might be an alias to acc1 or acc2
	val x = a(); // allowing this read will lead to indeterminacy (returns 0, 1, or 3)
}
async {
	val acc2 = new Acc(1);
	cell.value = acc2; // data race!
	acc2 <- 2;
}
\end{lstlisting}
However, we disallowed field assignment to avoid data races (and have determinacy).
Without field assignment, all objects can be stack allocated (an object cannot outlive its block, because an object can only point to objects created before it in scope).
Therefore, the second check vacaously passes (it always succeeds because an accumulator cannot leak to a non-children activity).
Phrased differently, our formalism has no need to keep track of $\pi$ (because we do not have field assignment).

The formalism without clocked types and without $\pi$ looks as follows:
\begin{figure}[t]
\begin{center}
\begin{tabular}{|l|l|}
\hline

$\hP ::= \ol{\hL},\hS$ & Program. \\

$\hL ::= \hclass ~ \hC~\hextends~\hD~\lb~\ol{\hF};~\ol{\hM}~\rb$
& cLass declaration. \\

$\hF ::= \hvar\,\hf:\hC$
& Field declaration. \\

$\hM ::= \hdef\ \hm(\ol{\hx}:\ol{\hC}):\hC\{\hS\}$
& Method declaration. \\

$\hp ::= \hl ~~|~~ \hx$
& Path. \\ %(location or parameter)

$\he ::=  \hp.\hf  ~|~ \hnew{\hC}(\ol{\hp}) ~|~ \hp()$
& Expressions. \\ %: locations, parameters, field access,  %invocation, \code{new}
$\hS ::=  \epsilon ~|~  \hp.\hm(\ol{\hp}); ~|~$ &  \\
$~~~~~ \valt{\hx}{\he} ~|~ \hp \leftarrow \hp ~|~ \hS~\hS ~|~  $ &\\
$~~~~~ \finishasync{\blockt{\ol{\hl}}{\hS}} $ & Statements. \\ %: locations, parameters, field access, invocation, \code{new}

\hline
\end{tabular}
\end{center}
\caption{FX10 Syntax without clocked types.}
\label{Figure:syntax2}
\end{figure}


\begin{figure*}[t]

\begin{center}
\begin{tabular}{|c|}
\hline
$\typerule{
}{
 \epsilon,\cH \reduce \cH
}$~\RULE{(R-Epsilon)}
~
$\typerule{
 \hS,\cH \reduce \hS',\cH' ~|~ \cH'
}{
  \begin{array}{rcl}
    \finishasync{\blockt{\ol{\hl}}{\hS}},\cH&\reduce &\finishasync{\blockt{\ol{\hl}}{\hS'}},\cH'
    ~|~ \cH' \\
    \hS~\hS_1, \cH &\reduce& \hS'~\hS_1,\cH' ~|~ \hS_1,\cH' \\
  \end{array}
}$~\RULE{(R-Trans)}
\\\\

$\typerule{
    \cH(\hl)=\hC(\ol{\hl'})
}{
  \hval{\hx}{\hl.\hf_i}{\hS},\cH \reduce \hS[\hl_i'/\hx],\cH
}$~\RULE{(R-Access)}
\gap
$\typerule{
    \cH(\hl')=\hC(\ldots)
        \gap
    \mbody{}(\hm,\hC)=\ol{\hx}.\hS
}{
  \hl'.\hm(\ol{\hl}),\cH \reduce \hS[\ol{\hl}/\ol{\hx},\hl'/\hthis],\cH
}$~\RULE{(R-Invoke)}
\\\\
$\typerule{
\cH(\ha)=\hAcc(\hr,\hv) \gap  \gap \ha\in \ol{\hl}
}{
\blockt{\ol{\hl}}{\hval{\hx}{\ha()}~\hS},\cH \reduce
\blockt{\ol{\hl}}{\hS[\hv/\hx]}, \cH'
}$~\RULE{(R-Acc-R)}
~
$\typerule{
  \cH(\ha)=\hAcc(\hr,\hv)\gap \hw=\hr(\hv,\hl) 
}{
  \ha \leftarrow \hl,\cH \reduce \cH[\ha \mapsto \hAcc(\hr,\hw)]
}$~\RULE{(R-Acc-W)}
\\\\
$\typerule{
    \hl' \not \in \dom(\cH)
}{
\blockt{\ol{\ha}}{\valt{\hx}{\hnew{\hC(\ol{\hl})}}~\hS},\cH \reduce
   \blockt{\ol{\ha},\hl}{\hS[\hl'/\hx]},\cH[ \hl' \mapsto \hC(\ol{\hl})] \\
}$~\RULE{(R-New)}
\\\\
\hline

$\typerule{
  \hS,\cH \reduce \hS', \cH' ~|~ \cH'
}{
  \async{\blockt{\ol{\hl}}{\hS"}}~\hS, \cH \reduce \async{\blockt{\ol{\hl}}{\hS"}}~\hS', \cH' ~|~ \async{\blockt{\ol{\hl}}{\hS"}}, \cH'\\
}$~\RULE{(R-Async)-}
\\
\hline
\end{tabular}
\end{center}


\caption{FX10 Reduction Rules without clocked types}
\label{Figure:reduction2}
\end{figure*}
