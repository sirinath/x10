\chapter{Fancy Types}

X10's types are a lot more powerful than we've seen so far.  They can do a lot
for you that types in Java and C++ can't do, if you want.   

Now, most of what types do for you is to prevent mistakes.  Here's a mistake: 
\begin{xten}
var total : Int = 0; 
total += "3";
\end{xten}
\xcd`total` is an integer.  You can't add a \xcd`String` value into it. 
This is a bit tricky, because you can add a \xcd`String` {\em to} it: 
\xcd`0 + "3"` evaluates to the string \xcd`"03"`.  In some languages, you {\em
can} add a string into an integer if the string contains a number, so adding
\xcd`"3"` into \xcd`total` would behave just like adding \xcd`3` into
\xcd`total`.  

A good type system will catch this mistake as early as possible, and tell you
about it in as useful a way as possible.  For X10, this means that it'll catch
the mistake when you try to compile your program -- or even sooner, if you're
using the programming environment X10DT -- and it'll print out a message
telling you that the code doesn't fit together right.   

The other thing that well-designed types do is try not to bother you too much.
This is a bit tricky. The ultimate purpose of types {\em is} to bother you --
to get in your face when you're about to goof up. At the very least, you have
to do some work in order to get any value of them. You have to write down some
types in your program, enough to tell X10 what you mean, so it can catch when
you don't do what you meant.  But X10 often lets you leave types off, so
they're not {\em too} much in your face.

\section{Constrained Types}

X10 has {\em constrained} types, sometimes called {\em dependent} types. 
You can use them to keep track of things you know about your data, \eg, that a
particular variable isn't \xcd`null`.  You can also take advantage of things
you know.

One common problem in programs (in most object-oriented languages) is that
some parts of code assume that some objects aren't \xcd`null`, but other parts
of code don't know about this assumption and set them to \xcd`null`.  This can
cause \xcd`NullPointerException`s and considerable premature gray hair.  
For example, 

%%START X10: NeedsNullCheck.x10 needsnullcheck
\fromfile{NeedsNullCheck.x10}
\begin{xtennum}[]
val x : Person = lookUp("Kim Geep");
Console.OUT.println("Kim's phone number is " + x.phoneNumber());
\end{xtennum}
%%END X10: NeedsNullCheck.x10 needsnullcheck

If Kim isn't in the database, \xcd`x.phoneNumber()` will throw an exception.  

If you want to protect yourself against this in X10, you can.  Declare \xcd`x`
with a type that says ``\xcd`x` is a \xcd`Person`, but not \xcd`null`''.  
Using this type obligates you to convince X10 that whatever value you give
\xcd`x` is not null.  Three good ways to convince X10 are: (1) use a
constructor call, since constructors never return \xcd`null`. 
(2) use a method declared to return a non-null value, though you will have to
convince X10 that method is defined properly. (3) Check the value at runtime,
with a type-cast (``\xcd`as`'') operation, 
and make sure it's not \xcd`null` there.\footnote{Method 3, checking values at
runtime, is pretty familiar from defensive programming in Java or C++.  X10's
types, if used this way, have the advantage that you can't {\em forget} to do
the check -- if you forget, your program won't compile.}

For our sample program, we choose a version of database lookup that is
guaranteed never to return \xcd`null`.  If \xcd`lookUpOrCreate(name)` doesn't
find \xcd`name` in the database, it creates a new record for that name.  This
approach doesn't make sense for all applications\footnote{Not even for this
one -- how do we really know the phone number of a newly-created
\xcd`Person`?}.  (In many cases, if some crucial datum really is missing,
there's no way to figure it out, and the best thing that can be done is to
report the error and ask a human for help.  Throwing a
\xcd`NullPointerException` is a greatly inferior choice.)

The code that uses non-null \xcd`Person`s is very much like the code that used
possibly-\xcd`null` ones: 
%%START X10: HasNullCheck.x10 hasnullcheck
\fromfile{HasNullCheck.x10}
\begin{xtennum}[]
val x : Person{self!=null} = lookUpOrCreate("Kim Geep");
Console.OUT.println("Kim's phone number is " + x.phoneNumber());
\end{xtennum}
%%END X10: HasNullCheck.x10 hasnullcheck

The code of \xcd`lookUpOrCreate` keeps track of the fact that its values are
never \xcd`null`.  The database \xcd`db` is a hash-table of
non-\xcd`null`\xcd`Person`s.  \xcd`lookUpOrCreate` itself returns a non-null
\xcd`Person`.  The constructor call at line \xlref{hasnullcheckDB-ctor}{6}
always produces a non-\xcd`null` value, and X10 knows that, so it works out
fine too.
%%START X10: HasNullCheck.x10 hasnullcheckDB
\fromfile{HasNullCheck.x10}
\begin{xtennum}[]
static val db = new HashMap[String, Person{self!=null}]();
static def lookUpOrCreate(name:String) : Person{self!=null} = {
  if( db.containsKey(name)) {
     return db.getOrThrow(name) ;
  }
  val p = new Person(); 
  db.put(name, p);
  return p;
}
\end{xtennum}
%%END X10: HasNullCheck.x10 hasnullcheckDB


\subsection{{\tt self}, {\tt this}, and all that}

Now, it's time to learn what that \xcd`self!=null` means.  You already know
\xcd`!=` and \xcd`null`, but \xcd`self` is new.  

When we're using a type, we can think of it as a test, asking if some thing
under consideration is a member of the type or not.  So, for the type
\xcd`Int`, imagine asking if \xcd`true` is a member (no), or \xcd`18` is
(yes).  With types that come from classes and such, like \xcd`Int`, we don't
need to have a name for the thing under consideration.
When we write a constraint, we do need a name for it -- and that name is
a special X10 keyword, \xcd`self`.  

So, we can write some other constraints.  Like this one, which says that the
variable \xcd`three` is an \xcd`Int` which is equal to \xcd`3`.  
%%START X10: ConstraintExamples.x10 constraintex1
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
val three : Int{self==3} = 3;
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintex1
Of course, if you try to set it to something that {\em isn't} three, it won't
work.  This doesn't compile:
%%START X10: ConstraintExamples.x10 constraintex2
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
val four : Int{self==3} = 4; 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintex2

Not-equals constraints are sometimes useful for excluding a few problem
values.    For example, if you're defining a reciprocal function, you might
want to constrain the input to avoid dividing by zero:
%%START X10: ConstraintExamples.x10 constraintexrecip
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
static def recip(n:Int{self!=0}) = 1.0/n; 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexrecip

This isn't a terrible idea, though it does require you to prove to X10 that
numbers are non-zero when you take their reciprocals.  Here are a few ways
that you can do it: 
%%START X10: ConstraintExamples.x10 constraintexUseRecip
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
static def useRecip(m:Int, n:Int{self!=0}) {
  val a = recip(n); 
  val three : Int{self==3} = 3; 
  val b = recip(three);
  val c = recip(m as Int{self!=0});
}
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexUseRecip
\begin{description}
\item [Line \xlref{constraintexUseRecip-a}{2}:] Use an argument which has been
      declared to be the right type.  That's an ordinary way to call methods
      anyhow.  Here, the right type is \xcd`Int{self!=0}`.  Since \xcd`n` has
      that type, it's fine.
\item [Line \xlref{constraintexUseRecip-b}{4}:] Use an argument which has a
      {\em more specific} type.  You're used to doing this too, when you have
      a method that takes a \xcd`Person` as an argument and you give it a
      subclass, like \xcd`Dentist`.  

      Here we're doing the same thing, in a
      slightly different way. 
      The type of \xcd`three` is \xcd`Int{self==3}`.  That's a subtype of 
      \xcd`Int{self!=0}`, because every number that {\em is} three {\em isn't}
      zero.    The official word for this is {\em subtyping by strengthening}.  
      \xcd`self==3` is logically {\em stronger} than \xcd`self!=0` --- also
      pronounced ``\xcd`self==3` implies \xcd`self!=0`''.  
      A constrained type with a stronger constraint is always a subtype of a
      type with the same base and a weaker one.  

      (As usual, we didn't have to write the type on line
      \xlref{constraintexUseRecip-decl}{3}.  We  just wrote it to make the
      example clearer.)
      
\item [Line \xlref{constraintexUseRecip-c}{5}:] 
      Use a {\em cast}.  
      At some point, you're going to
      have a value like \xcd`m`, which you don't know in advance is not zero,
      and you're going to have to tell X10 that it's not zero.  The way you
      say ``it's not zero'', here, is to use a type cast  
      \xcd`m as Int{self!=0}`.  This is just the same as any other time you
      have a value of one type and need it to be another type.

      Of course, \xcd`m` might be zero.  If \xcd`m` is zero, this cast fails
      -- \xcd`m as Int{self!=0}` first makes sure that \xcd`m` is an integer
      (which it can do at compile-time), and then that it's not zero (which
      has to be done at runtime).    If \xcd`m` is zero, this throws an
      exception, the same as any other attempt to cast a value to some type it
      isn't.   

      This isn't much of an improvement over getting a division-by-zero error.
      It might even be worse: the division by zero error is obviously about
      division by zero, but the cast error is a bit further removed from the
      problem.  

      The improvement comes earlier, when you try to write this: 
\begin{xten}
    val c = recip(m); 
\end{xten}
      This is wrong, because \xcd`m` could be zero.  
      X10 will give you a warning or an error here (depending on the 
      \xcd`STATIC_CHECKS` compiler flag -- see \Sref{sect:StaticChecks}).  

      At this point, you have been alerted to the problem. It's your
      responsibility as an intelligent programmer to figure out the right
      thing and do it.  Testing \xcd`m` and printing a comprehensible error
      message if it's zero, while untraditional in some circles, would not be
      out of the question.

\end{description}

\subsubsection{{\tt self} in nested types}

If you have a constrained type that looks like \xcd`T{c}`, where \xcd`T` is
some type and \xcd`c` some constraint, then \xcd`self` inside \xcd`c` means
{\em ``the value of type T that we're wondering whether it might be a member
of \xcd`T{c}` or not''}.  So, in \xcd`Int{self!=0}`, \xcd`self` is the
\xcd`Int` that we're saying had better not be zero.

That's a simple rule.  But it has some implications that might be brainhurty.
If you have a complicated type, there might be two \xcd`self`s inside it that
mean different things -- and are even of different types.

For example, \xcd`Array[U]{self!=null}` means ``A non-\xcd`null` array of
\xcd`U`'s''. The array itself isn't \xcd`null`. The \xcd`U`'s inside of it
might be \xcd`null`, depending on what \xcd`U` is.
\xcd`a:Array[String]{self!=null}` makes \xcd`a` be a non-\xcd`null` array of
strings, but \xcd`a` might have a \xcd`null` inside of it.

Similarly, \xcd`String{self!=null}` is the type of strings that aren't
\xcd`null`.  

So, we can use \xcd`String{self!=null}` for \xcd`U`.  
\xcd`Array[String{self!=null}]{self!=null}` is a non-\xcd`null` array of
non-\xcd`null` strings.  The first \xcd`self` refers to the \xcd`String` that
isn't null. The second one refers to the \xcd`Array` that isn't \xcd`null`.

It's easy to write an utterly incomprehensible type expression using this.  If
you find yourself tempted to do so, look at the \xcd`type` declaration
(\Sref{sect:TypeDecl}).  A couple of definitions and you can write
this: 
%%START X10: ConstraintExamples.x10 constraintexNotNull
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
var a : ArrayNotNull[StringNotNull]; 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexNotNull
which is much easier to read.


\subsection{{\tt val} variables instead of {\tt self}}


\bard{Another way of making it easier to read is variables...}

\subsection{Legal Constraints}
\subsection{Nulls and Constraints}
\subsection{Constraints and Subtyping}
\subsection{STATIC\_CHECKS}
\subsection{Incompleteness}
\subsection{Why Generics Lose Constraints At Runtime}

\section{Type Declarations}
\label{sect:TypeDecl}
\bard{do this -- note non-null type decl for niceifying Array[String{self!=null}]{self!=null} }
\section{Type Inference}
\bard{do this!}
\section{Generics}
\bard{do this!}
\section{Default Values}
\bard{do this!}
\section{Common Ancestors of Types}
\bard{do this!}
\section{When Types Don't Work}
\bard{do this!}

