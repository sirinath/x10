\section{Method Resolution}
\index{method!resolution}
\index{method!which one will get called}
\label{sect:MethodResolution}

Method resolution is the problem of determining, statically, which method (or
constructor or operator)
should be invoked, when there are several choices that could be invoked.  For
example, the following class has two overloaded \xcd`zap` methods, one taking
an \Xcd{Object}, and the other a \Xcd{Resolve}.  Method resolution will figure
out that the call \Xcd{zap(1..4)} should call \xcd`zap(Object)`, and
\Xcd{zap(new Resolve())} should call \xcd`zap(Resolve)`.  

\begin{ex}
%~~gen ^^^ MethodResolution10
%package MethodResolution.yousayyouwantaresolution;
% // This depends on https://jira.codehaus.org/browse/XTENLANG-2696
%~~vis
\begin{xten}
class Res {
  public static interface Surface {}
  public static interface Deface {}

  public static class Ace implements Surface {
    public static operator (Boolean) : Ace = new Ace();
    public static operator (Place) : Ace = new Ace();
  }
  public static class Face implements Surface, Deface{}

  public static class A {}
  public static class B extends A {}
  public static class C extends B {}

  def m(x:A) = 0;
  def m(x:Int) = 1;
  def m(x:Boolean) = 2;
  def m(x:Surface) = 3;
  def m(x:Deface) = 4; 

  def example() {
     assert m(100) == 1 : "Int"; 
     assert m(new C()) == 0 : "C";
     // An Ace is a Surface, unambiguous best choice
     assert m(new Ace()) == 3 : "Ace";
     // ERROR: m(new Face());

     // The match must be exact.
     // ERROR: assert m(here) == 3 : "Place";

     // Boolean could be handled directly, or by 
     // implicit coercion Boolean -> Ace.
     // Direct matches always win.
     assert m(true) == 2 : "Boolean"; 
  }
\end{xten}
%~~siv
%  public static def main(argv:Array[String](1)) {(new Res()).example(); Console.OUT.println("That's all!");}
% public def claim() { val ace : Ace = here; assert m(ace)==3; }
% }
% class Hook{ def run(){ (new Res()).example(); return true;} }
%~~neg

In the \xcd`"Int"` line, there is a very close match.  \xcd`100` is an
\xcd`Int`.  In fact, \xcd`100` is an \xcd`Int{self==100}`, so even in this
case the type of the actual parameter is not {\em precisely} equal to the type
of the method.

In the \xcd`"C"` line of the example, \xcd`new C()` is an instance of \xcd`C`,
which is a subtype of \xcd`A`, so the \xcd`A` method applies.  No other method
does, and so the \xcd`A` method will be invoked.

Similarly, in the \xcd`"Ace"` line, the \xcd`Ace` class implements
\xcd`Surface`, and so \xcd`new Ace()` matches the \xcd`Surface` method. 

However, a \xcd`Face` is both a \xcd`Surface` and a \xcd`Deface`, so there is
no unique best match for the invocation \xcd`m(new Face())`.  This invocation
would be forbidden, and a compile-time error issued.


The match must be exact.  There is an implicit coercion 
from \xcd`Place` to \xcd`Ace`, and \xcd`Ace` implements \xcd`Surface`, so the
code
\begin{xten}
val ace : Ace = here;
assert m(ace) == 3;
\end{xten}
works, by using the \xcd`Surface` form of \xcd`m`.  But doing it in one step
requires a deeper search than X10 performs\footnote{In general this search is
unbounded, so X10 can't perform it.}, and is not allowed.


For \xcd`m(true)`, both the \xcd`Boolean` and, with the implicit coercion,
\xcd`Ace` methods could apply.  Since the \xcd`Boolean` method applies
directly, and the \xcd`Ace` method requires an implicit coercion, this call
resolves to the \xcd`Boolean` method, without an error.

\end{ex}


The basic concept of method resolution is:
\begin{enumerate}
\item List all the methods that could possibly be used, inferring generic
      types but not performing implicit coercions.    
\item If one possible method is more specific than all the others, that one 
      is the desired method.
\item If there are two or more methods neither of which is more specific than
      the others, then the method invocation is ambiguous.  Method resolution
      fails and reports an error.
\item Otherwise, no possible methods were found without implicit coercions.
      Try the preceding steps again, but with coercions allowed: zero or one
      implicit coercion for each argument.  If a single
      most specific method is found with coercions, it is the desired method.
      If there are several, the invocation is ambiguous and erronious.
\item If no methods were found even with coercions, then the method invocation
      is undetermined.  Method resolution fails and reports an error.
\end{enumerate}

After method resolution is done, there is a validation phase that checks the
legality of the call, based on the \xcd`STATIC_CHECKS` compiler flag.  
With \xcd`STATIC_CHECKS`, the method's constraints must be satisfied; that is,
they must be entailed (\Sref{SemanticsOfConstraints}) by the information in
force at the point of the call.  With \xcd`DYNAMIC_CHECKS`, if the constraint
is not entailed at that point, a dynamic check is inserted to make sure that
it is true at runtime.

\noindent
In the presence of X10's highly-detailed type system, some subtleties arise. 
One point, at least, is {\em not} subtle. The same procedure is used, {\em
mutatis mutandis} for method, constructor, and operator resolution.  



\subsection{Space of Methods}

X10 allows some constructs, particularly \xcd`operator`s, to be defined in a
number of ways, and invoked in a number of ways. This section specifies which
forms of definition could correspond to a given definiendum.
%%OP%% , and (redundantly)
%%OP%% the syntax for invoking that definition unambiguously.  

Method invocations \xcd`a.m(b)`, where \xcd`a` is an expression, can be either
of the following forms.  There may be any number of arguments.
\begin{itemize}
\item An instance method on \xcd`a`, of the form \xcd`def m(B)`.
%%OP%% , so that the   invocation is \xcd`a.m(b)`;
\item A static method on \xcd`a`'s class, of the form \xcd`static def m(B)`.
%%OP%%       so that the invocation is \xcd`A.m(b)`.
\end{itemize}

The meaning of an invocation of the form \xcd`m(b)`, with any number of
arguments, depends slightly on its context.  Inside of a constraint, it might
mean \xcd`self.m(b)`.  Outside of a constraint, there is no \xcd`self`
defined, so it can't mean that.  The first of these that applies will be
chosen. 
\begin{enumerate}
\item Invoke a method on \xcd`this`, \viz{} \xcd`this.m(b)`.  Inside a
      constraint, it may also invoke a property method on \xcd`self`, \viz.
      \xcd`self.m(b)`.  It is an error if both \xcd`this.m(b)` and
      \xcd`self.m(b)` are possible.
\item Invoke a function named \xcd`m` in a local or field.
\item Construct a structure named \xcd`m`.
\end{enumerate}

Static method invocations, \xcd`A.m(b)`, where \xcd`A` is a container name,
can only be static.  There may be any number of arguments.
\begin{itemize}
\item A static method on \xcd`A`, of the form \xcd`static def m(B)`.
%%OP%%       the invocation is \xcd`A.m(b)`; 
\end{itemize}


Constructor invocations, \xcd`new A(b)`, must invoke constructors. There may
be any number of arguments. 
\begin{itemize}
\item A constructor on \xcd`A`, of the form \xcd`def this(B)`.
%%OP%% , so that the
%%OP%%       invocation is \xcd`new A(b)`.
\end{itemize}


A unary operator \xcdmath"$\star$ a" may be defined as: 
\begin{itemize}
\item An instance operator on \xcd`A`, defined as 
      \xcdmath"operator $\star$ this()".
%%OP%%       so that the invocation is 
%%OP%%       \xcdmath"a.operator $\star$()"; or
\item A static operator on \xcd`A`, defined as 
      \xcdmath"operator $\star$(a:A)".
%%OP%%       so that the invocation is 
%%OP%%       \xcdmath"A.operator $\star$(a)"
\end{itemize}

A binary operator \xcdmath"a $\star$ b" may be defined as: 
\begin{itemize}
\item An instance operator on \xcd`A`, defined as 
      \xcdmath"operator this $\star$(b:B)";
%%OP%%       so that the invocation is \xcdmath"a.operator $\star$(b)", 
or
\item A right-hand operator on \xcd`B`, defined as
      \xcdmath"operator (a:A) $\star$ this"; or
%%OP%%       so that the invocation is \xcdmath"b.operator ()$\star$(b)"

\item A static operator on \xcd`A`, defined as
      \xcdmath"operator (a:A) $\star$ (b:B)", 
%%OP%%       so that the invocation is \xcdmath"A.operator $\star$(a,b)"
; or
\item A static operator on \xcd`B`, if \xcd`A` and \xcd`B` are different
      classes, defined as
      \xcdmath"operator (a:A) $\star$ (b:B)"
%%OP%% , so that the invocation is 
%%OP%%       \xcdmath"B.operator $\star$(a,b)".
\end{itemize}
\noindent
If none of those resolve to a method, then either operand may be implicitly
coerced to the
other.  If one of the following two situations obtains, it will be done; if
both, the expression causes a static error.
\begin{itemize}
\item An implicit coercion from \xcd`A` to \xcd`B`, and 
      an operator \xcdmath"B $\star$ B" can be used, by 
      coercing \xcd`a` to be of type \xcd`B`, and then using \xcd`B`'s
      $\star$.  
\item An implicit coercion from \xcd`B` to \xcd`A`, and 
      an operator \xcdmath"A $\star$ A" can be used,
      coercing \xcd`b` to be of type \xcd`A`, and then using \xcd`A`'s
      $\star$.  
\end{itemize}

An application \xcd`a(b)`, for any number of arguments, can come from a number
of things. 
\begin{itemize}
\item an application operator on \xcd`a`, defined as \xcd`operator this(b:B)`;
%%OP%% , so that the 
%%OP%% invocation is \xcd`a.operator()(b)`
\item If \xcd`a` is an identifier, \xcd`a(b)` can also be a method invocation
      equivalent to \xcd`this.a(b)`, which  invokes \xcd`a` as
      either an instance or static method on \xcd`this`
\item If \xcd`a` is a qualified identifier, \xcd`a(b)` can also be an
      invocation of a struct constructor.
\end{itemize}


An indexed assignment, \xcd`a(b)=c`, for any number of \xcd`b`'s, can only
come from an indexed assignment definition: 
\begin{itemize}
\item \xcd`operator this(b:B)=(c:C) {...}`
%%OP%%       so that the invocation is \xcd`a.operator()=(b,c)`.
\end{itemize}

An implicit coercion, in 
which a value \xcd`a:A` is used in a context which requires a value of some
other non-subtype \xcd`B`, 
can only come from implicit coercion operation defined on
\xcd`B`: 
\begin{itemize}
\item an implicit coercion in \xcd`B`:
      \xcd`static operator (a:A):B`;
%%OP%%       so that the coercion is \xcd`B.operator[B](a)`;
\end{itemize}

An explicit conversion \xcd`a as B` can come from an explicit conversion
operator, or an implicit coercion operator.  X10 tries two things, in order,
only checking 2 if 1 fails: 
\begin{enumerate}
\item An \xcd`as` operator in \xcd`B`: 
      \xcdmath"static operator (a:A) as ?";
%%OP%%       so that the conversion is \xcd`B.operator as[B](a)`

\item or, failing that, an implicit coercion in \xcd`B`:
      \xcd`static operator (a:A):B`.
%%OP%% , so that the conversion is 
%%OP%%       \xcd`B.operator[B](a)`;

\end{enumerate}



\subsection{Possible Methods}

This section describes what it means for a method to be a {\em possible}
resolution of a method invocation.  



Generics introduce several subtleties, especially with the inference of
generic types. 
For the purposes of method resolution, all that matters about a method,
constructor, or operator \xcd`M` --- we use the word ``method'' to include all
three choices for this section --- is its signature, plus which method it is.
So, a typical \xcd`M` might look like 
\xcdmath"def m[G$_1$,$\ldots$, G$_g$](x$_1$:T$_1$,$\ldots$, x$_f$:T$_f$){c} =...".  The code body \xcd`...` is irrelevant for the purpose of whether a
given method call means \xcd`M` or not, so we ignore it for this section.

All that matters about a method definition, for the purposes of method
resolution, is: 
\begin{enumerate}
\item The method name \xcd`m`;
\item The generic type parameters of the method \xcd`m`,  \xcdmath"G$_1$,$\ldots$, G$_g$".  If there
      are no generic type parameters, {$g=0$}.  
\item The types \xcdmath"x$_1$:T$_1$,$\ldots$, x$_f$:T$_f$" of the formal parameters.  If
      there are no formal parameters, {$f=0$}. In the case of an instance
      method, the receiver will be the first formal parameter.\footnote{The
      variable names are relevant because one formal can be mentioned in a
      later type, or even a constraint: {\tt def f(a:Int, b:Point\{rank==a\})=...}.}
\item A {\em unique identifier} \xcd`id`, sufficient to tell the compiler
      which method body is intended.  A file name and position in that file
      would suffice.  The details of the identifier are not relevant.
\end{enumerate}

For the purposes of understanding method resolution, we assume that all the
actual parameters of an invocation are simply variables: \xcd`x1.meth(x2,x3)`.
This is done routinely by the compiler in any case; the code 
\xcd`tbl(i).meth(true, a+1)` would be treated roughly as 
\begin{xten}
val x1 = tbl(i);
val x2 = true;
val x3 = a+1;
x1.meth(x2,x3);
\end{xten}

All that matters about an invocation \xcd`I` is: 
\begin{enumerate}
\item The method name \xcdmath"m$'$";
\item The generic type parameters \xcdmath"G$'_1$,$\ldots$, G$'_g$".  If there
      are no generic type parameters, {$g=0$}.  
\item The names and types \xcdmath"x$_1$:T$'_1$,$\ldots$, x$_f$:T$'_f$" of the
      actual parameters.
      If
      there are no actual parameters, {$f=0$}. In the case of an instance
      method, the receiver is the first actual parameter.
\end{enumerate}

The signature of the method resolution procedure is: 
\xcd`resolve(invo : Invocation, context: Set[Method]) : MethodID`.  
Given a particular invocation and the set \xcd`context` of all methods
which could be called at that point of code, method resolution either returns
the unique identifier of the method that should be called, or (conceptually)
throws an exception if the call cannot be resolved.

The procedure for computing \xcd`resolve(invo, context)` is: 
\begin{enumerate}
\item Eliminate from \xcd`context` those methods which are not {\em
      acceptable}; \viz, those whose name, type parameters, and formal parameters
      do not suitably match \xcd`invo`.  In more detail:
      \begin{itemize}
      \item The method name \xcd`m` must simply equal the invocation name \xcdmath"m$'$";
      \item X10 infers type parameters, by an algorithm given in \Sref{TypeParamInfer}.
      \item The method's type parameters are bound to the invocation's for the
            remainder of the acceptability test.
      \item The actual parameter types must be subtypes of the formal
            parameter types, or be coercible to such subtypes.  Parameter $i$
            is a subtype if \xcdmath"T$'_i$ <: T$_i$".  It is implicitly
            coercible to a subtype if either it is a subtype, or if there is
            an implicit coercion operator 
            defined from \xcdmath"T$'_i$" to some type \xcd`U`, and 
            \xcdmath"U <: T$_i$". \index{method resolution!implicit coercions
            and} \index{implicit coercion}\index{coercion}.  If coercions are
            used to resolve the method, they will be called on the arguments
            before the method is invoked.
            
      \end{itemize}
\item Eliminate from \xcd`context` those methods which are not {\em
      available}; \viz, those which cannot be called due to visibility
      constraints, such as methods from other classes marked \xcd`private`.
      The remaining methods are both acceptable and available; they might be
      the one that is intended.
\item If the method invocation is a \xcd`super` invocation appearing in class
      \xcd`Cl`, methods of \xcd`Cl` and its subclasses are considered
      unavailable as well.
      
\item From the remaining methods, find the unique \xcd`ms` which is more specific than all the
      others, \viz, for which \xcd`specific(ms,mo) = true` for all other
      methods \xcd`mo`.
      The specificity test \xcd`specific` is given next.
      \begin{itemize}
      \item If there is a unique such \xcd`ms`, then
            \xcd`resolve(invo,context)` returns the \xcd`id` of \xcd`ms`.  
      \item If there is not a unique such \xcd`ms`, then \xcd`resolve` reports
            an error.
      \end{itemize}

\end{enumerate}

The subsidiary procedure \xcd`specific(m1, m2)` determines whether method
\xcd`m1` is equally or more specific than \xcd`m2`.  \xcd`specific` is not a
total order: is is possible for each one to be considered more specific than
the other, or either to be more specific.  \xcd`specific` is computed as: 
\begin{enumerate}
\item Construct an invocation \xcd`invo1` based on \xcd`m1`: 
      \begin{itemize}
      \item \xcd`invo1`'s method name is \xcd`m1`'s method name;
      \item \xcd`invo1`'s generic parameters are those of \xcd`m1`--- simply
            some type variables.
      \item \xcd`invo1`'s parameters are those of \xcd`m1`.
      \end{itemize}
\item If \xcd`m2` is acceptable for the invocation \xcd`invo1`,
      \xcd`specific(m1,m2)` returns true; 
\item Construct an invocation \xcd`invo2p`, which is \xcd`invo1` with the
      generic parameters erased.  Let \xcd`invo2` be \xcd`invo2p` with generic
      parameters as inferred by X10's type inference algorithm.  If type
      inference fails, \xcd`specific(m1,m2)` returns false.
\item If \xcd`m2` is acceptable for the invocation \xcd`invo2`,
      \xcd`specific(m1,m2)` returns true; 
\item Otherwise, \xcd`specific(m1,m2)` returns false.
\end{enumerate}

\subsection{Field Resolution}

An identifier \xcd`p` can refer to a number of things.  The rules are somewhat
different inside and outside of a constraint.

Outside of a constraint, the compiler chooses
the first one from the following list which applies: 
\begin{enumerate}
\item A local variable named \xcd`p`.
\item A field of \xcd`this`, \viz{} \xcd`this.p`.
\item A nullary property method, \xcd`this.p()`
\item A member type named \xcd`p`.
\item A package named \xcd`p`.
\end{enumerate}

Inside of a constraint, the rules are slightly different, because \xcd`self`
is available, and packages cannot be used per se.
\begin{enumerate}
\item A local variable named \xcd`p`.
\item A property of \xcd`this` or of \xcd`self`, \viz{} \xcd`this.p` or
      \xcd`self.p`.  If both are available, report an error.
\item A nullary property method, \xcd`this.p()`
\item A member type named \xcd`p`.
\end{enumerate}

\subsection{Other Disambiguations}
\label{sect:disambiguations}

It is possible to have a field of the same name as a method.
Indeed, it is a common pattern to have private field and a public
method of the same name to access it:
\begin{ex}
%~~gen ^^^ MethodResolution_disamb_a
%package MethodResolution_disamb_a;
%~~vis
\begin{xten}
class Xhaver {
  private var x: Int = 0;
  public def x() = x;
  public def bumpX() { x ++; }
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}

\begin{ex}
However, this can lead to syntactic ambiguity in the case where the field
\Xcd{f} of object \xcd`a` is a
function, array, list, or the like, and where \xcd`a` has a method also named
\xcd`f`.  The term \Xcd{a.f(b)} could either mean ``call method \xcd`f` of \xcd`a` upon
\xcd`b`'', or ``apply the function \xcd`a.f` to argument \xcd`b`''.  

%~~gen  ^^^ MethodResolution_disamb_b
%package MethodResolution_disamb_b;
%NOCOMPILE
%~~vis
\begin{xten}
class Ambig {
  public val f : (Int)=>Int =  (x:Int) => x*x;
  public def f(y:int) = y+1;
  public def example() {
      val v = this.f(10);
      // is v 100, or 11?
  }
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}

In the case where a syntactic form \xcdmath"E.m(F$_1$, $\ldots$, F$_n$)" could
be resolved as either a method call, or the application of a field \xcd`E.m`
to some arguments, it will be treated as a method call.  
The application of \xcd`E.m` to some arguments can be specified by adding
parentheses:  \xcdmath"(E.m)(F$_1$, $\ldots$, F$_n$)".

\begin{ex}

%~~gen ^^^ MethodResolution_disamb_c
%package MethodResolution_disamb_c;
%NOCOMPILE
%~~vis
\begin{xten}
class Disambig {
  public val f : (Int)=>Int =  (x:Int) => x*x;
  public def f(y:int) = y+1;
  public def example() {
      assert(  this.f(10)  == 11  );
      assert( (this.f)(10) == 100 );
  }
}
\end{xten}
%~~siv
%
%~~neg

\end{ex}

Similarly, it is possible to have a method with the same name as a struct, say
\xcd`ambig`, giving an ambiguity as to whether \xcd`ambig()` is a struct
constructor invocation or a method invocation.  This ambiguity is resolved by
treating it as a method invocation.  If the constructor invocation is desired,
it can be achieved by including the optional \xcd`new`.  That is, 
\xcd`new ambig()` is struct constructor invocation; \xcd`ambig()` is a 
method invocation.
