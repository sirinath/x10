\chapter{X10 basics}\label{chap:x10-basics}


\section{Core Object-oriented features}
The core object-oriented features of \Xten{} are very similar to those of Java or C\#.

A program consists of a collection of top-level compilation units
(``unit'' for short).  A unit is either a {\em class}, a {\em struct}
or an {\em interface}.  

{\footnotesize
\begin{verbatim}
package examples;
import x10.io.Console;
public class Hello {
  public static def main(args:Rail[String]){
     if(args.length>0) Console.OUT.println("The first arg is: "+args(0));
     Console.OUT.println("Hello, X10 world!");
     val h = new Hello(); 
     var result: Boolean = h.run(); 
     Console.OUT.println("The answer is: "+result);
  }
  public def run():Boolean=true; 
}  
\end{verbatim}}

Classes, structs and interfaces live in {\em packages} (e.g.{} {\tt
  examples} above). Packages typically consist of a sequence of
identifiers separated by ``{\tt .}'' (with no spaces). Packages are
``flat'' -- no containment relation is implied between the package
{\tt x10} and {\tt x10.examples} (for instance). 

Packages are used to control access to top-level units. If they are
marked {\tt public} they can be accessed from code in any other
package. If they have no accessibility modifier, they can be accessed
only by code living in the same package.

A file can contain multiple units -- however only one of them may be
marked {\tt public}. The name of the file must be the same as the name
of the {\tt public} unit, with the suffix ``{\tt .x10}''.

\todo{Introduce top level type defs}

The {\em fully qualified name} (FQN) of a class or interface is the
name of the class or interface prefixed with the name of the package
that unit lives in. For instance, the FQN for the class above is {\tt
examples.Hello}. A unit {\tt A} must use the FQN of another unit {\tt
B} unless it has an explicit {\tt import} statement.

For instance:
{\footnotesize
\begin{verbatim}
import x10.io.Console;
\end{verbatim}}

\noindent permits the name {\tt Console} to be used in all the units
in the file without being qualified by the package name.

The name of a package is connected to the directory structure of the
code. All the units defined in a package {\tt x10.examples} must
live in files in the directory {\tt x10/examples} (relative to some
base directory). All the units defined in the package {\tt x10}
must live in files in the directory {\tt x10}. 

\subsection{Class}

A class is a basic {\em bundle} of data and code. It specifies a number of
{\em members}, namely {\em fields}, {\em methods}, {\em consructors},
and member classes and interfaces.  Additionally a class specifies the name of
another class from which it {\em inherits} (the {\em superclass}) and zero
or more interfaces which it {\em implements}. 

The members available at a class (i.e.{} that can be used by variables
whose type is that class) are those defined at a class, and those
defined in superclasses.

% Accessibility of classes.

A class may be marked {\tt final}. {\tt final} classes cannot be subclassed.

\subsubsection{Fields}

A field specifies a data item that belongs to the class:

{\footnotesize
\begin{verbatim}
var nSolutions:Int=0;
public static val expectedSolutions =
  [0, 1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 
   365596, 2279184, 14772512];
val N:int;  
\end{verbatim}}

Fields may be mutable ({\tt var}) or immutable ({\tt val}). The type
of a mutable field must always be specified (it follows the name of
the variable, and a ``{\tt :}''). A mutable field may or may not be
initialized.  The type of an immutable field may be omitted if the
field declaration specifies an {\em initializer}.  For instance, in
the above fragment the type {\tt Rail[Int]} is inferred for the field
{\tt expectedSolutions}. The value of an immutable field does not have
to be specified through an initializer -- as long as it is supplied in
every constructor for the class. However, if an initializer is not
specified the type of the field must be specified.

Fields may be instance or static. By defaults fields are instance
fields, static fields are marked with the flag {\tt static} (as
illustrated above). Every object has one copy of an instance
field. However, there is only one copy of each static field for all
instances of that class. In \Xten{} static fields are required to be
immutable.

Instance fields are inherited by subclasses. This means that an object
always has enough space for the instance fields of the class of which
the object is an instance, and all of the object's superclasses.

A field defined in a class may be {\em shadowed} in a subclass if the
subclass defines a field with the same name (but possibly a different
type). The value of a shadowed field can always be accessed by using
the qualifier {\tt super}.

It is a compile-time error for a class to declare two fields with the
same name.

\subsubsection{Properties} \label{x10-basic-properties}
A class may specify one or more properties. Properties are immutable
instance fields of an object that are initialized in a particular way
and that can be used in constrained types
\Sref{sec:x10-basic-constrained-types}. 

To make the compile-time type-checking of constraints more tractable,
X10 v~\CurrVer{} requires 
that the types of properties are ``simpler'' than the type of the
class or struct they occur in. Specifically, the graph formed with
classes or structs as nodes and an edge from node $v$ to node $w$ if
the class or struct corresponding to $v$ has a field whose base type
is $w$ cannot have cycles. One consequence of this restriction is that
if a class or struct has a type parameter {\tt T}, then the type of a
field cannot be {\tt T}. 

\todo{What are other restrictions on properties?}

Properties are initialized by an invocation of a {\tt property} call
during execution of the constructor \Sref{sec:x10-basic-constructor} for
the object or struct. It is a compile time error for a constructor to
have a normal execution path which does not contain a {\tt property}
call. 

\subsubsection{Methods}\label{x10-basic-methods}

A method is a named piece of code, parametrized by zero or more
variables (the {\em parameters}). A method may be {\tt void} -- in
which case it returns no value and is usually called just for its
effect on the store -- or it may return a value of a given type. 

A method may have one or more type parameters; such a method is said
to be {\em type generic}. A method may have a {\em method guard }: the
guard may specify constraints on the type parameters. 

\todo{Check what else can be in a method guard.}

The {\em signature} of a method consists of its name and the types of
its arguments. A class may not contain two methods whose signatures
are the same. Additionally, a method specifies a {\em return type} and
zero or more {\em checked exceptions} that the body of the method is
permitted to throw. (The body of the method may throw any number of
unchecked exceptions.)

\todo{Checked exceptions are being re-introduced in 2.3. Check which
  version this document will deal with.}

A value {\tt e} may be returned from the body of a method by executing
a {\tt return e;} statement.  The return type of a method may be
inferred in \Xten{} (that is, it does not need to be explicitly
supplied by the user).  It is the least upper bound of the types of
all expressions {\tt e} where the body of the method contains a {\tt
return e} statement.

Methods may be {\em instance} methods or {\em static} methods. 
By default methods are instance methods. Methods are marked static by using 
the qualifier {\tt static}.

Consider the code in Table~\ref{table:NQueens-Board}.  The methods
{\tt safe(j:int)}, {\tt search(R:Region(1))} and {\tt def search()}
are instance methods.  The instance methods of a class are available
for every object that is an instance of the class.  Instance methods
are invoked using the syntax {\tt e.m(e1,..., en)}.  {\tt e} is said
to be the {\em receiver} of the method invocation, and {\tt e1,...,en}
the {\em arguments}.

Each expression in \Xten{} has a {\em static type}(Section
~\Sref{sec:static-type}).  The compiler reports an error when
processing a method invocation {\tt e.m(e1,..., en)} if it cannot find
precisely one method named {\tt m} on the static type of {\tt e} which
has {\tt n} arguments and which is such that the static type of {\tt
  ei} is a subtype of the declared type of the {\tt i}th argument.


\begin{table}
{\footnotesize
\begin{verbatim}
class Board {
 val q: Rail[Int];
 /** The number of low-rank positions that are fixed in this board for
  the purposes of search. */ 
 var fixed:Int;
 def this() {
   q = new Rail[Int](N);
   fixed = 0;
 }

 def this(b:Board) {
   this.q = new Rail[Int](N);
   Array.copy(b.q, q);
   this.fixed = b.fixed;
 }

 /** 
  * @return true if it is safe to put a queen in file <code>j</code>
  * on the next rank after the last fixed position.
  */
  def safe(j:Int) {
    for (k in 0..(fixed-1)) {
      if (j == q(k) || Math.abs(fixed-k) == Math.abs(j-q(k)))
         return false;
      }
      return true;
  }

  /** Search all positions for the current board. */
  def search() {
    for ([k] in R) searchOne(k);
  }

  /**
   * Modify the current board by adding a new queen
   * in file <code>k</code> on rank <code>fixed</code>,
   * and search for all safe positions with this prefix.
   */
  def searchOne(k:Int) {
    if (safe(k)) {
      if (fixed==(N-1)) {
        // all ranks safely filled
        NQueens.this.nSolutions++;
      } else {
          q(fixed++) = k;
          search();
          fixed--;
      }
    }
  }
}
\end{verbatim}}
  
\caption{NQueens Board}\label{table:NQueens-Board}
\end{table}

The body of an instance method may access the state of the receiver
(called the {\em current object}) through the special variable {\tt this}:
{\footnotesize
\begin{verbatim}
def search() {
  for ([k] in R) this.searchOne(k);
}
\end{verbatim}}

\noindent Unless there is risk of ambiguity, the prefix ``{\tt
  this.}'' may be omitted; thus the code can also be written as: 
{\footnotesize
\begin{verbatim}
def search() {
  for ([k] in R) searchOne(k);
}
\end{verbatim}}

The code for static methods does not have an associated current
object, and hence cannot use {\tt this}. Static methods are invoked
by naming the class as the receiver, e.g. {\tt NQueens.main(null)}.

\paragraph{Inheritance}
Methods may be inherited. That is, methods defined on superclasses are
available as methods on a subclass, unless they are overridden by
another method declaration with the same signature. Instance methods
are said to be {\em virtually dispatched}: this means that when a
method is invoked on an object {\tt o} that is an instance of class
{\tt C}, the inheritance tree for {\tt C} is searched (starting from
{\tt C}) for a method definition with the same signature. The first
definition found is executed. The type rules for \Xten{} guarantee
that at runtime such a method will exist.

\paragraph{Overloading}
In \Xten{} methods may be overloaded. This means that a class may have
multiple methods with the same name -- of necessity they must have a
different signature. These methods have nothing to do with each other. 

Overloading is very convenient -- it permits the programmer to use a
method name for some abstract concept and than provide instantiations
of that concept for different parameter types through different
overloaded methods with the same name. The name {\tt search} is overloaded in 
Table~\ref{table:NQueens-Board}, for instance.

\paragraph{Access control}
The qualifiers {\tt private, public,protected} may be used to limit
access to a method. {\tt private} methods may be accessed only by code
in the same class. {\tt public} methods can be accessed from any
code. {\tt protected} methods can only be accessed in the same class
or its subclasses. If no qualifier is provided, a method can be
accessed by code in the same package (it is said to be {\em package protected}).

\subsubsection{Constructors}

A class may specify zero or more {\em constructors}. For instance:
{\footnotesize
\begin{verbatim}
def this() {
   q = new Rail[Int](N);
   fixed = 0;
}
def this(b:Board) {
   this.q = new Rail[Int](N);
   Array.copy(b.q, q);
   this.fixed = b.fixed;
}
\end{verbatim}}

\noindent Constructors may be overloaded just like methods.  The
qualifiers {\tt private, public, protected} may be used to limit access
to a constructor.

Instances of a class are created by invoking constructors using the
{\tt new} expression:

{\footnotesize
\begin{verbatim}
new Board(q, k)
\end{verbatim}
}

The compiler declares an error if it cannot find a constructor for the
specified class with the same number of formal arguments such that the
formal type of each argument is a supertype of the type of each actual
argument.

If a class does not have a constructor an {\em implicit} constructor
is created. If the class has no properties then the implicit
constructor is of the form: 
{\footnotesize
\begin{verbatim}
def this() {}
\end{verbatim}}

If the class has properties {\tt x1:T1}, \ldots, {\tt xn:Tn} then the
implicit constructor is of the form:
{\footnotesize
\begin{verbatim}
def this(x1:T1,...,xn:Tn) {
    property(x1,...,xn);
}
\end{verbatim}}

\subsection{Structs}\label{sec:x10-basic-structs}

X10 also permits the definition of {\em structs}. An object is
typically represented through {\em handles}, indirect references to a
contiguous chunk of data on the heap. The space allocated
for an object typically consists of space for its fields and space for
a {\em header}. A header contains some bytes of data that represent
meta-information about the object, such as a reference to the table of
methods used to implement virtual dispatching on the object. 

A {\tt struct} is a ``header-less'' object. It can be represented by
exactly as much memory as is necessary to represent the fields of the
struct (modulo alignment constraints) and with its methods compiled to
``static'' methods.  This is accomplished by imposing certain
restrictions on structs (compared to objects).  A {\tt struct}
definition is just like a {\tt class} definition except that it is
introduced by the keyword {\tt struct} rather than by {\tt 
  class}.  Like a class, a struct may define zero or more fields,
constructors and methods and may implement zero or more
interfaces. However, a struct does not support inheritance; it may not
have an {\tt extends} clause. A struct may not be recursive: that
is, there can be no cycles in the graph whose nodes are struct
definitions and whose edges from $a$ to $b$ record that the struct $a$
has a field of type (struct) $b$.  

For instance the struct:
{\footnotesize
\begin{verbatim}
  struct Complex(re:Double, im:Double){}
\end{verbatim}}
\noindent defines a {\tt Complex} struct instanes of which can be
represented by  exactly two doubles. An {\tt Array[Complex]} with {\tt
  N} elements can be implemented with a block of memory containing
{\tt 2*N} doubles, with each {\tt Complex} object inlined. 

X10 does not support any notion of a reference to a struct. 
Structs are passed by value. Equality {\tt ==} on structs is defined as
point-wise equality on the fields of the struct. Further, structs are
immutable, no syntax is provided to update fields of a struct in
place.  While these decisions simplify the language, they make it
awkward to express certain kinds of code, hence mutability and
references to structs may be introduced in future versions of the
language. 

\subsection{Function literals}\label{sec:x10-basic-functions}\label{sec:x10-basics-functions}
X10 permits the definition of functions via literals. 
Such a literal consists of a parameter list, followed optionally by a
return type, followed by {\tt =>}, followed by the body (an
expression).

For instance the function that takes an argument {\tt i} that is an {\tt int} and returns
{\tt old(i)} if {\tt i < n} and {\tt newItem} otherwise, is written as:
{\footnotesize
\begin{verbatim}
(i:int)=> (i < n? old(i) : newItem)
\end{verbatim}}
The type of this value is {\tt (int)=>int}. Note that the return type is inferred in the above definition. We could also have written it explicitly as:
{\footnotesize
\begin{verbatim}
(i:int):int => (i<n?old(i):newItem)
\end{verbatim}}

For instance:
{\footnotesize
\begin{verbatim}
  (a:Int)=>a       // the identity function on Int's
  (a:Int, b:Int):Int => a < b? a:b // min function
\end{verbatim}}
Above, the type of the first value is {\tt (Int)=>Int}, the type of
functions from {\tt Int} to {\tt Int}. The type of the second is
{\tt (Int,Int)=>Int}. 

A function is permitted to access immutable variables defined outside
its body (such functions are sometimes called closures). Note that the
immutable variable may itself contain an object with mutable state.

The return type can often be omitted  -- it is inferred to be the
type of the return expression.

If {\tt x} is a  function value of type {\tt (S1, ..., Sn)=> T}, and 
{\tt s1, ..., sn} are values of the given types, then {\tt
  x(s1,...,sn)} is of type {\tt T}. 

%\section{Expressions}
%\Xten{} supports the usual 
% cover array literals, Range literals.

%% Somewhere talk about user defined operators. 
\section{Statements} \label{sec:x10-basic-statements}

The sequential statements of \Xten{} should be familiar   from Java
and C++.

\subsubsection{Assignment.}
The statement {\tt x=e} evaluates the expression
 {\tt e} and assigns it to the local variable {\tt x}.

The statement
 {\tt d.f=e} evaluates {\tt d} to determine an object {\tt o}. This
 object must have a field {\tt f} that is mutable. This value is
 changed to the value obtained by evaluating {\tt e}.

In both cases the compiler
 checks that the type of the right hand side expression is a subtype
 of the declared type.\footnote{If it is not, the compiler tries to
   first check for user-defined coercions. Only if it cannot find one
   does it declare an error. See the Language Manual for more details.}


\subsubsection{Conditionals.} {\tt if (c) then S else S}. The first branch is
 executed if the condition {\tt c} evaluates to true, else the second
 branch is executed. One-armed conditionals are also permitted (the
 {\tt else S} may be dropped).

\subsubsection{While loops.} {\tt while (c) S}. The condition {\tt c} is
 evaluated. If it is true, the body {\tt S} is executed, and the
 control returns to the top of the loop and the cycle of condition
 evluation and body execution repeats. Thus the loop terminates only
 when the condition evaluates to false.

 A while loop may be labeled {\tt l: while (c) S} (just as any other
 statement). The body of a {\tt while} loop may contain the statements
 {\tt continue l;} and {\tt break l;}. The first causes control to
 jump to the top of the loop labeled {\tt l}, i.e. the rest of the
 code in the body of the loop following the {\tt continue l;}
 statement is not executed. {\tt break l;} causes control to jump
 after the loop labeled {\tt l} (that is, control exits from that
 loop).

\subsubsection{For loops.}
\Xten{} supports the usual sort of {\tt for} loop.
The body of a {\tt for} loop
may contain {\tt break} and {\tt continue} statements just like {\tt
while} loops.

Here is an example of an explicitly enumerated for loop:
{\footnotesize
\begin{verbatim}
def sum(a:Rail[Int]):Int {
    var result:Int=0;
    for (var x:Int=0; x < a.size; ++x)
       result += a(x);
    return result;
}
\end{verbatim}}

\Xten{} also supports enhanced for loops.
The for loop may take an index specifier {\tt v in r}, where {\tt r}
is any value that implements {\tt x10.lang.Iterable[T]} for some type
{\tt T}. The body of the loop is executed once for every value
generated by {\tt r}, with the value bound to {\tt v}. 

{\footnotesize
\begin{verbatim}
def sum(a:Rail[Int]):Int {
   var result:Int=0;
   for (v in a.values())
      result += v;
   return result;
}
\end{verbatim}}

Of particular interest is {\tt IntRange}. The expression {\tt e1
  .. e2} produces an instance of {\tt IntRange} from {\tt l} to {\tt
  r} if {\tt e1} evaluates to {\tt l} and {\tt e2}
evaluates to {\tt r}. On iteration it enumerates all the values (if
any) from {\tt l} to {\tt r} (inclusive). Thus we can sum the numbers
from {\tt 0} to {\tt N}:

{\footnotesize
\begin{verbatim}
def sum(N:Int):Int =
  finish (Misc.Sum) {
    for (v in 0..N)
      offer v;
  };
\end{verbatim}}

One can iterate over multiple dimensions at the same time using {\tt
  Region}. A {\tt Region} is a data-structure that compactly
represents a set of {\em points}. For instance, the region {\tt
  (0..5)*(1..6)} is a 2-d region of points {\tt (x,y)} where {\tt x}
ranges over {\tt 0..5} and {\tt y} over {\tt 1..6}. (The bounds are
inclusive.) The natural iteration order for a region is
lexicographic. Thus one can sum the coordinates of all points in a
given rectangle:
{\footnotesize
\begin{verbatim}
def sum(M:Int, N:Int):Int =
  finish (Plus) {
    for ([x,y] in (0..M)*(0..N))
      offer x+y;
  };
\end{verbatim}}
Here the syntax {\tt [x,y]} is said to be {\em destructuring syntax};
it destructures a 2-d point into its coordinates {\tt x} and {\tt
  y}. One can write {\tt p[x,y]} to bind {\tt p} to the entire point.


\subsubsection{Throw statement.} \Xten{} has a non-resumptive exception
  model. This means that an exception can be thrown at any point in
  the code. Exceptions are of two kinds, {\em checked} and {\em
    unchecked} exceptions. Checked exceptions are subclasses of {\tt
    x10.lang.Exception}; if a method throws such an exception then it
  must declare that it does so with a {\tt throws} clause (placed
  after the return type of the method, if any, and the body of the
  method).

Throwing an exception causes the call stack to be unwound until a
catcher can be found (see below). If no catcher can be found the
exception is thrown to the closest dyamically enclosing {\tt finish}
surrounding the throw point. 

\subsubsection{Try catch statement.} A {\tt try/catch/finally} statement works
  just as in Java. It permits exceptions to be caught (through a {\tt
    catch} clause) and computation resumed from the point of
  capture. A {\tt finally} clause specifies code that must be run
  whenever control exits the {\tt try} block -- regardless of whether
  the return is normal or exceptional.

\subsubsection{Return statement.} The statement {\tt return;} causes control to
  return from the current method. The method must be a {\tt void}
  method. The statement {\tt return e;} causes control to return from
  the current method with the value {\tt e}.

A description of the other control constructs may be found in \cite{XtenManual}.

\section{Types}\label{sec:x10-basics-types}
The following topics will be covered in more detail in the next edition of these notes:

\begin{itemize}

  \item The name of a class or interface is the most basic form of a
  type in \Xten. A type specifies a set of members (fields, methods, contsructors) that are
  defined on expressions of that type.

  The availability of members of a type also depends on the
  accessibility relation. That is, a member of a type may be defined
  but not accessible (e.g. it is marked {\tt private}).

\item \Xten{} is a statically type-checked language. This means that
  the compiler checks the type of each expression, and ensures that
  the operations performed on an expression are those that are
  permitted by the type of the expression.  

\item A variable of a type {\tt S} can only be assigned values whose
static type {\tt T} is a {\em subtype} of {\tt S}. 

A class {\tt C} (viewed as a type) is a subtype of a class {\tt D}
(viewed as a type) if it inherits from {\tt D}.  

An interface {\tt I} viewed as a type is a subtype of an interface
{\tt J} (viewed as a type) if {\tt I} inherits from {\tt J}.

A class {\tt C} implementing an interface {\tt I} is a subtype of {\tt
  I}. 
\end{itemize}

\subsection{Generic types}\label{x10-basics-generic-types}
\Xten{} permits {\em generic types}. That is a class or interface may be declared parametrized by types:

{\footnotesize
\begin{verbatim}
class List[T] {
   var item:T;
   var tail:List[T];
   ...
}
\end{verbatim}}

This specifies that the class definition actually specifies an
infinite family of classes, namely those obtained by replacing the type
parameter {\tt T} with any concrete type. For instance, {\tt
List[int]} is the class obtained by replacing {\tt T} in the body of the class with {\tt int}:
{\footnotesize
\begin{verbatim}
class List_int {
   var item:int;
   var tail:List_int;
   ...
}
\end{verbatim}}

Clearly generic types are very convenient -- after all they let you
figure out the code of the class once, and then use it an unbounded
number of times ... in a type-safe fashion.

\Xten{} types are available at runtime, unlike Java (which erases
them).  Bounds may be specified on type parameters and methods can be
invoked on variables whose type is that parameter, as long as those
methods are defined and accessible on the bound.

\subsection{Constrained types}\label{x10-basics-constrained-types}
Constrained types are a key innovation of X10.

A constrained type is of the form {\tt T\{c\}} where {\tt T} is a
type and {\tt c} is a {\tt Boolean} expression of a restricted
kind. {\tt c} may contain references to the special variable
{\tt self}, and to any final variables visible at its point of
definition. 

Such a type is understood as the set of all entities {\tt o} which
are of type {\tt T} and satisfy the constraint {\tt c} when
{\tt self} is bound to {\tt o}.

The permitted constraints include the predicates {\tt ==} and
{\tt !=}.  These predicates may be applied to constraint terms. A
constraint term is either a final variable visible at the point of
definition of the constraint, or the special variable {\tt self} or
of the form {\tt t.f} where {\tt f} names a field, and {\tt t} is 
(recursively) a constraint term. In a term {\tt self.p} {\tt p} must
name a property of {\tt self}. 

Examples:
{\footnotesize
\begin{verbatim}
 Matrix[Int]{self.I==100, self.J==200} // 100 x 200 matrix
 Matrix[Int]{self.I==self.J} // the type of square matrices.
\end{verbatim}}

Constraints may also include occurrences of user-defined
predicates. See \cite{X10RefManual} for details.

\subsection{Type definitions}

A type definition permits a simple name to be supplied for a
complicated type, and for type aliases to be defined. A type
definition consists of a name, an optional list of type parameters, an
optional list of (typed arguments), an ``{\tt =}'' symbol, followed by
a type in which the type parameters and arguments may be used.

For instance the type definition:
{\footnotesize
\begin{verbatim}
  public static type boolean(b:Boolean) = Boolean{self==b};
\end{verbatim}}
\noindent permits the expression {\tt boolean(true)} to be used as shorthand the type {\tt Boolean\{self==true\}}.

X10 permits top-level type definitions. A type definition with
principal name {\tt N} must be defined in the file
{\tt N.x10}. Example:

{\footnotesize
\begin{verbatim}
// Matrix.x10
public class Matrix[T](I:Int, J:Int) { 
...
}
type Matrix[T](I:Int,J:Int)=Matrix[T]{self.I==I, self.J==J};
// end of Matrix.x10
\end{verbatim}}

Note that a file may contain a type definition all by itself. This is
the case for {\tt Rail.x10}:

{\footnotesize
\begin{verbatim}
// x10/lang/Rail.x10
package x10.lang;

public type Rail[T] = Array[T]{self.rank==1,self.zeroBased,self.rect,self.rail};
// end of x10/lang/Rail.x10
\end{verbatim}}







