
This section presents an informal description of 
dependent and generic types in \Xten{}.  In this presentation,
we simplify and elide many details of the \Xten{} semantics.

\Xten{} is a class-based object-oriented language.
The language has a sequential core similar to Java or Scala, but
also
constructs for concurrency and distribution, as well as constrained
types, described here.  Like Java, the language provides single class
inheritance and multiple interface inheritance.

A constrained type in \Xten{} is written \xcd"C{e}", where \xcd"C" is the
name of a class and \xcd"e" is a constraint on the properties of
\xcd"C" and the final variables in scope at the type.  The
constraint \xcd"e" may refer to the value being constrained through
the special variable \xcd"self", which has type \xcd"C" in the
constraint.  Constraints are drawn from a constraint language that,
syntactically, is a subset of the boolean expressions of \Xten{}.  For
brevity, the constraint may be omitted and interpreted as \xcd"true".

To illustrate the features of dependent types in \Xten{}, we
develop a \xcd"List"
class.  We will present several versions of \xcd"List" as we
introduce new features.
A \xcd"List" class with a type property \xcd"T" and an \xcd"int"
property \xcd"length" is declared as in Figure~\ref{fig:list0}.
Classes in \Xten{} may be declared with any number of type properties and
value properties.

\begin{figure}
{\footnotesize
\begin{xtennoindent}
class List[T](length: int) {
  var head: T;
  val tail: List[T];
  def get(i: int): T {
    if (i == 0) return head;
    else return tail.get(i-1);
  }
  def this[S](hd: S, tl: List[S]): List[S](tl.length+1) {
    property[S](tl.length+1);
    head = hd; tail = tl;
  }
}
\end{xtennoindent}
}
\caption{List example, simplified}
\label{fig:list0}
\end{figure}

Like in Scala, fields are declared using the keywords \xcd"var"
or \xcd"val".  The \xcd"List" class has a mutable \xcd"head"
field with type \xcd"T" (which resolves to \xcd"this.T"), and an
immutable (final) \xcd"tail" field with type \xcd"List[T]", that
is, with type \xcd"List{self.T==this.T}".  Note that \xcd"this" occurring
in the constraint refers to the instance of the enclosing
\xcd"List" class,
and \xcd"self" refers to the value being
constrained---\xcd"this.tail" in this case.

Methods are declared with the \xcd"def" keyword.
The method \xcd"get" takes a final integer \xcd"i" argument
and returns the element at that position.

Objects in \Xten{} are initialized with constructors, which
must ensure that all properties of the new object
are initialized and that the class invariants of the object's
class and its superclasses and superinterfaces hold.
\Xten{} uses method syntax with the name
\xcd"this" for constructors.
In \Xten{}, constructors have a ``return type'', which constrains
the properties of the new object.  The constructor in
Figure~\ref{fig:list0} takes a type argument \xcd"S"
and two value arguments \xcd"hd" and \xcd"tl".  The constructor
return type specifies that the constructor initializes the
object to have type \xcd"List[S](tl.length+1)", that is,
\xcd"List{self.T==S," \xcd"self.length==tl.length+1}".
The formal parameter types and return types of both methods and
constructors may refer to final parameters of the same
declaration.

The body of the constructor
begins with a \xcd"property" statement that initializes the
properties of the new instance.  All properties are initialized
simultaneously and it is required that the property assignment
entail the constructor return type.
The remainder of the constructor assigns the fields of the
instance with the constructor arguments.

We next present a version of \xcd"List" where we write
invariants to be enforced statically.  Consider the new version
in Figure~\ref{fig:list}.

\begin{figure}
{\footnotesize
\begin{xtenmathnoindent}
class List[T](length: int){length >= 0} {
  var head{length>0}: T;
  val tail{length>1}: List[T](length-1);

  def get(i: int{0 <= i, i < length}){length > 0} {
    return i==0 ? head : tail.get(i-1);
  }

  def map[S](f: T => S): List[S] {
    if (length==0)
      return new List[S](0);
    else if (length==1)
      return new List[S](f(head));
    else
      return new List[S](f(head), tail.map[S](f));
  }

  def this[S](): List[S](0) = property[S](0);
  def this[S](hd: S): List[S](1) {
    property[S](1); head = hd;
  }
  def this[S](hd: S, tl: List[S]): List[S](tl.length+1) {
    property[S](tl.length+1);
    head = hd; tail = tl;
  }
}
\end{xtenmathnoindent}}
\caption{List example, with more constraints}
\label{fig:list}
\end{figure}

\subsection{Class invariants}

Properties of a class may be constrained with 
a \emph{class invariant}.   
The \xcd"List" declaration's class invariant in
Figure~\ref{fig:list} specifies that the length of
the list be non-negative.  
The class invariant must be established by all constructors of
the class and can subsequently be assumed for all instances of the class.

For generic types, the invariant is used to provide subtyping
bounds on the type properties.  For instance, a binary
tree class
might require that its elements implement the \xcd"Comparable"
interface:
\begin{xtenmath}
class Tree[T]{T $\extends$ Comparable[T]} {
  left, right: Tree[T]; ...
}
\end{xtenmath}

\subsection{Class member invariants}

Class and interface member declarations may have additional
constraints, or \emph{guards}, that must be satisfied for access.

The field declarations in Figure~\ref{fig:list}
each have a guard.  The guard on
\xcd"head" requires that \xcd"length" \xcd">" \xcd"0";
that is \xcd"this.head" may not be dereferenced
unless \xcd"this" has type \xcd"List{length>0}".  Similarly,
\xcd"tail" cannot be accessed unless the list has a non-empty tail.  The
compiler is free to generate optimized representations of
instances of \xcd"List" with a given length: it may remove the
the \xcd"head" and \xcd"tail" fields for empty lists, for
instance.  Similarly, the compiler may specialize instances of
\xcd"List" with a given concrete type for \xcd"T".  This
specialization is described in Section~\ref{sec:impl}.

The method \xcd"get" in Figure~\ref{fig:list}
has a constraint on the type of \xcd"i" that requires
that it be within the list bounds.
The method also has a guard that
requires that the actual
receiver's
\xcd"length" field must be non-zero---calls to \xcd"get" on empty lists are not
permitted.
A method with a guard is called a \emph{conditional method}.
The constraint on \xcd"get" ensures that the guard on 
\xcd"tail" is satisfied in the method body.
In the method body, the \xcd"head" of the list is returned for
position \xcd"0"; otherwise, the call recurses on \xcd"tail".
Note that for this example to type-check, the constraint system
must establish the guard on \xcd"tail"
and the guard on the recursive call to \xcd"get";
that is, it must be able
guarantee that the \xcd"tail" is non-empty and that
\xcd"i-1" is within the bounds of \xcd"tail".
\eat{
The constraint solver must prove
{\footnotesize
$$
\begin{array}[t]{l}
\tt length > 0, tail.length=length-1, 0 \leq i, i < length, i \not= 0 \\
\tt \quad\vdash tail.length > 0, 0 \leq i-1,i-1 < tail.length 
\end{array}
$$}
}

Method overriding is similar to Java: a method of a subclass
with the same name and parameter types overrides a method of the
superclass.  An overridden method may have a return type that is
a subtype of the superclass method's return type.
A method guard may be weakened by an overriding
method; that is, the guard in the superclass must entail the  
guard in the subclass.

Methods may also have type parameters.  
For instance, the \xcd"map" method in Figure~\ref{fig:list} 
has a type parameter \xcd"S" and a value parameter that is a
function from \xcd"T" to \xcd"S".
A parametrized method is invoked by giving type arguments before the
expression arguments (see recursive call to
\xcd"map").\footnote{Actual type arguments can be inferred from the types
of the value arguments. Type inference is out of the scope of this paper.}

\xcd"List" also defines three constructors: the first
constructor takes no value arguments and initializes
the length to \xcd"0".  Note that \xcd"head" and \xcd"tail" are
not assigned since they are inaccessible.
The second constructor takes an argument for the head of the
list; the third takes both a head and tail.

\subsection{Type constraints and variance}
\label{sec:variance}
Use-site variance based on structural virtual types were proposed by
Thorup and Torgerson~\cite{unifying-genericity} and extended for
parametrized type systems by Igarashi and
Viroli~\cite{variant-parametric-types}.  The latter type system lead
to the development of wildcards in
Java~\cite{Java3,adding-wildcards,wildcards-safe}.

Type properties and subtyping constraints may be used in \Xten{} to 
provide use-site variance
constraints.

Consider the following subtypes  of \xcd"List" from
Figure~\ref{fig:list}.
\begin{itemize}
\item \xcd"List".  This type has no constraints on the type
property \xcd"T".
Any type that constrains \xcd"T",
is a subtype of \xcd"List".  The type \xcd"List" is equivalent to
\xcd"List{true}".
%
For a \xcd"List" \xcd"l", the return type of the \xcd"get" method
is \xcd"l.T".
Since the property \xcd"T" is unconstrained,
the caller can only assign the return value of \xcd"get"
to a variable of type \xcd"l.T" or of type \xcd"Object".

\item \xcd"List{T==float}".
The type property \xcd"T" is bound to \xcd"float".
For a final expression \xcd"l" of this type,
\xcd"l.T" and \xcd"float" are equivalent types and can be used
interchangeably.

\item \xcdmath"List{T$\extends$Collection}".
This type constrains \xcd"T" to be a subtype of \xcd"Collection".
All instances of this type must bind \xcd"T" to a subtype of
\xcd"Collection"; for example \xcd"List[Set]" (i.e.,
\xcd"List{T==Set}") is a subtype of
\xcdmath"List{T$\extends$Collection}" because \xcd"T==Set" entails
\xcdmath"T"
\xcdmath"$\extends$"
\xcdmath"Collection".
%
If \xcd"l" has the type \xcdmath"List{T$\extends$Collection}",
then the return type of \xcd"get" has type \xcd"l.T", which is an unknown but
fixed subtype of \xcd"Collection"; the return value can be
assigned into a variable of type \xcd"Collection".

\item \xcdmath"List{T$\super$String}".  This type bounds the type property
\xcd"T"
from below.  For a \xcd"List" \xcd"l" of this type, any
supertype of \xcd"String" may flow into a variable of type \xcd"l.T".
The return type of the \xcd"get"
method is known to be a
supertype of \xcd"String" (and implicitly a subtype of \xcd"Object").
\end{itemize}

In the shortened syntax for types (e.g., \xcd"List[T](n)"),
an actual type argument \xcd"T" may optionally
be annotated
with
a \emph{use-site variance tag}, either \xcd"+" or \xcd"-":
if \xcd"X" is a type property, then
the syntax \xcd"C[+T]" is shorthand for \xcdmath"C{X$\extends$T}" and
\xcd"C[-T]" is shorthand for \xcdmath"C{X$\super$T}"; of course,
\xcd"C[T]" is shorthand for \xcd"C{X==T}".



\eat{
\subsection{Type properties}

Type properties may be declared invariant, covariant, or
contravariant.
If a property \xcd"X" of a class \xcd"C" is covariant,
then if \xcd"S" is a subtype of
\xcd"T", the type \xcd"C{X==S}" is a subtype of \xcd"C{X==T}".
Similarly, if \xcd"X" is contravariant, 
                  \xcd"C{X==T}" is a subtype of \xcd"C{X==S}".
It is illegal for a covariant property to occur in a negative
position in its class declaration and for a contravariant
property to occur in a positive position.  A position is
negative if it is a formal parameter type, or occurs in a method
where clause.  A position is positive if it is a return type or
occurs in a method constraint.
}

\eat{
\subsection{Methods}

Methods in \Xten{} are declared with the \xcd"def" keyword.
The \xcd"List" class in Figure~\ref{fig:list} declares methods
\xcd"get" and \xcd"map".

Like Java, \Xten{} supports both instance and static methods.
Since a type property is an instance member, a static method may
not refer to a type property of the class.

Interfaces are also permitted to have static methods.  Classes
implementing the interface must provide an implementation of the
static methods of the interface.
This feature is
useful when a type property \xcd"T" is constrained to implement
an interface \xcd"I"; static methods of \xcd"I" can be invoked
through \xcd"T".
}

\eat{
\subsection{Interfaces}

optional interfaces
value properties in interfaces
static methods in interfaces

\subsubsection{Optional methods and interfaces}

Method constraints also provide support for optional methods.

{\footnotesize
\begin{xtenmath}
class List[T] {
    ...
    def print(){T $\extends$ Printable} {
        for (x: T in this)
            x.print();
    }
}
\end{xtenmath}}

\xcd"List.print" may only be called on lists instantiated on
subtypes of the \xcd"Printable" interface.

Optional methods generalize to optional interfaces.

{\footnotesize
\begin{xtenmath}
interface Printable { def print(); }

class List[T] implements Printable if {T $\extends$ Printable} {
    ...
    def print(){T $\extends$ Printable} {
        for (x: T in this)
            x.print();
    }
}
\end{xtenmath}}

In this case \xcd"List" implements the \xcd"Printable" interface
only if \xcd"List.T" implements \xcd"Printable".
Thus \xcd"List{T==String}"
and \xcd"List{T==List[String]}"
are subtypes of \xcd"Printable", but
\xcd"List{T" \xcd"==DirtyWord}" is not.


Without optional interfaces, \xcd"List" cannot be a subtype
of \xcd"Printable".  The constraint \xcdmath"{T $\extends$ Printable}" on
the \xcd"print" method is more restrictive than the 
constraint (i.e., \xcd"true") on 
\xcd"Printable.print".
}
