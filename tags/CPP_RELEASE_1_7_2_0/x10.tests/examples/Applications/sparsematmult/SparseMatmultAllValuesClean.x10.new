/*
 *
 * (C) Copyright IBM Corporation 2006
 *
 *  This file is part of X10 Test.
 *
 */
import java.util.Random;
import harness.x10Test;;

/**
 * Version of the JGF SparseMatmult benchmark with
 * mostly values and no async operations (differs in
 * terms of how data is distributed from JGF).
 *
 * This version also uses the Random number generator
 * differently and does not iterate, hence the different
 * final result.
 *
 * @author Christian Grothoff
 */
public class SparseMatmultAllValuesClean extends x10Test {

	const RANDOM_SEED: long = 10101010;
	const size: int = 0;
	const datasizes_M: Array[int] = { 500, 100000, 500000 };
	const datasizes_N: Array[int] = { 500, 100000, 500000 };
	const datasizes_nz: Array[int] = { 2500, 500000, 2500000 };
	const R: Random = new Random(RANDOM_SEED);

	public def this(): SparseMatmultAllValuesClean = { }

	public static def main(var args: Rail[String]): void = {
		new SparseMatmultAllValuesClean().execute();
	}

	var pos: int; // X10 hack (local variable of run that must be modified in inner class)

	public def run(): boolean = {
		final val nthreads: int = place.MAX_PLACES;
		final val d_places: dist = distmakeUnique(place.places);
		final val r_N: region = [0..datasizes_N(size-1)];
		final val r_M: region = [0..datasizes_M(size-1)];
		final val r_nz: region = [0..datasizes_nz(size-1)];
		final val r_nthreads: region = [0..nthreads-1];
		final val d_N: dist = distmakeBlock(r_N, place.places);
		final val d_M: dist = distmakeBlock(r_M, place.places);
		final val d_nz: dist = distmakeBlock(r_nz, place.places);
		final val d_nthreads: dist = distmakeUnique(place.places);

		final val row: Array[int] = new Array[int](Dist.makeConstant(r_nz, here), (var point[i]: point): int => {
				return Math.abs(R.nextInt()) % datasizes_M(size);
			});
		final val col: Array[int] = new Array[int](Dist.makeConstant(r_nz, here), (var point[i]: point): int => {
				return Math.abs(R.nextInt()) % datasizes_N(size);
			});

		// val is the representation of the sparse MxN matrix;
		// val[i,j] corresponds to matrix[row[i],col[j]]
		final val val: Array[double] = new Array[double](Dist.makeConstant(r_nz, here), (var point[i]: point): double => {
				return R.nextDouble();
			});

		// reorder arrays for parallel decomposition
		// reorders the matrix to group entries that will
		// be processed at the same place.

		final val rowt: Array[int] = new Array[int](Dist.makeConstant(r_nz, here));
		final val colt: Array[int] = new Array[int](Dist.makeConstant(r_nz, here));
		final val valt: Array[double] = new Array[double](Dist.makeConstant(r_nz, here));

		pos = 0;
		final val workranges: Array[region] = new Array[region](Dist.makeConstant(r_nthreads, here), (var point[j]: point): region => {
				var yrange: region = (d_M | d_places(j)).region;
				var low: int = pos;
				var high: int = low-1;
				for (var i: int = 0; i < datasizes_nz(size); i++) {
					if (! yrange.contains(point.factory.point(row(i))))
						continue;
					high++;
					rowt(high) = row(i);
					colt(high) = col(i);
					valt(high) = val(i);
				}
				pos = high + 1;
				return [low..high];
			});
		//assert (pos == datasizes_nz[size]);

		if (pos != datasizes_nz(size)) throw new Error();

		// convert to values
		final val Vrow: Array[int] = new Array[int](Dist.makeConstant(r_nz, here), (var point[i]: point): int => {
				return rowt(i);
			});
		final val Vcol: Array[int] = new Array[int](Dist.makeConstant(r_nz, here), (var point[i]: point): int => {
				return colt(i);
			});
		final val Vval: Array[double] = new Array[double](Dist.makeConstant(r_nz, here), (var point[i]: point): double => {
				return valt(i);
			});

		// "x" value with which matrix is going to be multiplied
		final val x: Array[double] = RandomVector(d_N);

		// "y" is the vector with which is supposed to become y : = mat(val) * x
		final val y: Array[double] = new Array[double](d_M);

		// do parallel multiplication
		finish ateach (val p: point[i] in d_places) mul(Vval, x, y, Vrow, Vcol, workranges(i));

		// validate
		var ytotal: double = 0.0;
		for (val p: point in y.region) ytotal += (future (y.dist(p)) { y(p) }).force();

		double var refval: Array[double] = { 6.195840478801247E-4, 0.1249404059302216, 0.0 };
		var dev: double = Math.abs(ytotal - refval(size));
		if (dev > 1.0e-10) {
			System.out.println("Validation failed");
			System.out.println("ytotal = " + ytotal + "  " + dev + "  " + size);
			throw new Error("Validation failed");
		} else {
			System.out.println("Validation succeeded");
		}
		return true;
	}

	private static def mul(var val: Array[double], var x: Array[double], var yt: Array[double], var row: Array[int], var col: Array[int], var sumrange: region): void = {
		for (val i: point in sumrange) {
			final val rowi: int = row(i);
			yt(rowi) = yt(rowi) + x(col(i)) * val(i);
		}
	}

	// trivial helper
	private static def RandomVector(var d: dist): Array[double] = {
		return new Array[double](d, (var point[i]: point): double => {
			return R.nextDouble() * 1e-6;
		});
	}
}
