.TH "x10.h" 3 "20 May 2008" "Version 1.0" "X10LIB" \" -*- nroff -*-
.ad l
.nh
.SH NAME
x10.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdio.h>\fP
.br
\fC#include 'x10_types.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_init\fP ()"
.br
.RI "\fIinit/finalize \fP"
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_finalize\fP ()"
.br
.ti -1c
.RI "EXTERN \fBx10_comm_handle_t\fP \fBx10_async_spawn\fP (const \fBx10_place_t\fP tgt, const \fBx10_async_closure_t\fP *closure, const size_t cl_size, const \fBx10_finish_record_t\fP *frecord, const \fBx10_clock_t\fP *clocks, const int num_clocks)"
.br
.RI "\fIasyncs spawn an async on given target (NON-BLOCKING). x10lib assumes SPMD programming model; code is replicated everywhere \fP"
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_async_spawn_wait\fP (\fBx10_comm_handle_t\fP handle)"
.br
.RI "\fIwait for the async_spawn to complete locally (BLOCKING) \fP"
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_probe\fP ()"
.br
.RI "\fIcheck for any asyncs in the internal async queue and execute them. This method should be used on the receiver side to make progress (NON-BLOCKING) \fP"
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_infinite_poll\fP ()"
.br
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_finish_begin\fP (\fBx10_finish_record_t\fP *frecord, void *mult_ex_buf, int *ex_offsets, int max_ex_buf_size, int max_num_exceptions)"
.br
.RI "\fIfinish start the finish_scope (called by root activity only) \fP"
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_finish_begin_global\fP (\fBx10_finish_record_t\fP *frecord, void *mult_ex_buf, int *ex_offsets, int max_ex_buf_size, int max_num_exceptions)"
.br
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_finish_end\fP (const \fBx10_finish_record_t\fP *finish_record, int *num_exceptions)"
.br
.RI "\fIend the finish_scope (called by root activity only). Waits for global termination of all the activities (BLOCKING) \fP"
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_finish_child\fP (const \fBx10_finish_record_t\fP *frecord, void *ex_buf, int ex_buf_size)"
.br
.RI "\fInotify the 'root' that I have finished (called by children activity only) \fP"
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_clock_init\fP (\fBx10_clock_t\fP *c)"
.br
.RI "\fIclocks initialize a clock c (see \fBx10_types.h\fP for \fBx10_clock_t\fP) \fP"
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_clock_free\fP (\fBx10_clock_t\fP *c)"
.br
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_clock_resume\fP (\fBx10_clock_t\fP *c)"
.br
.RI "\fIperform a resume operation on clock c \fP"
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_clock_drop\fP (\fBx10_clock_t\fP *c)"
.br
.RI "\fIdrop a clock c \fP"
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_next\fP (\fBx10_clock_t\fP *c)"
.br
.RI "\fIperform a next operation \fP"
.ti -1c
.RI "EXTERN \fBx10_err_t\fP \fBx10_next_all\fP ()"
.br
.ti -1c
.RI "EXTERN \fBx10_remote_ref_t\fP \fBx10_serialize_ref\fP (void *ref)"
.br
.RI "\fIremote reference serialize a reference (local or remote) \fP"
.ti -1c
.RI "EXTERN void * \fBx10_deserialize_ref\fP (\fBx10_remote_ref_t\fP ref)"
.br
.RI "\fIdeserialize a remote reference \fP"
.ti -1c
.RI "EXTERN int \fBx10_get_loc\fP (void *ref)"
.br
.ti -1c
.RI "EXTERN bool \fBx10_is_localref\fP (void *ref)"
.br
.RI "\fIcheck if the reference is local \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBx10_place_t\fP \fB__x10_here\fP"
.br
.ti -1c
.RI "unsigned int \fB__x10_numplaces\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "EXTERN \fBx10_comm_handle_t\fP x10_async_spawn (const \fBx10_place_t\fP tgt, const \fBx10_async_closure_t\fP * closure, const size_t cl_size, const \fBx10_finish_record_t\fP * frecord, const \fBx10_clock_t\fP * clocks, const int num_clocks)"
.PP
asyncs spawn an async on given target (NON-BLOCKING). x10lib assumes SPMD programming model; code is replicated everywhere 
.PP
\fBParameters:\fP
.RS 4
\fItgt\fP target place 
.br
\fIclosure\fP pointer to async closure (see \fBx10_types.h\fP) 
.br
\fIcl_size\fP size of the async closure 
.br
\fIfrecord\fP pointer to the finish record (see \fBx10_types.h\fP) 
.br
\fIclocks\fP clock set for the async (see \fBx10_types.h\fP) 
.br
\fInum_clocks\fP number of clocks in the clock set
.RE
.PP
\fBReturns:\fP
.RS 4
handle to wait for 
.RE
.PP

.SS "EXTERN \fBx10_err_t\fP x10_async_spawn_wait (\fBx10_comm_handle_t\fP handle)"
.PP
wait for the async_spawn to complete locally (BLOCKING) 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP handle returned by x10_async_spawn (see \fBx10_types.h\fP)
.RE
.PP
\fBReturns:\fP
.RS 4
returns an error or success 
.RE
.PP

.SS "EXTERN \fBx10_err_t\fP x10_clock_drop (\fBx10_clock_t\fP * c)"
.PP
drop a clock c 
.PP
.SS "EXTERN \fBx10_err_t\fP x10_clock_free (\fBx10_clock_t\fP * c)"
.PP
.SS "EXTERN \fBx10_err_t\fP x10_clock_init (\fBx10_clock_t\fP * c)"
.PP
clocks initialize a clock c (see \fBx10_types.h\fP for \fBx10_clock_t\fP) 
.PP
.SS "EXTERN \fBx10_err_t\fP x10_clock_resume (\fBx10_clock_t\fP * c)"
.PP
perform a resume operation on clock c 
.PP
.SS "EXTERN void* x10_deserialize_ref (\fBx10_remote_ref_t\fP ref)"
.PP
deserialize a remote reference 
.PP
.SS "EXTERN \fBx10_err_t\fP x10_finalize ()"
.PP
.SS "EXTERN \fBx10_err_t\fP x10_finish_begin (\fBx10_finish_record_t\fP * frecord, void * mult_ex_buf, int * ex_offsets, int max_ex_buf_size, int max_num_exceptions)"
.PP
finish start the finish_scope (called by root activity only) 
.PP
\fBParameters:\fP
.RS 4
\fIfrecord\fP the finish record 
.br
\fImulti_ex_buf\fP buffer for the resulting multi_exceptions (if any) 
.br
\fIex_offsets\fP offsets array for individual exceptions 
.br
\fImax_ex_buf_size\fP maximum size of the multi_ex_buf 
.br
\fImax_num_exceptions\fP maximum number of individual exceptions 
.RE
.PP

.SS "EXTERN \fBx10_err_t\fP x10_finish_begin_global (\fBx10_finish_record_t\fP * frecord, void * mult_ex_buf, int * ex_offsets, int max_ex_buf_size, int max_num_exceptions)"
.PP
.SS "EXTERN \fBx10_err_t\fP x10_finish_child (const \fBx10_finish_record_t\fP * frecord, void * ex_buf, int ex_buf_size)"
.PP
notify the 'root' that I have finished (called by children activity only) 
.PP
\fBParameters:\fP
.RS 4
\fIfrecord\fP finish record 
.br
\fIex_buf\fP exception buffer 
.br
\fIex_buf_size\fP size of the exception buffer 
.RE
.PP

.SS "EXTERN \fBx10_err_t\fP x10_finish_end (const \fBx10_finish_record_t\fP * finish_record, int * num_exceptions)"
.PP
end the finish_scope (called by root activity only). Waits for global termination of all the activities (BLOCKING) 
.PP
\fBParameters:\fP
.RS 4
\fIfinish_record\fP pointer to finish_record 
.br
\fInum_exceptions\fP total number of exceptions 
.RE
.PP

.SS "EXTERN int x10_get_loc (void * ref)"
.PP
\\ brief get the location of a reference 
.SS "EXTERN \fBx10_err_t\fP x10_infinite_poll ()"
.PP
Performs x10_probe infinitely, until a termination message is received (BLOCKING) 
.SS "EXTERN \fBx10_err_t\fP x10_init ()"
.PP
init/finalize 
.PP
.SS "EXTERN bool x10_is_localref (void * ref)"
.PP
check if the reference is local 
.PP
.SS "EXTERN \fBx10_err_t\fP x10_next (\fBx10_clock_t\fP * c)"
.PP
perform a next operation 
.PP
.SS "EXTERN \fBx10_err_t\fP x10_next_all ()"
.PP
.SS "EXTERN \fBx10_err_t\fP x10_probe ()"
.PP
check for any asyncs in the internal async queue and execute them. This method should be used on the receiver side to make progress (NON-BLOCKING) 
.PP
.SS "EXTERN \fBx10_remote_ref_t\fP x10_serialize_ref (void * ref)"
.PP
remote reference serialize a reference (local or remote) 
.PP
.SH "Variable Documentation"
.PP 
.SS "\fBx10_place_t\fP \fB__x10_here\fP"
.PP
.SS "unsigned int \fB__x10_numplaces\fP"
.PP
.SH "Author"
.PP 
Generated automatically by Doxygen for X10LIB from the source code.
