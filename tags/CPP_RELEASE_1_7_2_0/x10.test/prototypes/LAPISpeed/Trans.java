/***
Trans.[java|cpp] are SPMD programs that use LAPI to transpose large
arrays of doubles.  The idea is to determine if a serialization-less
JVM->JVM copy can be effected quickly enough to compete with C (or C++)

LAPISupport.cpp is the LAPI support library and is used by both the
Java and C++ versions.  For the Java version it requires Trans.h and
VMInfo.h which are generated by javah.

xlC -g -o Trans -O Trans.cpp LAPISupport.cpp -bmaxdata:0x80000000 -llapi_r
javac Trans.java
javah Trans
javah VMInfo
xlC_r -DFOR_JAVA -g -qnolm -qnoeh -qnotempinc -bM:SHR -bnoentry -bexpall -I${classesdir} -I$JAVA_HOME/bin/include -I$JAVA_HOME/include -llapi_r -o libLAPISupport.a LAPISupport.cpp
***/

import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.util.Iterator;
import java.util.Properties;
import java.util.StringTokenizer;

class Trans {

    public static void main(String[] args) {
        int parms[] = new int[4];
        parms[0] = parms[1] = parms[2] = parms[3] = 2;
        int parmIndex = 0;
        int argPos = 0;
        int numTimes = 10;
        boolean do_local_xpos = false;
        String confFile = "myConf";
        while (argPos < args.length) {
            if (args[argPos].charAt(0) == '-') {
                if (args[argPos].equals("-conf")) {
                    ++argPos;
                    confFile = args[argPos++];
                } else if (args[argPos].equals("-vm")) {
                    ++argPos;
                    VMInfo.thisIsTask = java.lang.Integer.parseInt(args[argPos++]);
                    if (VMInfo.thisIsTask >= NUMBER_OF_VMS) {
                        System.err.println("vm # " + VMInfo.thisIsTask +
                                           " >= " + NUMBER_OF_VMS);
                        throw new Error();
                    }
                } else if (args[argPos].equals("-n")) {
                    ++argPos;
                    numTimes = java.lang.Integer.parseInt(args[argPos++]);
                } else if (args[argPos].equals("-x")) {
                    ++argPos;
                    do_local_xpos = true;
                } else {
                    ++argPos;
                }
            } else {
                if (parmIndex < parms.length) {
                    parms[parmIndex++] = java.lang.Integer.parseInt(args[argPos++]);
                } else {
                    ++argPos;
                }
            }
        }
        VMInfo.PtimesQ = parms[2] * parms[3];
        System.loadLibrary("LAPISupport");
        for (int vm_no = 0; vm_no < VM_.length; ++vm_no) {
            VM_[vm_no].lapiTarget = vm_no;
        }
        VMInfo.init(VM_);
        Trans tm = new Trans(parms[0], parms[1], parms[2], parms[3], VMInfo.thisIsTask, NUMBER_OF_VMS, do_local_xpos);
        long accumulatedTime = 0;
        for (int t = 0; t < numTimes; ++t) {
            tm.MatGen(t);
            long start_time0 = System.nanoTime();
            tm.transpose();
            long finish_time0 = System.nanoTime();
            accumulatedTime += (finish_time0-start_time0);
        }
        VMInfo.term();
        String kindoftime = "microseconds";
        System.out.println("Number of " + kindoftime + " for task " + VMInfo.thisIsTask + ": " + (accumulatedTime / 1000));
        tm.dumpCounts();
        tm.cleanUp();
    }
    
    Trans(int p, int q, int P, int Q,
          int thisIsTask, int numLAPITasks, boolean doLocalXpos)
    {
        p_ = p; q_ = q; P_ = P; Q_ = Q;
        thisIsTask_ = thisIsTask; numLAPITasks_ = numLAPITasks;
        numGlobalBlocks_ = P * Q;
        doLocalXpos_ = doLocalXpos;
        int numLocalBlocksX = (P*Q) / numLAPITasks;
        if (thisIsTask < ((P*Q) % numLAPITasks)) ++numLocalBlocksX;
        numLocalBlocks_ = numLocalBlocksX;
        myLocalBlocks0_ = new double[numLocalBlocks_][p * q];
        myLocalBlocks1_ = new double[numLocalBlocks_][p * q];
        expectedBlocks_ = new int[numLocalBlocks_];
        receivedFlags_ = new boolean[numLocalBlocks_];
        for (int i = 0; i < numLocalBlocks_; ++i) {
            int j = (i * numLAPITasks) + thisIsTask;
            expectedBlocks_[i] = ((j % P) * Q) + (j / P);
        }
        outGoingCount_ = inComingCount_ = 0;
        executionTimes_ = new long[5];
        // let's only make a globalRef once
        for (int i = 0; i < numLocalBlocks_; ++i) {
            if ((expectedBlocks_[i] % numLAPITasks_) != thisIsTask_) {
                AcceptBlockHere(expectedBlocks_[i], myLocalBlocks1_[i], receivedFlags_, i);
            }
        }
    }

    void cleanUp() {
        for (int i = 0; i < numLocalBlocks_; ++i) {
            if ((expectedBlocks_[i] % numLAPITasks_) != thisIsTask_) {
                AcceptBlockHere(expectedBlocks_[i], null, null, 0);
            }
        }
    }
    
    void MatGen(int timeStep) {
        for (   int i = 0; i < numLocalBlocks_; ++i) {
            int blockNum = (i * numLAPITasks_) + thisIsTask_;
            for (int r = 0; r < p_; ++r) {
                for (int c = 0; c < q_; ++c) {
                    myLocalBlocks0_[i][(r*q_)+c] = (blockNum * 1000000) + (r * 1000) + c;
                }
            }
            myLocalBlocks0_[i][0] = timeStep_ = timeStep;
        }
    }

    native private static void AcceptBlockHere(int expectedBlock, double[] target, boolean[] flagsArray, int indexIntoFlags);
    native private static void sendMyArrayBlock(int tgt,
                                                int globalBlockNum,
                                                double[] data,
                                                int size);
    void transpose() {
        // First we need to tell LAPI where to send all the incoming
        // blocks that we expected
        for (int i = 0; i < numLocalBlocks_; ++i) {
            if ((expectedBlocks_[i] % numLAPITasks_) == thisIsTask_) {
                // We are expecting to send this block to ourselves
                double[] tmp = myLocalBlocks0_[i];
                myLocalBlocks0_[i] = myLocalBlocks1_[i];
                myLocalBlocks1_[i] = tmp;
                receivedFlags_[i] = true;
            } else {
                receivedFlags_[i] = false;
                // commented out for speed
                //AcceptBlockHere(expectedBlocks_[i], myLocalBlocks1_[i], receivedFlags_, i);
            }
        }
        // Tell the world that we're all set to receive
        long start_time0 = System.nanoTime();
        VMInfo.globalFence();
        long finish_time0 = System.nanoTime();
        executionTimes_[0] += (finish_time0 - start_time0);

        // Now send out all of the blocks we need to
        start_time0 = System.nanoTime();
        for (int i = 0; i < numLocalBlocks_; ++i) {
            int globalBlockNum = (i * numLAPITasks_) + thisIsTask_;
            int tgt = (((globalBlockNum % Q_) * P_) + (globalBlockNum / Q_)) % numLAPITasks_;
            if (tgt != thisIsTask_) {
                sendMyArrayBlock(tgt, globalBlockNum, myLocalBlocks0_[i], p_ * q_);
                ++outGoingCount_;
            }
        }
        finish_time0 = System.nanoTime();
        executionTimes_[1] += (finish_time0 - start_time0);

        // now we wait until we have received everything we want to
        start_time0 = System.nanoTime();
        int numReceived = 0;
        do {
            numReceived = 0;
            for (int i = 0; i < numLocalBlocks_; ++i) {
                if (receivedFlags_[i]) ++numReceived;
            }
        } while (numReceived != numLocalBlocks_);
        finish_time0 = System.nanoTime();
        executionTimes_[2] += (finish_time0 - start_time0);

        // now really transpose each local block
        start_time0 = System.nanoTime();
        for (int i = 0; i < numLocalBlocks_; ++i) {
            if ((expectedBlocks_[i] % numLAPITasks_) == thisIsTask_) {
                //printf("ahk task %d already has expected block %d\n", thisIsTask_, expectedBlocks_[i]);
               //System.out.println("ahk task " + thisIsTask_ + " already has expected block " + expectedBlocks_[i]);
            } else {
                ++inComingCount_;
                //AcceptBlockHere commented out for speed
                //AcceptBlockHere(expectedBlocks_[i], null, null, 0);
                //printf("ahk task %d local block %d expectedblock %d timestep %d %d %f\n", thisIsTask_, i, expectedBlocks_[i], timeStep_, (int) myLocalBlocks1_[i][0], myLocalBlocks1_[i][1] / 1000000);
                //System.out.println("ahk task " + thisIsTask_ + " local block " + i + " expectedblock " + expectedBlocks_[i] + " timestep " + timeStep_ + " " + myLocalBlocks1_[i][0] + "  " + myLocalBlocks1_[i][1] / 1000000);
            }
            if (doLocalXpos_) {
                for (int r = 0; r < p_; ++r) {
                    for (int c = 0; c < q_; ++c) {
                        myLocalBlocks0_[i][(c*p_)+r] = myLocalBlocks1_[i][(r*q_)+c];
                    }
                }
            }
        }
        finish_time0 = System.nanoTime();
        executionTimes_[3] += (finish_time0 - start_time0);
        start_time0 = System.nanoTime();
        VMInfo.globalFence();
        finish_time0 = System.nanoTime();
        executionTimes_[4] += (finish_time0 - start_time0);
    }

    void dumpCounts() {
        System.out.print("task: " + thisIsTask_ + " " + outGoingCount_ + " blocks sent, " + inComingCount_ + " received. Wait times (microseconds):");
        for (int i = 0; i < executionTimes_.length; ++i) {
            System.out.print(" " + (executionTimes_[i] / 1000));
        }
        System.out.println();
    }
    
    private final int p_;            // rows in each block
    private final int q_;            // columns in each block
    private final int P_;            // rows of blocks
    private final int Q_;            // columns of blocks
    private final int thisIsTask_;
    private final int numLAPITasks_;
    private final int numLocalBlocks_;
    final double[][] myLocalBlocks0_;
    final double[][] myLocalBlocks1_;
    private final int numGlobalBlocks_;
    private final int[] expectedBlocks_;
    volatile boolean[] receivedFlags_;
    private int timeStep_;
    private boolean doLocalXpos_;
    private int outGoingCount_;
    private int inComingCount_;
    private long[] executionTimes_;
    
    public static int NUMBER_OF_VMS = 1;
    public static VMInfo[] VM_;
    private static String getConfigurationFileName_() {
        String rc = System.getProperty("lapi.conf");
        if (rc == null) rc = "myConf";
        return rc;
    }
    static {        
        String cfg = getConfigurationFileName_();
        if (cfg != null) {
            try {
                Properties props = new Properties();
                FileInputStream fis = new FileInputStream(cfg);
                byte[] data = new byte[fis.available()];
                if (data.length != fis.read(data))
                    throw new Error();
                String s = new String(data).replace('\\','/');
                props.load(new ByteArrayInputStream(s.getBytes()));
                // arrg... the Iterator isn't always in order of text
                Iterator i = props.keySet().iterator();
                while (i.hasNext()) {
                    String key = (String) i.next();
                    if (key.equals("NUMBER_OF_VMS")) {
                        String val = props.getProperty(key);
                        set(key, val);
                        VM_ = new VMInfo[NUMBER_OF_VMS];
                    }
                }
                
                i = props.keySet().iterator();
                while (i.hasNext()) {
                    String key = (String) i.next();
                    String val = props.getProperty(key);
                    set(key, val);
                } // end of 'for each configuration directive'
            } catch (IOException io) {
                System.err.println("Failed to read configuration file " + cfg + ": " + io);
                throw new Error(io);
            }
        } // end of 'have configuration file'       
    }

    // Borrowed from X10 Runtime.... basically reading configuration file
    // to set up LAPI tasks
    private static void set(String key, String val) {
        Class c = Trans.class;
        int idx=0;
        String fld = null;
        try {
            if (key.indexOf('[') > 0) {
                idx = Integer.parseInt(key.substring(key.indexOf('[')+1,key.indexOf(']')));
                fld = key.substring(key.indexOf('.')+1);
                key = key.substring(0, key.indexOf('['));
            }
            Field f = c.getField(key);
            Class t = f.getType();
            Object o = null;
            if (fld != null) {
                if (t.isArray()) {
                    if (t.getComponentType().isPrimitive()) {
                    } else {
                        o = Array.get(f.get(null), idx);
                        if (o == null) {
                            Array.set(f.get(null), idx, o = t.getComponentType().newInstance());
                        }
                        f = o.getClass().getField(fld);
                        t = f.getType();
                    }
                } else {
                    System.err.println(key + " is not an array");
                }
            }
            if (t == String.class) {
                f.set(o, val);
            } else if (t == Integer.TYPE) {
                f.setInt(o, new Integer(val).intValue());
            } else if (t == Float.TYPE) {
                f.setFloat(o, new Float(val).floatValue());
            } else if (t == Double.TYPE) {
                f.setDouble(o, new Double(val).doubleValue());
            } else if (t == Long.TYPE) {
                f.setLong(o, new Long(val).longValue());
            } else if (t == Short.TYPE) {
                f.setShort(o, new Short(val).shortValue());
            } else if (t == Byte.TYPE) {
                f.setByte(o, new Byte(val).byteValue());
            } else if (t == Character.TYPE) {
                if (val.length() != 1)
                    System.err.println("Parameter" + key + " only takes on character,"+
                                       " using only the first character of configuration"+
                                       " value >>" + val + "<<");
                f.setChar(o, new Character(val.charAt('0')).charValue());
            } else if (t == Boolean.TYPE) {
                if (val.equalsIgnoreCase("true")) {
                    f.setBoolean(null, true);
                } else if (val.equalsIgnoreCase("false")) {
                    f.setBoolean(null, false);
                } else {
                    System.err.println("Parameter |" + key + "| expects a boolean, not |" 
                                       + val + "|. Ignored.");
                }
            }
        } catch (NoSuchFieldException nsfe) {
            System.err.println("Parameter " + key + " not found, configuration directive ignored.");
        } catch (InstantiationException ie) {
            System.err.println("Failed to create object for " + key);
            throw new Error(ie);
        } catch (IllegalAccessException iae) {
            System.err.println("Wrong permissions for field " + key + ": " + iae);
            throw new Error(iae);
        } catch (NumberFormatException z) {
            System.err.println("Parameter |" + key + "| expects a number, not |" + val + "|. Ignored.");
        }
    }
}

final class VMInfo {
    public static final int MasterVM = 0;
    public static native void init(VMInfo[] VM_);
    public static native void term();
    public static native void globalFence();
    public static VMInfo[] VM_;         // copied from Trans.VM_
    public static int thisIsTask = 0;
    public static int PtimesQ = 0;
    public String          hostName;
    public int             portNumber;
    public int lapiTarget;   // must == index into VM_ table
}
