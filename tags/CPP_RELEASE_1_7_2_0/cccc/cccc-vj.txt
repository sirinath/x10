Wed Dec 06 07:20:22 2006
CCCC -- Cache-coherent Causal Consistency
Revision Notes

** Changed SACC-HB --> CCCC.
** Used Doug's name for rules.
** This document contains the generalized "boundary" version of Local
   Consistency. (01/30/07)

-----------

The core idea behind CCCC is to provide a weaker model than sequential
consistency which is still strong enough to permit various mutual
exclusion algorithms to be written. In particular this model permits
different processors to have different perceptions about the write
orders of writes performed by other processors. For instance, assume
processor 1 performs a write w1, and p2 performs write w2. A processor
p3 may observe w1 before w2, and processor p4 may observe w2 before
w1. Specifically, the model is not required to satisfy that w --> w'
(that is, w must publically be known to precede w') from  w --> r -->
w'  if w, r, w' are executed by different processors. However, each
processor is required to respect the obsevrations made by a processor
involving its own writes. Thus if p1 observes w1 before w2, then all
processors must respect this observation.

CCCC is being attempted as a common abstraction of properties
satisfied by today's leading architectures. It is related to several
other weak memory models for hardware that have been proposed since
1990 (e.g. various flavors of processor consistency).

This formalization of CCCC presents an execution as a graph G = (S,
-->) where S is a set of read/write events (generated by a given set
of processors operating against a given shared memory) and -->
captures "common knowledge" facts about the ordering of events in S,
together with facts established by the program order of each
processor. (A fact is common knowledge if it is known to each
processor.)

However there are facts that may be known by a processor i privately,
e.g. write/write orders which involve third party writes. These facts
will lie in (G | E(i) u W)* but not in  (G | E(i) u W).  We need these
additional facts to be consistent, that is, (G | E(i) u W)* should be
a partial order (no cycles).

DEFINITION: See cccc-definition.txt

Note: --> is *not* a partial order. It is an arbitrary relation. Its
restrictions are partial orders, corresponding to <i, the order
induced by each processor.

The propagation rule does not support the inference w --> w' from  w
--> r --> w'  if w, r, w' are executed by different processors.

===================================================================== 

EXAMPLES: See cccc-examples.txt

=====================================================================
CCCC with scync.

See cccc-definition.txt for definitions.

One could ask -- why would we not adopt the following even simpler model.  
Forget about splitting scync into scync_start and scync_end. Instead, require:

[Strong-Scync]
   For any two scync events e1, e2, either e1 --> e2 or e2 --> e1.

But this is very strong! It is not difficult to see that given Causal 
Propagation and Local Consistency (extended to include boundary elements), 
Strong-Scync implies that in any process scyncs are totally ordered! 
(I think Doug had suggested that such a totally ordered scync might be 
a way to get SC.)

 (Proof: First note that for any process i, all the scyncs are boundary events, 
  because of the Strong-Scync condition. Therefore there cannot be any cycles 
  involving scyncs. Second note that if e1 --> e2 and e2 --> e3, it must be 
  the case that e1 --> e3, because of Local Consistency and [Strong-Scync]. 
  So consider the dag of all scyncs. This must have a unique root, for if there 
  were two roots, s0 and s1 then by [Strong-Scync] either s0 --> s1 or s1 --> s0. 
  So give this root the next unassigned number (starting with 0). Now consider all 
  unnumbered scyncs, and ignore edges from numbered scyncs into unnumbered scyncs. 
  Again this subgraph must have a unique root. So we can repeat this process. 
  In the end we will have a number for each scync, no two scyncs will have the 
  same number and the number for s is less than the number for s' iff s --> s'. 
  So  the scyncs are totally ordered.)

However, [Scync] does not have the property that in every process all the scyncs 
are totally ordered. The reason is precisely the splitting up of a scync into 
scync_start and scync_end -- and reflects the computational intuition that sending 
messages and receiving acknowledges introduces only pairwise consistency, not global 
consistency (this in my opinion is the key intuition behind CCCC vs SC ... CCCC can 
be implemented with message-passing semantics, i.e. local semantics, there is no 
need for any global information).

[Scync] instead implies the following weaker property: 
Let m=(m_s, m_e) and n=(n_s, n_e) be two sync_start/sync_end pairs. 
Then either m_s --> n_s or n_e --> m_e.  Equivalently, either m_s --> n_e or n_s --> m_e. 
(This is easy to establish.)

Say we try and order scyncs using this weaker property. So we say that m leq n 
if m_s --> n_e. But now leq is not transitive! i.e. we can exhibit m, n and 
p s.t. m leq n and n leq p but not m leq p.

m_s --> n_s   (e.g. because the message from m was ack by an instruction before n)
n_s --> p_e
p_e --> n_e

Through transitivity we will get m_s --> p_e, but this is not strong enough to 
establish m leq p.
