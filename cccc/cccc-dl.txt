Edited version of Doug's mail to C++ list. 
Definition has been removed to cccc-definition.txt
Examples have been moved to cccc-examples.txt (and more examples added).
=========================================================================

Subject: [cpp-threads] Alternatives to SC
From: Doug Lea <dl@cs.oswego.edu>
Date: Thu, 11 Jan 2007 08:01:27 -0500
To: C++ threads standardisation <cpp-threads@decadentplace.org.uk>

[I've been meaning to post this for a month or so, but have been
diverted doing other things...]

The question of whether "strong" volatiles/atomics are or should be
required to be sequentially consistent has been around for years. In
the absence of compelling evidence (at the time) about platform
limitations, the JMM adopted simplicity and defined them as SC.  Now
that processor verndors are slowly coming out with more believable and
precise specs, this is in the midst of being re-examined. And should
probably also be carefully thought out for C++.

The issue tends to factionalize discussion. SC purists cannot imagine
weaker rules. Hard-core concurrent programmers cannot understand what
all the fuss is about.

A few months ago, it occurred to me that some of the unproductiveness
of such discussions stems from not having a well-defined alternative
to SC. So asked: what's the strongest model that appears to be
supported using solely loads, stores, and fences, across all
"reasonable" multiprocessors?  In other words, what is the model for a
program in which all loads and stores are issued in program-order and
are surrounded by the strongest possible fences?

The answer to this, along with extensions (for mixtures with non
volatile/atomics, CAS etc) is still a work in progress, but seems to
be an attractive option for memory models:
     Cache-coherent causal consistency.

This models two properties that not only does everyone think are
necessary, but also seem to be universally supported. It would be
nice if the hardware specs would come out and explicitly say so.

Cache coherence  in turn has two parts:
  * Globally totally ordered writes
  * Fresh reads (never read a value that has been overritten)
As does causal consistency:
  * Causality:
     If p2 sees p1's write, and p3 sees p2's write, p3 sees p1's write
  * Local acyclicity: Each thread sees an acyclic order of events that
     is consistent with program order.

(Since starting on this, I've found that this model has been around in
various guises for over 20 years, but apparently never fleshed out enough
to serve as a basis for language-level memory models.)

The current best formal version of model is appended below.
(Thanks mainly to Vijay Saraswat for help with this.)
Like any memory model, it needs a bunch of notation to get across.
But the main thing to note is that it matches SC for all cases except
those involving independent reads of independent writes (IRIW --
see the derivation of the most famous example of this below.)

If nothing else, I hope this focusses further discussion:

Should sequential consistency be mandated for independent
reads of independent writes?

My view is no -- that CCCC would be a fine basis for defining strong
volatiles/atomics. While I do appreciate the view
that SC is simpler to express and has a better chance of being
understood by programmers, constructions involving IRIW don't have any
reasonable sequential analogs anyway, so there's no SC intuition that
needs preserving. And as a working concurrent programmer, I think that
the extra bit of concurrent readability CCCC allows hardware to
exploit is a feature, not a bug.  And I worry that if language-level
models do require SC, then compliance checking is going to be
problematic. It's not clear whether some processors can support it
without resorting to awful things like using CAS or LL/SC for each
load. And if processors are required to do so, then programmers will
routinely find some cheaper workaround hacks that are unlikely to be as
well-defined or correct as plain CCCC versions would be.

(Note also that any program using locks (that are in turn created
using CCCC-compliant primitives) is SC. It's only volatiles/atomics that
allow concurrent independent reads.)

DEFINITION: See cccc-definition.txt
EXAMPLES: See cccc-examples.txt