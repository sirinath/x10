EXAMPLES:

1. Dekker (forbidden outcome)

Given

T1             T2
[1] x = 1      [3] y = 1
[2] r1 = y(0)  [4] r2 = x(0)

Program Order gives
  [1] --> [2], [3] --> [4],
Write Serialization and Freshness give
  [2] --> [3], [4] --> [1].
Propagation adds
  [3] --> [1], [1] --> [3] (and some other edges).

This graph is not an execution because (G | {[1],[3],[4]})* has a
cycle ([1] --> [3] --> [1])

======

2. IRIW (Independent reads of independent write -- allowed outcome)
   Note that this is not SC.


T1          T2         T3                T4

[1] x = 1   [2] y = 1

                      [3] r1 = x (1)    [5] r3 = y (1)
                      [4] r2 = y (0)    [6] r4 = x (0)

Program Order, Write Serialization, and Freshness give:
  [1] --> [3] --> [4] --> [2]
  [2] --> [5] --> [6] --> [1]
Propagation adds
  [2] --> [6], [5] --> [1] and [1] --> [4], [3] --> [2].

This graph satisfies all these conditions. (Note that [1] --> [2] is
in (G | W u E(T2))* and [2] --> [1] is in (G | W u E(T1)*), but both
these graphs are separately acyclic.)

This execution remains valid when events are decorated with world-maps.
=======

3. CC (Causal consistency -- forbidden outcome)

T1           T2               T3
[1] x = 1
            [2] r1 = x (1)   [4] r2 = y (1)
            [3] y = 1        [5] r3 = x (0)

Program Order, Write Serialization, and Freshness give:
 [1] --> [2] --> [3] --> [4] --> [5] --> [1].
This is not an execution because
 G | E u E(T3) = G | {[1],[3],[4],[5]}*
has cycle [1]-->[3]-->[4] --> [5] --> [1].

=======
3a. LCC (Longer Chain of causal consistency)
This example is due to Sebastian Burckhardt.

   T0        T1              T2              T3
[1] x = 1   [2] r1 = x (1)   [4] r2 = y (1)  [6] r3 = z (1)
            [3] y = 1        [5] z = 1       [7] r4 = x (0)

We have:
[1] --> [2] --> [3] --> [4] --> [5] --> [6] --> [7] --> [1]

This example is ruled out by CCCC. E(T3) u W is {[1],[3],[5],[6],[7]}. 
G | (E(T3) u W) contains the edges [1] -> [3], [3] -> [5], [5] -> [7]. Therefore
the transitive closure must contain [1] -> [7], and hence r4 must contain 1.

However, this execution is ruled out by CCCC with world maps. The world
map at [2] must be above {x:1}. This is also true for all steps [i]
for i in 3..7. Hence the read by [7] must read the value for version 1
of x, i.e. 1.
=======

4. DC (Another causal consistency example -- forbidden outcome)

T1           T2               T3
[1] y = 1
            [2] x = 1        [4] r3 = y (1)
            [3] r2 = y (0)   [5] r4 = x (0)

Program Order, Write Serialization, and Freshness give:
  [1] -> [4] --> [5] --> [2] --> [3] --> [1]
Propagation adds
  [2] --> [1] (among others).
This is not an execution because
  G | W u E(T3) = G | {[1],[2],[4],[5]}
has the cycle [1] --> [4] --> [5] --> [2] --> [1].

=========

5. Lock-free Stack/Queue/List/etc - r2 must read 1 
(Example due to Maged Michael)

T1 (producer)     T2 (consumer)
[1] x=1           [3] r1=y(1)
[2] y=1           [4] r2=x(1)

[1] --> [2] --> [3] --> [4]. 
Further [1] --> [4] (Causal Propagation). 
Therefore in [4] r2 cannot read 0, because if it did
there would be an edge [4] --> [1] and now Local Consistency
would fail.
=======

7. Snapshot problem
(Example due to Maged Michael)
T1         T2   T3 (snapshot)   T4 (snapshot)
[1] x=1 [2] y=1 [3] r1=x(1)     [6] r4=x(0)
                [4] r2=yl(0)    [7] r5=y(1)
                [5] r3=x(1)     [8] r6=x(0))

T3 and T4 want to capture atomic snapshots of x and y.

In a snapshot object (see a short lecture at www.cse.yorku.ca/~ruppert/6117-W02/lec16.ps) 
reads must return values that are consistent with an execution where all writes to the 
snapshot object components are totally ordered. Components don't need to be written
atomically.

Looking just at two variables x and y. An atomic snapshot read of x and y
by T3 (or T4) must return values that are consistent with an execution that
has a total order of all writes to x and y, i.e., total order on W(x) U W(y).
In the example above valid values returned by snapshot reads by T3 and T4
of (x,y) must either both belong to {(0,0),(0,1),(1,1)} or to
{(0,0),(1,0),(1,1)}

CCCC allows T3 and T4 to return (1,0) and (0,1). 
This is true even when world maps are considered.
============================

Obtaining SC executions in CCCC.

1. IRIW (Independent reads of independent write -- disallowed outcome)

T1          T2         T3                T4

[1] x = 1   [2] y = 1

                      [3] r1 = x (1)    [5] r3 = y (1)
                      [3a]scync_start   
                      [3b]scync_end     
                      [4] r2 = y (0)    [6] r4 = x (0)

Consider the reflection of the [3] sync in T4. A single scync pair in either T3 or T4 is 
adequate to disallow the given behavior. Consider the case in which the scync is placed
in T3. The reflection point for T3 in T4 must lie after [6]. (If it lies before [6], then
[6]'s label must lie above {x:1}, and [6] will read 1.) But then the backedge into [3b]
ensures that the label of [3b] (and hence [4]) is above {y:1}. Hence [4] reads 1.

2. Snapshot problem.

T1         T2   T3 (snapshot)   T4 (snapshot)
[1] x=1 [2] y=1 [3] r1=x(1)     [6] r4=x(0)
                [3a]scync_start
                [3b]scync_end
                [4] r2=y(0)     [7] r5=y(1)
                [5] r3=x(1)     [8] r6=x(0))
                
Same reasoning as above.

--- IRIW-2, IRIW with additional read --------
T1          T2         T3                    T4
[1] x = 1   [2] y = 1

                      [3] _ = x (1)         [5] _ = y (1)
                      [3a] scync_start      [5a] scync_start
                      [3b] scync_end        [5b] scync_end
                      [4] _ = y (0)         [6] _ = x (0)
                      [4a] _=x              [6a] _ = x
--------------------------------------------------

Suppose [3a] --> [6a] --> [3b]. Then [5] --> [3b], hence [5] --> [4].

But this is not strong enough to imply that [4] must read 1-- 
since we do not have the required transitivity: [2] --> [5] and 
[5] --> [4] does not imply [2] --> [4] since [2], [4] and 
[5] belong to different threads.

However, by  introducing world maps and requiring [Monotonicity], 
we force [4] to read 1 since the world map at [4] will be higher than {y:1}.




