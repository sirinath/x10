Wed Dec 06 07:20:22 2006
CCCC -- Cache-coherent Causal Consistency
-----------

The core idea behind CCCC is to provide a weaker model than sequential
consistency which is still strong enough to permit various mutual
exclusion algorithms to be written. In particular this model permits
different processors to have different perceptions about the write
orders of writes performed by other processors. For instance, assume
processor 1 performs a write w1, and p2 performs write w2. A processor
p3 may observe w1 before w2, and processor p4 may observe w2 before
w1. Specifically, the model is not required to satisfy that w --> w'
(that is, w must publically be known to precede w') from  w --> r -->
w'  if w, r, w' are executed by different processors. However, each
processor is required to respect the obsevrations made by a processor
involving its own writes. Thus if p1 observes w1 before w2, then all
processors must respect this observation.

CCCC is being attempted as a common abstraction of properties
satisfied by today's leading architectures. It is related to several
other weak memory models for hardware that have been proposed since
1990 (e.g. various flavors of processor consistency).

This formalization of CCCC presents an execution as a graph G = (S,
-->) where S is a set of read/write events (generated by a given set
of processors operating against a given shared memory) and -->
captures "common knowledge" facts about the ordering of events in S,
together with facts established by the program order of each
processor. (A fact is common knowledge if it is known to each
processor.)

However there are facts that may be known by a processor i privately,
e.g. write/write orders which involve third party writes. These facts
will lie in (G | E(i) u W)* but not in  (G | E(i) u W).  We need these
additional facts to be consistent, that is, (G | E(i) u W)* should be
a partial order (no cycles).

================================= CCCC-HB  ========================= 
Here is a global formulation of CCCC. 

Let e ranges over read and write events, r over read events and w over
write events. For any event e, p(e) is the processor which executed e,
and for any processor p, E(p) is the set of events executed by p.  Let
W(x) be the set of all write events on location x, and W the set of
all write events.

A graph G=(S,-->) is a set of nodes S and a binary (directed) relation
--> on the nodes.

G is a partial order if --> is transitive and irreflexive. 

G is a total order if --> is a partial order and for any two nodes a,
b in S either a --> b or b --> a.

If G=(S, -->) is a graph and T is a subset of S, then G | T (the graph
G restricted to T) is the graph with nodes in T and with a --> b in T
iff a --> b in S.

If G is a graph then G* is the transitive closure of the graph. 

For a set T of events, b(T) is T together with boundary events, i.e. 
events e s.t. e-->e' or e'-->e, for e' in T.

================== CCCC =============== 
An execution is a graph G=(S, -->) over a set of events S satisfying: 

 A. For each variable x, W(x) is non-empty and G | W(x) is a total order. 

 B. For every read r of x, min(W(x)) --> r and  G | (W(x) u {r}) is a
    total order.

 C. (Propagation) e --> e'' if there is an e' in E(p(e'')) u E(p(e))
    st e --> e' --> e'' .

 D. (Local Consistency) For all processors i,  (G | b(E(i)))* is a
    partial order. Further, G | E(i) is a total order.

======================================== 

Note: --> is *not* a partial order. It is an arbitrary relation. Its
restrictions are partial orders, corresponding to <i, the order
induced by each processor.

The propagation rule does not support the inference w --> w' from  w
--> r --> w'  if w, r, w' are executed by different processors.

===================================================================== 

1. Dekker: 

Given 

T1             T2 
[1] x = 1      [3] y = 1 
[2] r1 = y(0)  [4] r2 = x(0) 

The given  relation is [1] --> [2], [3] --> [4], [2] --> [3] and [4]
--> [1]. Propagation forces [3] --> [1]  and [1] --> [3] (and some
other edges).

Now this graph is not an execution because (G | {[1],[3],[4]}) has a
cycle ([1] --> [3] --> [1])

====== 

2. IRIW example 


T1          T2         T3                T4 

[1] x = 1   [2] y = 1 

                      [3] r1 = x (1)    [5] r3 = y (1) 
                      [4] r2 = y (0)    [6] r4 = x (0) 

The given relation is: 

[1] --> [3] --> [4] --> [2] 
[2] --> [5] --> [6] --> [1] 

Propagation forces:  [2] --> [6], [5] --> [1] and [1] --> [4], [3] --> [2]. 

This graph satisfies all these conditions. (Note that [1] --> [2] is
in (G | W u E(T2))* and [2] --> [1] is in (G | W u E(T1)*), but both
these graphs are separately acyclic.)

======= 

3. CC example 

T1           T2               T3 
[1] x = 1 
            [2] r1 = x (1)   [4] r2 = y (1) 
            [3] y = 1        [5] r3 = x (0) 

The given edges are [1] --> [2] --> [3] --> [4] --> [5] --> [1]. These
will induce other edges, however already G | E u E(T3) = G |
{[1],[3],[4],[5]} has a cycle [1]-->[3]-->[4] --> [5] --> [1].

Hence this is not an execution. 

======= 

4. DC example: (DC stands for "Dekker + causality"] 

T1           T2               T3 
[1] y = 1 
            [2] x = 1        [4] r3 = y (1) 
            [3] r2 = y (0)   [5] r4 = x (0) 

The given edges are: 
[1] -> [4] --> [5] --> [2] --> [3] --> [1] 
and closure gives the edge [2] --> [1] (among others). 

Now G | W u E(T3)  = G | {[1],[2],[4],[5]} has the cycle [1] --> [4]
--> [5] --> [2] --> [1].

Hence this is not an execution. 


