
\section{Introduction}
\label{s:intr}

 Graph theoretic problems arise in several traditional and emerging scientific disciplines such as VLSI design, optimization, databases, and computational biology. There are plenty of theoretically fast parallel algorithms, for example, work-time optimal PRAM algorithms, for graph problems; however, in
 practice few parallel implementations beat the best sequential implementations for arbitrary, sparse
 graphs. The mismatch between theory and practice suggests a large gap between algorithmic model and the actual architecture. We observe that the gap is increasing as new diversified architectures emerge. Elegant solutions seem hard to come by from even combined efforts of algorithmic and architectural improvement. What is lacking is an effient way of mapping fine-grained parallelism expressed by the algorithm to target architectures with good performance. X10 is a new parallel programming language that provides expressive programming constructs and efficient runtime support that effectively helps reduce the gap between theory and practice in solving graph problems. In this paper we show that with X10 the fine-grained parallelism for a graph problem can be expressed much easier at a high algorithmic level, and the X10 program, compared with native C implementation, is much simpler and more elegant, and achieves comparable, and sometimes, even better performance. 

 The challenges of solving large-scale graph problems on current and emerging systems come from the irregular and combinatorial nature of the problem. Many of the important real world graphs, for example, internet topology, social interaction network, transfortation network, protein-protein interaction network, and etc., exhibit a ``small-world'' nature, and can be modeled as the so-called ``scale-free'' graph. There is no known efficient technique to partion such graph, which makes it hard to solve on distributed-memory systems. Also compared with the well-known sequential algorithms, for example, depth-first search (DFS) or breadth-first search (BFS) for the spanning tree problem, the parallel graph algorithms take exotic approaches such as ``graft-and-shortcut''. In the absence of efficient scheduling support of parallel activities, fine-grained parallelism incurs large overhead on current systems and oftentimes do not show practical parallel performance advantage. Lastly, graph algorithms tend to be load/store intensive compared with other scientific problems. For example,  They put great pressure on the memory subsystem. The problem obviously gets worse on distributed-memory architectures if necessary task management and memory affinity scheduling are not provided.  
 
 Several features of X10 make it an ideal language for soving large-scale graph problems. X10 provides a shared address space that obviates the need to partition a graph and to issue message passing requests explicitly to access remote data. It would be very difficult to implement a graph algorithm with irregular inputs on districuted-memory architecture.  In fact, non of the SSCA graph benchmarks has MPI implementation. X10 provides a rich collection of programming constructs that may be used to express various levels of parallelism and synchronization scheme. Depending on the input and the target systems, different algorithms can be easily implemented to fit with the archtecture. X10 runtime manages parallel activities effectively with low cost.

 In this paper we present the X10 support for solving irregular graph problems on a cluster of SMPs. In fact, most current and emerging supercomputers are clusters of SMPs. it is important to solve the problems efficiently on these platforms. The algorithms we consider include both PRAM algorithms and efficient algorithms that based on more realistic models such as the SMP model \cite{HJ}. PRAM algorithms are in general synchronous and provide massive amount of parallelism. Other types of algorithms are asynchronous or bulk-synchronous with relatively low algorithmic overhead.  It is important that reasonable performance is achived for both classes of algorithms. 
The problem we consider is the spanning tree problem. It is notoriously hard to achieve good parallel performance, and at the same time, the algorithms we study represent different classes of algorithms. We implement the algorithms in X10 and other languages, and show that the X10 implementation is preferable in terms of ease-of-programe and performance.

 The rest of the paper is organized as follows. Section~\ref{s:x10} describes the language features of X10. Section~\ref{s:design} presents spanning tree algorithms in X10. Section~\ref{s:runtime} presents the runtime support for X10, especially for activity scheduling, with comparison to other runtime systems. 
 Section~\ref{s:results} gives our experimental results. In Section~\ref{s:concl} we conclude and give future work. 
 Throughout the paper, we
 use $n$ and $m$ to denote the number of vertices and the number of
 edges of an input graph $G=(V,E)$, respectively. 
  


