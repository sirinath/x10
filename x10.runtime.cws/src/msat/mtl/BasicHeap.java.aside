package msat.mtl;

class BasicHeap {
    Comparator     lt;
    VecInt heap;     // heap of ints

    // Index "traversal" functions
    static int left  (int i) { return i*2+1; }
    static int right (int i) { return (i+1)*2; }
    static int parent(int i) { return (i-1) >> 1; }

    void percolateUp(int i)
    {
        int x = heap.get(i);
        while (i != 0 && lt.apply(x, heap.get(parent(i)))){
            heap.set(i, heap.get(parent(i));
            i                = parent(i);
        }
        heap.set(i,x);
    }

    void percolateDown(int i)
    {
        int x = heap.get(i);
        while (left(i) < heap.size()){
            int child = right(i) < heap.size() && 
            lt(heap.get(right(i)), heap.get(left(i))) ? right(i) : left(i);
            if (!lt(heap.get(child), x)) break;
            heap.set(i,heap.get(child));
            i                = child;
        }
        heap.set(i, x);
    }

    boolean heapProperty(int i) {
        return i >= heap.size()
            || ((i == 0 || !lt(heap.get(i), heap.get(parent(i)))) 
            		&& heapProperty(left(i)) && heapProperty(right(i))); }

    public BasicHeap(Comparator c) { lt=c; }

    public int  size      ()           { return heap.size(); }
    public boolean empty     ()        { return heap.size() == 0; }
    public int  get(int index)         { return heap.get(index+1); }
    public void clear(boolean dealloc) { heap.clear(dealloc); }
    public void clear () { clear(false);}
    public void insert    (int n)  { heap.push(n); percolateUp(heap.size()-1); }
    public int  removeMin() {
    	int r   = heap.get(0);
    	heap.set(0, heap.last());
    	heap.pop();
    	if (heap.size() > 1) percolateDown(0);
    	return r; 
    }
    // DEBUG: consistency checking
    public boolean heapProperty() { return heapProperty(1); }

    // COMPAT: should be removed
    public int  getmin    ()      { return removeMin(); }
}

