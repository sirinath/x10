\documentclass[10pt,a4paper]{article}

%% For typesetting theorems and some math symbols.
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{fullpage}

\title{Featherweight X10}

\author{}

\date{}




\input{commands}


\begin{document}


\maketitle


\lstset{language=java,basicstyle=\ttfamily\small}

%\chapter{Featherweight Ownership and Immutability Generic Java}
\section{Introduction}


We begin with some definitions.

FX10 program consists of class declarations followed by the program's expression.
The source language does not contain


An expression/type is called \emph{closed} if it does not contain \proto nor
    free variables (but it may contain \cooked or other locations).
For example, the expression~$\code{new Foo<l>()}$ is closed, but $\code{new Foo<proto>()}$ is not closed.

Given a field $\code{A}~\hT~\hf$ and a method $\code{U m(}\ol{\hV}~\ol{\hx}\code{) K \lb~return e;~\rb}$ in class~\hC,
    we define
\beqst
    \code{\mtype{}(m,C)} &= \ol{\hV}\mapsto\hU\\
    \code{\mtype{}(m,C<K>)} &= [\hK/\proto]\code{\mtype{}(f,C)}\\
    \code{\mbody{}(m,C)} &= \he\\
    \code{\mproto{}(m,C)} &= \hK\\
    \code{\ftype{}(f,C)} &= \hT\\
    \code{\isVar{}(f,C)} &= (\code{A}=\code{var})\\
\eeq

Given a proto set~$P$, functions receive a cooker~$\hK ::= \proto ~|~ \cooked ~|~ {\hl}$,
    and return whether it is cooked or proto:
\beqst
\isCooked(\hK) &= \hK=\code{cooked} \text{~~or~~} (\hK=\hl \text{~~and~~}\hl \not \in P)\\
\isProto(\hK) &= \hK=\code{proto} \text{~~or~~} (\hK=\hl \text{~~and~~}\hl \in P)\\
\eeq

Note that for every cooker~\hK, either $\isCooked(\hK)$ or $\isProto(\hK)$ (and never both).

%\begin{cases}
%\hl & \he=\hl \\
%\code{error} & \text{otherwise} \\
%\end{cases}

Given an expression~\he, we define~$R(\he)$ to be the set
    of all ongoing constructors in~\he, i.e., all locations in subexpressions~\code{e;return l}.
Formally,
\[
R(\he) =
\begin{cases}
    R(\code{e'}) \cup \{ l \} & \text{if~}\he=(\code{e';return l}) \\
    R(\code{e'}) & \text{if~}\he=(\code{e'.f}) \\
    R(\code{e'}) \cup R(\code{e"}) & \text{if~}\he=(\code{e'.f=e"}) \\
    \cup R(\ol{\he'}) & \text{if~}\he=(\code{new T}\hparen{\ol{\he'}}) \\
    R(\code{e"}) \cup R(\ol{\he'}) & \text{if~}\he=(\code{e".m}\hparen{\ol{\he'}}) \\
    \end{cases}
\]

Summary of syntax used:
The comma operator~$,$ represents disjoint union.
Environment $\Gamma ::= \epsilon ~|~ \hx:\hT,\Gamma ~|~ \hl:\hT,\Gamma$.
Proto locations (locations whose constructor is still ongoing) $P::= \epsilon ~|~ \hl,P$.

A \emph{location}~\hl is a pointer to an object on the heap.
An \emph{object} has the form~$\code{C<l>}\hparen{\ol{\hv}}$, where~\hC is a class,~$\hl$ is the object's cooker, and~$\ol{\hv}$ are the values of the object's fields.
A \emph{heap} is a pair $\angular{H,P}$, where $H$ maps locations to objects, and $P \in \dom(H)$ is the set of proto locations.

A \emph{well-typed} heap~$\angular{H,P}$ satisfies:
    (i)~there is a linear order~$\Tprec$ over~$\dom{}(H)$ such that for every location~\hl, $H[\hl]=\code{C<l'>}\hparen{\ol{\hv}}$,
        we have~$\hl' \Tprec \hl$,
        and
    (ii)~each non-null field location is a subtype (using $\Pst$) of the declared field type.
A heap~$\angular{H,P}$ is \emph{well-typed for~\he} if~$\angular{H,P\cup R(\he)}$ is well-typed.

Summary of judgements:
\beqst
\Gamma,P & \vdash \hT \st \code{T'}\\
\Gamma,P & \vdash \hT \Pst \code{T'}\\
\Gamma,P & \vdash \he : \hT\\
P & \vdash H,\he \rightarrow H',\code{e'}\\
& \vdash \angular{H,P} \text{~is well-type}\\
& \vdash \angular{H,P} \text{~is well-type for~\he}\\
\eeq

\begin{smaller}
\input{formal-syntax}
\input{formal-subtyping}
\input{formal-typing}
\input{formal-reduction}
\end{smaller}


Next we describe the syntax (\Ref{Figure}{syntax}),
    subtyping rules (\Ref{Figure}{subtyping}),
    expression typing rules (\Ref{Figure}{expressions}),
    and reduction rules (\Ref{Figure}{reduction}).

\section{Syntax}
Obviously, class declarations cannot contain locations.

\section{Subtyping}


\section{Typing}
\paragraph{Method typing}
If \proto appears in $\mtype{}(\hm,\hC)$ then $\mproto{}(\hm,\hC)=\proto$.

An overriding method must keep the same $\mtype$ and $\mproto$.

In class~\hC, when typing a method:
        $\code{U} ~ \hm\hparen{\ol{\code{V}} ~ \ol{\hx}} ~ \hK~ \lb\ \hreturn ~ \he\texttt{;} \rb$\\
        we use an environment~$\Gamma=\{\ol{\hx}:\ol{\code{T}}, \this:\code{C<K>}\}$, $P=\{\}$,
        and we must prove that~$\Gamma,P \vdash \he:\code{S}$
        and~$\Gamma,P \vdash \code{S} \st \code{U}$.

\paragraph{Expression typing}
See \Ref{Figure}{expressions}.



\end{document}
