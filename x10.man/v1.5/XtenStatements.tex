\chapter{Statements}\label{XtenStatements}\index{statements}

\Xten{} inherits all the standard statements of \Java{}, with the expected semantics:

\begin{verbatim}
EmptyStatement      LabeledStatement  
ExpressionStatement IfStatement
SwitchStatement     WhileDo
DoWhile             ForLoop           
BreakStatement      ContinueStatement  
ReturnStatement     ThrowStatement
TryStatement
\end{verbatim}

\section{Empty statement}

The empty statement \xcd";" does nothing.  It is useful when a
loop header is evaluated for its side effects.  For example,
the following code sums the elements of an array.
\begin{xten}
var sum: Int = 0;
for (i: Int = 0; i < a.length; i++, sum += a[i])
    ;
\end{xten}

\section{Expression statement}

The expression statement evaluates an expression, ignoring the
result.  The expression must be either an assignment, an
allocation, or a call.

\section{Labeled statement}

Statements may be labeled.  The label may be used as the target
of a break or continue statement.  The scope of a label is the
statement labeled.

\section{Break statement}

An unlabeled break statement exits the currently enclosing loop
or switch statement.

An labeled break statement exits the enclosing loop
or switch statement with the given label.

It is illegal to break out of a loop not defined in the current
method, constructor, initializer, or closure.

The following code searches for an element of a two-dimensional
array and breaks out of the loop when found:

\begin{xten}
var found: Boolean = false;
for (i: Int = 0; i < a.length; i++)
    for (j: Int = 0; j < a(i).length; j++)
        if (a(i)(j) == v) {
            found = true;
            break;
        }
\end{xten}

\section{Continue statement}

An unlabeled continue statement branches to the top of the
currently enclosing loop.

An labeled break statement branches to the top of the enclosing loop
with the given label.

It is illegal to continue a loop not defined in the current
method, constructor, initializer, or closure.

\section{If statement}

An if statement comes in two forms: with and without an else
clause.

The if-then statement evaluates a condition expression and 
evaluates the consequent expression if the condition is
\xcd"true".  If the 
condition is \xcd"false",
the if-then statement completes normally.

The if-then-else statement evaluates a condition expression and 
evaluates the consequent expression if the condition is
\xcd"true"; otherwise, the alternative statement is evaluated.

The condition must be of type \xcd"Boolean".

\section{Switch statement}

A switch statement evaluates an index expression and then branches to
a case whose value equal to the value of the index expression.
If no such case exists, the switch branches to the 
\xcd"default" case, if any.

Statements in each case branch evaluated in sequence.  At the
end of the branch, normal control-flow falls through to the next case, if
any.  To prevent fall-through, a case branch may be exited using a \xcd"break",
\xcd"continue", \xcd"return", or \xcd"throw" statement.

The index expression must be of type \xcd"Int".

Case labels must be of type \xcd"Int" and must be compile-time
constants.  Case labels cannot be duplicated within the
\xcd"switch" statement.

\section{While statement}

A while statement evaluates a condition and executes a loop body
if \xcd"true".  If the loop body completes normally (either by reaching
the end or via a \xcd"continue" statement with the loop header
as target), the condition is reevaluated and the loop repeats if
\xcd"true".  If the condition is \xcd"false", the loop
exits.

The condition must be of type \xcd"Boolean".

\section{Do--while statement}

A do-while statement executes a loop body, and then evaluates a
condition expression.  If \xcd"true", the loop repeats.
Otherwise, the loop exits.

The condition must be of type \xcd"Boolean".

\section{For statement}

A for statement consists of an initializer, a condition, an
iterator, and a body.  First, the initializer is evaluated.
The initializer may introduce local variables that are in scope
throughout the for statement.  An empty initializer is
permitted.
Next, the condition is evaluated.  If \xcd"true", the loop body
is executed; otherwise, the loop exits.
The condition may be omitted, in which case the condition is
considered \xcd"true".
If the loop completes normally (either by reaching the end
or via a \xcd"continue" statement with the loop header as
target),
the iterator is evaluated and then the condition is reevaluated
and the loop repeats if
\xcd"true".  If the condition is \xcd"false", the loop
exits.

The condition must be of type \xcd"Boolean".
The initializer and iterator are statements, not expressions
and so do not have types.

\section{Throw statement}

The \xcd"throw" statement throws an exception.  The exception
must be of type \xcd"x10.lang.Throwable".  If the exception is
\xcd"null", a \xcd"NullPointerException" is thrown.

\section{Try--catch statement}




\section{Assignment}\index{assignment}\label{AssignmentStatement}

%It is often the case that an \Xten{} variable is assigned to only
%once. The user may declare such variables as \xcd"final". However,
%this is sometimes syntactically cumbersome.
%
%{}\Xten{} supports the syntax \xcd"l := r" for assignment to mutable
%variables.  The user is strongly enouraged to use this syntax to
%assign variables that are intended to be assigned to more than
%once. The \Xten{} compiler may issue a warning if it detects code 
%that uses \xcd"=" assignment statements on \xcd"mutable" variables.

{}\Xten{} supports assignment \xcd"l = r" to array variables. In this
case \xcd"r" must have the same distribution \xcd"D" as \xcd"l". This
statement involves control communication between the sites hosting
\xcd"D". Each site performs the assignment(s) of array components
locally. The assignment terminates when assignment has terminated at
all sites hosting \xcd"D".

%% TODO: Sectional assignment??

\section{Point and region construction}\label{point-syntax}\index{[] syntax}
\Xten{} specifies a simple syntax for the construction of points and regions.
\begin{grammar}
ArgumentList \: Expression ( \xcd"," Expression )\star \\
Primary \: \xcd"Point" \xcd"(" ArgumentList \xcd")"
\end{grammar}
Each element in the argument list must be either of type \xcd"int" or 
of type \xcd"region". In the former case the expression 
\xcdmath"(a$_1$, $\dots$, a$_k$)" is treated as syntactic shorthand for
\begin{xtenmath}
point.factory.point(a$_1$, $\dots$, a$_k$)
\end{xtenmath}
\noindent and in the latter case as shorthand for
\begin{xten}
region.factory.region(a$_1$, $\dots$, a$_k$)
\end{xten}

\section{Exploded variable declarations}\label{exploded-syntax}\index{variable declarator!exploded}

\Xten{} permits a richer form of specification for variable
declarators in method arguments, local variables and loop variables
(the ``exploded'' or {\em destructuring} syntax).
\begin{grammar}
VariableDeclaratorId \:
           Identifier \xcd"(" IdentifierList \xcd")" \\
           \| \xcd"(" IdentifierList \xcd")" \\
\end{grammar}
In \XtenCurrVer{} the \grammarrule{VariableDeclaratorId} must be declared at
type \xcd{x10.lang.point}. Intuitively, this syntax allows a
point to be ``destructured'' into its corresponding \xcd{int} 
indices in a pattern-matching style.
The $k$th identifier in the \grammarrule{
IdentifierList} is treated as a \xcd{final} variable of type \xcd{int}
that is initialized with the value of the $k$th index of the point. 
The second form of the syntax (Rule 82) permits the specification of only
the index variables.

Future versions of the language may allow destructuring syntax for all
value classes.

\paragraph{Example.}
The following example succeeds when executed.
\begin{xten}
public class Array1Exploded {
  public def select(p(i,j): point, (k,l): point): int {
      return i+k;
  }
  public def run(): boolean {
    d: distribution = [1:10, 1:10] -> here;
    ia: array[int] = new array[int](d);
    for (p(i,j): point in [1:10,1:10]) {
        if (ia(p) != 0) return false;
        ia(p) = i+j;
    }
    for (p(i,j): point in d) {
      q1: point = (i,j);
      if (i != q1(0)) return false;
      if (j != q1(1)) return false;
      if(ia(i,j) != i+j) return false;
      if(ia(i,j) != ia(p)) return false;
      if(ia(q1)  != ia(p)) return false;
    }
    if (! (4 == select([1,2],[3,4]))) return false;
    return true;
  }
        
  public static def main(args: array[String]) {
     b: boolean = (new Array1Exploded()).run();
     System.out.println("++++++ "
                        + (b ? "Test succeeded."
                             : "Test failed."));
     System.exit(b ? 0 : 1);
  }
}
\end{xten}



