\chapter{Places}\label{XtenPlaces}\index{places}

An \Xten{} place is a repository for data and activities. Each place
is to be thought of as a locality boundary: the activities running in
a place may access data items located at that place with the
efficiency of on-chip access. Accesses to remote places may take
orders of magnitude longer.

{}\Xten{} provides a built-in value class, \xcd"x10.lang.place"; all
places are instances of this class.  This class is \xcd"final" in
{}\XtenCurrVer.

In \XtenCurrVer{}, the set of places available to a computation is
determined at the time that the program is run and remains fixed
through the run of the program. The number of places available 
may be determined by reading (\xcd"place.MAX_PLACES"). (This number
is specified from the command line/configuration information; 
see associated {\tt README} documentation.)

All scalar objects created during program execution are located in one
place, though they may be referenced from other places. Aggregate
objects (arrays) may be distributed across multiple places using
distributions.

The set of all places in a running instance of an \Xten{} program may
be obtained through the \xcd"const" field \xcd"place.places".  (This
set may be used to define distributions, for instance,
\S~\ref{XtenDistributions}.) 


The set of all places is totally ordered.  The first place may be
obtained by reading \xcd"place.FIRST_PLACE". The initial activity for
an \Xten{} computation starts in this place
(\S~\ref{initial-computation}). For any place, the operation \xcd"next()"
returns the next place in the total order (wrapping around at the
end). Further details on the methods and fields available on this
class may be obtained by consulting the API documentation.

{\em Note: Future versions of the language may permit user-definable
places, and the ability to dynamically create places. }

\paragraph{Static semantics.}
Variables of type \xcd"place" must be initialized and are implicitly
\xcd"final".  

\section{Place expressions}
Any expression of type \xcd"place" is called a place expression. 
Examples of place expressions are \xcd"this.location" (the place
at which the current object lives), \xcd"place.FIRST_PLACE"
(the first place in the system in canonical order). 

Place expressions are used in the following contexts: 
\begin{itemize}
%\item As a  place type in a type (\S~\ref{PlaceTypes}).
\item As a target for an \xcd"async" activity or a future
(\S~\ref{AsyncActivity}).
\item In a class cast expression  (\S~\ref{ClassCast}).
\item In an \xcd"instanceof" expression (\S~\ref{instanceOf}).
\item In stable equality comparisons, at type \xcd"place".
\end{itemize}

Like values of any other type, places may be passed as arguments
to methods, returned from methods, stored in fields etc.

\section{\Xcd{here}}\index{here}\label{Here}
\Xten{} supports a special indexical constant\footnote{
An indexical constant is one whose value depends on its context
of use.} \xcd"here":
\begin{verbatim}
22 ExpressionName ::= here
\end{verbatim}
The constant evaluates to the place at which the current activity is
running. Unlike other place expressions, this constant cannot be 
used as the placetype of fields, since the type of a field 
should be independent of the activity accessing it.

\paragraph{Example.}
The code:
\begin{xten}
public class F {
  public def m(a: F) {
    val OldHere: place = here;
    async (a) {
      System.out.println("OldHere == here:" 
                         + (OldHere == here));
    }
  }
  public static void main(s: array[String]) {
    new F().m(future(place.FIRST_PLACE.next())
              { new F() }.force());
  }
}  
\end{xten}
\noindent will print out \xcd"true" iff the computation was configured
to start with the number of places set to \xcd"1". 


\section{Implicit syntax}\label{ImplicitSyntax}\index{implicit syntax}

Recall that the explicit syntax for \Xten{} requires the programmer to use
asyncs/future to ensure the Locality Principle: An activity accesses
only those mutable locations that reside in the same place as the
activity. 

Explicit syntax has the advantage that the performance model for \Xten{}
is explicit from the syntax. It has the disadvantage that the
programmer has to manually reason about the placement of various
objects. If the programmer reasons incorrectly then computation may
abort at runtime with an exception.

The place-based type system enables the compiler to support the
Locality principle. The programmer uses the type system to establish
that the types of various objects are local. These assertions are
checked by the compiler (as a side-effect of checking dependent
types). Additionally, the programmer may now use normal variable
syntax to access (read/write) variables, and invoke methods on
objects. Suppose the type of the variable \xcd"v" is \xcd"C{c}".
If \xcd"c" establishes
\xcd"location==here" then the compiler generates code for
performing the relevant operation on the local variable (read,
write, method invocation) synchronously. 

Otherwise the compiler generates code in explicit syntax as
follows. If the operation is a read, the compiler generates code to
perform a future/force on the variable

\begin{xten}
future(v) { v }.force();  
\end{xten}

If the operation is a write \xcd"v=e", the compiler generates code to perform
the write synchronously:

\begin{xten}
val temp: T = e;
finish async (v) { v = w; }
\end{xten}

If the operation is a read on an array variable a[p] the compiler
generates the code:

\begin{xten}
future(a.dist(p)) { a(p) }.force();  
\end{xten}


If the operation is a write \xcd"a[p]=e", the compiler generates code to perform
the write synchronously:

\begin{xten}
val tp: point = p;
val t: T = e;
finish async (a.dist(tp)) { a(tp) = t; }
\end{xten}

If the operation is a method invocation \xcdmath"e.m(e$_1$,..., e$_n$)"
for a void method, the compiler generates code to
perform the method invocation synchronously:

\begin{xten}
val t: T! = e;
val t1: P1! = e1;
...
val tn: Pn! = en;
finish async (t) {
  t.m(t1,..., tn);
}
\end{xten}


If the operation is a method invocation
\xcdmath"e.m(e$_1$,...,e$_n$)" for a method that returns a value
of type E, then the compiler generates the following code:

XXX remove this -- do not define semantics by translation

\begin{xten}
( (t: T!, t1: P1!, ..., tn: Pn!) => { 
    return future(t) { t.m(t1,...tn) }.force();
  } )(e, e1, ..., en)
\end{xten}


