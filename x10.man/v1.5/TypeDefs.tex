 typedef defines an alias for a type:

TypeDef ::= type Identifier TypeParametersopt FormalParametersopt = Type ;
ClassMember ::= TypeDef
BlockStatement ::= TypeDef

A typedef may appear within a block of statements; the scope of the
definition is the remainder of the block. Typedefs may also appear as
class or interface members.

Typedefs may be parameterized on other types (see #Generics below) or on
values. Parameterized typedefs may be thought of as static or instance
methods that return types.

class Foo {
 type FooSet = Set<Foo>;
 type StockadeOf<A> = <T>(T owner)Stockade<T>(owner)<A>;
 type StockadeOwnedBy(Object o) = Stockade<o.type>(o);
}

Typedefs are not recursive. It is a static error for a typedef to
resolve to a type that uses itself (e.g., as a type property
initializer). Typedefs are always final; there is no type assignment
operation.

A type defined by a typedef may be used anywhere a type can be used. The
compiler resolves the definition and substitutes in the resolved type
during type checking.

Type members may be declared static or not. Non-static members may be
referred to using a path-dependent type.

Every typedef can be resolved to a canonical type. All types with the
same canonical type are equivalent.

Question: value in lexical distinction between types defined by typedefs
and other types?

Question: might want to typedef a primitive type and have it be distinct
from the original; and add operations to the typedefed primitive. See
rep in CLU.

Question: can we just subclass int?

Question: distinguish between applicative and generative typedefs:

type Color <= int;

vs.

type Color = int;

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=27>]

