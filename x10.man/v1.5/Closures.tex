\Xten{} provides first-class, typed closures.  Variables
referenced within closures need not be final.  Methods and
operators may be viewed as closures.

We introduce a new expression. For types \xcd"T",
\xcdmath"T$_1$", \dots
\xcdmath"T$_n$", then the following are closure expressions:

\begin{xtenmath}
(x$_1$: T$_1$, $\dots$, x$_n$: T$_n$): T throws (U$_1$, $\dots$, U$_k$) => { s }
(x$_1$: T$_1$, $\dots$, x$_n$: T$_n$) => { s }
\end{xtenmath}

In the first form, the terminal expression \xcd"e" in
xcd"s", if any, is thought of as shorthand for the statement
\xcd"return e". 

In particular, \xcd"return" statements in \xcd"s", if any,
\xcd"return" from the function
being defined, and not any enclosing function. Similarly,
\xcd"continue" and
\xcd"break" statements may occur in \xcd"s" only if the target
lies within \xcd"s". That
is, a closure cannot be used to exit a lexically enclosing block on
invocation.

\begin{example}
\begin{xten}
def find[T](f: T => Boolean, xs: List[T]): T {
  for (x: T in xs)
    if (f(x)) return x;
  null
}
\end{xten}
\end{example}

If the return type is omitted, it is inferred, as described in
\Sref{TypeInference}.
It is a static error if the return type cannot be inferred.

As with a normal method, the closure may have a \xcd"throws" clause. It is a
static error if a checked exception is thrown that is not declared in
the \xcd"throws" clause.

\begin{note}
We could omit throws clauses and turn uncaught checked
exceptions into unchecked exceptions. Or, we could not require checked
exceptions at all in X10, but that affects Java compatibility.
\end{note}

\subsection{Functions are objects}

Functions in \Xten{} are objects.  In particular they are
instances of anonymous classes that implement the appropriate
\xcd"Fun" interface.  As objects, closure body may refer to
\xcd"this", and use it to invoke the closure recursively.

\eat{
Design Note: The syntax has been chosen to be similar to a method
definition with missing qualifiers and no name. As discussed below we
will in fact be able to reconceptualize methods as qualified, named
functions.
}

\subsection{Closures in initailizers}

In variable initailizers, blocks may be used for closures:

\begin{xten}
val f(x: Int): Int = { x + 1 };
\end{xten}

is equivalent to

\begin{xten}
val f: Int => Int = (x: Int) => { x + 1 };
\end{xten}

The scope of \xcd"x" above is just the block on the
right-hand-side. In a
subsequent assignment to it, the value may not refer to \xcd"x".

\subsection{Outer variable access}

The body \xcd"s" in a function
\xcdmath"(x$_1$: T$_1$, $\dots$, x$_n$: T$_n$) => { s }"
may access fields
of enclosing classes and local variable declared in an outer scope.

Recall that languages such as \java{} require that methods may
access only those local variables declared in an enclosing scope
("outer variables") which are final. This is valuable in
preventing accidental races between multiple closures reading
and writing the same outer variable. At the same time, it is
desirable to support the following common idiom of expression:

\begin{xten}
def allPositive(c: Collection): Boolean {
  result: Boolean = true;
  c.applyToAll((x: Int) => { if (x < result) atomic {result=false;}});
  return result;
}
\end{xten}

This motivates the following rule:

\begin{staticrule*}
In an expression
\xcdmath"(x$_1$: T$_1$, $\dots$, x$_n$: T$_n$) => { s }",
any non-final outer local variable accessed by \xcd"s" must be (declared
as) \xcd"@shared".
\end{staticrule*}

A shared local variable is thought of as being accessible by any spawned
activity in its lexical scope. (A final qualifier on a variable implies
a shared qualifier.) An implementation may consider boxing shared outer
variables and making a reference to the boxed value available to the
closure. Note that \xcd"s" may access fields of enclosing classes. In such a
case a reference to the instance whose field is being accessed is made
available to the closure.

\begin{note}
The main activity may run in parallel with any
closures it creates. Hence even the read of an outer variable by the
body of a closure may result in a race condition, Since closures are
first-class, the analysis of whether a closure may execute in parallel
with the activity that created it is very difficult.
\end{note}

\begin{note}
The rule for accessing outer variables from closure bodies
should be the same as the rule for accessing outer variables from local
or anonymous classes.
\end{note}

\subsection{Function application}

A variable \xcd"m" of type
\xcdmath"(x$_1$: T$_1$, $\dots$, x$_n$: T$_n$) => T",
can be applied thus:
\xcdmath"m(e$_1$, $\dots$, e$_n$)".

It is a static error if a call is may resolve to both a closure call or
to a method call.

\eat{
\subsection{Implicit coercions}

Many Java idioms that called for interfaces with a single method, e.g.
Runnable, Callable etc may now be replaced with idioms that use an
argument of an appropriate function type.

A value of a function type may be coerced to an interface containing a
single method with a compatible type.
}

\subsection{Fields of function type}

To avoid an ambiguity, it is a static error for a class to declare a
field with a function type whose erased signature is the same as a
method of the same class.

\section{Methods as functions}

As discussed above, a function is identified by its type and body.
Methods are named functions associated with classes, and subject to
inheritance.

The syntax and semantics of method definition, inheritance and
overriding remains unchanged. However, we now think of a method definition:

\begin{grammar}
def m[X](x: T): U = { S }
\end{grammar}

as binding the function

\begin{xten}
[X](x: T): U => { S }
\end{xten}

to the method-name--argument-list tuple (\xcd"m", \xcd"X",
\xcd"x: T").  That is, underlying every method is a function.

\begin{note}
Because of overloading, a method name is not sufficient to
uniquely identify a function for a given class (in Java-like languages).
One needs the argument type information as well.
\end{note}

\eat{
If the method is an instance method its body may reference the variables
this and super (and Type.this and Type.super in case the method is
defined on a nested class); these are implicitly declared in the lexical
scope surrounding the body. One should think of an instance method as
binding a function to a (name, list of types) pair for each instance of
a class. The state associated with the instance is accessible within the
body of the function in the usual way (using this, super etc).
}

This motivates us to introduce the instance function selector. For a
type \xcd"T", a list of types
(\xcdmath"T$_1$", \dots,
\xcdmath"T$_n$"), 
a method name
\xcd"m" and an expression \xcd"e" of type \xcd"T",
\xcdmath"e.m.(T$_1$, $\dots$, T$_n$)" denotes the function,
if any, bound to the instance method named \xcd"m" at type
\xcd"T" whose argument
type is
\xcdmath"(T$_1$, $\dots$, T$_n$), with \xcd"this" in the method
body bound to the value obtained
by evaluating \xcd"e". The
return type of the function is specified in the method declaration.

Thus, the expression

\begin{xtenmath}
e.m.(T$_1$, $\dots$, T$_n$)
\end{xtenmath}

evaluates to

\begin{xtenmath}
(x$_1$: T$_1$, $\dots$, x$_n$: T$_n$) => e.m(x$_1$, $\dots$, x$_n$)
\end{xtenmath}

\begin{note}
The selector syntax (dot) is used to distinguish \xcd"e.m()" (a
method invocation on \xcd"e" of method named \xcd"m" with no arguments)
from \xcd"e.m.()"
(the function bound to the method). 
\end{note}

A static method provides a binding from a name to a function that is
independent of any instance of a class; rather it is associated with the
class itself. The static function selector
\xcdmath"T.m.(T$_1$, $\dots$, T$_n$)" denotes the
function bound to the static method named \xcd"m", with argument types
\xcdmath"(T$_1$, $\dots$, T$_n$) for the type \xcd"T". The return type
of the function is specified by the declaration of \xcd"T.m".

Users of a function type do not care whether a function was defined
directly (using the closure syntax), or obtained via (static or
instance) function selectors.

\begin{note}
Design note: The function selector syntax is consistent with the
reinterpretation of the usual method invocation syntax
\xcdmath"e.m(e$_1$,..., e$_n$)"
into a function specifier, \xcd"e.m", applied to a tuple of arguments
\xcdmath"(e$_1$,..., e$_n$)". Note that the receiver is not
treated as ``an extra argument'' to the
function. That would break the above approach.
\end{note}


\section{Operators as functions}

Every operator (e.g.,
\xcd"+",
\xcd"-",
\xcd"*",
\xcd"/",
\dots) has a family of functions, one for
each type on which the operator is defined. The function can be
selected using the "." syntax:

\begin{grammar}
Primary \: TypeName \xcd"." Operator \xcd"(" TypesOrFormals\opt \xcd")" \\
        \| TypeName \xcd"." Operator \\
\end{grammar}

If an operator has more than one arity (e.g., unary and binary
\xcd"-"), the appropriate version may be selected by giving the
formal parameter types.  The binary version is selected by
default.
For example, the following equivalences hold:

\begin{xtenmath}
String.+             $\equiv$ (x: String, y: String): String => x + y
Long.-               $\equiv$ (x: Long, y: Long): Int => x - y
Float.-(Float,Float) $\equiv$ (x: Float, y: Float): Int => x - y
Int.-(Int)           $\equiv$ (x: Int): Int => -x
Boolean.&            $\equiv$ (x: Boolean, y: Boolean): Boolean => x & y
Boolean.!            $\equiv$ (x: Boolean): Boolean => !x
Int.<(Int,Int)       $\equiv$ (x: Int, y: Int): Boolean => x < y
Dist.|(Place)        $\equiv$ (d: Dist, p: Place): Dist => d | p
\end{xtenmath}

Unary and binary promotion (\Sref{XtenPromotions}) is not performed
when invoking these
operations; instead, the operands are coerced individually via implicit
coercions (\Sref{XtenConversions}), as appropriate.

Additionally, for every expression \xcd"e" of a type \xcd"T" at which a binary
operator \xcd"OP" is defined, the expression \xcd"e.OP" or
\xcd"e.OP(T)" represents the function
defined by:

\begin{xten}
(x: T): T => { e OP x }
\end{xten}

\begin{grammar}
Primary \: Expr \xcd"." Operator \xcd"(" TypesOrFormals\opt \xcd")" \\
        \| Expr \xcd"." Operator \\
\end{grammar}

For every expression \xcd"e" of a type \xcd"T" at which a unary
operator \xcd"OP" is defined, the expression \xcd"e.OP()" represents the function
defined by:

\begin{xten}
(x: T): T => { OP x }
\end{xten}


For example,
one may write an expression that adds one to each member of a list \xcd"xs" by:

\begin{xten}
xs.map(1.+)
\end{xten}

\eat{
X10's \xcd"async", \xcd"future", \xcd"foreach", \xcd"ateach"
can be defined as syntactic
abbreviation for the invocation of the following static methods:

\begin{xten}
static native def async(() => Void, clocks: Set);
static native def future(p: Place, b: => T): Future[T];
static native def foreach(r: Region, s: (Point) => Void);
static native def ateach(d: Dist, s: (Point) => Void);
\end{xten}

Similarly an initializer for an array of base type \xcd"T" is thought of as
taking an argument closure of type \xcd"(Point) => T".
}


