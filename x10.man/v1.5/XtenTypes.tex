\chapter{Types}
\label{XtenTypes}\index{types}

{}\Xten{} is a {\em strongly typed} object-oriented language: every variable
and expression has a type that is known at compile-time. Further,
\Xten{} has a {\em unified} type system: all data items created at
runtime are {\em objects} (\Sref{XtenObjects}. Types limit the
values that variables can hold and specify the places at which these
values lie.

{}\Xten{} supports two kinds of objects, {\em reference objects} and
{\em value objects}.  Reference objects are instances of {\em
reference classes} (\Sref{ReferenceClasses}). They may contain
mutable fields and must stay resident in the place in which they were
created. Value objects are instances of {\em value classes}
(\Sref{ValueClasses}). They are immutable and may be freely copied
from place to place. Either reference or value objects may be 
{\em scalar} (instances of a non-array class) or {\em aggregate} (instances
of arrays).
Only variables of reference types may be assigned \xcd"null".

Types are used in variable declarations, casts, object creation, array
creation, class literals and \xcd"instanceof" expressions.\footnote{In
order to allow this version of the language to focus on the core new
ideas, \XtenCurrVer{} does not have user-definable classloaders,
though there is no technical reason why they could not have been
added.}

\section{Type definitions and type constructors}

Types in \Xten{} are specified through declarations and through
type constructors:

\paragraph{Class types.}
\label{ReferenceTypes}

\index{types!class types}
\index{class}
\index{class!reference class}
\index{class declaration}
\index{declaration!class declaration}

        A {\em class declaration} (\Sref{XtenClasses})
        introduces a 
        {\em (reference) class type}
\index{class!reference class}\index{reference class type}
        containing all instances of the class.

        Class instances are created via
        constructor calls.  Class instances have fields and
        methods, type members, and value and type properties bound at
        construction time.  In addition, classes have static
        members: constant fields, type definitions, and member
        classes and member interfaces.

\Xten{} does
not
permit mutable static state, so the role of static methods and
initializers is quite limited. Instead programmers should use
singleton classes to carry mutable static state.
        
        Reference classes are structured in a
        single-inheritance hierarchy; that is,
        classes are declared to extend a single
        superclass (except for \xcd"x10.lang.Object", the root
        of the class hierarchy, which extends no other class),
        and zero or more interfaces.

\paragraph{Value class types.}

\index{types!value class types}
\index{class}
\index{class!value class}
\index{class declaration}
\index{value class declaration}
\index{declaration!value class declaration}

A {\em value class type}\index{class!value class}\index{value class type}
is a class type in which all fields of the class are immutable.

Values classes are specified via {\em value class declarations}
(\Sref{XtenClasses}).

Variables of value class type may not be \xcd"null".
There is no subtyping relationship between different value
classes.

\paragraph{Interface types.}

\index{types!interface types}
\index{interface}
\index{interface declaration}
\index{declaration!interface declaration}

        An {\em interface declaration} (\Sref{XtenInterfaces})
        defines an {\em interface type}, which specifies a set of
        methods, type members, and properties to be implemented by any class
        declared to implement the interface.  Interfaces also
        have static members: constant fields, type definitions,
        and member classes and interfaces.


        An interface may extend multiple interfaces.

Classes may be declared to implement 
multiple interfaces. 
Semantically, the interface type is the set of all objects that are
instances of (value or reference) classes that implement the
interface. A class implements an interface if it is declared to if
it implements all the methods defined in the interface.
        
\paragraph{Type properties.}

\index{types!type properties}
\index{properties!type properties}
\index{types!path types}

        Classes and interface have {\em type properties}, bound
        to concrete types on object creation.
        A class or interface type
        with one or more type properties is called a {\em
        generic type}.

        Type properties introduce {\em path types}.
        Given an object
        denoted by expression \xcd"e", if \xcd"e" has a 
        type property \xcd"X", then \xcd"e.X" is a type.
        To ensure soundness, the expression \xcd"e"
        must be a final access path.  

\paragraph{Type parameters.}

\index{types!type parameters}

        A method, constructor, or closure may have type parameters, which
        introduces a type whose scope is the parameterized method or
        constructor. 
        Type parameters may be constrained by a {\em where
        clause} on the method.
        The type parameters must be bound to
        concrete types at invocation.

\paragraph{Type definitions.}
\index{types!type definitions}
\index{declarations!type definitions}
\index{types!path types}

        Types may be defined through {\em type definitions}.
        A type definition is a type alias or a type-valued function
        that maps value and type parameters to another type.
        A type definition may appear as a static or instance
        class or interface
        member or in statement block.

\eat{
\begin{xten}
class Foo {
    int x;
    class C { }
    type T(y) = Bar{p==x};
}
\end{xten}
}

        For instance type members, type definitions define path
        types: Given an object
        denoted by expression \xcd"e", if \xcd"e" has an
        instance
        type member \xcd"X", possibly with parameters, e.g.,
        \xcd"X[Y](z: T)", then \xcd"e.X" (and also \xcd"e.X[Y](z)")
        is a type.

        If \xcd"C" is a class or interface with static type
        member \xcd"X", then \xcd"C.X" is a type.

        A local type declaration for type \xcd"X" defines a type
        named \xcd"X" within the scope of the declaration.

        Type definitions may be parameterized on both types and
        values.

\paragraph{Function types.}
\index{types!function types}

        Function types are defined via the \xcd"=>" type
        constructor.  The type
  \xcdmath"[X$_1$, $\dots$, X$_k$](x$_1$: T$_1$, $\dots$, x$_n$: T$_n$) => T"
        is the type of functions that take type parameters
        \xcdmath"X$_i$"
        and value parameters
        \xcdmath"x$_i$"
        of types
        \xcdmath"T$_i$"
        and returns a value of type \xcd"T".

\paragraph{Constrained types.}
\index{types!constrained types}
\index{types!generic types}
        Given a type \xcd"T", a {\em constrained type}
        \xcd"T{e}" may be
        constructed by constraining its properties with a
        boolean predicate \xcd"e".

        \xcd"T{e}" is a {\em dependent type}, that is, a type
        dependent on values.
        The type \xcd"T" is called the
        {\em base type} and \xcd"e" is called the {\em constraint}.
        For reference types, the constraint may
        specify the places at which the object resides.

        A {\em generic type} is a class or interface type
        declared with one or more type properties.  Generic
        types can be instantiated by constraining the type
        properties of the base type.



\begin{grammar}
Type \: FunctionType \\
    \| ConstrainedType  \\

FunctionType \: TypeParameters\opt \xcd"(" TypesOrFormals\opt
\xcd")" Constraint\opt \xcd"=>" Type  \\
TypeParameters \: \xcd"[" TypeParameter ( \xcd"," TypeParameter )\star \xcd"]" \\
TypeParameter \: Identifier \\
TypesOrFormals \: TypeOrFormal ( \xcd"," TypeOrFormal )\star \\
TypeOrFormal   \: Type \\
               \| Formal \\

ConstrainedType \: BaseType Constraint\opt PlaceConstraint\opt
Annotation\star \\

BaseType \: ClassBaseType \\
     \| InterfaceBaseType \\
     \| PathType \\
     \| \xcd"(" Type \xcd")" \\

ClassType \: ClassBaseType Constraint\opt PlaceConstraint\opt
Annotation\star \\
InterfaceType \: InterfaceBaseType Constraint\opt
PlaceConstraint\opt Annotation\star \\

PathType \: Expression \xcd"." Identifier \\

Annotation \: \xcd"@" InterfaceBaseType Constraint\opt \\

ClassOrInterfaceType \: ClassType \\ \| InterfaceType \\
ClassBaseType \: TypeName \\
InterfaceBaseType \: TypeName \\
\end{grammar}

\section{Generic types}
\label{Generics}

A {\em generic type} is a class or interface type declared with
one or more type properties.

Like a value property, a type property is an instance member.
The type properties of an object are bound to concrete types
when the object is
created.
Types may be defined by constraining the type properties as
well as the value properties of a class.

The following code declares a class \xcd"Cell" with a type
property named \xcd"T".
\begin{xten}
class Cell[T] {
    var x: T;
    def this(x: T) { this.x = x; }
    def get(): T = x;
    def set(x: T) = { this.x = x: }
}
\end{xten}
The class has a mutable field \xcd"x", initialized by the
constructor, and has a getter method and a setter method.

This example shows that type properties are in many ways similar to
type parameters as provided in languages such as Java and Scala.
Type properties are types in their own right:
they may be used in any context a type may be used,
including in \xcd"instanceof" and cast expressions.
However, the key semantic distinction between type properties
and type parameters is that type properties are instance
members.
Thus, for an expression \xcd"e" of type \xcd"Cell", \xcd"e.T" is a type. 
To ensure
soundness, \xcd"e" is restricted to final access paths.
Within the body of a class, a property name \xcd"T" resolves
to \xcd"this.T" (or to \xcd"C.this.T" if \xcd"T" is a property of
an enclosing class \xcd"C"), just as value properties are
resolved.

As with value properties, type properties may be constrained
by predicates to produce new types.
For instance, the type \xcd"Cell{T==String}" is the type of
all \xcd"Cell"s that contain a \xcd"String".
Constraints on properties induce a natural subtyping relationship:
\xcd"C{c}" is a subtype of
\xcd"D{d}" if \xcd"C" is a subclass of \xcd"D" and
\xcd"c" entails \xcd"d".

The following are legal types:
\begin{itemize}
\item \xcd"Cell".  This type has no constraints on \xcd"T".
Any type that constrains \xcd"T", including the three below,
is a subtype of \xcd"Cell".  The type \xcd"Cell" is equivalent to
\xcd"Cell{true}".
%
For a \xcd"Cell" \xcd"c", the return type of the \xcd"get" method 
is \xcd"c.T".  
Since the property \xcd"T" is unconstrained,  
the caller can only assign the return value of \xcd"get"
to a variable of type \xcd"c.T" or of type \xcd"Object".
In the following code, \xcd"y" cannot be passed to the \xcd"set" method
because, since \xcd"T" is not bounded,
it cannot be determined statically if \xcd"Object" is a
subtype of \xcd"c.T".
\begin{xten}
val x: c.T = c.get();
val y: Object = c.get();
c.set(x); // legal
c.set(y); // illegal
\end{xten}

\item \xcd"Cell{T==Float}".
The type property \xcd"T" is bound to \xcd"Float".
Assuming \xcd"c" has this type, the following code is legal:
\begin{xten}
val x: Float = c.get();
c.set(1.0);
\end{xten}
The type of \xcd"c.get()" is \xcd"c.T", which is equivalent to
\xcd"Float".
Similarly, the \xcd"set" method takes a \xcd"Float" as argument.

\item \xcd"Cell{T<:Int}".
This type constrains \xcd"T" to be a subtype of \xcd"Int".
All instances of this type must bind \xcd"T" to a subtype of \xcd"Int".
The following expressions have this type:
\begin{xten}
new Cell[Int](1);
new Cell[Int{self==3}](3);
\end{xten}
The cell in the first expression may contain any \xcd"Int".
The cell in the second expression may contain only \xcd"3".
%
If \xcd"c" has the type \xcd"Cell{T<:Int}",
then \xcd"c.get()" has type \xcd"c.T", which is an unknown but
fixed subtype of \xcd"Int".  The \xcd"set" method of \xcd"c" can
only be called with an object of type \xcd"c.T".

\item \xcd"Cell{T:>String}".  This type bounds the type property
\xcd"T"
from below.  The \xcd"set" method may be called with any
supertype of \xcd"String"; the return type of the \xcd"get"
method is known to be a
supertype of \xcd"String" (and implicitly a subtype of \xcd"Object").
\end{itemize}

For brevity, the constraint may be omitted and
interpreted as \xcd"true".
The syntax 
\xcdmath"C[T$_1$,$\dots$,T$_m$](e$_1$,$\dots$,e$_n$)" is sugar for
\xcdmath"C{X$_1$==T$_1$,$\dots$,X$_m$==T$_m$,x$_1$==e$_1$,$\dots$,x$_n$==e$_n$}"
where \xcd"Xi" are the type properties and \xcd"xi" are the
value properties of \xcd"C".  
If either list of properties is empty, it may be omitted.

In this shortened syntax, a type \xcd"T" used may also be annotated
with
a \emph{use-site variance tag}, either \xcd"+" or \xcd"-":
if \xcd"X" is a type property, then
the syntax \xcd"C[+T]" is sugar \xcd"C{X<:T}" and
\xcd"C[-T]" is sugar \xcd"C{X:>T}"; of course,
\xcd"C[T]" is sugar \xcd"C{X==T}".

\input{FunctionTypes}

\section{Type definitions}

With value arguments, type arguments, and constraints, the
syntax for \Xten{} types can often be verbose;
\Xten{} therefore provides {\em type definitions}
to allow aliases to be defined for types.
Type definitions have the following syntax:

\begin{grammar}
TypeDefinition \: 
                \xcd"type"~Identifier
                           ( \xcd"[" TypeParameters \xcd"]" )\opt \\
                        && ( \xcd"(" Formals \xcd")" )\opt
                            WhereClause\opt \xcd"=" Type \\
\end{grammar}

\noindent
A type definition can be thought of as a type-valued function,
mapping type parameters and value parameters to a concrete type.
%
The following examples are legal type definitions:
\begin{xten}
type StringSet = Set[String];
type MapToList[K,V] = Map[K,List[V]];
type Nat = Int{self>=0};
type Int(x: Int) = Int{self==x};
type Int(lo: Int, hi: Int) = Int{lo <= self, self <= hi};
\end{xten}

As the two definitions of \xcd"Int" demonstrate, type definitions may 
be overloaded: a type definition with a different number of type
parameters or with different types of value
parameters---according to the method overloading rules
(\Sref{MethodOverload}) define distinct types.

Type definitions may appear as class members or in the body of a
method, constructor, or initializer.  Type definitions that are
members of a class are \xcd"static"; type properties can be used
for non-static type definitions.

Type definitions are applicative, not generative; that is, they
are define aliases for types and do not introduce new types.
Thus, the following code is legal:
\begin{xten}
type A = Int;
type B = String;
type C = String;
a: A = 3;
b: B = new C("Hi");
c: C = b + ", Mom!";
\end{xten}
A type defined by a type definition
has the same constructors as its defining type; however, a
constructor may not be invoked using a given type definition
name if the constructor return type is not a subtype of the
defined type.

All type definitions are members of their enclosing package or
class.  A compilation unit may have one or more type definitions
or class or interface declarations with the same name, as long
as the types are unique by overloading.

\section{Path types}

Path types of the form \xcd"p.X" consist of a final access path,
\xcd"p", and a type
member (including type properties), \xcd"X".
The final access path \xcd"p" must be either \xcd"this", \xcd"self", a final
local variable, or a final field or value property whose target
is itself a final access path.  The path must type-check 
as a normal expression in the scope in which it appears.
The type member
\xcd"X" must be an instance member of the static type of the
path \xcd"p".

If an identifier \xcd"X" resolves to a type member or property
of an enclosing class or interface \xcd"T", then \xcd"X" is equivalent to
the path type \xcd"T.this.X".

\section{Constrained types}
\label{DepType:DepType}
\label{DepTypes}\index{dependent types}
        
        Given a type \xcd"T", a {\em constrained type}
        \xcd"T{e}" may be
        constructed by constraining its properties with a
        boolean predicate \xcd"e".

\subsection{Constraints}

Expressions used as constraints are restricted by the
constraint system in use to ensure that the constraints can
be solved at compile time.

If a type is unconstrained, it is considered to have the
constraint \xcd"true".
A type may also be constrained using lists of type arguments and
value arguments.  A base type \xcd"C" with type properties
\xcdmath"X$_1$", \dots,
\xcdmath"X$_n$" and
with the type argument list
\xcdmath"[T$_1$, $\dots$, T$_n$]" is equivalent to the type
\xcdmath"C{X$_1$==T$_1$, $\dots$, X$_n$==T$_n$}".
Similarly, a base type \xcd"C" with value properties
\xcdmath"x$_1$", \dots,
\xcdmath"x$_n$" and
with the value argument list
\xcdmath"(e$_1$, $\dots$, e$_n$)" is equivalent to the type
\xcdmath"C{x$_1$==e$_1$, $\dots$, x$_n$==e$_n$}".

\def\withmath#1{\relax\ifmmode#1\else{$#1$}\fi}
\def\LL#1{\withmath{\lbrack\!\lbrack #1\rbrack\!\rbrack}}

\begin{grammar}
Constraint \: TypeArguments     ValueArguments\opt WhereClause\opt \\
           \| TypeArguments\opt ValueArguments     WhereClause\opt \\
           \| TypeArguments\opt ValueArguments\opt WhereClause     \\
           \\
TypeArguments    \:  \xcd"[" Type ( \xcd"," Type )\star \xcd"]" \\
ValueArguments   \:  \xcd"(" ArgumentList\opt \xcd")" \\
ArgumentList     \:  Expression ( \xcd"," Expression )\star \\
WhereClause        \: \xcd"{" Expression \xcd"}" \\
\end{grammar}

\begin{staticrule}{Variable Occurrence}
In a deptype \xcd"T" = \xcd"C{c}", the only variables that may
occur in \xcd"c" are (a)
\xcd"self", (b) properties visible at \xcd"T", (c) final local variables, final
method parameters or final constructor parameters visible at \xcd"T", (d)
final fields visible at \xcd"T"'s lexical place in the source program.  
\end{staticrule}

\begin{staticrule}{Restrictions on \xcd"this"}
  The special variable \xcd"this" may be used in a depclause for a type \xcd"T"
  only if (a)~\xcd"T" occurs in a property declaration for a
  class, (b)~\xcd"T"
  occurs in an instance method, (c)~\xcd"T" occurs in an
  instance field, (d)~\xcd"T"
  occurs in an instance initializer.

  In particular, \xcd"this" may not be used in types that occur in a static
  context, or in the arguments, body or return type of a constructor or
  in the extends or implements clauses of class and interface
  definitions.  In these contexts, the object that \xcd"this" would
  correspond to is not defined.
\end{staticrule}

\begin{staticrule}{Variable visibility}
  If a type \xcd"T" occurs in a field, method or constructor
  declaration, then all variables used in \xcd"T" must have at least the
  same visibility as the declaration.  The relation ``at least the same
  visibility as'' is given by the transitive closure of:

\begin{xten}
public > protected > package > private
\end{xten}

All inherited properties of a type \xcd"T" are visible in the property
list of \xcd"T", and the body of \xcd"T".

\end{staticrule}

In general, variables (i.e., local variables, parameters,
properties, fields) are visible at
\xcd"T" if they are defined before \xcd"T" in the program. This rule applies to
types in property lists as well as parameter lists (for methods and
constructors).
A formal parameter is visible in the types of all other formal
parameters of the same method, constructor, or type definition,
as well as in the method or constructor body itself.
Properties are accessible via their containing object--\xcd"this"
within the body of their class declaration.  The special
variable \xcd"this" is in scope at each property
declaration, constructor signatures and bodies, instance method signatures
and bodies,
and instance field signatures and initializers, but not in scope
at \xcd"static" method or field declarations or \xcd"static"
initializers.  

We permit variable declarations \xcd"v: T" where \xcd"T" is obtained
from a dependent type \xcd"C{c}" by replacing one or more occurrences
of \xcd"self" in \xcd"c" by \xcd"v". (If such a declaration \xcd"v: T"
is type-correct, it must be the case that the variable \xcd"v" is not
visible at the type \xcd"T". Hence we can always recover the
underlying deptype \xcd"C{c}" by replacing all occurrences of \xcd"v"
in the constraint of \xcd"T" by \xcd"self".)

For instance, \xcd"v: Int{v > 0}" is shorthand for \xcd"v: Int{self > 0}".

\begin{staticrule}{Constraint type}
  The type of a constraint \xcd"c" must be \xcd"Boolean".  
\end{staticrule}

A variable occuring in the constraint \xcd"c" of a deptype, other than
\xcd"self" or a property of \xcd"self", is said to be a {\em
parameter} of \xcd"c".\label{DepType:Parameter} \index{parameter}

An instance \xcd"o" of \xcd"C" is said to be of type \xcd"C{c}"
(or: {\em belong to}
\xcd"C{c}") if the predicate \xcd"c" evaluates to \xcd"true" in the current lexical
environment, augmented with the binding \xcd"self" $\mapsto$ \xcd"o". We shall
use the function \LL{\mbox{\Xcd{C\{c\}}}} to denote the set of
objects that belong to \xcd"C{c}". 

\input{PlaceTypes}

\subsection{Type invariants}\label{DepType:TypeInvariant}\index{Type invariant}
\label{DepType:Where}

A class or interface declaration may specify a
\grammarrule{WhereClause}, an invariant on all
instances of that type.
All the properties in the list, together with inherited properties,
may appear in the class invariant. A where clause \xcd"c" with
type property list \xcdmath"X$_1$, $\dots$, X$_k$"
and value property list \xcdmath"x$_1$: T$_1$, $\dots$, x$_n$: T$_n$"
for a class \xcd"C" is said to be consistent if each of the \xcdmath"T$_i$" are
consistent and the constraint
\begin{xtenmath}
$\exists$X$_1$, $\dots$, X$_k$, x$_1$: T$_1$, $\dots$, x$_n$: T$_n$, self: C. c
\end{xtenmath}
\noindent is valid (always true).

With every defined class or interface \xcd"T" we associate a {\em type
invariant} $\mathit{inv}($\xcd"T"$)$ as follows. The type
invariant associated with \xcd"x10.lang.Object" is the
proposition:

\begin{xten}
self.location: Place
\end{xten}

The type invariant associated with any interface \xcd"I" that extends
interfaces \xcdmath"I$_1$, $\dots$, I$_k$" and defines properties
\xcdmath"x$_1$: P$_1$, $\dots$, x$_n$: P$_n$" and
specifies a where clause \xcd"c" is given by:

\begin{xtenmath}
$\mathit{inv}$(I$_1$) && $\dots$ && $\mathit{inv}$(I$_k$)
    && self.x$_1$: P$_1$ && $\dots$ && self.x$_n$: P$_n$ && c  
\end{xtenmath}

Similarly the type invariant associated with any class \xcd"C" that
implements interfaces \xcdmath"I$_1$, $\dots$, I$_k$",
extends class \xcd"D" and defines properties
\xcdmath"x$_1$: P$_1$, $\dots$, x$_n$: P$_n$" and
specifies a where clause \xcd"c" is
given by:
\begin{xtenmath}
$\mathit{inv}$(D) && $\mathit{inv}$(I$_1$) && $\dots$ && $\mathit{inv}$(I$_k$)
    && self.x$_1$: P$_1$ && $\dots$ && self.x$_n$: P$_n$ && c  
\end{xtenmath}

It is required that the
type invariant associated with a class entail the type invariants of
each interface that it implements.

It is guaranteed that for any variable \xcd"v" of
type \xcd'T{c}' (where \xcd"T" is an interface name or a class name) the only
objects \xcd"o" that may be stored in \xcd"v" are such that \xcd"o" satisfies
$\mathit{inv}(\mbox{\xcd"T"}[\mbox{\xcd"o"}/\mbox{\xcd"this"}])
\wedge \mbox{\xcd"c"}[\mbox{\xcd"o"}/\mbox{\xcd"self"}]$.

%% XXX check parens

\subsection{Consistency of deptypes}\label{DepType:Consistency}\index{deptype,consistency}

A dependent type \xcd"C{c}" may contain zero or more parameters. We require
that a type never be empty---so that it is possible for a variable of
the type to contain a value. This is accomplished by requiring that
the constraint \xcd"c" must be satisfiable {\em regardless} of the value assumed
by parameters to the contraint (if any). Formally, consider a type
\xcd"T" = \xcd"C{c}", with the variables
\xcdmath"f$_1$: F$_1$, $\dots$, f$_k$: F$_k$"
free in \xcd"c".  Let 
\xcdmath"$S$ = {f$_1$: F$_1$, $\dots$, f$_k$: F$_k$, f$_{k+1}$: F$_{k+1}$, $\dots$, f$_n$: F$_n$}"
be the smallest set of
declarations containing
\xcdmath"f$_1$: F$_1$, $\dots$, f$_k$: F$_k$"
and closed under the rule:
\xcd"f: F" in $S$ if a reference to variable \xcd"f" (which
is declared as \xcd"f: F") occurs in a type in $S$.

(NOTE: The syntax rules for the language ensure that $S$ is always
finite. The type for a variable \xcd"v" cannot reference a variable whose
type depends on \xcd"v".)

We say that \xcd"T" = \xcd"C{c}" is {\em parametrically consistent} (in brief:
{\em consistent}) if:

\begin{itemize}
\item Each type \xcdmath"F$_1$, $\dots$, F$_n$" is (recursively) parametrically consistent, and
\item It can be established that
\xcdmath"$\forall$f$_1$: F$_1$, $\dots$, f$_n$: F$_n$. $\exists$self: C. c && $\mathit{inv}$(C)".
\end{itemize}

\noindent
where \xcdmath"$\mathit{inv}$(C)" is the invariant associated
with the type \xcd"C" (\Sref{DepType:TypeInvariant}).  Note by
definition of $S$ the formula above has no free variables.

\begin{staticrule*}
For a declaration \xcd"v: T" to be type-correct, \xcd"T" must be parametrically
consistent. The compiler issues an error if it cannot determine
the type is parametrically consistent.
\end{staticrule*}

\begin{example}

A class that represents a line has two distinct points:

\begin{xten}
class Line(start: Point, 
           end: Point{self != this.start}) {...}      
\end{xten}
\end{example}

One can use deptypes to define other closed geometric figures as well.

\begin{example}
Here is an example:
\begin{xten}
class Point(x: Int, y: Int) {...}
\end{xten}
\end{example}


To see that the declaration \xcd"end: Point{self != start}" is
parametrically consistent, note that the following formula is valid:
\begin{xtenmath}
$\forall$this: Line. $\exists$self: Point. self != this.start  
\end{xtenmath}
\noindent since the set of all \xcd"Point"s has more than one element.

\begin{example}
A triangle has three lines sharing three vertices.
\begin{xten}
class Triangle 
 (a: Line, 
  b: Line{a.end == b.start}, 
  c: Line{b.end == c.start && c.end == a.start}) 
 { ... }
\end{xten}
\end{example}


Given \xcd"a: Line", the type \xcd"b: Line{a.end == b.start}" is consistent,
and
given the two, the type \xcd"c: Line{b.end == c.start, c.end == a.start}"
is consistent.

%%Similarly:
%%
%%   // A class with properties a, b,c,x satisfying the 
%%   // given constraints.
%%   class SolvableQuad(a: Int, b: Int, 
%%                      c: Int{b*b - 4*a*c >= 0},
%%                      x: Int{a*x*x + b*x + c==0}) { 
%%     ...
%%   }
%%
%%  // A class with properties r, x, and y satisfying
%%  // the conditions for (x,y) to lie on a circle with center (0,0)
%%  // and radius r.
%%   class Circle (r: Int{r > 0},
%%                 x: Int{r*r - x*x >= 0},
%%                 y: Int{y*y == r*r -x*x}) { 
%%   ...
%%   }

\subsection{Constraint system}

\Xten{} provides a simple constraint system,  
permitting conjunctions of equalities between variables and
constants, and existential quantification over typed variables.

The constraint system can be extended via compiler plugins.

Subsquent implementations are intended to support boolean algebra,
arithmetic, relational algebra etc to permit types over regions and
distributions. We envision this as a major step towards removing most
(if not all) dynamic array bounds and places check from \Xten{}.

\section{Subtyping and type equivalence}\label{DepType:Equivalence}\label{deptype,equivalence}

Subtyping is relation between types.  It is the
reflexive, transitive 
closure of the {\em direct subtyping} relation, defined as
follows.

\paragraph{Class types.}  A class type is a direct subtype of
any
class it is declared to extend.  A class type is direct subtype
of any interfaces it is declared to implement.

\paragraph{Interface types.}  An interface type is a direct
subtype of any interfaces it is declared to extend.

\paragraph{Function types.}

The subtyping rules for function types follow directly from the
interpretation of a function type as an interface type
\xcdmath"Fun_$_k$_$_n$".
For instance,
a function type
\xcd"S1 => T1" 
is a subtype of another function type
\xcd"S2 => T2" 
if \xcd"S2" is a subtype of \xcd"S1"
and \xcd"T1" is a subtype of \xcd"T2".

\paragraph{Constrained types.}

Two dependent types \xcd"C{c}" and \xcd"C{d}" are said to be {\em equivalent} if 
\xcd"c" is true whenever \xcd"d" is, and vice versa. Thus, 
$\LL{\mbox{\Xcd{C\{c\}}}} = \LL{\mbox{\Xcd{C\{d\}}}}$.

Note that two deptypes that are syntactically different may be
equivalent. For instance, \xcd"Int{self >= 0}" and
\xcd"Int{self == 0 || self > 0}" are equivalent though they are syntactically
distinct. The \Java{} type system is essentially a nominal system---two
types are the same if and only if they have the same name. The \Xten{}
type system extends the nominal type system of \Java{} to permit
constraint-based equivalence.

A dependent type \xcd"C{c}" is a subtype of a type \xcd"C{d}" if
\xcd"c" implies \xcd"d".  In such a case we have
$\LL{\mbox{\Xcd{C\{c\}}}}$ is a
subset of $\LL{\mbox{\Xcd{C\{d\}}}}$. All dependent types
defined on a class \xcd"C"
refine the unconstrained class type \xcd"C"; \xcd"C" is
equivalent to \xcd"C{true}".

\paragraph{Path types.}

A path type \xcd"p.X" is a subtype of a type \xcd"T" if
\xcd"p" has type \xcd"C{c}" (where \xcd"C" has a type property
\xcd"X") and \xcd"c" implies that \xcd"self.X" is a subtype of \xcd"T".

\input{Coercions}

%\subsection{Syntactic abbreviations}\label{DepType:SyntaxAbbrev}

\section{Built-in types}

The package \xcd"x10.lang" provides a number of built-in class and
interface declarations that can be used to construct types.

\subsection{The value class \Xcd{Any}}\label{Any}\index{\Xcd{Any}}

The value class \xcd"x10.lang.Any" is the superclass of all
value and reference classes.  All \Xten{} types are subtypes of
\xcd"Any".  \xcd"Any" has no members.

\begin{xten}
package x10.lang;
public class Any { }
\end{xten}

\subsection{The class \Xcd{Object}}\label{Object}\index{\Xcd{Object}}
The class \xcd"x10.lang.Object" is the superclass of all other reference
classes.
A variable of this type can hold a reference to an instance of any
reference type.

\begin{xten}
package x10.lang;
public class Object extends Any {
  def toString(): String {...}
  def equals(o: Object): Boolean {...}
  def hashCode(): Int {...}
}
\end{xten}

The method \xcd"equals" and \xcd"hashCode" are useful in hashtables,
and are defined as in \java. The default implementation of \xcd"equals"
is stable equality, \Sref{StableEquality}. This method may be overridden
in a (value or reference) subclass.

\subsection{The class \Xcd{String}}

\Xten{} supports strings as in \java{}. A string object is immutable,
and has a concatenation operator (\xcd"+")  available on it.

\xcd"x10.lang.String" is a value class.


\subsection{Primitive value classes}

Several value types are provided that encapsulate
abstractions (such as fixed point and floating point arithmetic)
commonly implemented in hardware by modern computers.

\begin{xten}
package x10.lang;

public value Boolean { }

public abstract value Number { }
public abstract value Integer extends Number { }

public value Byte extends Integer  { }
public value Short extends Integer { }
public value Int extends Integer   { }
public value Char extends Integer  { }
public value Long extends Integer  { }

public value Float extends Number  { }
public value Double extends Number { }
\end{xten}

A program may contain literals
that stand for specific instances of these classes. The syntax
for literals is the same as for \java{} (\Sref{Literals}).

Binary and unary operations produce new instances of these
classes.

Values of one numeric class may be coerced into values of
another value class via the \xcd"to" operation.

\futureext{
\Xten{} may provide mechanisms in the future to permit the programmer
to specify how a specific value class is to be mapped to special
hardware operations (e.g., along the lines of
\cite{kava}). Similarly, mechanisms may be provided to permit the user
to specify new syntax for literals.
}

\input{ArrayTypes}
\input{FutureTypes}

\section{Box types}
\label{BoxType}

The class \xcd"Box" allows a value type to be used at a
reference type.

\begin{xten}
package x10.lang;
public class Box[T](unbox: T) { }
\end{xten}

The \xcd"to" expression may be used to convert to and from a
boxed type:

\begin{xten}
val x = new Box[Int](0); // box using constructor call
val y = x to Int;        // unbox using to-operation
val z = y to Box;        // box using to-operation
\end{xten}

Assignment of a value type into a variable of reference type
automatically boxes the value.

\section{Type inference}

\XtenCurrVer{} supports limited local type inference.

The type of a variable declaration can be omitted if the
declaration has an initializer.  The inferred type of the
variable is the computed type of the initializer.

The return type of a method can be omitted if the method has a
body (i.e., is not \xcd"abstract" or \xcd"extern").  The
inferred return type is the computed type of the body.

The return type of a closure can be omitted.
The inferred return type is the computed type of the body.

The return type of a constructor can be omitted if the
constructor has a body (i.e., is not \xcd"extern").
The inferred return type if the enclosing class type with
properties bound to the arguments in the constructor's \xcd"property"
statement, if any, or to the unconstrained class type.

The inferred type of a method or closure body is the least common ancestor
of the types of the expressions in \xcd"return" statements
in the body.  If the method does not return a value, the
inferred type is \xcd"Void".

A call to a polymorphic method, closure, or constructor may omit the
explicit type arguments.  If the method has a type parameter
\xcd"T", the type argument corresponding to \xcd"T" is inferred
to be the least common ancestor of the types of any formal
parameters of type \xcd"T".



