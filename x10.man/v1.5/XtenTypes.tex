\chapter{Types}
\label{XtenTypes}\index{types}

XXX Olivier: type system is not unified; there are values
(records) and references.
Object is the superclass of all reference types.

{}\Xten{} is a {\em strongly typed} object-oriented language: every variable
and expression has a type that is known at compile-time. Further,
\Xten{} has a {\em unified} type system: all data items created at
runtime are {\em objects} (\S~\ref{XtenObjects}. Types limit the
values that variables can hold and specify the places at which these
values lie.

{}\Xten{} supports two kinds of objects, {\em reference objects} and
{\em value objects}.  Reference objects are instances of {\em
reference classes} (\S~\ref{ReferenceClasses}). They may contain
mutable fields and must stay resident in the place in which they were
created. Value objects are instances of {\em value classes}
(\S~\ref{ValueClasses}). They are immutable and may be freely copied
from place to place. Either reference or value objects may be 
{\em scalar} (instances of a non-array class) or {\em aggregate} (instances
of arrays).

An \Xten{} type consists of a {\em base type}, which is a set of
objects, and a boolean {\em constraint} on the immutable state of
the objects.
The constraint also
specifies the places at which the object resides.

\index{type constructors}\label{TypeConstructors}
Types are constructed through the application of {\em type constructors}.
Every class and interface definition in \Xten{} defines a type with
the same name. Additionally, {}\Xten{} supports {\em function
types}
and {\em path types}.
We discuss these type constructors and constrained typess in detail
in the sections that follow.

Types are used in variable declarations, casts, object creation, array
creation, class literals and \xcd"instanceof" expressions.\footnote{In
order to allow this version of the language to focus on the core new
ideas, \XtenCurrVer{} does not have user-definable classloaders,
though there is no technical reason why they could not have been
added.}


%% Final variables play an 
%% important role in \Xten{}, as we shall discuss below. For this reason,
%% \Xten{} enforces the lexical restriction that all variables whose name
%% starts with an upper case letter are implicitly declare final. (It is
%% not an error to also explicitly declare such variables as
%% final.)\index{Upper-case Convention}

\begin{grammar}
Type \: FunctionType \\
    \| ConstrainedType  \\

FunctionType \: TypeParameters\opt \xcd"(" TypesOrFormals\opt \xcd")" \xcd"=>" Type  \\
TypeParameters \: \xcd"[" Type ( \xcd"," Type )\star \xcd"]" \\
TypesOrFormals \: TypeOrFormal ( \xcd"," TypeOrFormal )\star \\
TypeOrFormal   \: Type \\
               \| Formal \\

ConstrainedType \: BaseType Constraint\opt PlaceConstraint\opt
Annotation\star \\

BaseType \: PrimitiveBaseType \\
     \| ClassBaseType \\
     \| InterfaceBaseType \\
     \| PathType \\
     \| \xcd"(" Type \xcd")" \\

ClassType \: ClassBaseType Constraint\opt PlaceConstraint\opt
Annotation\star \\
InterfaceType \: InterfaceBaseType Constraint\opt
PlaceConstraint\opt Annotation\star \\
PrimitiveType \: PrimitiveBaseType Constraint\opt
Annotation\star \\

PathType \: Expression \xcd"." Identifier \\

Annotation \: \xcd"@" InterfaceBaseType Constraint\opt \\

ClassOrInterfaceType \: ClassType \\ \| InterfaceType \\
ClassBaseType \: TypeName \\
InterfaceBaseType \: TypeName \\
PrimitiveBaseType \: TypeName \\
\end{grammar}

\section{Properties}\label{DepType:Properties}\index{properties}

Types in \Xten{} consist of a base type, instantiated through one of
the type constructors described below and a constraint on the
properties of the base type.
A {\em constrained type}, or dependent type (deptype),
is of the form \xcd"T{c}" where \xcd"T" is a base type (class,
interface, function, array)
and \xcd"c" is a {\em constraint}.  \xcd"T" is said to be 
{\em the base type} of the deptype, and \xcd"c" the {\em constraint}
of the deptype.
Constraints are boolean expressions 
defined over the properties of the base type and immutable
variables in scope at the type.

Properties may be either value properties or type
properties.
\index{properties!value properties}
The immutable state of an object is captured by its
\emph{value properties}: public final fields of the object.
For instance, the following class declares a two-dimensional
point with \xcd"float" properties \xcd"x" and \xcd"y":
\begin{xten}
class Point(x: float, y: float) { }
\end{xten}
A constrained type is a type \xcd"C{e}", where \xcd"C" is a
class and \xcd"e" is a boolean predicate on the properties of
\xcd"C" and the final variables in scope at the type.
For example, given the above class definition,
the type \xcd"Point{x*x+y*y==1}" is the type of all
points on the unit circle.

\index{properties!type properties}
{\em Type properties} are used to define generic classes and
interfaces.
Like a value property, a type property is an instance member.
The type properties of an object are bound to concrete types
when the object is
created.
Types may be defined by constraining the type properties as
well as the value properties of a class.


\section{Class types}\label{ReferenceTypes}

A class type consists of the name of a class
and an
associated constraint on the properties of the class.
Semantically, the class type is the set of all objects which are
instances of (subclasses of) the class for which the constraint
holds.
A {\em class declaration} (\S~\ref{XtenClasses})
introduces a class type containing all instances of the class.

Classes are structured in a
single-inheritance code
hierarchy, may implement multiple interfaces, may have static
and
instance fields, may have static and instance methods, may have
constructors, may have static and instance initializers, may
have
static and instance inner classes and interfaces. \Xten{} does
not
permit mutable static state, so the role of static methods and
initializers is quite limited. Instead programmers should use
singleton classes to carry mutable static state.


\section{Value class types}\index{class!value class}\index{value class type}

A {\em value class type}\index{class!value class}\index{value class type}
is a class type in which all fields of the class are immutable.

Values classes are specified via {\em value class declarations}
(\S~\ref{XtenClasses}).

Variables of value class type may not be \xcd"null".
There is no subtyping relationship between different value
classes.

\section{Boxed types}

For a value type \xcd"T", the type constructor \xcd"Box[T]"
defines an class with the same members as \xcd"T". 
Like \xcd"T", all fields of \xcd"Box[T]" are final.

Unlike value classes, variables of \xcd"Box" type may be \xcd"null".

\section{Interface types}\label{InterfaceTypes}

Interfaces are defines via {\em interface declarations}
(\S~\ref{XtenInterfaces}),
which specifies a name, a list of extended
interfaces, properties,
constants, and
method signatures associated. Each interface
declaration introduces a type with the same name as the declaration.

Classes may be declared to implement 
one or more interfaces.  
Semantically, the interface type is the set of all objects that are
instances of (value or reference) classes that implement the
interface. A class implements an interface if it is declared to if
it implements all the methods defined in the interface.

\section{Generic types}

A {\em generic type} is a class or interface type declared with
one or more type properties.

Like a value property, a type property is an instance member.
The type properties of an object are bound to concrete types
when the object is
created.
Types may be defined by constraining the type properties as
well as the value properties of a class.

The following code declares a class \xcd"Cell" with a type
property named \xcd"T".
\begin{xten}
class Cell[T] {
    var x: T;
    def this(x: T) { this.x = x; }
    def get(): T = x;
    def set(x: T) = { this.x = x: }
}
\end{xten}
The class has a mutable field \xcd"x", initialized by the
constructor, and has a getter method and a setter method.

This example shows that type properties are in many ways similar to
type parameters as provided in languages such as Java and Scala.
Type properties are types in their own right:
they may be used in any context a type may be used,
including in \xcd"instanceof" and cast expressions.
However, the key semantic distinction between type properties
and type parameters is that type properties are instance
members.
Thus, for an expression \xcd"e" of type \xcd"Cell", \xcd"e.T" is a type. 
To ensure
soundness, \xcd"e" is restricted to final access paths.
Within the body of a class, a property name \xcd"T" resolves
to \xcd"this.T" (or to \xcd"C.this.T" if \xcd"T" is a property of
an enclosing class \xcd"C"), just as value properties are
resolved.

As with value properties, type properties may be constrained
by predicates to produce new types.
For instance, the type \xcd"Cell{T==String}" is the type of
all \xcd"Cell"s that contain a \xcd"String".
Constraints on properties induce a natural subtyping relationship:
\xcd"C{c}" is a subtype of
\xcd"D{d}" if \xcd"C" is a subclass of \xcd"D" and
\xcd"c" entails \xcd"d".

The following are legal types:
\begin{itemize}
\item \xcd"Cell".  This type has no constraints on \xcd"T".
Any type that constrains \xcd"T", including the three below,
is a subtype of \xcd"Cell".  The type \xcd"Cell" is equivalent to
\xcd"Cell{true}".
%
For a \xcd"Cell" \xcd"c", the return type of the \xcd"get" method 
is \xcd"c.T".  
Since the property \xcd"T" is unconstrained,  
the caller can only assign the return value of \xcd"get"
to a variable of type \xcd"c.T" or of type \xcd"Object".
In the following code, \xcd"y" cannot be passed to the \xcd"set" method
because it is not known if \xcd"Object" is a subtype of \xcd"c.T".
\begin{xten}
val x: c.T = c.get();
val y: Object = c.get();
c.set(x); // legal
c.set(y); // illegal
\end{xten}

\item \xcd"Cell{T==float}".
The type property \xcd"T" is bound to \xcd"float".
Assuming \xcd"c" has this type, the following code is legal:
\begin{xten}
val x: float = c.get();
c.set(1.0);
\end{xten}
The type of \xcd"c.get()" is \xcd"c.T", which is equivalent to
\xcd"float".
Similarly, the \xcd"set" method takes a \xcd"float" as argument.

\item \xcd"Cell{T<:int}".
This type constrains \xcd"T" to be a subtype of \xcd"int".
All instances of this type must bind \xcd"T" to a subtype of \xcd"int".
The following expressions have this type:
\begin{xten}
new Cell[int](1);
new Cell[int{self==3}](3);
\end{xten}
The cell in the first expression may contain any \xcd"int".
The cell in the second expression may contain only \xcd"3".
%
If \xcd"c" has the type \xcd"Cell{T<:int}",
then \xcd"c.get()" has type \xcd"c.T", which is an unknown but
fixed subtype of \xcd"int".  The \xcd"set" method of \xcd"c" can
only be called with an object of type \xcd"c.T".

\item \xcd"Cell{T:>String}".  This type bounds the type property
\xcd"T"
from below.  The \xcd"set" method may be called with any
supertype of \xcd"String"; the return type of the \xcd"get"
method is known to be a
supertype of \xcd"String" (and implicitly a subtype of \xcd"Object").
\end{itemize}

For brevity, the constraint may be omitted and
interpreted as \xcd"true".
The syntax 
\xcd"C[T1,...,Tm](e1,...,en)" is sugar for
\xcd"C{X1==T1,...,Xm==Tm,x1==e1,...,xn==en}"
where \xcd"Xi" are the type properties and \xcd"xi" are the
value properties of \xcd"C".  
If either list of properties is empty, it may be omitted.

In this shortened syntax, a type \xcd"T" used may also be annotated
with
a \emph{use-site variance tag}, either \xcd"+" or \xcd"-":
if \xcd"X" is a type property, then
the syntax \xcd"C[+T]" is sugar \xcd"C{X<:T}" and
\xcd"C[-T]" is sugar \xcd"C{X:>T}"; of course,
\xcd"C[T]" is sugar \xcd"C{X==T}".

\section{Function types}

The \xcd"=>" type constructor instantiates a function type.

\begin{grammar}
FunctionType \: TypeParameters\opt \xcd"(" TypesOrFormals\opt \xcd")" \xcd"=>" Type  \\
TypeParameters \: \xcd"[" Type ( \xcd"," Type )\star \xcd"]" \\
TypesOrFormals \: TypeOrFormal ( \xcd"," TypeOrFormal )\star \\
TypeOrFormal   \: Type \\
               \| Formal \\
\end{grammar}

The function type
\xcdmath"[X$_1$, $\dots$, X$_k$](x$_1$: T$_1$ $\dots$, x$_n$: T$_n$) => S"
is the type of a function that takes type parameters
\xcdmath"X$_1$", \dots, \xcdmath"X$_k$"
and value parameters
\xcdmath"x$_1$", \dots, \xcdmath"x$_n$"
with types
\xcdmath"T$_1$", \dots, \xcdmath"T$_n$"
returns a value of type \xcd"S".  The value parameters may
optionally be named; these names are in scope in the subsequent
value parameter types and in the return type.
Like other types, function types may be constrained.

Closures are values of function type.

Method selectors return values of function type.

The function type
\xcdmath"[X$_1$, $\dots$, X$_k$](x$_1$: T$_1$ $\dots$, x$_n$: T$_n$) => S"
may be considered equivalent to the class type defined by:
\begin{xtenmath}
package x10.lang;
class Function$_{k,n}$ {
    def __apply__[X$_1$, $\dots$, X$_k$](x$_1$: T$_1$ $\dots$, x$_n$: T$_n$): S
}
\end{xtenmath}

\section{Type definitions}

Because
the syntax for constrained types can often be verbose,
\Xten{} supports {\em type definitions}
to allow types to be written more succinctly.
Type definitions have the following syntax:

\begin{grammar}
TypeDefinition \: 
                \xcd"type"~Identifier
                        ( \xcd"[" TypeParameters \xcd"]" )\opt
                        ( \xcd"(" Formals \xcd")" )\opt?
                        WhereClause\opt \xcd"=" Type \\
\end{grammar}

\noindent
A type definition can be thought of as a type-valued function.
Type definitions may be parameterized on both types and values.
%
The following examples are legal type definitions:
\begin{xten}
type StringSet = Set[String];
type MapToList[K,V] = Map[K,List[V]];
type int(x: int) = int{self==x};
type int(lo: int, hi: int) = int{lo <= self, self <= hi};
\end{xten}

Type definitions may appear as class members or in the body of a
method, constructor, or initializer.  Type definitions that are
members of a class are \xcd"static"; type properties can be used
for non-static type definitions.

Type definitions are applicative, not generative; that is, they
are define aliases for types and do not introduce new types.
Thus, the following code is legal:
\begin{xten}
type A = int;
type B = String;
type C = String;
a: A = 3;
b: B = new C("Hi");
c: C = b + ", Mom!";
\end{xten}
A type defined by a type definition
has the same constructors as its defining type.

\section{Path types}

Path types of the form \xcd"p.X" consist of a final access path,
\xcd"p", and a type
member (including type properties), \xcd"X".
The final access path \xcd"p" must be either \xcd"this", \xcd"self", a final
local variable, or a final field or value property whose target
is itself a final access path.  The path must type-check 
as a normal expression in the scope in which it appears.
The type member
\xcd"X" must be an instance member of the static type of the
path \xcd"p".

If an identifier \xcd"X" resolves to a type member or property
of an enclosing class or interface \xcd"T", then \xcd"X" is equivalent to
the path type \xcd"T.this.X".

\section{Constraints}\label{DepTypes}\index{dependent types}

Expressions used as constraints are restricted by the
constraint system in use to ensure that the constraints can
be solved at compile time.

If a type is unconstrained, it is considered to have the
constraint \xcd"true".
A type may also be constrained using lists of type arguments and
value arguments.  A base type \xcd"C" with type properties
\xcdmath"X$_1$", \dots,
\xcdmath"X$_n$" and
with the type argument list
\xcdmath"[T$_1$, $\dots$, T$_n$]" is equivalent to the type
\xcdmath"C{X$_1$==T$_1$, $\dots$, X$_n$==T$_n$}".
Similarly, a base type \xcd"C" with value properties
\xcdmath"x$_1$", \dots,
\xcdmath"x$_n$" and
with the value argument list
\xcdmath"(e$_1$, $\dots$, e$_n$)" is equivalent to the type
\xcdmath"C{x$_1$==e$_1$, $\dots$, x$_n$==e$_n$}".

\def\withmath#1{\relax\ifmmode#1\else{$#1$}\fi}
\def\LL#1{\withmath{\lbrack\!\lbrack #1\rbrack\!\rbrack}}

\begin{grammar}
Constraint \: TypeArguments     ValueArguments\opt DepClause\opt \\
           \| TypeArguments\opt ValueArguments     DepClause\opt \\
           \| TypeArguments\opt ValueArguments\opt DepClause     \\
           \\
TypeArguments    \:  \xcd"[" Type ( \xcd"," Type )\star \xcd"]" \\
ValueArguments   \:  \xcd"(" ArgumentList\opt \xcd")" \\
ArgumentList     \:  Expression ( \xcd"," Expression )\star \\
DepClause        \: \xcd"{" Expression \xcd"}" \\
\end{grammar}

\begin{staticrule}{Variable Occurrence}
In a deptype \xcd"T" = \xcd"C{c}", the only variables that may
occur in \xcd"c" are (a)
\xcd"self", (b) properties visible at \xcd"T", (c) final local variables, final
method parameters or final constructor parameters visible at \xcd"T", (d)
final fields visible at \xcd"T"'s lexical place in the source program.  
\end{staticrule}

\begin{staticrule}{Restrictions on \xcd"this"}
  The special variable \xcd"this" may be used in a depclause for a type \xcd"T"
  only if (a)~it occurs in a property declaration for a class, (b)~it
  occurs in an instance method, (c)~it occurs in an instance field, (d)~it
  occurs in an instance initializer.
\end{staticrule}

In particular it may not be used in types that occur in a static
context, or in the arguments, body or return type of a constructor or
in the extends or implements clauses of class and interface
definitions.  In these contexts the object that \xcd"this" would
correspond to has either not been formed or is not well defined.

\begin{staticrule}{Variable visibility}
  If a type \xcd"T" occurs in a field, method or constructor
  declaration, then all variables used in \xcd"T" must have at least the
  same visibility as the declaration.  The relation ``at least the same
  visibility as'' is given by the transitive closure of:

\begin{xten}
public > protected > package > private
\end{xten}

All inherited properties of a type \xcd"T" are visible in the property
list of \xcd"T", and the body of \xcd"T".

\end{staticrule}

In general local variables/parameters/properties/fields are visible at
\xcd"T" if they are defined before \xcd"T" in the program. This rule applies to
types in property lists as well as parameter lists (for methods and
constructors).  An exception is made for the return type of a method:
all the arguments to the method are considered to be visible, even
though they occur lexically after the return type (given the \Java{}
syntactic convention that the return type for a method precedes the
argument list for the method).

We permit variable declarations \xcd"v: T" where \xcd"T" is obtained
from a dependent type \xcd"C{c}" by replacing one or more occurrences
of \xcd"self" in \xcd"c" by \xcd"v". (If such a declaration \xcd"v: T"
is type-correct, it must be the case that the variable \xcd"v" is not
visible at the type \xcd"T". Hence we can always recover the
underlying deptype \xcd"C{c}" by replacing all occurrences of \xcd"v"
in the constraint of \xcd"T" by \xcd"self".)

For instance, \xcd"v: int{v > 0}" is shorthand for \xcd"v: int{self > 0}".

\begin{staticrule}{Constraint type}
  The type of a constraint \xcd"c" must be \xcd"boolean".  
\end{staticrule}

A variable occuring in the constraint \xcd"c" of a deptype, other than
\xcd"self" or a property of \xcd"self", is said to be a {\em
parameter} of \xcd"c".\label{DepType:Parameter} \index{parameter}

An instance \xcd"o" of \xcd"C" is said to be of type \xcd"C{c}"
(or: {\em belong to}
\xcd"C{c}") if the predicate \xcd"c" evaluates to \xcd"true" in the current lexical
environment, augmented with the binding \xcd"self" $\mapsto$ \xcd"o". We shall
use the function \LL{\mbox{\Xcd{C\{c\}}}} to denote the set of
objects that belong to \xcd"C{c}". 

\input{PlaceTypes}

\section{Built-in types}

The package \xcd"x10.lang" provides a number of built-in class and
interface declarations that can be used to construct types.

\subsection{The class \Xcd{Object}}\label{Object}\index{Object}
The class \xcd"x10.lang.Object" is a superclass of all other reference classes.
A variable of this type can hold a reference to an instance of any
scalar or array type.

\begin{xten}
package x10.lang;
public class Object {
  def toString(): String {...}
  def equals(o: Object): Boolean {...}
  def hashCode(): Int {...}
}
\end{xten}

The method \xcd"equals" and \xcd"hashCode" are useful in hashtables,
and are defined as in \java. The default implementation of \xcd"equals"
is stable equality, \S~\ref{StableEquality}. This method may be overridden
in a (value or reference) subclass.

\subsection{The class \Xcd{String}}
\Xten{} supports strings as in \java{}. A string object is immutable,
and has a concatenation operator (\xcd"+")  available on it.

XXX

\xcd"x10.lang.String" is a value class.


\subsection{Primitive value classes}

Several value types are provided that encapsulate
abstractions (such as fixed point and floating point arithmetic)
commonly implemented in hardware by modern computers.

These are defined by the following value class declarations:
\begin{xten}
package x10.lang;

public value class boolean { native def this(); }

public abstract value class number
    provides byte, short, int, char, long, float, double { }
public abstract value class integer extends number { }

public value class byte extends integer  { native def this(); }
public value class short extends integer { native def this(); }
public value class int extends integer   { native def this(); }
public value class char extends integer  { native def this(); }
public value class long extends integer  { native def this(); }

public value class float extends number  { native def this(); }
public value class double extends number { native def this(); }
\end{xten}

A program may contain literals
that stand for specific instances of these classes. The syntax
for literals is the same as for \java{} (\S~\ref{Literals}).

Binary and unary operations produce new instances of these
classes.

Values of one numeric class may be coerced into values of
another value class via the \xcd"to" operation.

\futureext{
\Xten{} may provide mechanisms in the future to permit the programmer
to specify how a specific value class is to be mapped to special
hardware operations (e.g., along the lines of
\cite{kava}). Similarly, mechanisms may be provided to permit the user
to specify new syntax for literals.
}

\input{FutureTypes}
\input{ArrayTypes}

\section{Class and interface declarations}\label{DepType:Class}

A class declaration 

\begin{grammar}
NormalClassDeclaration \: 
      ClassModifiers\opt \xcd"class" Identifier  \\
   && TypePropertyList\opt PropertyList\opt WhereClause\opt \\
   && Extends\opt Interfaces\opt ClassBody \\
\end{grammar}

\noindent and an interface declaration

\begin{grammar}
NormalInterfaceDeclaration \: 
      InterfaceModifiers\opt \xcd"interface" Identifier  \\
   && TypePropertyList\opt PropertyList\opt WhereClause\opt \\
   && ExtendsInterfaces\opt InterfaceBody \\
\end{grammar}

\noindent
specifies a single base type that may be refined with constraints
to define several dependent types.

\section{Type invariants}\label{DepType:TypeInvariant}\index{Type invariant}

A class or interface declaration may specify a
\grammarrule{WhereClause}, an invariant on all
instances of that type.
All the properties in the list, together with inherited properties,
may appear in the class invariant. A where clause \xcd"c" with
type property list \xcd"X1, ...., Xk"
and value property list \xcd"x1: T1, ...., xn: Tn"
for a class \xcd"C" is said to be consistent if each of the \xcd"Ti" are
consistent and the constraint
\begin{xtenmath}
$\exists$X$_1$, $\dots$, X$_k$, x$_1$: T$_1$, $\dots$, x$_n$: T$_n$, self: C. c
\end{xtenmath}
\noindent is valid (always true).

With every defined class or interface \xcd"T" we associate a {\em type
invariant} $\mathit{inv}($\xcd"T"$)$ as follows. The type invariant associated with
\xcd"x10.lang.Object" is the proposition

\begin{xten}
self.location: place
\end{xten}

The type invariant associated with any interface \xcd"I" that extends
interfaces \xcd"I1,..., Ik" and defines properties \xcd"x1: P1, ..., xn: Pn" and
specifies a where clause \xcd"c" is given by:

\begin{xten}
ti(I1) && ... && tk(Ik) && self.x1: P1 && ... && self.xn: Pn && c  
\end{xten}

Similarly the type invariant associated with any class \xcd"C" that
implements interfaces \xcd"I1,..., Ik", extends class \xcd"D" and defines
properties \xcd"x1: P1,..., xn: Pn" and specifies a where clause \xcd"c" is
given by:
\begin{xten}
i(D) && self.x1: P1 && ... && self.xn: Pn && c  
\end{xten}

It is required that the
type invariant associated with a class entail the type invariants of
each interface that it implements.

It is guaranteed that for any variable \xcd"v" of
type \xcd'T{c}' (where \xcd"T" is an interface name or a class name) the only
objects \xcd"o" that may be stored in \xcd"v" are such that \xcd"o" satisfies
$\mathit{inv}(\mbox{\xcd"T"}[\mbox{\xcd"o"}/\mbox{\xcd"this"}])
\wedge \mbox{\xcd"c"}[\mbox{\xcd"o"}/\mbox{\xcd"self"}]$.

%% XXX check parens

\section{Consistency of deptypes}\label{DepType:Consistency}\index{deptype,consistency}

A dependent type \xcd"C{c}" may contain zero or more parameters. We require
that a type never be empty---so that it is possible for a variable of
the type to contain a value. This is accomplished by requiring that
the constraint \xcd"c" must be satisfiable {\em regardless} of the value assumed
by parameters to the contraint (if any). Formally, consider a type
\xcd"T" = \xcd"C{c}", with the variables \xcd"f1: F1, ..., fk: Fk"
free in \xcd"c".  Let 
\xcd"S={f1: F1, .., fk: Fk, fk+1: Fk+1, ... fn: Fn}" be the smallest set of
declarations containing \xcd"f1: F1, ..., fk: Fk" and closed under the rule:
\xcd"f: F" in \xcd"S" if a reference to variable \xcd"f" (which
is declared as \xcd"f: F") occurs in a type in \xcd"S".

(NOTE: The syntax rules for the language ensure that \xcd"S" is always
finite. The type for a variable \xcd"v" cannot reference a variable whose
type depends on \xcd"v".)

We say that \xcd"T" = \xcd"C{c}" is {\em parametrically consistent} (in brief:
{\em consistent}) if

\begin{itemize}
  \item Each type \xcd"F1, ..., Fn" is (recursively) parametrically consistent, and
\item It can be established that \xcd"forall f1: F1, .., fn: Fn.  exists self: C . c && i(C)".
\end{itemize}
\noindent where \xcd"i(C)" is the invariant associated with the type \xcd"C"
(\S~\ref{DepType:TypeInvariant}).  Note by definition of \xcd"S" the formula on the
above has no free variables.

\begin{staticrule*}
For a declaration \xcd"T v" to be type-correct, \xcd"T" must be parametrically
consistent. The compiler issues an error if it cannot determine
the type is parametrically consistent.
\end{staticrule*}

\begin{example}

A class that represents a line has two distinct points:
\begin{xten}
class Array(rank: int, 
            region: region{rank==this.rank}) {...}  
\end{xten}
\end{example}

One can use deptypes to define other closed geometric figures as well.

\begin{example}
Here is an example:
\begin{xten}
class Point(x: int, y: int) {...}
class Line(start: Point, 
          end: Point{self != this.start}) 
{...}      
\end{xten}
\end{example}


To see that the declaration \xcd"end: Point{self != start}" is
parametrically consistent, note that the following formula is valid:
\begin{xten}
forall this: Line. 
  exists self: Point. self != this.start  
\end{xten}
\noindent since the set of all \xcd"Points" has more than one element.

\begin{example}
A triangle has three lines sharing three vertices.
\begin{xten}
class Triangle 
 (a: Line, 
  b: Line{a.end == b.start}, 
  c: Line{b.end == c.start && c.end == a.start}) 
 { ... }
\end{xten}
\end{example}


Given \xcd"a: Line", the type \xcd"b: Line{a.end == b.start}" is consistent,
and
given the two, the type \xcd"c: Line{b.end == c.start, c.end == a.start}"
is consistent.

%%Similarly:
%%
%%   // A class with properties a, b,c,x satisfying the 
%%   // given constraints.
%%   class SolvableQuad(a: int, b: int, 
%%                      c: int{b*b - 4*a*c >= 0},
%%                      x: int{a*x*x + b*x + c==0}) { 
%%     ...
%%   }
%%
%%  // A class with properties r, x, and y satisfying
%%  // the conditions for (x,y) to lie on a circle with center (0,0)
%%  // and radius r.
%%   class Circle (r: int{r > 0},
%%                 x: int{r*r - x*x >= 0},
%%                 y: int{y*y == r*r -x*x}) { 
%%   ...
%%   }

\section{Subtyping and type equivalence}\label{DepType:Equivalence}\label{deptype,equivalence}

Subtyping is relation between types.  It is the
reflexive, transitive 
closure of the {\em direct subtyping} relation, defined as
follows.

\subsection{Class types}

\subsection{Interface types}

\subsection{Function types}



A class type \xcd"C" is a direct subtype of another class type \xcd"D" if
\xcd"C" is declared to extend
One class type is a direct subtype of another if 

One base class type is a subtype of another if it exp

Two dependent types \xcd"C{c}" and \xcd"C{d}" are said to be {\em equivalent} if 
\xcd"c" is true whenever \xcd"d" is, and vice versa. Thus, 
$\LL{\mbox{\Xcd{C\{c\}}}} = \LL{\mbox{\Xcd{C\{d\}}}}$.

Note that two deptypes that are syntactically different may be
equivalent. For instance, \xcd"int{self >= 0}" and
\xcd"int{self == 0 || self > 0}" are equivalent though they are syntactically
distinct. The \Java{} type system is essentially a nominal system---two
types are the same if and only if they have the same name. The \Xten{}
type system extends the nominal type system of \Java{} to permit
constraint-based equivalence.

A dependent type \xcd"C{c}" is a subtype of a type \xcd"C{d}" if
\xcd"c" implies \xcd"d".  In such a case we have
$\LL{\mbox{\Xcd{C\{c\}}}}$ is a
subset of $\LL{\mbox{\Xcd{C\{d\}}}}$. All dependent types defined on \xcd"C" refine
\xcd"C" since \xcd"C" is equivalent to \xcd"C{true}".


A path type \xcd"p.X" is a subtype of a type \xcd"T" if
\xcd"p" has type \xcd"C{c}" (where \xcd"C" has a type property
\xcd"X") and \xcd"c" implies that \xcd"self.X" is a subtype of \xcd"T".


\section{Constraint system}

\Xten{} provides a simple constraint system,  
permitting conjunctions of equalities between variables and
constants, and existential quantification over typed variables.

The constraint system can be extended via compiler plugins.

Subsquent implementations are intended to support boolean algebra,
arithmetic, relational algebra etc to permit types over regions and
distributions. We envision this as a major step towards removing most
(if not all) dynamic array bounds and places check from \Xten{}.

%\subsection{Syntactic abbreviations}\label{DepType:SyntaxAbbrev}




\input{Coercions}

