%III. Applied constrained calculii. (3 pages)
%
%For each example below, formal static and dynamic semantics rules for
%new constructs extension over the core CFJ. Subject-reduction and
%type-soundness theorems. Proofs to be found in fuller version of
%paper.
%
%(a) arrays, region, distributions -- type safe implies no arrayoutofbounds
%exceptions, only ClassCastExceptions (when dynamic checks fail).
%
%Use Satish's conditional constraints example.
%-- emphasize what is new over DML. 
%
%(b) places, concurrency -- place types.
%
%(c) ownership types, alias control.
%
\def\clocked{{\tt clocked}}
The following section presents examples using several different
constraint systems.

In the following we will use the shorthand $\tt C(\bar{t}:c)$ for the
type $\tt C(:\bar{f}=\bar{t},c)$ where the declaration of the class
{\tt C} is $\tt \class\ C(\bar{\tt T}\ \bar{\tt f}:c)\ldots$  Also,
we abbreviate $\tt C(\bar{t}:\true)$ as $\tt C(\bar{t})$.
\eat{
Finally, we
will also have need to use the shorthand
${\tt C}_1(\bar{t}_1:{\tt c}_1)\& \ldots {\tt C}_k(\bar{\tt t}_k:{\tt c}_k)$
for the type
${\tt C}_1(:\bar{\tt f}_1=\bar{\tt t}_1, \ldots,
            \bar{\tt f}_k=\bar{\tt t}_k,{\tt c}_1,\ldots,{\tt c}_k)$ 
provided that the ${\tt C}_i$ form a subtype chain
and the declared fields of ${\tt C}_i$ are ${\tt f}_i$.

Constraints naturally allow for partial specification
(e.g., inequalities) or incomplete specification (no constraint on a
variable) with the same simple syntax. In the example below,
the type of {\tt a} does not place any constraint on the second
dimension of {\tt a}, but this dimension can be used in other
types (e.g., the return type).
{\footnotesize
\begin{verbatim}
  class Matrix(int m, int n) {
    Matrix(m,a.n) mul(Matrix(:m=this.n) a) {...}
    ...
  }
\end{verbatim}}

Constraints also naturally permit the expression of existential types:
{\footnotesize
\begin{verbatim}
  class List(int length) { 
    List(:length <= this.length) filter(Comparator k) {...} 
    ...
  }
\end{verbatim}}
\noindent
Here, the length of the list returned by the {\tt filter} method is 
unknown, but is bound by the length of the original list.
}

\subsection{AVL trees and red--black trees}

AVL trees and red-black trees can be modeled so that the
data structure invariant is enforced statically.

{\footnotesize
\begin{verbatim}
class AVLTree(int(:self >= 0) height) {...}
class Leaf(Object key) extends AVLTree(0) {...}
class Node(Object key, AVLTree l, AVLTree r
         : int d=l.height-r.height; -1 <= d, d <= 1) 
    extends AVLTree(max(l.height,r.height)+1) {...}
\end{verbatim}}

Red--black trees may be modeled similarly. Such trees have the
invariant that (a) all leaves are black, (b) each non-leaf node has
the same number of black nodes on every path to a leaf (the black
height), (c) the immediate children of every red node are black.
{\footnotesize
\begin{verbatim}
class RBTree(int blackHeight) {...}
class Leaf extends RBTree(0) { int value; ... }
class Node(boolean isBlack, 
           RBTree(:this.isBlack || isBlack) l, 
           RBTree(:this.isBlack || isBlack,
                 blackHeight=l.blackHeight) r)
    extends RBTree(l.blackHeight+1) { int value; ... }
\end{verbatim}}

\eat{
\subsection{Nullable types}

A constraint system that supports disequalities can be used to
enforce a non-null invariant on reference types.
A non-null type {\tt C} can be written simply as {\tt C(:self != null)}.
}

\subsection{Array bounds}

Xi and Pfenning proposed using dependent types for eliminating
array bounds checks~\cite{xi98array}.
In CFJ, an array of type {\tt T[]} indexed by (signed) integers
can be modeled as a class with the following
signature:\footnote{For this example, we assume generics and
interfaces are supported.}
{\footnotesize
\begin{verbatim}
interface Array<T>(int(:self >= 0) length) {
  T get(int(:0 <= self, self < this.length) i);
  void set(int(:0 <= self, self < this.length) i, T v);
}
\end{verbatim}}

Bounds can be checked using a constraint system based on
Presburger arithmetic~\cite{omega}.  Constraint terms include
integer constrants, scalar multiplication, and addition.
Constraints include inequalities:

\begin{tabular}{rcl}
{\tt c} &::=& {\tt t <= t} \bnf \dots \\
{\tt t} &::=& {\tt n} \bnf {\tt n*t} \bnf {\tt t+t} \bnf \dots
\end{tabular}

\eat{
Some code that iterates over an array (sugaring {\tt get} and {\tt set}):
{\footnotesize
\begin{verbatim}
double dot(double[] x, double[] y
         : x.length = y.length) {
  double r = 0.; 
  for (int(:self >= 0, self < x.length)
       i = 0; i < x.length; i++) {
    r += x[i] * y[i];
  }
  return r;
}
\end{verbatim}
}
}

\eat{
Another one:
{\footnotesize
\begin{verbatim}
double[](:length = x.length) saxpy(double a, double[] x, double[] y : x.length = y.length) {
    double[](:length = x.length) result = new double[x.length];
    for (int(:self >= 0, self < x.length) i = 0; i < x.length; i++) {
        result[i] = a * x[i] + y[i];
    }
    return result;
}
\end{verbatim}
}
}

\subsection{Region-based arrays}

\Xten{} takes another approach to ensuring array bounds violations
do no occur.
Following ZPL~\cite{ZPL}, arrays in \Xten{}
are defined over sets of $n$-dimensional {\em index points}
called {\em regions}~\cite{gps06-arrays}.
For instance, the region {\tt [0:200,1:100]} specifies a
collection of two-dimensional points {\tt (i,j)} with {\tt i}
ranging from {\tt 0} to {\tt 200} and {\tt j} ranging from
{\tt 1} to {\tt 100}.

Constrained types ensure array bounds
violations do not occur:
an array access type-checks if the index point can be statically
determined to be in the region over which the array is defined.

Region constraints are subset constraints and have the following syntax:

\begin{tabular}{rrcl}
  (Constraint)   &{\tt c} &::=& ${\tt r} \subseteq {\tt r}$ \bnf \dots \\
  (Region) &{\tt r} &::=& {\tt t} \bnf [${\tt b}_1$:${\tt d}_1$,\ldots,${\tt b}_k$:${\tt d}_k$] \bnf  \\
           &        &   & {\tt r|r} \bnf {\tt r{\&}r} \bnf {\tt r-r} \bnf {\tt r+p} \\
  (Point)  &{\tt p} &::=& ${\tt t} \bnf [{\tt b}_1,\ldots,{\tt b}_k]$ \\
(Integer)&{\tt b},{\tt d} &::=& ${\tt t} \bnf {\tt n}$ \\
\end{tabular}

\noindent
Regions used in constraints are either constraint terms {\tt t},
region constants, unions ({\tt |}), intersections ({\tt \&}),
or differences ({\tt -}), or regions where each point is
offset by another point {\tt p}.

\begin{figure}
\footnotesize
\input{sor}
\caption{Successive over-relaxation with regions}
\label{fig:sor}
\end{figure}

For example, the code in Figure~\ref{fig:sor} performs a successive
over-relaxation~\cite{sor} of an $n \times n$ matrix {\tt G}.
The type-checker establishes that the {\tt region}
property of the point {\tt ij} (line 17) is
{\tt inner \& [i,i:d1min,d1max]}, and that this
region is a subset of {\tt outer}, the region of the array {\tt G}.

\eat{
\subsection{Self types and binary methods}

Self types~\cite{bsg95,bfp-ecoop97-match} can be implemented
using a {\tt klass} property on objects.  The {\tt klass}
property represents the run-time class of the object.
Self types can be used to solve the binary method problem \cite{bruce-binary}.

In the example below, the {\tt Set} interface has a {\tt union} method
whose argument must be of the same class as {\tt this}.
\noindent This enables the {\tt IntSet} class's {\tt union}
method to access the {\tt bits} field of its argument {\tt s}.
{\footnotesize
\begin{verbatim}
  interface Set(:Class klass) {
    Set(this.klass) union(Set(this.klass) s);
  }
  class IntSet(:Class klass) implements Set(klass) {
    long bits;

    IntSet(IntSet.class)() { property(IntSet.class); }

    IntSet(IntSet.class)(int(:0 <= self, self <= 63) i) {
      property(IntSet.class);
      bits = 1 << i; }

    Set(this.klass) union(Set(this.klass) s) {
      IntSet(this.klass) r = new IntSet(this.klass);
      r.bits = this.bits | s.bits;
      return r; }
  }
\end{verbatim}}
\noindent
The key to ensuring that this code type-checks is the
\rn{T-constr}
rule.
With a constraint system ${\cal C}_{\mathsf{klass}}$ aware of
the {\tt klass} property, the rule 
\rn{T-var} is used to subsume an expression of type
${\tt Set(this.class)}$ to type ${\tt IntSet(this.class)}$
when {\tt this} is known to be an {\tt IntSet}:
{\footnotesize
\[
\from{\begin{array}{c}
{\tt IntSet}~{\tt this}, {\tt Set}({\tt this.klass})~{\tt s}
        \vdash {\tt Set}({\tt this.klass})~{\tt s} \\
{\tt IntSet}~{\tt this}, {\tt Set}({\tt this.klass})~{\tt s}
        \vdash_{{\cal C}_{\mathsf{klass}}} {\tt IntSet}({\tt this.klass})~{\tt s} \\
\end{array}}
\infer{
{\tt IntSet}~{\tt this}, {\tt Set}({\tt this.klass})~{\tt s}
        \vdash {\tt IntSet}({\tt this.klass})~{\tt s}}
\]}
}


\eat{
\subsection{Binary search}

An informal study by Jon Bentley~\cite{programming-pearls}
found that x\% of professional programmers attending in a course
could not correctly implement binary search.

Dependent types can help here by adding the invariants to the
index types.

\subsection{Quicksort}

{\footnotesize
\begin{verbatim}
int(:left <= self & self <= right)
partition(T[] array, int left, int right, int pivotIndex : left <= pivotIndex & pivotIndex <= right) {
     T pivotValue = array[pivotIndex];

     // Move pivot to end
     swap(array, pivotIndex, right);

     int(:left <= self & self <= right) storeIndex;
     storeIndex = left;
     for (int(:left <= self & self <= right-1) i = left; i < right; i++) {
         if (array[i] <= pivotValue) {
             swap(array, storeIndex, i);
             storeIndex++;
         }
     }

     // Move pivot to its final place
     swap(array, right, storeIndex)
     return storeIndex;
}

void swap(T[] array,
          int(:0 <= self & self < array.length i,
          int(:0 <= self & self < array.length j) {
    T tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
}

void quicksort(T[] array, int left, int right : left <= right) {
    if (left < right) {
         // select a pivot index
         int(:left <= self & self <= right) pivotIndex = (left + right) / 2;
         pivotNewIndex = partition(array, left, right, pivotIndex)
         quicksort(array, left, pivotNewIndex-1)
         quicksort(array, pivotNewIndex+1, right)
    }
}
\end{verbatim}
}
}


\subsection{Place types}

This example is due to Satish Chandra. We wish to specify a balanced
distributed tree with the property that its right child is always at
the same place as its parent, and once the left child is at the same
place then the entire subtree is at that place:

{\footnotesize
\begin{verbatim}
class Tree(boolean localLeft,
  Tree(:this.localLeft => (loc=here,self.localLeft)) left, 
  Tree(:loc=here) right) extends Object {...}
\end{verbatim}}

\subsection{Clocked types}

Clocks are barriers that are adapted to a context where activities may be
dynamically created, and are designed so that all clock operations are
determinate.

For each arity $n$, we introduce a {\em Gentzen predicate} ${\tt
clocked(\bar{t})}$. A $k$-ary Gentzen predicate $a$ satisfies the
property that $a(t_1,\ldots, t_k) \vdash a(s_1,\ldots,s_n)$ iff $k=n$
and $t_i=s_i$ for $i\leq k$.

Such a {\tt clocked} atom is added to the context by an {\tt clocked async}:
$$
\from{\Gamma, {\tt clocked(\bar{\tt v})} \vdash {\tt T}\ {\tt e}}
\infer{\Gamma \vdash {\tt T}\ {\tt async}\ {\tt clocked}(\bar{\tt v}) {\tt e}}
$$

A programmer can require that a method may be invoked only if the
invoking activity is registered on the clocks $\bar{\tt k}$ by adding
a {\tt clocked} clause. The rule for method elaboration and method invocation then change:
$$
\begin{array}{l}
\from{ \bar{\tt T}\ \bar{\tt x}, {\tt C}\ \this, {\tt c},\clocked(\bar{\tt k}) \vdash {\tt S}\ {\tt e}, {\tt S} \subtype {\tt T} }   
\infer{\tt T\ m(\bar{\tt T}\,\bar{\tt x} : c) \clocked(\bar{\tt k})\{\return\ e;\}\ \mbox{OK in}\ C} 
\\ \quad\\ 
\rname{T-Invk}%
\from{\begin{array}{l}
\Gamma \vdash {\tt T}_{0:n} \ {\tt e}_{0:n}  \\
\mtype({\tt T}_0,{\tt m},{\tt z}_0)= \tt {\tt Z}_{1:n}\ {\tt z}_{1:n}:c,clocked(\bar{\tt k}) \rightarrow {\tt S} \\
\Gamma, {\tt T}_{0:n}\ {\tt z}_{0:n} \vdash {\tt T}_{1:n} \subtype {\tt Z}_{1:n}\\
\sigma(\Gamma, {\tt T}_{0:n}\ {\tt z}_{0:n}) \vdash_{\cal C} {\tt c} \ \ \ 
\mbox {(${\tt z}_{0:n}$ fresh)} \\
\Gamma \vdash \clocked(\bar{\tt k})\\
\end{array}}
\infer{\Gamma \vdash ({\tt T}_{0:n}\ {\tt z}_{0:n}; S)\ {\tt e}_0.{\tt m({\tt e}_{1:n})}}
\end{array}
$$

\eat{
\subsection{Capabilities}

Capablities (from Radha and Vijay's paper on neighborhoods)
}

\subsection{Activity-local objects}

Parallelism in \Xten{} is supported through lightweight asynchronous {\em
activities}, created by {\tt async} statements.
It is often useful to restrict objects so that they are {\em local} to a
particular activity.
A local object may be accessed only by
the activity that created it or by an ancestor of that activity.
% it may be written only by the activity that created
% it or by a descendant of that activity.
Local objects are declared and created by qualifying their type
with {\tt local}:
{\footnotesize
\begin{verbatim}
  local C o = new local C();
\end{verbatim}}
For example

To encode local objects in CFJ, we add an {\tt activity} property to objects:
{\footnotesize
\begin{verbatim}
  class Object(Activity activity) { ... }
\end{verbatim}}
\noindent
where {\tt Activity} has a possibly null {\tt parent} property:
{\footnotesize
\begin{verbatim}
  class Activity(Activity parent) { ... }
\end{verbatim}}
\noindent

To track the current activity ({\tt z}), we augment typing judgments
as follows:
\[
  {\tt z};~\Gamma \vdash {\tt T}\ {\tt e}
\]
\noindent where ${\tt Activity}({{\tt z}'})~{\tt z} \in \Gamma$.
When the current activity is {\tt z},
we encode the type {\tt local C} as ${\tt C}({\tt z})$.

Spawning a new activity with an {\tt async} statement
introduces a fresh activity ${\tt z}'$:
\[
\from{
{\tt z}';~\Gamma,~{\tt Activity}({\tt z})~{\tt z'} \vdash {\tt T}\ {\tt e}\ \ \ 
\mbox{(${\tt z}'$ fresh)}
}
\infer{
{\tt z};~\Gamma \vdash {\tt T}\ ({\tt async}\ {\tt e})
}
\]
The rule \rn{T-Field} is strengthened to require that reads 
only be performed on objects whose {\tt activity} property is a
descendant of the current activity.
%\rname{T-Field-Local}%
\[
\from{
\begin{array}{ll}
{\tt z};~\Gamma \vdash {\tt T}_0\ {\tt e} \\
\mathit{fields}({\tt T}_0,{\tt z}_0)= \bar{\tt U}\ \bar{\tt f}_i &
\mbox{(${\tt z}_0$ fresh)} \\
{\tt z};~\Gamma \vdash {\tt T}_0 \subtype {\tt C}(:{\tt activity} = {\tt z}') &
\Gamma \vdash {\tt z}~\mathsf{spawns}~{\tt z}'
\end{array}
}
\infer{{\tt z};~\Gamma \vdash ({\tt T}_0\ {\tt z}_0; {\tt z}_0.{\tt f}_i=\self;{\tt U}_i)\ {\tt e.f}_i}
\]

%\Gamma \vdash {\tt z}_0.{\tt activity} = {\tt z}' &

\noindent
where the $\mathsf{spawns}$ relation is defined as follows:
\[
\Gamma \vdash {\tt z}~\mathsf{spawns}~{\tt z}
\]
\[
\from{
\Gamma \vdash {\tt z_1}~\mathsf{spawns}~{\tt z_2} \ \ \ 
\Gamma \vdash {\tt z_2}~\mathsf{spawns}~{\tt z_3}}
\infer{\Gamma \vdash {\tt z_1}~\mathsf{spawns}~{\tt z_3}}
\]
\[
\from{\Gamma \vdash {\tt z_2}.{\tt parent} = {\tt z_1}}
\infer{\Gamma \vdash {\tt z_1}~\mathsf{spawns}~{\tt z_2}}
\]

\eat{
local objects owned by activity that created it.

locals cannot be read by contained asyncs.

locals can be written by contained asyncs.

locals created by an activity are inherited by the parent when
the activity terminates.

{\footnotesize
\begin{verbatim}
C(:thread = current) x = ...;
finish foreach (...) {
  C(:thread = current) y = x; // no!
  x = y;
}
\end{verbatim}}

// can read if thread prop is current, or an ancestor of current
// can write if thread prop is current or a child of current

e : C(:thread = x)
current owns x
fields(...) = Ti fi
-----------------------
e.fi : Ti

extensions:

1. add thread to context
2. strengthen T-field rule
}

\eat{
\subsection{Ownership types}

\begin{figure}
\input{LO}
\caption{Ownership types}
\label{fig:ownership}
\end{figure}

Figure~\ref{fig:ownership} shows
 a fragment of {\tt List} class, 
demonstrating how ownership
types~\cite{ownership-types} can be encoded in CFJ.
Each {\tt Owned} object has an {\tt owner} property.
Objects also have properties used as owner parameters.
The {\tt List} class has a property {\tt valOwner} that is
instantiated with the owner of the values in the list, stored
in the {\tt head} field of each element.
The {\tt tail} of the list is owned by the list object itself.

To enforce the ``owners as dominators'' property, the owner of
the values {\tt valOwner} must be contained within the owner
of the list itself; that is, {\tt valOwner} must be {\tt owner}
or {\tt valOwner}'s owner must be contained in {\tt owner}.
This is captured by the constraint {\tt owner owns valOwner}.

The {\tt expose} method incorrectly leaks the
list's {\tt tail} pointer.
The constraint system catches this XXX.
Variables must be {\tt T(:owner=o, this owns o) x;}?

Additional rules need to be imposed to enforce the ``owners as
dominators'' property.

If a class subclasses {\tt Owned}, its owner parameters must
be transitivly owned themselves by the {\tt owner} property.

Second, permit this to be visible only within the current
object.

{\footnotesize
\begin{verbatim}
e0 : T0
_e : _S
mtype(T0, m) = (_x:_T) -> T'
_S <: _T[this(e0)/this]
--------------
e0.m(_e) : T'[this(e0)/this]
\end{verbatim}}

Need to prevent fields owned by {\tt this} escaping.
When type-checking code in class {\tt C}, need to add {\tt C}
to assumptions.

When checking calls and field accesses, only allow substitution
for {\tt this} when {\tt this} is the receiver.

\[
\rname{T-Field-Owner}%
\from{
\begin{array}{lll}
\Gamma \vdash {\tt T}_0\ {\tt e} &
\mathit{fields}({\tt T}_0,{\tt z}_0)= \bar{\tt U}\ \bar{\tt f}_i &
\mbox{(${\tt z}_0$ fresh)} \\
\Gamma \vdash {\tt T}_0 \subtype {\tt C}(: {\tt owner} = {\tt this}) &
XXX
\end{array}
}
\infer{\Gamma \vdash ({\tt T}_0\ {\tt z}_0; {\tt z}_0.{\tt f}_i=\self;{\tt U}_i)\ {\tt e.f}_i}
\]
}

\eat{
\subsection{Discussion}

\paragraph{Control-flow.}
Tricky to encode.  Need something like {\tt pc} label~\cite{jif}.

\paragraph{Type state.}
Type state depends on the mutable state of the 
objects.  Cannot do in this framework.

Dependent types are of use in annotations~\cite{ns07-x10anno}.
}
