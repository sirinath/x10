This section describes constrained types in \Xten{}.

\subsection{Properties}

A property is a \xcd{public} \xcd{final} instance field of the
class that cannot be overridden by subclassing. Like any other field,
a property is typed, and its type need not necessarily be
primitive. Thus, properties capture the immutable public state of an
object, initialized when the object is created, that can be
classified by constrained types. Syntactically, properties are
specified in a parameter list right after the name of the class in a
class definition. The class body may contain specifications of other
fields; these fields are considered mutable.

Properties may be of arbitrary type. For instance, the class
\tcd{region} has an \tcd{int} property called \tcd{rank}. In turn, the
class \tcd{dist} has a \tcd{region} property, called \tcd{region}, and
also an \tcd{int} property \tcd{rank}.  The invariant for \tcd{dist}
ensures that \tcd{rank == region.rank}. Similarly, an array has
properties \tcd{dist}, \tcd{region}, and \tcd{rank}
and appropriate constraints ensuring that the statically available
information about them is consistent.\footnote{All constraint
languages used in constrained types permit object references, field
selection and equality. Such constraint systems have been studied
extensively under the name of ``feature structures''
\cite{feature-structures}.}
%
In this way, rich  
constraints on the immutable portion of
the object reference graph, rooted at the current object and utilizing
objects at user-defined types, may be specified.

\subsection{Constraints}
A constrained type is of the form \xcd{C(:e)}, consisting of a
{\em base class} \xcd{C} and a {\em condition} \xcd{e}, a
boolean expression on the properties of the base class and the
\xcd{final} variables in scope at the type.  Constraints specify
(possibly) partial information about the variables of interest.
The type \xcd{C(:e)} represents the set of all
instances of \xcd{C} whose immutable state satisfies the
condition \xcd{e}.

Constraints may use the special variable \xcd{self} to stand for
the object whose type is being defined. Thus, \xcd{int(:self >= 0)} is
the set of natural numbers, and \xcd{point(:x*x + y*y <= 1.0)}
represents the interior of a circle (for a class \xcd{point} with two
\xcd{float} properties \xcd{x} and \xcd{y}). The type \xcd{C(:self !=
null)} represents all instances of \xcd{C}. When there is no
ambiguity, a property reference \xcd{self.x} may be abbreviated
to \xcd{x}. The type \xcd{int(:self==v)} represents a ``singleton'' type, an
\xcd{int} is of this type only if it has the same value as \xcd{v}.

To be clear, \xcd{self} is not the same as \xcd{this}.  In the
\xcd{List} example of Figure~\ref{fig:list-example}, the
\xcd{filter} method (line 24) returns
a list with type
\xcd{List(:self.n <= this.n)}; the term
\xcd{self.n} is the length of
the returned \xcd{List}; the term \xcd{this.n} is the length of the 
receiver of the call to \xcd{filter}.

Constraints are specified in terms of an underlying
constraint system~\cite{CCCC}---a pre-defined logical vocabulary of
functions and predicates with algorithms for consistency and
entailment.  The \Xten{} compiler permits different constraint
systems to be installed using compiler
plugins~\cite{bracha04-pluggable}.
%
Constraint system plugins define a language of constraints by
symbolically interpreting
the boolean expression specifying a type's condition; plugins
may report an error if the condition cannot be interpreted.

In principle, types may be constrained by any boolean
expression over the properties.  For practical reasons,
restrictions need to be imposed to ensure constraint checking is
decidable.

The condition of a constrained type must be a pure
function only of the properties of the base class.
Because properties are
\xcd{final} instance fields of the object,
this requirement
ensures that whether or not an object belongs to a constrained type does
not depend on the {\em mutable} state of the object.
That is, the status of the
predicate ``this object belongs to this type'' does not
change over the lifetime of the object.  Second, by insisting that each
property be a {\em field} of the object, the question of
whether an object is of a given type can be
determined merely by examining the state of the object and evaluating
a boolean expression. Of course, an implementation is free to not {\em
explicitly} allocate memory in the object for such fields. For
instance, it may use some scheme of tagged pointers to implicitly
encode the values of these fields.

Further, by requiring that the programmer distinguish certain
\xcd{
final} fields of a class as properties, we ensure that the programmer
consciously controls {\em which} \xcd{final} fields should be available for
constructing constrained types. A field that is ``accidentally''
\xcd{
final} may not be used in the construction of a constrained type. It must be
declared as a property.


\subsection{Subtyping}
Constrained types come equipped with a subtype relation that
combines the nominal subtyping relation of classes and interfaces with
the logical entailment relation of the constraint system. Namely, a
constraint \xcd{C(:c)} is a subtype of \xcd{D(:d)} if \xcd{C} is a
subtype of \xcd{D} and every value in \xcd{C} that satisfies \xcd{c}
also satisfies \xcd{d}.

% Thus, the set of constrained types on a base
% type \xcd{C} inherits a lattice structure from the underlying
% constraint system. The maximal element is \xcd{C(:true)}, which is
% just \xcd{C}, and the minimal element is the unsatisfiable constraint.

% Constrained types come equipped with a {\em subtyping
% structure}: type $t_1$ is a subtype of $t_2$ if the denotation of
% $t_1$ is a subset of $t_2$.
This definition 
% satisfies Liskov's Substitution Principle~\cite{liskov-behaviors}) and
implies that
\xcd{C(:e1)} is a subtype of \xcd{C(:e2)} if \xcd{e1} implies \xcd{e2}.
In particular, for all conditions \xcd{e},
\xcd{C(:e)} is a subtype of \xcd{C}.
\xcd{C(:e)} is empty exactly
when \xcd{e} conjoined with \xcd{C}'s class invariant is inconsistent.

Two constrained types \xcd{C1(:e1)} and \xcd{C2(:e2)} are considered
equivalent if \xcd{C1} and \xcd{C2} are the same base type and
\xcd{
e1} and \xcd{e2} are equivalent when considered as logical
expressions. Thus, \xcd{C(:x*x==4)} and \xcd{C(:x==2 || x==-2)} are
equivalent types.

\subsection{Final variables}

The use of \xcd{final} local variables, formal parameters, and
fields in constrained
types has proven to be particularly valuable in practice. The same
variable that is being used in computation can also be used to specify
types. There is no need to introduce separate, universally and
existentially quantified ``index'' variables as in, for
instance, \DML{}~\cite{xi99dependent}.
%
During type-checking, \xcd{final} variables are turned into symbolic
variables---some fixed but unknown value---of the same type.
Computation is performed in a constraint-based fashion on such
variables.

\subsection{Method and constructor preconditions}

Methods and constructors may specify preconditions on their parameters
as where clauses.  For an invocation of a method (or constructor) to
be type-correct, the associated where clause must be statically known
to be satisfied. Note that the where clause may contain constraints on
the properties of \xcd{this}. Thus the where clause may be used to
specify that a method is {\em conditionally} available on some objects
of the class and not others.

The
return type of a method may also contain expressions involving the
arguments to the method.  Any argument used in this way must
be declared \xcd{final},
ensuring it is not mutated by the method body.  For instance,
the following is a valid method declaration:
\begin{displayxten}
List(arg.length-1)
  tail(final List arg: arg.length > 0) {
     ...
}
\end{displayxten}
\noindent
It says that
\xcd{tail} must be passed a non-empty list, and it returns a list
whose length is one less than its argument.

\subsection{Method overloading and overriding}

The definitions of method overloading, overriding, hiding,
shadowing and obscuring in \Xten{} are the same as in
\Java~\cite{Java3}, modulo the following considerations
motivated by dependent types.

Our current implementation
erases dependent type information when compiling to Java. Therefore it
must be the case that a class does not have two different method
definitions that conflict with each other when the constrained
clauses in their types are erased.

A class \xcd{C} inherits from its direct superclass and
superinterfaces all their methods that are visible according to the access
modifiers and that are not hidden or overridden. A method
\xcd{m1} in a class \xcd{C} overrides a method \xcd{m2} in a
superclass \xcd{D} if \xcd{m1} and \xcd{m2} have signatures
with equivalent (unerased) formal parameter types. 

Dynamic method lookup does not take dependent type information into
account, only the class hierarchy. This design decision ensures that
serious errors such as method invocation errors are captured at
compile-time. Such errors can arise because multiple incomparable
methods with the same name and acceptable argument lists might be
available at the dynamic dependent type of the subject.

\eat{
The current \Xten{} compiler produces \Java{} code. It further
implements the restriction that no two methods for the same class can
have the same signature after their constraints are erased. This
simplifies implementation---no name mangling is needed to preserve
the dependent type distinction in the generated \Java{} code.
However, this approach does cut down on the usefulness of constrained
clauses for method dispatch.
}

\subsection{Constructors for dependent classes}

\eat{
Like a method definition,
a constructor may
specify preconditions on its arguments
and a postcondition on the value produced by the constructor.
%
Postconditions may be specified in a constructor declaration between
the name of the class and the argument list of the constructor using a
where clause. The where clause can reference only the properties of
the class.
}

Constructors must ensure that the class invariants of the given
class and its superclasses and superinterfaces hold.
For instance, the
nullary constructor for \xcd{List} ensures that the property
\xcd{length} has the value \xcd{0}:
\begin{displayxten}
    public List(0)() { property(0); }
\end{displayxten}
The \xcd{property} statement is used to set all the properties
of the new object simultaneously.  Capturing this assignment in
a single statement simplifies checking that the constructor
postcondition and class invariant are established.  If a class
has properties, every path through the constructor must contain
exactly one \xcd{property} statement.

\java{}-like languages permit constructors to throw exceptions. This
is necessary to deal with the situation in which the arguments to a
constructor for a class \xcd{C} are such that no object can be
constructed that satisfies the invariants for \xcd{C}. Dependent
types make it possible to perform some of these checks at
compile-time. The class invariant of a class explicitly captures
conditions on the properties of the class that must be satisfied by
any instance of the class.  Constructor preconditions capture
conditions on the constructor arguments.
The compiler's static check for
non-emptiness of the type of any variable captures these invariant
violations at compile-time.

%% Cannot throw an exception.

%% Figure out the real condition. Not sure this is important.

\subsection{Extending dependent classes}

A class may extend a constrained class, e.g.,
\xcd{class C(}\dots\xcd{) extends D(:d)}.
This documents the programmer's intention that
every call to \xcd{super} in a constructor for \xcd{C} must ensure
that the invariant \xcd{d} is established on the state of the class
\xcd{D}. The expressions in the actual parameter list for the super
class may involve only the properties of the class being defined.

%{\em MetaNote: This should be standard. A class definition may extend
%a dependent super class, e.g. class Foo(int i) extends Fum(i*i) \{
%\ldots \}. The expressions in the actual parameter list for the super
%class may involve only the properties of the class being defined. The
%intuition is that these parameters are analogous to explicit arguments
%that must be passed in every super-constructor invocation.}

\subsection{Dependent interfaces}

\java{} does not allow interfaces to specify instance fields. Rather all
fields in an interface are final static fields (constants).
However,
since properties play a central role in the specification of
refinements of a type, it makes sense to permit interfaces to specify
properties.
Similarly, an interface
definition may specify an invariant on its properties.  Methods
in the body of an interface may have where clauses
as well.

All classes implementing an interface must have a property
with the same name and
type (either declared in the class or inherited from the superclass)
for each property in the interface. If a class implements
multiple interfaces and more than one of them specify a property
with the same name, then they must all agree on the type of the
property. The class must have a single property with the given name
and type.

The general form of a class declaration is now:
\begin{displayxten}
class C(T$_1$ x$_1$, ..., T$_k$ x$_k$)
      extends B(:c)
      implements I$_1$(:c$_1$), ..., I$_n$(:c$_n$) {...}
\end{displayxten}
\noindent
For such a declaration to type-check, it must be that the class
invariant of \xcd{C} implies \inv(${\tt I}_i$)\xcd{\ & c}$_i$, where
\inv(${\tt I}_i$) is the
invariant associated with interface \xcd{I}$_i$.  Again, a constrained
class or interface \xcd{I} is taken as shorthand for \xcd{I(:true)}.
Further, every method specified in the interface must have a
corresponding method in the class with the same signature whose
precondition, if any, is implied by the precondition of the method in
the interface.


\subsection{Separation between compile-time and run-time computation}

Our design distinguishes between compile-time execution (performed
during type-checking) and run-time execution. At compile-time, the
compiler processes the abstract syntax tree of the program generating
queries to the constraint solver. The only computation engine running
is the constraint solver, which operates on its own vocabulary of
predicates and functions. Program variables (such as local variables)
that occur in types are dealt with symbolically. They are replaced
with logical variables---some fixed, but unknown value---of the same
type. The constraint solver must know how to process pieces of partial
information about these logical variables in order to determine
whether some constraint is entailed. At run time, the same program
variable will have a concrete value and will perform ``arithmetic''
(calculations) where the compiler performed ``algebra'' (symbolic
analysis).

Constrained types may occur in a class cast \xcd{(T)}\;\xcd{e}.  Code is
generated to check at run time that the expression \xcd{e}
satisfies any constraints in \xcd{T}.

\subsection{Equality-based constraints}

The \Xten{} compiler includes a simple equality-based constraint
system.
All constraint systems installed using plugins must support at least the core
equality-based constraints.
Constraints are conjunctions of equalities between
constraint terms: properties, \xcd{final} variables,
compile-time constants, and \xcd{self}:

{\small
\begin{tabular}{r@{\quad}rcl}
\\
    (C Term) & \xcd{t} &{::=}& \xcd{x} \alt \xcd{this} \alt
    \xcd{self} \alt \xcd{t.f} \alt $n$ \\
(Constraint) & \xcd{c},\xcd{d} &{::=}& \xcd{true} \alt \xcd{t ==
t}
\alt
\xcd{c & c}
%\alt
\\ & & \alt &
\xcd{T x; c} \\
\\
\end{tabular}
}

\noindent
We use the syntax \xcd{T x; c} for the constraint obtained by existentially
quantifying the variable \xcd{x} of type \xcd{T} in \xcd{c}.

\subsection{Existential quantification}

Constrained types subsume existential types.
For example, the length of the
list returned by \xcd{filter} in Figure~\ref{fig:list-example} is existentially
quantified.
\if 0
Existential quantification may also be introduced explicitly:
the following function computes the greatest
common divisor of two integers:\footnote{Checking this program
requires a constraint system capable of reasoning about integer
multiplication and
division.  We have not yet implemented such a system.}
\begin{displayxten}
int(:int x; int y; a==x*self & b==y*self)
  gcd(final int a, final int b)
{
    if (b == 0) return a;
    else return gcd(b, a % b);
}
\end{displayxten}
\fi

Operations on values of constrained type
propagate constraints
to the operation result by introducing existentially quantified
variables.  Consider the assignment to \tcd{c} below:
\begin{displayxten}
int(:self >= 0) a = ...;
int(:self >= 0) b = ...;
int(:self >= 0) c = a*b;
\end{displayxten}
During type-checking, the type of \xcd{a*b} is
computed from the types of \xcd{a} and \xcd{b} to be
the type:
\begin{displayxten}
int(:int x; int y; self==x*y & x>=0 & y>=0)
\end{displayxten}
That is, there exist non-negative \tcd{int}s \tcd{x} and \tcd{y} 
whose product is \tcd{self}.
The constraint on this type is strong enough to establish the
constraint on the return type.  If the computed constraint cannot be
represented by any installed constraint system,
the type of \xcd{a*b} is promoted to the unconstrained supertype \xcd{int}.

\subsection{Query evaluation}

Because object-oriented languages permit arbitrary mutual recursion between
classes: classes \xcd{A} and \xcd{B} may have fields of type \xcd{B} and
\xcd{A} respectively---the type/property graph may have cycles. The nodes
in this graph are base types (class and interface names). There is an
edge from node \xcd{A} to node \xcd{B} if \xcd{A} has a property whose
base type is \xcd{B}.

Let us define the {\em real clause} of a constrained type \xcd{C(:c)} to be
the set of constraints that must be satisfied by any instance of
\xcd{C(:c)}. This includes not only the condition \xcd{c} but also
constraints that hold for all instances of \xcd{C}, as
determined by \xcd{C}'s class invariant. Let 
$\rc({\tt C(:c)})$ denote the {\em real clause} of \xcd{C(:c)}.
For simplicity, we consider only top-level classes; thus, the
only free variable
in $\rc({\tt C(:c)})$ is \xcd{self}.  We draw out \xcd{self} as a
formal parameter and write $\rc({\tt C(:c)}, {\tt X})$
for $\rc({\tt C(:c}[{\tt X}/\mbox{\xcd{self}}]))$.

Consider a general class definition:
\begin{displayxten}
class C(C$_1$(:c$_1$) x$_1$, ..., C$_k$(:c$_k$) x$_k$: c)
  extends D(:d) { ... }
\end{displayxten}

\noindent From this, we get:

$$\rc({\tt C},{\tt X}) ~ \iff \!\!\!\!\!\!\!\!\!\!
\begin{array}{l}
\quad  ({\tt c} \wedge {\tt d})[{\tt X}/\this]
\;\wedge\; \rc({\tt D},{\tt X}) \;\wedge \\
\quad  \rc(\mbox{\tcd{C$_1$(:c$_1$)}}, {\tt X.x}_1) \;\wedge\; \cdots
\;\wedge\; \rc(\mbox{\tcd{C$_k$(:c$_k$)}}, {\tt X.x}_k)
\end{array}
$$

That is, given a program $P$ with classes ${\tt C}_1,\ldots, {\tt
C}_k$, the set of real clauses for ${\tt C}_1,\ldots, {\tt C}_k$ are
defined in a mutually recursive fashion through the Clark completion
of a Horn clause theory (over an underlying constraint system).

The central algorithmic question now becomes whether given a
constrained clause {\tt d}, does $\rc(\mbox{\tt C(:c)},{\tt X})$ entail {\tt d}? 
%
From the above formulation the question is clearly semi-decidable. It
is not clear however whether it is decidable. This is a direction for
further work.

The \Xten{} compiler is conservative and rejects
programs with cyclic dependency graphs: programs where the real
clause of the type
of a property \tcd{p} itself constrains \tcd{p}.
%
% XXX can such a program even be constructed
%
In practice, many data structures have non-cyclic dependency
graphs. For such programs the real clause can be computed quickly and
only a bounded number of questions to the constraint solver are
generated during type-checking.

\eat{
\subsection{Existential types}

The use of constraints makes existential types very natural.  Consider
the return type of \xcd{filter} in Figure~\ref{fig:list-example}:
it specifies that the list
returned is of some unknown length, which is known
to be bounded by \xcd{n}. Thus, constrained types naturally
subsume existential dependent types. Indeed, every base type \xcd{C}
is an ``existential'' constrained type since it does not specify any
constraint on its properties. Thus, code written with constrained types
can interact seamlessly with legacy library code---using just base
types wherever appropriate.
}

\subsection{Parametric consistency}

Consider the set of final variables that are referenced in a type
\xcd{T} = \xcd{C(:c)}. These are the {\em parameters} of the type. A
type is said to be {\em parametrically consistent} if its where clause
\xcd{c} is solvable for each possible assignment of values to
parameters.  Types are required to be parametrically
consistent. Parametric consistency is sufficient to ensure that the
extension of a type is non-empty.\footnote{It is not necessary in that
there may be programs whose types are not parametrically inconsistent
but which never encounter empty types at runtime because of
relationships in data values that are to complicated to be captured by
the type system.}

Consider a variation of List from Figure~\ref{fig:list-example}:
\begin{displayxten}
class List(int(:self >= 0) n) {
  Object head;
  List(:self.n==this.n-1 & self!=null) tail;
  ...
}
\end{displayxten}
The type of the field \xcd{tail} is not parametrically
consistent. There exists a value for its parameter \xcd{n}, namely
\xcd{0}, for which the real clause \xcd{self}~\xcd{!=}~\xcd{null} \xcd{&}
\xcd{self.n}~\xcd{==}~\xcd{this.n-1} \xcd{&}
\xcd{self.n}~\xcd{>=}~\xcd{0} is not satisfiable.

The compiler will throw a type error when it encounters the
initializer for this field in a constructor since it will not be able
to prove that the initial value is of the given type.


