Our basic approach to introducing dependent types into
class-based statically typed OO languages is to
follow the spirit of generic types, but use values instead of
types.

We permit the definition of a class {\tt C} to specify
a list of typed parameters, or {\em properties},
{\tt (T1 x1, \ldots, Tk xk)} similar in syntactic structure to
a method argument list. Each
property in this list is treated as a {\tt public final} instance
field of the class.
We also permit the
specification of a {\em class invariant}, a
{\em where clause}~\cite{where-clauses}
in the class definition. A where
clause is a boolean expression on the properties separated from the
property list with a ``{\tt :}''.  The compiler ensures that all
instances of the class created at runtime satisfy the where clause
associated with the class.
Thus, for instance, we may specify a class {\tt List} with an
{\tt int length} property as follows:
\begin{code}
  class List(int length: length >= 0) \{...\}
\end{code}

Given such a definition for a class {\tt C},
types can be constructed by {\em constraining} the properties of
{\tt C}.
In principle, {\em any} boolean expression over the
properties specifies a type: the type of all instances of the
class which satisfy the boolean expression. Thus,
{\tt List(:length == 3)} is a permissible type, as are
{\tt List(:length <= 41)} and even
{\tt List(:length * f() >= g())}.


Accordingly, a {\em constrained type} is of the form {\tt C(:e)}, the name of
a class or interface {\tt C}, called the {\em base class}, followed by a
where clause {\tt e}, called the {\em condition}, a boolean expression
on the properties of the base class. 
The denotation, or
semantic interpretation, of such a type is the set of all instances
of subclasses of the base class whose properties satisfy the
condition.
Clearly, for the denotation of a constrained type $t$ to be
non-empty the condition of $t$ must be consistent with the class
invariant, if any, of the base class of $t$.  The compiler is required to
ensure that the type of any variable declaration is non-empty.

For brevity, we write {\tt C} as a type as well; it
corresponds to the (vacuously) constrained type {\tt C(:true)}.
We also permit the syntax {\tt C(t1,\ldots, tk)} for
the type {\tt C (:x1 = t1, \ldots, xk = tk)} (assuming that
the property list for {\tt C} specifies the {\tt k} properties {\tt
x1,\ldots, xk}, and each term {\tt ti} is of the correct
type). 
%Thus, using the definition above, {\tt List(n)} is the type of
%all lists of length {\tt n}.

Constrained types naturally come equipped with a {\em subtyping
structure}: type $t_1$ is a subtype of $t_2$ if the denotation of
$t_1$ is a subset of $t_2$. This definition satisfies
Liskov's Substitution Principle~\cite{liskov-behaviors}),
and implies that
{\tt C(:e1)} is a subtype of {\tt C(:e2)} if {\tt e1} implies {\tt e2}.
In particular, for all conditions {\tt e},
{\tt C(:e)} is a subtype of {\tt C}.
{\tt C(:e)} is empty exactly
when {\tt e} conjoined with {\tt C}'s class invariant is inconsistent.

Two constrained types {\tt C1(:e1)} and {\tt C2(:e2)} are considered
equivalent if {\tt C1} and {\tt C2} are the same base type and {\tt
e1} and {\tt e2} are equivalent when considered as logical
expressions. Thus {\tt C(:x*x=4)} and {\tt C(:x=2 || x=-2)} are
equivalent types.

\subsection{Method and constructor preconditions}

Methods and constructors may specify preconditions on their parameters
as where clauses.  For an invocation of a method (or constructor) to
be type-correct, the associated where clause must be statically known
to be satisfied. Note that the where clause may contain constraints on
the properties of {\tt this}. Thus the where clause may be used to
specify that a method is {\em conditionally} available on some objects
of the class and not others.

The
return type of a method may also contain expressions involving the
arguments to the method. However, we will require
that any argument used in this way must be declared {\tt final},
ensuring it is not mutated by the method body.
For instance:
\begin{verbatim}
  List(arg.length-1)
    tail(final List arg : arg.length > 0) {...}
\end{verbatim}
\noindent will be a valid method declaration. It says that
{\tt tail} must be passed a non-empty list, and it returns a list
whose length is one less than its argument.

\subsubsection{Constructors for dependent classes}

Like a method definition,
a constructor may
specify preconditions on its arguments
and a postcondition on the value produced by the constructor.

Postconditions may be specified in a constructor declaration between
the name of the class and the argument list of the constructor using a
where clause. The where clause can reference only the properties of
the class.

For instance, the
nullary constructor for {\tt List} ensures that the property
{\tt length} has the value {\tt 0}:
{\footnotesize
\begin{verbatim}
    public List(0)() { property(0); }
\end{verbatim}}
The {\tt property} statement is used to set all the properties
of the new object simultaneously.  Capturing this assignment in
a single statement simplifies checking that the constructor
postcondition and class invariant are established.  If a class
has properties, every path through the constructor must contain
exactly one {\tt property} statement.

%% Cannot throw an exception.

%% Figure out the real condition. Not sure this is important.

\subsection{Constraints}

In this framework, types may be constrained by any boolean
expression over the properties.  For practical reasons,
restrictions need to be imposed to ensure constraint checking is
decidable.

The condition of a constrained type must be a pure
function only of the properties of the base class.
Because properties are
{\tt final} instance fields of the object,
this requirement
ensures that whether or not an object belongs to a constrained type does
not depend on the {\em mutable} state of the object.
That is, the status of the
predicate ``this object belongs to this type'' does not
change over the lifetime of the object.  Second, by insisting that each
property be a {\em field} of the object, the question of
whether an object is of a given type can be
determined merely by examining the state of the object and evaluating
a boolean expression. Of course, an implementation is free to not {\em
explicitly} allocate memory in the object for such fields. For
instance, it may use some scheme of tagged pointers to implicitly
encode the values of these fields.

Further, by requiring that the programmer distinguish certain {\tt
final} fields of a class as properties, we ensure that the programmer
consciously controls {\em which} {\tt final} fields should be available for
constructing constrained types. A field that is ``accidentally'' {\tt
final} may not be used in the construction of a constrained type. It must be
declared as a property.

\java{}-like languages permit constructors to throw exceptions. This
is necessary to deal with the situation in which the arguments to a
constructor for a class {\tt C} are such that no object can be
constructed which satisfies the invariants for {\tt C}. Dependent
types make it possible to perform some of these checks at
compile-time. The class invariant of a class explicitly captures
conditions on the properties of the class that must be satisfied by
any instance of the class.  Constructor preconditions capture
conditions on the constructor arguments.
The compiler's static check for
non-emptiness of the type of any variable captures these invariant
violations at compile-time.




\subsection{Extending dependent classes}

A class may extend a constrained class, e.g. ${\tt \class C(\ldots)\
\extends D(:d)\ldots}$. This documents the programmer's intention that
every call to {\tt super} in a constructor for {\tt C} must ensure
that the invariant {\tt d} is established on the state of the class
{\tt D}. The expressions in the actual parameter list for the super
class may involve only the properties of the class being defind.

%{\em MetaNote: This should be standard. A class definition may extend
%a dependent super class, e.g. class Foo(int i) extends Fum(i*i) \{
%\ldots \}. The expressions in the actual parameter list for the super
%class may involve only the properties of the class being defined. The
%intuition is that these parameters are analogous to explicit arguments
%that must be passed in every super-constructor invocation.}

\subsection{Dependent interfaces}

\java{} does not allow interfaces to specify instance fields. Rather all
fields in an interface are final static fields (constants).

\Xten{} supports rich user-definable extensions to the type system by
allowing the user of a type to construct new constrained types: new
types that are predicates on the immutable state of the base type.
For interfaces to support this extension, they must support
user-definable properties, so that constrained types can be
built over interfaces.

As with classes, an interface definition may specify properties
in a 
list after the name of the interface. Similarly, an interface
definition may specify a where clause in its property list. Methods
in the body of an interface may have where clauses
as well.

All classes implementing an interface must have a property
with the same name and
type (either declared in the class or inherited from the superclass)
for each property in the interface. If a class implements
multiple interfaces and more than one of them specify a property
with the same name, then they must all agree on the type of the
property. The class must have a single property with the given name
and type.

The general form of a class declaration is now:
\begin{verbatim}
  class C(T1 x1, ..., Tk xk)
        extends B(:e)
        implements I1(:e1), ..., In(:en) {...}
\end{verbatim}
\noindent
For such a
declaration to type-check, it must be that the class invariant
implies {\tt inv(I) \&\& e}, where {\tt inv(I)} is the invariant associated with
interface {\tt I}.  Again, a constrained class or interface {\tt I} is taken as
shorthand for {\tt I(:true)}.  Further, every method specified in the
interface must have a corresponding method in the class with the same
signature whose precondition, if any, is implied by the precondition
of the method in the interface.



