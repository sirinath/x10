Constraint-based type systems:

\cite{mitchell84}

\cite{fuh88}

\cite{curtis90}

\cite{aiken93}

\cite{jones94}

\cite{smith94}

\cite{palsberg95}

\cite{trifonov96}

        Types of the form $T\backslash C$, where $C$ is
        a set of subtyping constraints.

        Not dependent.

\cite{fahndrich99}

% Pottier

Pottier~\cite{pottier96simplifying,pottier01b}
presents a constraint-based type system for an ML-like language with
subtyping.

% HM(X)

HM(X)~\cite{sulzmann97type,pottier01a,pottier-remy-attapl}
is a constraint-based framework
for Hindley--Milner style type systems.
The framework is parameterized on the specific constraint system
X; instantiating X yields extensions of the HM type system.



\begin{itemize}
\item Pottier
\item HM(X)
\item Xi and Pfenning (POPL99)

Dependent types in practical programming.
Dependent ML.  DML(C). Objects drawn from constraint domain C.

Index objects must be pure.
Singleton types int(n).

ML$^{\Pi}_0$:
Refinement of the ML type system: does not affect the
operational semantics.  Can erase to ML$_0$.



\item Ada dependent types

Ada has constrained array definitions.  A constraint
\cite{ada-ref-man}.  Not clear if their dependent.  Are there other dependent
types?

\item singleton kinds (Chris Stone)

\item Nested types, vObj, Scala, gbeta, J\&

Nested types: witness types, p
vObj, Scala: p.type.
J\&: p.class
gbeta: p.C

\item Where clauses for F-bounded polymorphism (Theta and PolyJ)

Bounded quantification: Cardelli and Wegner.  Bound T with T'
F-bounds: Canning, Cook, Hill, Olthoff, Mitchell.  Bound T with F(T).

Not dependent types.

\item Hybrid type checking (Flanagan, POPL06)


Refinement types.  Types can be arbitrary predicates:

        { z : Int | z >= 0 }
        equivalent to the X10 type:
        Int(:self >= 0)

Subtyping is undecidable.  Type-checker can report ``yes'',
``no'',
or ``don't know''.  If the latter, dynamic checks inserted where
subsumption occurs.

Also Hybrid Types, Invariants and Refinements for Imperative
Objects (Flanagan, Freund, Tomb, FOOL06).

    Constraints must be pure.  Update is not pure.
    Calls must have pure actuals + receiver.
    What about alising?


\item Soft typing with conditional types (Aiken, POPL94)

Aiken, Wimmers, and T.K. Lakshman.

\item Cayenne (Augustsson, ICFP98)

Result type of function can depend on argument value.
Any expression is a type.
Haskell-like.
Undecidable type checking.

\item Cardelli, type checking dependent types and subtypes

\item Esterel

\item Findler, Felleisen, Contracts for higher-order functions (ICFP02)

example: int[> 9]

contracts are either simple predicates or function contracts.
defined by (define/contract ...)

enforced at run-time.

\item Jif (final access paths in security labels)
\item FX-90
\item ESCJava \cite{esc-java}, Spec\#
\item JSR 308, Javari
\item Freeman, Pfenning, Refinement types for ML (PLDI91)
\item Holt, Cordy, the Turing programming language
\item Mandelbaum, Walker, Harper, effective thy of type refinements
\item Ou, Tan, Mandelbaum, Walker, Dynamic typing with dependent types

Separate dependent and simple parts of the program.
Statically type the dependent parts.
Dynamic checks when passing values into dependent part.

\item Dependently typed data structurse (Xi)
\item Dead code elimination through dependent types (Xi)
\end{itemize}
