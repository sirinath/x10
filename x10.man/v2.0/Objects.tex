\chapter{Objects}\label{XtenObjects}\index{Object}

\section{Basic desing}
An object is an instance of a scalar class or an array type.  It is
created by using a allocation expression
(\Sref{ClassCreation}) or an array creation
(\Sref{ArrayInitializer}) expression, such as an array
initializer. 

All classes subclass from \xcd"x10.lang.Object".
This class has one property \xcd"location" of type
\xcd"x10.lang.Place". \index{place.location} Thus all objects in \Xten{}
are located (have a place). 

In \XtenCurrVer{} an object stays resident at the place at
which it was created for its entire lifetime. However, the
programmer may designate certain immutable field of an object
as \Xcd{global}. The value of these fields 

{}\Xten{} has no operation to dispose of a reference.  Instead, the
collection of all objects across all places is globally garbage
collected.

Unlike \java{},
{}\Xten{} objects do not have any synchronization information (e.g.,
a lock) associated with them. 
Instead, programmers should use atomic blocks
(\Sref{AtomicBlocks}) for mutual exclusion and clocks
(\Sref{XtenClocks}) for sequencing multiple parallel operations.

An object may have many references, stored in fields of
objects or components of arrays. A change to an object made through
one reference is visible through another reference. 

Note that the creation of a remote async activity
(\Sref{AsyncActivity}) \xcd"A" at \xcd"P" may cause the automatic creation of
references to remote objects at \xcd"P". (A reference to a remote
object is called a {\em remote object reference}, to a local object a
{\em local object reference}.)  For instance \xcd"A" may be created
with a reference to an object at \xcd"P" held in a variable referenced
by the statement in \xcd"A".  Similarly the return of a value by a
\xcd"future" may cause the automatic creation of a remote object
reference, incurring some communication cost.  An {}\Xten{}
implementation should try to ensure that the creation of a second or
subsequent reference to the same remote object at a given place does
not incur any (additional) communication cost.

A reference to an object carries with it the values of final \Xcd{global} fields
of the object. The implementation should try to ensure that the cost
of communicating the values of final fields of an object from the
place where it is hosted to any other place is not incurred more than
once for each target place.

{}\Xten{} does not have an operation (such as Pascal's ``dereference''
operation) which returns an object given a reference to the
object. Rather, most operations on object references are transparently
performed on the bound object, as indicated below. The operations on
objects and object references include:
\begin{itemize}

{}\item Field access (\Sref{FieldAccess}). An activity holding a
reference to a reference object may perform this operation only if the
object is local.  An activity holding a reference to a value object
may perform this operation regardless of the location of the object
(since value objects can be copied freely from place to place).  The
implementation should try to ensure that the cost of copying the field
from the place where the object was created to the referencing place
will be incurred at most once per referencing place, according to the
rule for final fields discussed above.

\item Method invocation (\Sref{MethodInvocation}).  
Methods may be marked \Xcd{global}. A \Xcd{global} method may 
be invoked at any place. It may access only the global fields
of the object. The mutable fields of an object that are not marked
\Xcd{global} may be accessed only by activities operating at the place
where the object is located. Any activity may use an \Xcd{at} statement
to place-shift to the place of the object.

{}\item Casting (\Sref{ClassCast}).  An activity can perform this
operation on local or remote objects, and should not incur
communication costs (to bring over type information) more than once
per place.

{}\item \xcd"instanceof" operator (\Sref{instanceOf}).  An activity
can perform this operation on local or remote objects, and should not
incur communication costs (to bring over type information) more than
once per place.

\item The equality operators \xcd"==" and \xcd"!="
(\Sref{StableEquality}). On creation, each object is associated with a globally
unique identifier (guid). Two object references are \xcd"==" iff they refer to objects
with the  same guid.

\end{itemize}

\Xten{} has a rather simple \emph{distributed object model}. 

The state of an object is partitioned into \emph{global} state (a
programmer defined subset of \Xcd{val} fields, \Sref{GlobalField}) and \emph{non-global} state.

 \begin{itemize}
\item  Field definitions are marked with the qualifier \Xcd{global} if they are intended to be included in the global state. 
\item  If the \Xcd{global} qualifier is omitted, the field is considered global. 
\item  Properties and static fields are implicitly marked \Xcd{global}. 
\item \Xcd{var} fields cannot be marked \Xcd{global}. 
\item  Fields not marked \Xcd{global} cannot be overriden by fields marked \Xcd{global}.
\end{itemize}
 
Similarly, the methods of an object may be qualified as \Xcd{global}(\Sref{global}) ; if
they are not global they are said to be \emph{non-global}.


Consider the execution of an \Xcd{at (P) S} statement at a place \Xcd{Q} different
from \Xcd{P}. Suppose \Xcd{x} is an in-scope immutable local variable and contains a
reference to an object \Xcd{o} created at \Xcd{Q}. Then within \Xcd{S}, \Xcd{x} is said to be
a \emph{remote reference} to \Xcd{o}. References to \Xcd{o} from place \Xcd{Q} are said
to be \emph{local references}. \Xten{} permits \Xcd{global} fields to be read
and \Xcd{global} methods to be invoked through a remote reference.


Like local references, remote references are first-class entities:
they may be passed as arguments to methods, returned from methods,
stored in fields of objects.

Remote references may also be compared for equality (\Xcd{==}). Two
remote reference are equal if they are references to the same
object. Equality is guaranteed to be a constant-time operation and not
involve any communication.

When a remote reference to an object \Xcd{o} located at place \Xcd{P} is
transmitted to \Xcd{P} it automatically becomes a local reference to
\Xcd{o}. Therefore the situation in which a local reference can be compared
to a remote reference simply cannot arise.

The \Xten{} compiler ensures that non-global methods on \Xcd{o} can only be invoked in a place where \Xcd{here== o.loc()}, i.e. the place where \Xcd{o} was created.

\paragraph{Implementation notes}
Remote references to an object \Xcd{o} are intended to be implemented
by serializing the global state of \Xcd{o} across the network,
together with a globally unique id (guid). The data is deserialized at
the receiver to create an implementation-level entity that is the
remote reference. There is no requirement that the implementation
intern such entities; however the implementation must correctly
implement equality (see below).

There is no requirement that a remote reference use only as much space as a local reference.

  
\paragraph{Local execution}


 The semantics of \Xcd{atomic} and \Xcd{when} constructs requires that their
 bodies do not execute any \Xcd{at} operations, implicitly or
 explicitly. Hence the compiler must establish that if a non-global method
\Xcd{m} is being invoked on a reference \Xcd{o} in the body of such a construct,
 then \Xcd{o} is a local reference. This can be done using place types (\Sref{PlaceType}).

  
\section{Examples}

Assume the class declarations. 

 \begin{x10}
class C { ...} 
class D {
   var f:C=null;
}
\end{x10}
 
Now the code below must behave as described.
\begin{x10}
val x = new C(..); // C object o created, reference stored in x. 
at (P) { // In the body x contains a remote reference to o
      val f = new D();
      f.x1  = x; // remote reference stored in f.x1
      Console.OUT.println((f.x1 == x);               // must print true
      Console.OUT.println((x == x);                  // must print true
      at (Q) { // x continues to be a remote reference to o1.
         at (P) {  
             Console.OUT.println(f.x1 == x);   // must print true
             Console.OUT.println((x == x);   // must print true
         }
      }
}
\end{x10}
  

Here is another example.
 \begin{x10}
val x = new C(..); 
// C object o created, reference stored in x. 
// type of x is rooted C{c} if the return type of the constructor is C{c}. 
at (P) { 
    val x1 = x; // type of x is C{c} because of the place shift introduced by at(P)
  at (x.loc()) {
        // x is now bound to o through a local reference. So is x1.
    Console.out.println(x1==x); // Must print true.
      // rooted methods can be invoked on x or x1 and will execute locally on o
      // type of both x and x1 is rooted C{c}.
  }
}
\end{x10}
 


  
\subsection{Programming Methodology}


A programmer wishing to ensure that a \Xcd{val} field is not serialized when
the containing object is serialized (e.g. because it contains a large
cache which makes sense only in the current place) must ensure the
field is \emph{not} marked global.


