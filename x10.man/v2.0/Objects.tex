%%Objects-moved-to-Classes%% \section{Principles of X10 Objects}\label{XtenObjects}\index{Object}
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% \subsection{Basic Design}
%%Objects-moved-to-Classes%% An object is an instance of a scalar class or an array type.  It is
%%Objects-moved-to-Classes%% created by using an allocation expression
%%Objects-moved-to-Classes%% (\Sref{ClassCreation}) or an array creation
%%Objects-moved-to-Classes%% (\Sref{ArrayInitializer}) expression, such as an array
%%Objects-moved-to-Classes%% initializer. 
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% All classes subclass from \xcd"x10.lang.Object".
%%Objects-moved-to-Classes%% This class has one property \xcd"home" of type
%%Objects-moved-to-Classes%% \xcd"x10.lang.Place". \index{place.home} Thus all objects in \Xten{}
%%Objects-moved-to-Classes%% are located (have a place). 
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% In \XtenCurrVer{} an object stays resident at the place at
%%Objects-moved-to-Classes%% which it was created for its entire lifetime. However, the
%%Objects-moved-to-Classes%% programmer may designate certain immutable field of an object
%%Objects-moved-to-Classes%% as \Xcd{global}. The value of these fields is accessible 
%%Objects-moved-to-Classes%% at every place the object can be referenced.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% {}\Xten{} has no operation to dispose of a reference.  Instead, the
%%Objects-moved-to-Classes%% collection of all objects across all places is globally garbage
%%Objects-moved-to-Classes%% collected.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% Unlike \java{},
%%Objects-moved-to-Classes%% {}\Xten{} objects do not have any synchronization information (e.g.,
%%Objects-moved-to-Classes%% a lock) associated with them. 
%%Objects-moved-to-Classes%% Instead, programmers should use atomic blocks
%%Objects-moved-to-Classes%% (\Sref{AtomicBlocks}) for mutual exclusion and clocks
%%Objects-moved-to-Classes%% (\Sref{XtenClocks}) for sequencing multiple parallel operations.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% An object may have many references, stored in fields of
%%Objects-moved-to-Classes%% objects or components of arrays. A change to an object made through
%%Objects-moved-to-Classes%% one reference is visible through another reference. 
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% Note that the creation of a remote async activity
%%Objects-moved-to-Classes%% (\Sref{AsyncActivity}) \xcd"A" at \xcd"P" may cause the automatic creation of
%%Objects-moved-to-Classes%% references to remote objects at \xcd"P". (A reference to a remote
%%Objects-moved-to-Classes%% object is called a {\em remote object reference}, to a local object a
%%Objects-moved-to-Classes%% {\em local object reference}.)  For instance \xcd"A" may be created
%%Objects-moved-to-Classes%% with a reference to an object at \xcd"P" held in a variable referenced
%%Objects-moved-to-Classes%% by the statement in \xcd"A".  Similarly the return of a value by a
%%Objects-moved-to-Classes%% \xcd"future" may cause the automatic creation of a remote object
%%Objects-moved-to-Classes%% reference, incurring some communication cost.  An {}\Xten{}
%%Objects-moved-to-Classes%% implementation should try to ensure that the creation of a second or
%%Objects-moved-to-Classes%% subsequent reference to the same remote object at a given place does
%%Objects-moved-to-Classes%% not incur any (additional) communication cost.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% A reference to an object carries with it the values of  \Xcd{global} \xcd`val`
%%Objects-moved-to-Classes%% fields
%%Objects-moved-to-Classes%% of the object. The implementation should try to ensure that the cost
%%Objects-moved-to-Classes%% of communicating the values of \xcd`val` fields of an object from the
%%Objects-moved-to-Classes%% place where it is hosted to any other place is not incurred more than
%%Objects-moved-to-Classes%% once for each target place.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% {}\Xten{} does not have an operation (such as Pascal's ``dereference''
%%Objects-moved-to-Classes%% operation) which returns an object given a reference to the
%%Objects-moved-to-Classes%% object. Rather, most operations on object references are transparently
%%Objects-moved-to-Classes%% performed on the bound object, as indicated below. The operations on
%%Objects-moved-to-Classes%% objects and object references include:
%%Objects-moved-to-Classes%% \begin{itemize}
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% {}\item Field access (\Sref{FieldAccess}). An activity holding a
%%Objects-moved-to-Classes%% reference to an object may perform this operation only if the
%%Objects-moved-to-Classes%% object is local.  (By contrast, an activity holding a reference to a struct
%%Objects-moved-to-Classes%% may perform this operation regardless of the location of the struct, 
%%Objects-moved-to-Classes%% since structs can be copied freely from place to place.).  The
%%Objects-moved-to-Classes%% implementation should try to ensure that the cost of copying the field
%%Objects-moved-to-Classes%% from the place where the object was created to the referencing place
%%Objects-moved-to-Classes%% will be incurred at most once per referencing place, according to the
%%Objects-moved-to-Classes%% rule for \xcd`val` fields discussed above.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% {}\item Method invocation (\Sref{MethodInvocation}).  
%%Objects-moved-to-Classes%% \label{GlobalAnnotation}
%%Objects-moved-to-Classes%% A method may be
%%Objects-moved-to-Classes%% marked \Xcd{global}. A \Xcd{global} method may be invoked at any
%%Objects-moved-to-Classes%% place. It may access only the global fields of the object. The
%%Objects-moved-to-Classes%% mutable fields of an object may be accessed only by activities
%%Objects-moved-to-Classes%% operating in its home.  Any activity may use an \Xcd{at} statement
%%Objects-moved-to-Classes%% to place-shift to the place of the object. Methods may also be
%%Objects-moved-to-Classes%% marked \Xcd{pinned}, \Xcd{nonblocking}, \Xcd{sequential},
%%Objects-moved-to-Classes%% \Xcd{safe}, and \Xcd{pure} (\Sref{MethodQualifier})..
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% {}\item Casting (\Sref{ClassCast}).  An activity can perform this
%%Objects-moved-to-Classes%% operation on local or remote objects, and should not incur
%%Objects-moved-to-Classes%% communication costs (to bring over type information) more than once
%%Objects-moved-to-Classes%% per place.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% {}\item \xcd"instanceof" operator (\Sref{instanceOf}).  An activity
%%Objects-moved-to-Classes%% can perform this operation on local or remote objects, and should not
%%Objects-moved-to-Classes%% incur communication costs (to bring over type information) more than
%%Objects-moved-to-Classes%% once per place.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% \item The equality operators \xcd"==" and \xcd"!="
%%Objects-moved-to-Classes%% (\Sref{StableEquality}). On creation, each object is associated with a globally
%%Objects-moved-to-Classes%% unique identifier (guid). Two object references are \xcd"==" iff they refer to objects
%%Objects-moved-to-Classes%% with the  same guid.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% \end{itemize}
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% \Xten{} has a rather simple \emph{distributed object model}. 
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% The state of an object is partitioned into \emph{global} state (a
%%Objects-moved-to-Classes%% programmer defined subset of \Xcd{val} fields, \Sref{GlobalField}) and
%%Objects-moved-to-Classes%% \emph{non-global} state.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%%  \begin{itemize}
%%Objects-moved-to-Classes%% \item Field definitions are marked with the qualifier \Xcd{global} if
%%Objects-moved-to-Classes%%   they are intended to be included in the global state.
%%Objects-moved-to-Classes%% \item If the \Xcd{global} qualifier is omitted, the field is
%%Objects-moved-to-Classes%%   considered non-global.
%%Objects-moved-to-Classes%% \item Properties and static fields are implicitly marked \Xcd{global}.
%%Objects-moved-to-Classes%% \item \Xcd{var} fields cannot be marked \Xcd{global}.
%%Objects-moved-to-Classes%% %\item  Fields marked \Xcd{global} cannot be overriden by fields not marked \Xcd{global}.
%%Objects-moved-to-Classes%% \end{itemize}
%%Objects-moved-to-Classes%%  
%%Objects-moved-to-Classes%% Similarly, the methods of an object may be qualified as
%%Objects-moved-to-Classes%% \Xcd{global}(\Sref{GlobalMethod}) ; if they are not global they are
%%Objects-moved-to-Classes%% said to be \emph{non-global}. 
%%Objects-moved-to-Classes%% Global methods cannot be overridden by non-global methods.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% Consider the execution of an \Xcd{at (P) S} statement at a place
%%Objects-moved-to-Classes%% \Xcd{Q} different from \Xcd{P}. Suppose \Xcd{x} is an in-scope
%%Objects-moved-to-Classes%% immutable local variable and contains a reference to an object \Xcd{o}
%%Objects-moved-to-Classes%% created at \Xcd{Q}. Then within \Xcd{S}, \Xcd{x} is said to be a
%%Objects-moved-to-Classes%% \emph{remote reference} to \Xcd{o}. References to \Xcd{o} from place
%%Objects-moved-to-Classes%% \Xcd{Q} are said to be \emph{local references}. \Xten{} permits
%%Objects-moved-to-Classes%% \Xcd{global} fields to be read and \Xcd{global} methods to be invoked
%%Objects-moved-to-Classes%% through a remote reference.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% Like local references, remote references are first-class entities:
%%Objects-moved-to-Classes%% they may be passed as arguments to methods, returned from methods,
%%Objects-moved-to-Classes%% stored in fields of objects.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% Remote references may also be compared for equality (\Xcd{==}). Two
%%Objects-moved-to-Classes%% remote reference are equal if they are references to the same
%%Objects-moved-to-Classes%% object. Equality is guaranteed to be a constant-time operation and not
%%Objects-moved-to-Classes%% involve any communication.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% When a remote reference to an object \Xcd{o} located at place \Xcd{P} is
%%Objects-moved-to-Classes%% transmitted to \Xcd{P} it automatically becomes a local reference to
%%Objects-moved-to-Classes%% \Xcd{o}. Therefore the situation in which a local reference can be compared
%%Objects-moved-to-Classes%% to a remote reference simply cannot arise.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% The \Xten{} compiler ensures that non-global methods on \Xcd{o} can
%%Objects-moved-to-Classes%% only be invoked in a place where \Xcd{here== o.home()}, i.e. the place
%%Objects-moved-to-Classes%% where \Xcd{o} was created.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% \paragraph{Implementation notes}
%%Objects-moved-to-Classes%% Remote references to an object \Xcd{o} are intended to be implemented
%%Objects-moved-to-Classes%% by serializing the global state of \Xcd{o} across the network,
%%Objects-moved-to-Classes%% together with a globally unique id (guid). The data is deserialized at
%%Objects-moved-to-Classes%% the receiver to create an implementation-level entity that is the
%%Objects-moved-to-Classes%% remote reference. There is no requirement that the implementation
%%Objects-moved-to-Classes%% intern such entities; however the implementation must correctly
%%Objects-moved-to-Classes%% implement equality (see below).
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% There is no requirement that a remote reference use only as much space as a local reference.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%%   
%%Objects-moved-to-Classes%% \paragraph{Local execution}
%%Objects-moved-to-Classes%%  The semantics of \Xcd{atomic} and \Xcd{when} constructs requires that their
%%Objects-moved-to-Classes%%  bodies do not execute any \Xcd{at} operations, implicitly or
%%Objects-moved-to-Classes%%  explicitly. Hence the compiler must establish that if a non-global method
%%Objects-moved-to-Classes%% \Xcd{m} is being invoked on a reference \Xcd{o} in the body of such a construct,
%%Objects-moved-to-Classes%%  then \Xcd{o} is a local reference. This can be done using place types (\Sref{PlaceType}).
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%%   
%%Objects-moved-to-Classes%% \subsection{Examples}
%%Objects-moved-to-Classes%% Assume the class declarations. 
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% \begin{xten}
%%Objects-moved-to-Classes%% class C { } 
%%Objects-moved-to-Classes%% class D {
%%Objects-moved-to-Classes%%    var f:C=null;
%%Objects-moved-to-Classes%% }
%%Objects-moved-to-Classes%% \end{xten}
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% %%TODO--Add a variant of the following code to the test suite
%%Objects-moved-to-Classes%% Then the following code behaves as stated.
%%Objects-moved-to-Classes%% %~~gen
%%Objects-moved-to-Classes%% % package objects.dwiffle.and.a.half.a.moon;
%%Objects-moved-to-Classes%% % class C { } 
%%Objects-moved-to-Classes%% % class D {
%%Objects-moved-to-Classes%% %    var f:C=null;
%%Objects-moved-to-Classes%% % }
%%Objects-moved-to-Classes%% % class Fudders {
%%Objects-moved-to-Classes%% % def plongent(P:Place, Q:Place) throws Exception {
%%Objects-moved-to-Classes%% %~~vis
%%Objects-moved-to-Classes%% \begin{xten}
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% val x = new C(); 
%%Objects-moved-to-Classes%% // C object o1 created, reference stored in x. 
%%Objects-moved-to-Classes%% at (P) { 
%%Objects-moved-to-Classes%%       // In the body x contains a remote reference to o
%%Objects-moved-to-Classes%%       val d = new D();
%%Objects-moved-to-Classes%%       d.f  = x; // remote reference stored in d.f
%%Objects-moved-to-Classes%%       Console.OUT.println(d.f == x);        // must print true
%%Objects-moved-to-Classes%%       Console.OUT.println(x == x);          // must print true
%%Objects-moved-to-Classes%%       at (Q) { 
%%Objects-moved-to-Classes%%          // x continues to be a remote reference to o1.
%%Objects-moved-to-Classes%%          at (P) {  
%%Objects-moved-to-Classes%%              Console.OUT.println(d.f == x);   // must print true
%%Objects-moved-to-Classes%%              Console.OUT.println(x == x);   // must print true
%%Objects-moved-to-Classes%%          }
%%Objects-moved-to-Classes%%       }
%%Objects-moved-to-Classes%% }
%%Objects-moved-to-Classes%% \end{xten}
%%Objects-moved-to-Classes%% %~~siv
%%Objects-moved-to-Classes%% %}}
%%Objects-moved-to-Classes%% %~~neg
%%Objects-moved-to-Classes%%   
%%Objects-moved-to-Classes%% %%TODO--Add a variant of the following code to the test suite
%%Objects-moved-to-Classes%% %%TODO--rewrite this
%%Objects-moved-to-Classes%% Here is another example.
%%Objects-moved-to-Classes%% %~~gen
%%Objects-moved-to-Classes%% % package objects.armor.of.eyeballs;
%%Objects-moved-to-Classes%% % class C { } 
%%Objects-moved-to-Classes%% % class D {
%%Objects-moved-to-Classes%% %    var f:C=null;
%%Objects-moved-to-Classes%% % }
%%Objects-moved-to-Classes%% % class Fudders {
%%Objects-moved-to-Classes%% % def plongent(P:Place, Q:Place) throws Exception {
%%Objects-moved-to-Classes%% %~~vis
%%Objects-moved-to-Classes%% \begin{xten}
%%Objects-moved-to-Classes%% val x = new C(); 
%%Objects-moved-to-Classes%% // C object o created, reference stored in x. 
%%Objects-moved-to-Classes%% // The type inferred for x is C!
%%Objects-moved-to-Classes%% at (P) { 
%%Objects-moved-to-Classes%%     val x1 = x; 
%%Objects-moved-to-Classes%%     // The type inferred for x1 is C, not C!;
%%Objects-moved-to-Classes%%     // the change is due to the place shift 'at(P)'
%%Objects-moved-to-Classes%%   at (x.home) {
%%Objects-moved-to-Classes%%         // x is now bound to o through a local reference. So is x1.
%%Objects-moved-to-Classes%%     Console.OUT.println(x1==x); // Must print true.
%%Objects-moved-to-Classes%%       // non-global methods can be invoked on x or x1 and will 
%%Objects-moved-to-Classes%%       // execute locally on o
%%Objects-moved-to-Classes%%       // type of both x and x1 is C!.
%%Objects-moved-to-Classes%%   }
%%Objects-moved-to-Classes%% }
%%Objects-moved-to-Classes%% \end{xten}
%%Objects-moved-to-Classes%% %~~siv
%%Objects-moved-to-Classes%% %}}
%%Objects-moved-to-Classes%% %~~neg
%%Objects-moved-to-Classes%%  
%%Objects-moved-to-Classes%% \subsection{Programming Methodology}
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% A programmer wishing to ensure that a \Xcd{val} field is not serialized when
%%Objects-moved-to-Classes%% the containing object is serialized (e.g. because it contains a large
%%Objects-moved-to-Classes%% cache which makes sense only in the current place) must ensure the
%%Objects-moved-to-Classes%% field is \emph{not} marked global.
%%Objects-moved-to-Classes%% 
%%Objects-moved-to-Classes%% 
