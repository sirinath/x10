\section{Coercions and conversions}
\label{XtenConversions}
\label{User-definedCoercions}
\index{conversions}\index{coercions}

\XtenCurrVer{} supports the following coercions and conversions

\subsection{Coercions}

A {\em coercion} does not change object identity; a coerced object may
be explicitly coerced back to its original type through a cast. A {\em
  conversion} may change object identity if the type being converted
to is not the same as the type converted from. \Xten{} permits
user-defined conversions (\Sref{sec:user-defined-conversions}).

\paragraph{Subsumption coercion.}
A subtype may be implicitly coerced to any supertype.
\index{coercions!subsumption coercion}

\paragraph{Explicit coercion (casting with \xcd"as")}
A reference type may be explicitly coerced to any other
reference type using the \xcd"as" operation.
If the value coerced is not an instance of the target type,
a \xcd"TypeCastException" is thrown.  Casting to a constrained
type may require a run-time check that the constraint is
satisfied.
\index{coercions!explicit coercion}
\index{casting}
\index{\Xcd{as}}

\subsection{Conversions}

\paragraph{Narrowing conversion.}
A value class may be explicitly converted to any superclass
using the \xcd"as" operation.

\index{conversions!narrowing conversions}

\paragraph{Widening numeric conversion.}
A numeric type may be implicitly converted to a wider numeric type. In
particular, an implicit conversion may be performed between a numeric
type and a type to its right, below:

\begin{xten}
Byte < Short < Int < Long < Float < Double
\end{xten}

\index{conversions!widening conversions}
\index{conversions!numeric conversions}

\paragraph{String conversion.}
Any object that is an operand of the binary
\xcd"+" operator may
be converted to \xcd"String" if the other operand is a \xcd"String".
A conversion to \xcd"String" is performed by invoking the \xcd"toString()"
method of the object.

\index{conversions!string conversion}

\paragraph{User defined conversions.}\label{sec:user-defined-conversions}
\index{conversions!user defined}

The user may define conversion operators from type \Xcd{A} {\em to} a
container type \Xcd{B} by specifying a method on \Xcd{B} as follows:

\begin{xten}
  public static operator (r: A): T = ... 
\end{xten}

The return type \Xcd{T} should be a subtype of \Xcd{B}. The return
type need not be specified explicitly; it will be computed in the
usual fashion if it is not. However, it is good practice for the
programmer to specify the return type for such operators explicitly.

For instance, the code for \Xcd{x10.lang.Point} contains:

\begin{xten}
  public static global safe operator (r: Rail[int]): Point(r.length) = make(r);
\end{xten}

The compiler looks for such operators on the container type \Xcd{B}
when it encounters an expression of the form \Xcd{r as B} (where
\Xcd{r} is of type \Xcd{A}). If it finds such a method, it sets the
type of the expression \Xcd{r as B} to be the return type of the
method. Thus the type of \Xcd{r as B} is guaranteed to be some subtype
of \Xcd{B}.

\begin{example}
Consider the following code:  
\begin{xten}
val p  = [2, 2, 2, 2, 2] as Point;
val q = [1, 1, 1, 1, 1] as Point;
val a = p - q;    
\end{xten}
This code fragment compiles successfully, given the above operator definition. 
The type of \Xcd{p} is inferred to be \Xcd{Point(5)} (i.e.{} the type \Xcd"Point{self.rank==5}".
Similarly for \Xcd{q}. Hence the application of the operator ``\Xcd{-}'' is legal (it requires both arguments to have the same rank). The type of \Xcd{a} is computed as \Xcd{Point(5)}.
\end{example}
