\chapter{Overview of \Xten}

\Xten{} is a statically typed object-oriented language, extending a
sequential core language with
\emph{places}, \emph{activities}, \emph{clocks},
(distributed, multi-dimensional) \emph{arrays} and \emph{struct}
types. All these changes are motivated by the desire to use the new
language for high-end, high-performance, high-productivity computing.

\section{Object-oriented features}

The sequential core of \Xten{} is a {\em container-based} object-oriented language
similar to \java{} and C++, and more recent language such as Scala.  
Programmers write \Xten{} code by defining containers for data and behavior called
\emph{interfaces}
(\Sref{XtenInterfaces}),
\emph{classes}
(\Sref{XtenClasses}) and
\emph{structs}
(\Sref{XtenStructs}).
X10 provides inheritance and subtyping in fairly traditional ways. 

\begin{example}

\xcd`Normed` describes entities with a \xcd`norm()` method. \xcd`Normed` is
intended to be used for entities with a position in some coordinate system,
and \xcd`norm()` gives the distance between the entity and the origin. A
\xcd`Slider` is an object which can be moved around on a line; a
\xcd`PlanePoint` is a fixed position in a plane. Both \xcd`Slider`s and
\xcd`PlanePoint`s have a sensible \xcd`norm()` method, and implement
\xcd`Normed`.

%~~gen
% package Overview;
%~~vis
\begin{xten}
interface Normed {
  def norm():Double;
}
class Slider implements Normed {
  var x : Double = 0;
  public def norm() = Math.abs(x);
  public def move(dx:Double) { x += dx; }
}
struct PlanePoint implements Normed {
  val x : Double, y:Double;
  public def this(x:Double, y:Double) {
    this.x = x; this.y = y;
  }
  public def norm() = Math.sqrt(x*x+y*y);
}
\end{xten}
%~~siv
%
%~~neg
\end{example}

\paragraph{Interfaces}

An \Xten{} interface specifies a collection of abstract methods; \xcd`Normed`
specifies just \xcd`norm()`. Classes and
structs can be specified to {\em implement} interfaces, as \xcd`Slider` and
\xcd`PlanePoint` implement \xcd`Normed` , and, when they do so, must provide
all the methods that the interface demands.

Interfaces are
purely abstract. Every value of type \xcd`Normed` must be an instance of some
class like \xcd`Slider` or some struct like \xcd`PlanePoint` which implements
\xcd`Normed`; no value can be \xcd`Normed` and nothing else. 


\paragraph{Classes and Structs}

There are two kinds of concrete containers: \emph{classes}
(\Sref{ReferenceClasses}) and \emph{structs} (\Sref{Structs}). Concrete
containers hold data in {\em fields}, and give concrete implementations of
methods, as \xcd`Slider` and \xcd`PlainPoint` above.

Classes are organized in a single-inheritance tree: a class may have only a
single parent class, though it may implement many interfaces and have many
subclasses. Classes may have mutable fields, as \xcd`Slider` does.

In contrast, structs are headerless values, lacking the internal organs
which give objects their intricate behavior.  This makes them less powerful
than objects (\eg, structs cannot inherit methods, though objects can), but also
cheaper (\eg, they can be inlined, and they require less space than objects).  
Structs are immutable, though their fields may be immutably set to objects
which are themselves mutable.  They behave like objects in all ways consistent
with these limitations; \eg, while they cannot {\em inherit} methods, they can
have them -- as \xcd`PlanePoint` does.

\Xten{} has no primitive classes per se. However, the standard library
\xcd"x10.lang" supplies structs \xcd"Boolean", \xcd"Byte", \xcd"Short",
\xcd"Char", \xcd"Int", \xcd"Long", \xcd"Float", \xcd"Double", \xcd"Complex"
and \xcd"String". The user may defined additional arithmetic structs using the
facilities of the language.



\paragraph{Functions.}

X10 provides functions (\Sref{Closures}) to allow code to be used
as values.  Functions are first-class data: they can be stored in lists,
passed between activities, and so on.  \xcd`square`, below, is a function
which squares an \xcd`Int`.  \xcd`of4` takes an \xcd`Int`-to-\xcd`Int`
function and applies it to the number \xcd`4`.  So, \xcd`fourSquared` computes
\xcd`of4(square)`, which is \xcd`square(4)`, which is 16, in a fairly
complicated way.
%~~gen
% package Overview.of.Functions.one;
% class Whatever{
% def chkplz() {
%~~vis
\begin{xten}
  val square = (i:Int) => i*i;
  val of4 = (f: (Int)=>Int) => f(4);
  val fourSquared = of4(square);
\end{xten}
%~~siv
%}}
%~~neg



They are used extensively in X10
programs.  For example, the normal way to construct a \xcd`Rail[Int]` --
that is, a fixed-length array of numbers, like an \xcd`int[]` in Java -- is to
pass two arguments to a factory method: the first argument being the length of
the rail, and the second being a function which computes the initial value of
the \xcd`i`{$^{th}$} element.  The following code constructs a rail
initialized to the squares of 0,1,...,9: \xcd`r(0) == 0`, \xcd`r(5)==25`, etc. 
%~~gen
% package Overview.of.Functions.two;
% class Whatevermore {
%  def plzchk(){
%    val square = (i:Int) => i*i;
%~~vis
\begin{xten}
  val r : Rail[Int] = Rail.make[Int](10, square);
\end{xten}
%~~siv
%}}
%~~neg




%%BARD-HERE



\paragraph{Constrained Types}

X10 containers may declare {\em properties}, which are fields bound immutably
at the creation of the container.  The static analysis system understands
properties, and can work with them logically.   


For example, an implementation of matrices \xcd`Mat` might have the numbers of
rows and columns as properties.  A little bit of care in definitions allows
the definition of a \xcd`+` operation that works on matrices of the same
shape, and \xcd`*` that works on matrices with appropriately matching shapes
The following code typechecks, but an attempt to compute \xcd`axb1 + bxc` or
\xcd`bxc * axb1` would result in a compile-time type error:
%~~gen
%package Overview.Mat1;
%abstract class Mat(rows:Int, cols:Int) {
%  static type Mat(r:Int, c:Int) = Mat{self.rows==r&&self.cols==c};
%  public def this(r:Int, c:Int) : Mat(r,c) = {property(r,c);}
%  static def makeMat(r:Int,c:Int) : Mat(r,c) = null;
%  abstract global operator this + (y:Mat(this.rows,this.cols)):Mat(this.rows, this.cols);
%  abstract global operator this * (y:Mat) {this.cols == y.rows} : Mat(this.rows, y.cols);
%~~vis
\begin{xten}
  static def example(a:Int, b:Int, c:Int) {
    val axb1 : Mat(a,b) = makeMat(a,b);
    val axb2 : Mat(a,b) = makeMat(a,b);
    val bxc  : Mat(b,c) = makeMat(b,c);
    val axc  : Mat(a,c) = (axb1 +axb2) * bxc;
  }

\end{xten}
%~~siv
%}
%~~neg

The ``little bit of care'' shows off many of the features of constrained
types.    
The \xcd`(rows:Int, cols:Int)` in the class definition declares two
properties, \xcd`rows` and \xcd`cols`.\footnote{The class is officially declared
abstract to allow for multiple implementations, like sparse and band matrices,
but in fact is abstract to avoid having to write the actual definitions of
\xcd`+` and \xcd`*`.}  

A constrained type looks like \xcd`Mat{self.rows==r && self.cols==c}`: a type
name, followed by a Boolean expression in braces.  The special variable
\xcd`self` refers to the matrix whose number of rows and columns is being
checked.  The \xcd`type` declaration on the second line makes
\xcd`Mat(2,3)` be a synonym for \xcd`Mat{self.rows==r && self.cols==c}`,
allowing for compact types in many places.

Functions can return constrained types.  
The \xcd`makeMat(r,c)` method returns a \xcd`Mat(r,c)` -- a matrix whose shape
is given by the arguments to the method.  For the sake of brevity in
the example, it returns \xcd`null`; in real code, it would actually produce a
matrix -- which must be statically provable to have the right shape.

The arguments of methods can have type constraints as well.  The 
\xcd`operator this +` line lets \xcd`A+B` add two matrices.  The type of the
second argument \xcd`y` is constrained to have the same number of rows and
columns as the first argument \xcd`this`. Attempts to add mismatched matrices
will be flagged as type errors at compilation.

At times it is more convenient to put the constraint on the method as a whole,
as seen in the \xcd`operator this *` line. Unlike for \xcd`+`, there is no
need to constrain both dimensions; we simply need to check that the columns of
the left factor match the rows of the right. This constraint is written in
\xcd`{...}` after the argument list.  The shape of the result is computed from
the shapes of the arguments.

And that is all that is necessary for a user-defined class of matrices to have
shape-checking for matrix addition and multiplication.  The \xcd`example`
method compiles under those definitions.

%~~gen
%package Overview.Mat2;
%~~vis
\begin{xten}
abstract class Mat(rows:Int, cols:Int) {
 static type Mat(r:Int, c:Int) = Mat{self.rows==r&&self.cols==c};
 static def makeMat(r:Int,c:Int) : Mat(r,c) = null;
 abstract global operator this + (y:Mat(this.rows,this.cols))
                 :Mat(this.rows, this.cols);
 abstract global operator this * (y:Mat) {this.cols == y.rows} 
                 :Mat(this.rows, y.cols);
\end{xten}
%~~siv
%  static def example(a:Int, b:Int, c:Int) {
%    val axb1 : Mat(a,b) = makeMat(a,b);
%    val axb2 : Mat(a,b) = makeMat(a,b);
%    val bxc  : Mat(b,c) = makeMat(b,c);
%    val axc  : Mat(a,c) = (axb1 +axb2) * bxc;
%  }
%}
%~~neg




%%BARD-HERE

\paragraph{Generic types}

Classes and interfaces may have type parameters, permitting the definition of
{\em generic types}.  Type parameters may be instantiated by any type -- a
container type or a function type.

For example,
the following code declares a simple \xcd"List" class with a
type parameter \xcd"T".

%~~gen
%~~vis
\begin{xten}
class List[T] {
    var head: T;
    var tail: List[T]!;
    def this(h: T, t: List[T]!) { head = h; tail = t; }
    def add(x: T) {
        if (this.tail == null)
            this.tail = new List(x, null);
        else
            this.tail.add(x);
    }
}
\end{xten}
%~~siv
%~~neg
The constructor (\xcd"def this") initializes the fields of the new object.
The \xcd"add" method appends an element to the list.
\xcd"List" is a generic type.  When  instances of \xcd"List" are
allocated, the type \param{} \xcd"T" must be bound to a concrete
type.  \xcd"List[Int]" is the type of lists of element type
\xcd"Int", \xcd"List[String]" is the type of lists of element
type \xcd"String".

\section{The sequential core}

\paragraph{Control flow.}  \Xten{} supports standard sequential control flow
constructs: \xcd"if" statements, \xcd"while" loops, \xcd"for" loops,
\xcd"switch" statements, etc.  \Xten{} also supports exceptions: exceptions are
raised by \xcd"throw" statements and are handled by \xcd"try"--\xcd"catch"
statements.

\paragraph{Primitive operations.}  The language provides syntax for performing
binary and unary operations on values. The programmer may specify code
by using \Xcd{operator} definitions.
%% TODOvj: Add link to operator section.


\paragraph{Allocation.}
Objects are allocated with the \xcd"new" operator
(\Sref{ClassCreation}), which takes a class name and type and value
arguments to pass to the class's constructor.  The constructor must
ensure that all properties of the class and its superclasses are
bound. Structs are created through the invocation of a constructor
without using the \Xcd{new} operator and live on the heap only in
the fields of objects.

\paragraph{Coercions and conversions}
\Xten{} supports implicit and explicit coercions and
conversions (\Sref{XtenConversions}).

Values of one type can be converted to another type using the
\xcd"as" operation:
%~~gen
%class AsIsizer {
%~~vis
\begin{xten}
val x: Int = 65535;
val y: Byte = x as Byte; // convert to Byte,
                         // retaining the lower 8 bits
\end{xten}
%~~siv
%}
%~~neg
The \xcd"as" operation does not necessarily preserve equality
and for numeric values may
result in a loss of precision.

References may be coerced to another type, preserving object
identity.  A run-time check is performed to ensure the reference
is to an object of the target type.  If not,
a \xcd"ClassCastException" is thrown.
%TODO -- needs dynamic test case.
%~~gen
% class B{}
% class C extends B{}
% class D extends B{}
% class Whudnut { def plurd() {
%~~vis
\begin{xten}
// C and D are immediate subclasses of B.
val x: B = new C();
val y: C = x as C; // run-time check succeeds
val z: D = x as D; // run-time check fails
\end{xten}
%~~siv
%}}
%~~neg


\section{Places and activities}
An \Xten{} program is intended to run on a wide range of computers,
from uniprocessors to large clusters of parallel processors supporting
millions of concurrent operations. To support this scale, \Xten{}
introduces the central concept of \emph{place} (\Sref{XtenPlaces}).
Conceptually, a place is a ``virtual shared-memory multi-processor'':
a computational unit with a finite (though perhaps changing) number of
hardware threads and a bounded amount of shared memory, uniformly
accessible by all threads.

An \Xten{} computation acts on \emph{data
objects}(\Sref{XtenObjects}) through the execution of lightweight
threads called \emph{activities}(\Sref{XtenActivities}).  Objects are
of two kinds. A \emph{scalar} object has a small, statically fixed set
of fields, each of which has a distinct name. A scalar object is
located at a single place and stays at that place throughout its
lifetime.  An \emph{aggregate} object has many fields (the number may
be known only when the object is created), uniformly accessed through
an index (e.g., an integer) and may be distributed across many
places. The distribution of an aggregate object remains unchanged
throughout the computation. \Xten{} assumes an underlying garbage
collector will dispose of (scalar and aggregate) objects and reclaim
the memory associated with them once it can be determined that these
objects are no longer accessible from the current state of the
computation. (There are no operations in the language to allow a
programmer to explicitly release memory.)

{}\Xten{} has a \emph{unified} or \emph{global address space}. This
means that an activity can reference objects at other places.
However, an activity may synchronously access data items only in the
current place (the place in which the activity is running). It may
atomically update one or more data items, but only in the current
place.  To read a remote location, an activity must spawn another
activity \emph{asynchronously} (\Sref{AsynchronousActivity}). This
operation returns immediately, leaving the spawning activity with a
\emph{future} (\Sref{XtenFutures}) for the result. Similarly, remote
location can be written into only by asynchronously spawning an
activity to run at that location.

Throughout its lifetime an activity executes at the same place. An
activity may dynamically spawn activities in the current or remote
places.

\paragraph{Place casts.}
The programmer may use the standard type cast mechanism
(\Sref{ClassCast}) to cast a value to a located type. A
\xcd"BadPlaceException" is thrown if the value is not of the given
type. This is the only language construct that throws a \xcd"BadPlaceException".

\paragraph{Atomic blocks.}

\Xten{} introduces statements of the form \xcd"atomic S" where \xcd"S"
is a statement.  The type system ensures that such a statement will
dynamically access only local data. (The statement may throw
a \xcd"BadPlaceException"---but only because of a failed place cast.)
Such a statement is executed by the activity as if in a single step
during which all other activities are frozen.

\paragraph{Asynchronous activities.}

An asynchronous activity is created by a statement \xcd"async (P) S"
where \xcd"P" is a place expression and \xcd"S" is a statement.  Such
a statement is executed by spawning an activity at the place
designated by \xcd"P" to execute statement \xcd"S".

An asynchronous expression of type \xcd"Future[T]" has the form
\xcd"future (p) e" where \xcd"e" is an expression of type
\xcd"T".  The expression \xcd"e"
may reference \xcd`val`s and shared \xcd`var`s declared in the lexically
enclosing environment.  It executes the expression \xcd"e" at the
place \xcd"p" as an asynchronous activity, immediately returning with
a future. The future may later be forced causing the activity to be
blocked until the return value has been computed by the asynchronous
activity.

\section{Clocks}
The MPI style of coordinating the activity of multiple processes with
a single barrier is not suitable for the dynamic network of (possibly
diverse) activities in an \Xten{} computation. Instead, it becomes
necessary to allow a computation to use multiple barriers. \Xten{}
\emph{clocks} (\Sref{XtenClocks}) are designed to offer the
functionality of multiple barriers in a dynamic context while still
supporting determinate, deadlock-free parallel computation.

Activities may use clocks to repeatedly detect quiescence of arbitrary
programmer-specified, data-dependent set of activities. Each activity
is spawned with a known set of clocks and may dynamically create new
clocks. At any given time an activity is \emph{registered} with zero or
more clocks. It may register newly created activities with a clock,
un-register itself with a clock, suspend on a clock or require that a
statement (possibly involving execution of new async activities) be
executed to completion before the clock can advance.  At any given
step of the execution a clock is in a given phase. It advances to the
next phase only when all its registered activities have \emph{quiesced}
(by executing a \xcd"next" operation on the clock).
When a clock advances, all its activities may now resume execution.

Thus clocks act as \emph{barriers} for a dynamically varying collection
of activities. They generalize the barriers found in MPI style program
in that an activity may use multiple clocks simultaneously. Yet
programs using clocks are guaranteed not to suffer from
deadlock.

\futureext{In future versions of the language,
clocks will be integrated into the \Xten{} type system,
permitting variables to be declared so that they are \xcd`val` in each
phase of a clock.}

\section{Arrays, regions and distributions}

An \Xten{} array type is a map from a \emph{distribution}
(\Sref{XtenDistributions}) to a type, which may itself be an
array type.

% POINT REGION
A distribution is a map from a \emph{region} (\Sref{XtenRegions}) to
places.  A region is a collection of \emph{points} or
\emph{indices}. For instance, the region \xcd"[0..200,1..100]" specifies
a collection of two-dimensional points \xcd"(i,j)" with
\xcd"i" ranging from \xcd"0" to \xcd"200" and \xcd"j" ranging
from \xcd"1" to \xcd"100". Points are used in array index expressions
to pick out a particular array element.

Operations are provided to construct regions from other regions, and
to iterate over regions. Standard set operations, such as union,
disjunction and set difference are available for regions.

A primitive set of distributions is provided, together with operations
on distributions. A \emph{sub-distribution} of a distribution is one
defined on a smaller region and agrees with the distribution
at all points.  The standard operations on regions are extended to
distributions.

% XXX views

A new array can be created by restricting an existing array to a
sub-distribution, by combining multiple arrays, and by performing
pointwise operations on arrays with the same distribution.

\Xten{} allows array constructors to iterate over the underlying
distribution and specify a value at each item in the underlying
region. Such a constructor may spawn activities at multiple places.

\emph{In future versions of the language, a programmer may specify new
distributions, and new operations on distributions.}

\section{Annotations}

\Xten{} supports annotations on classes and interfaces, methods
and constructors,
variables, types, expressions and statements.
These annotations may be processed by compiler plugins.

\section{Translating MPI programs to \Xten{}}

While \Xten{} permits considerably greater flexibility in writing
distributed programs and data structures than MPI, it is instructive
to examine how to translate MPI programs to \Xten.

Each separate MPI process can be translated into an \Xten{}
place. Async activities may be used to read and write variables
located at different processes. A single clock may be used for barrier
synchronization between multiple MPI processes. \Xten{} collective
operations may be used to implement MPI collective operations.
\Xten{} is more general than MPI in (a)~not requiring synchronization
between two processes in order to enable one to read and write the
other's values, (b)~permitting the use of high-level atomic blocks
within a process to obtain mutual exclusion between multiple
activities running in the same node (c)~permitting the use of multiple
clocks to combine the expression of different physics (e.g.,
computations modeling blood coagulation together with computations
involving the flow of blood), (d)~not requiring an SPMD style of
computation.


%\note{Relaxed exception model}
\section{Summary and future work}
\subsection{Design for scalability}
\Xten{} is designed for scalability. An activity may atomically
access only multiple locations in the current place. Unconditional
atomic blocks are statically guaranteed to be non-blocking, and may
be implemented using non-blocking techniques that avoid mutual
exclusion bottlenecks. Data-flow synchronization permits point-to-point
coordination between reader/writer activities, obviating the need for
barrier-based or lock-based synchronization in many cases.

\subsection{Design for productivity}
\Xten{} is designed for productivity.

\paragraph{Safety and correctness.}
Programs written in \Xten{} are guaranteed to be statically
\emph{type safe}, \emph{memory safe} and \emph{pointer safe}. Static type safety
guarantees that at run time a location contains only those values whose

dynamic type satisfies the constraints imposed by the location's
static type and every run-time operation performed on the value in a
location is permitted by the static type of the location.

Memory safety guarantees that an object may only access memory within
its representation, and other objects it has a reference to. \Xten{}
supports no pointer arithmetic, and bound-checks array accesses
dynamically if necessary. \Xten{} uses dynamic garbage collection to
collect objects no longer referenced by the computation. \Xten{}
guarantees that no object can retain a reference to an object
whose memory has been reclaimed.  Further, \Xten{} guarantees that
every location is initialized at run time before it is read,
and every value read from a location has previously been written into
that location.

%XXX
%Pointer safety guarantees that a null pointer exception cannot be
%thrown by an operation on a value of a non-nullable type.

Because places are reflected in the type system, static type safety
also implies \emph{place safety}: a location may contain references to only
those objects whose location satisfies the restrictions of the static
place type of the location.

\Xten{} programs that use only clocks and unconditional atomic
blocks are guaranteed not to deadlock. Unconditional atomic blocks
are non-blocking, hence cannot introduce deadlocks (assuming the
implementation is correct).

Many concurrent programs can be shown to be determinate (hence
race-free) statically.

\paragraph{Integration.}
A key issue for any new programming language is how well it can be
integrated with existing (external) languages, system environments,
libraries and tools.

We believe that \Xten{}, like \java{}, will be able to support a large
number of libraries and tools. An area where we expect future versions
of \Xten{} to improve on \java{} like languages is \emph{native
integration} (\Sref{extern}). Specifically, \Xten{} will permit
permit multi-dimensional local arrays to be operated on natively by
native code.

%% Portability measures the amount of effort required to move an
%% application across multiple platforms, architectures and system
%% generations. The performance portability of applications across widely
%% different computer architectures (distributed cluster vs. vector
%% processor) depends significantly on inherent properties of the
%% underlying algorithms used in the application.
%%
\subsection{Conclusion}
{}\Xten{} is considerably higher-level than thread-based languages in
that it supports dynamically spawning very lightweight activities, the
use of atomic operations for mutual exclusion, and the use of clocks
for repeated quiescence detection.

Yet it is much more concrete than languages like HPF in that it forces
the programmer to explicitly deal with distribution of data
objects. In this the language reflects the designers' belief that
issues of locality and distribution cannot be hidden from the
programmer of high-performance code in high-end computing.  A
performance model that distinguishes between computation and
communication must be made explicit and transparent.\footnote{In this
\Xten{} is similar to more modern languages such as ZPL \cite{zpl}.}
At the same time we believe that the place-based type system and
support for generic programming will allow the \Xten{} programmer to
be highly productive; many of the tedious details of
distribution-specific code can be handled in a generic fashion.

We expect the next version of the language to be significantly
informed by experience in implementing and using the language. We
expect it to have constructs to support continuous program
optimization, and allow the programmer to provide guidance on
clustering places to (hardware) nodes. For instance, we may introduce
a notion of hierarchical clustering of places.
