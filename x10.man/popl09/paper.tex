\documentclass[preprint,nocopyrightspace,9pt]{sigplanconf}
%\documentclass{llncs}

\newif\iflncs
\lncsfalse

\usepackage{times-lite}
\usepackage{mathptm}
\usepackage{txtt}
\usepackage{stmaryrd}
\usepackage{code}
\usepackage{bcprules}
%\usepackage{ttquot}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{afterpage}
\usepackage{balance}
\usepackage{floatflt}
\usepackage{defs}
\usepackage{utils}
\usepackage[pdftex]{graphicx}
\usepackage{xspace}
\usepackage{ifpdf}
\usepackage{listings}
\usepackage{x10}

\newif\ifsemantics
%\semanticsfalse
\semanticstrue

\hfuzz=1pt

\pagestyle{plain}


\ifpdf
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}
\fi


% \input{../../../../vj/res/pagesizes}
% \input{../../../../vj/res/vijay-macros}
\newcommand\alt{\bnf}

\newcommand\Implies{\Rightarrow}

\iflncs
\else
\newtheorem{example}{Example}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newenvironment{proof}{
\trivlist
\item[\hskip \labelsep \textsc{Proof.}]
\selectfont
\ignorespaces}{$\Box$}

%\newtheorem{proof}[theorem]{Proof}
\fi

\begin{document}

\title{Genericity through Dependent Types}

\iflncs

\author{
Nathaniel Nystom\inst{1}
\and
Igor Peshansky\inst{1}
\and
Vijay Saraswat\inst{1}
}

\institute{IBM T.~J. Watson Research~Center, P.O.~Box~704, Yorktown~Heights NY 10598 USA,
\email{\{nystrom,vsaraswa\}@us.ibm.com}}

\else

\authorinfo{Nathaniel Nystrom\titlenote{IBM T.~J. Watson Research
Center, P.O. Box 704, Yorktown Heights NY 10598 USA}}{}
  {nystrom@us.ibm.com}
\authorinfo{Igor Peshansky$^{\;*}$}{}
  {igorp@us.ibm.com}
\authorinfo{Vijay Saraswat$^{\;*}$}{}
  {vsaraswa@us.ibm.com}

% \conferenceinfo{POPL'08}{XXX}
% \copyrightyear{2008}
% \copyrightdata{[to be supplied]}

\fi

\maketitle

\begin{abstract}
Genericity is a key requirement for modern object-oriented languages.
In this paper, we describe a design for generic types in
the programming language X10.
X10 has an expressive and powerful dependent type system
in which types are specified by constraining the immutable state
of objects.  Generic types are defined
in a natural extension of the
dependent type system.


The immutable state of an object is represented by its
\emph{properties}, public final fields of the object.
A \emph{constrained type} then, is a defined by a class type and
a boolean predicate on the properties of the class.
Generic types are defined by first introducing \emph{type properties} into
the language, and then constraining those properties using
subtyping constraints.

The type system presented  here  subsumes the expressive power
of Java's generic types, virtual types,
and generalized constraints proposed for C\#.
The system also admits an efficient implementation
and eschews the pitfalls of a type erasure semantics.
We describe also a local type inference algorithm for constrained
types that permits type annotations and constraints to be elided
by the programmer.
\end{abstract}

\section{Introduction}

\todo{Possible claim: first type system
that combines genericity and dep types in some vague general way.}

\todo{Incorporate some text from OOPSLA paper on deptypes.}

\todo{Cite liquid types and whatever it cites}

X10 is a statically typed object-oriented language
designed for high-performance computing~\cite{X10}. The language extends a
class-based sequential core language similar to Java
with constructs for distribution and
fine-grained concurrency.  However, X10 does not yet support
generic types, a standard feature of modern object-oriented languages.
This paper presents a design for generics that is a natural
extension of the language's core dependent type system.

The sequential semantics of X10 are similar to Java's
X10 programs and execute on a Java virtual machine.
After evaluating several existing proposals for generic types in
Java-like
languages~\cite{Java3,adding-wildcards,GJ,Pizza,polyj,thorup97,allen03,allen04,csharp,emir06,scala},
we concluded that these proposals were insufficient for our needs.

% Most of these languages support genericity through parameterized
% types.
A problem with many of these proposals, and in particular with
Java5~\cite{Java3} and Scala~\cite{scala}, is that generic types
are implemented via type erasure.
Our design is not implemented via type erasure and, in addition,
supports run-time introspection of generic types.

Another problem with many of these proposals is inadequate support
for primitive types, especially arrays. The performance of primitive arrays is
critical for the high-performance applications for which
X10 is intended. These proposals introduce unnecessary boxing
and unboxing of primitives.
Our design does not require primitives be boxed.

The design of generics in X10 and is based on its existing
dependent type system~\cite{X10,constrained-types}.
To rule out large classes of errors statically,
X10 provides \emph{constrained types},
a form of dependent type
defined on predicates over the immutable state of
objects~\cite{X10,constrained-types}.
%
The immutable state of an object is captured by its
\emph{value properties}: public final fields of the object.
For instance, the following class declares a two-dimensional
point with properties \xcd"x" and \xcd"y" of type \xcd"float":
\begin{xten}
class Point(x: float, y: float) { }
\end{xten}
A constrained type is a type \xcd"C{e}", where \xcd"C" is a
class and \xcd"e" is a boolean predicate on the properties of
\xcd"C" and the final variables in scope at the type.
For example, given the above class definition,
the type \xcd"Point{x*x+y*y<1}" is the type of all
points within the unit circle.

To support genericity these types are generalized
to allow \emph{type properties} and constraints on these properties.
Like a value property, a type property is an instance member.
The type properties of an object are bound to concrete types
when the object is
created.
Types may be defined by constraining the type properties as
well as the value properties of a class.

The following code declares a class \xcd"Cell" with a type
property named \xcd"T".
\begin{xten}
class Cell[T] {
    var x: T;
    def get(): T = x;
    def set(x: T) = { this.x = x: }
}
\end{xten}
The class has a mutable field \xcd"x",
and has \xcd"get" and \xcd"set" methods for accessing the field.

This example shows that type properties are in many ways similar to
type parameters as provided in object-oriented languages such as
Java and Scala.
Type properties are types in their own right:
they may be used in any context a type may be used,
including in \xcd"instanceof" and cast expressions.
However, the key semantic distinction between type properties
and type parameters is that type properties are instance
members.
Thus, for an expression \xcd"e" of type \xcd"Cell", \xcd"e.T" is
a type, equivalent to the concrete type to which \xcd"T" was
initialized when the object \xcd"e" was instantiated.
To ensure
soundness, \xcd"e" is restricted to final access paths.
Within the body of a class, a property name \xcd"T" resolves
to \xcd"this.T" (or to \xcd"C.this.T" if \xcd"T" is a property of
an enclosing class \xcd"C"), just as value properties are
resolved.

As with value properties, type properties may be constrained
by predicates to produce new types.
X10 supports
equality constraints, written \xcdmath"T$_1$==T$_2$", and
subtyping constraints, written \xcdmath"T$_1$<:T$_2$".
For instance, the type \xcd"Cell{T==String}" is the type of
all \xcd"Cell"s that contain a \xcd"String".

In general, the syntax of a constrained type is
\xcd"C{c}", where \xcd"C" is a base class and
\xcd"c" is a predicate on the properties of \xcd"C".
For brevity, a constraint can be written as
a comma-separated list of conjuncts; that is, the constraint
\xcd"c1"~\xcd"&&"~\xcd"c2" can be written
\xcd"c1,"~\xcd"c2".

Constraints on properties induce a natural subtyping relationship:
\xcd"C{c}" is a subtype of
\xcd"D{d}" if \xcd"C" is a subclass of \xcd"D" and
\xcd"c" entails \xcd"d".

We consider here only constraints on type properties.
See Nystrom et al.~\cite{constrained-types} for a more thorough
presentation of constrained types in X10.
The following are legal types:
\begin{itemize}
\item \xcd"Cell".  This type has no constraints on \xcd"T".
Any type that constrains \xcd"T", those below,
is a subtype of \xcd"Cell".  The type \xcd"Cell" is equivalent to
\xcd"Cell{true}".
%
For a \xcd"Cell" \xcd"c", the return type of the \xcd"get" method
is \xcd"c.T".
Since the property \xcd"T" is unconstrained,
the caller can only assign the return value of \xcd"get"
to a variable of type \xcd"c.T" or of type \xcd"Object".
In the following code, \xcd"y" cannot be passed to the \xcd"set" method
because it is not known if \xcd"Object" is a subtype of \xcd"c.T".
\begin{xten}
val x: c.T = c.get();
val y: Object = c.get();
c.set(x); // legal
c.set(y); // illegal
\end{xten}

\item \xcd"Cell{T==float}".
The type property \xcd"T" is bound to \xcd"float".
Assuming \xcd"c" has this type, the following code is legal:
\begin{xten}
val x: float = c.get();
c.set(1.0);
\end{xten}
The type of \xcd"c.get()" is \xcd"c.T", which is equivalent to
\xcd"float".
Similarly, the \xcd"set" method takes a \xcd"float" as argument.

\item \xcd"Cell{T<:int}".
This type constrains \xcd"T" to be a subtype of \xcd"int".
All instances of this type must bind \xcd"T" to a subtype of \xcd"int".
The following expressions have this type:
\begin{xten}
new Cell[int](1);
new Cell[int{self==3}](3);
\end{xten}
The cell in the first expression may contain any \xcd"int".
The cell in the second expression may contain only \xcd"3".
%
If \xcd"c" has the type \xcd"Cell{T<:int}",
then \xcd"c.get()" has type \xcd"c.T", which is an unknown but
fixed subtype of \xcd"int".  The \xcd"set" method of \xcd"c" can
only be called with an object of type \xcd"c.T".

\item \xcd"Cell{T:>String}".  This type bounds the type property
\xcd"T"
from below.  The \xcd"set" method may be called with any
supertype of \xcd"String"; the return type of the \xcd"get"
method is known to be a
supertype of \xcd"String" (and implicitly a subtype of \xcd"Object").
\end{itemize}

For brevity, the constraint may be omitted and
interpreted as \xcd"true".
The syntax
\xcd"C[T1,...,Tm](e1,...,en)" is sugar for
\xcd"C{X1==T1,...,Xm==Tm,x1==e1,...,xn==en}"
where \xcd"Xi" are the type properties and \xcd"xi" are the
value properties of \xcd"C".
If either list of properties is empty, it may be omitted.

In this shortened syntax, a type argument \xcd"T" used may also be annotated
with
a \emph{use-site variance tag}, either \xcd"+" or \xcd"-":
if \xcd"X" is a type property, then
the syntax \xcd"C[+T]" is sugar \xcd"C{X<:T}" and
\xcd"C[-T]" is sugar \xcd"C{X:>T}"; of course,
\xcd"C[T]" is sugar \xcd"C{X==T}".

The rest of the paper\dots

\section{X10}

Before describing the generic type system, we present an
overview of X10's syntax and semantics.
X10 is a class-based language similar to Java or Scala.
Superficially, the language may be thought of as sequential
Java with some elements of Scala syntax and with new constructs
for concurrency and distribution.
Like Java, the language provides both classes and interfaces; it does not
yet support traits, as found in Scala.

Both classes and interfaces may define properties. Value
properties may be considered to be public final fields. Whereas
Java supports only static fields in interfaces, X10
allows interfaces to define value properties. Any class implementing
an interface must declare, and initialize in its
constructor,
the properties inherited from the interface.

Classes may define fields, methods, and constructors. The
declaration syntax,
illustrated in the \xcd"Cell" example
above,
is similar to Scala's.  Fields may be
declared either \xcd"val" or \xcd"var".  A \xcd"val" is n
\emph{final} and must be assigned exactly once.  Methods are
declared with a \xcd"def" keyword.
As in Java, methods may be declared \xcd"static", however fields cannot.
Constructor syntax is
similar to method syntax and X10 adopts Scala's convention of
using the name \xcd"this" for constructors.
In X10, constructors have a return type, which constrains
the properties of the new object.

\if 0
\section{Typing}

As stated above, if \xcd"p" is a final access path of a
type with property \xcd"T", then \xcd"p.T" is a legal type.
Given an expression context \xcd"E"$[\cdot]$, if
the expression \xcd"E"$[{\tt x}]$ has type \xcd"x.T",
then the expression \xcd"E"$[{\tt e}]$ has type \xcd"z.T",
where ${\tt z} = {\tt e}$ if \xcd"e" is a final access path
or else \xcd"z" is a fresh variable.
\fi

\section{Generics}

\subsection{Subtyping}

\xcd"C{c}" is a subtype of \xcd"D{d}" if \xcd"C" is a subclass
of \xcd"D" and \xcd"c" entails \xcd"d".

\subsection{Use-site variance}

\subsection{Class declarations}

Classes may be declared with any number of type properties and
value properties.  These properties can be constrained with a
\emph{class invariant}, specified by a \xcd"where" clause,
a predicate on the properties of any instance of the class.
%
The general form of a class definition is:
\begin{xtenmath}
class C[X$_1$, $\dots$, X$_p$](x$_1$: T$_1$, $\dots$, x$_k$: T$_k$)
      where c
      extends B{c$_0$}
      implements I$_1${c$_1$}, $\dots$, I$_n${c$_n$} {$\dots$}
\end{xtenmath}

\subsection{Definition-site variance}

In a class definition,
a type property may be declared with a \emph{definition-site variance tag}, either \xcd"+" or
\xcd"-".  A \xcd"+" tag indicates that the class is covariant on
the property; that is, given a definition
\xcd"Cell[+T]",
if \xcd"A" $\subtype$ \xcd"B", then
\xcd"Cell[A]" $\subtype$ \xcd"Cell[B]".
Similarly,
\xcd"Cell[-T]" indicates that \xcd"T" is contravariant in \xcd"Cell";
that is, if \xcd"A" $\subtype$ \xcd"B", then
\xcd"Cell[B]" $\subtype$ \xcd"Cell[A]".

A definition-site variance tag changes the meaning of the
syntactic sugar for the type \xcd"Cell[A]".
If the property is covariant (i.e., is declared as \xcd"+T"), \xcd"Cell[A]"
is sugar for \xcd"Cell{T<:A}".
If the property is contravariant (\xcd"-T"), then \xcd"Cell[A]"
is sugar for \xcd"Cell{T:>A}".
Otherwise, the property is invariant and \xcd"Cell[A]"
is sugar for \xcd"Cell{T==A}".

The compiler should issue a warning if
a covariant property is used in a negative position (e.g., in a
method parameter type)
in its class definition,
or if a contravariant property is used in a positive position
(e.g., in a method return type).
Without these restrictions, methods or fields with types
dependent on the property would be safe, but not be accessible
using the default instantiation (e.g., \xcd"Cell[int]").

\if 0
More formally, a type property cannot be used in a position
where its actual variance differs from its declared variance.

\infrule{
\vdash_{+} T
\vdash_{-} T
}{
var x \ty T = e
}

\infrule{
\vdash_{+} T
}{
val x \ty T = e
}

\infrule{
\vdash_{-} T1
\vdash_{+} T2
\vdash_{-} c
}{
def f(x: T1) \ty T2 where c = e
}

\infrule{
\vdash_{+}
}{}
\fi

\if 0
%
A type appears in a negative position if:
\begin{itemize}
\item it is the type of a mutable or immutable field; or,
\item it is the type of a method formal parameter; or,
\item it appears in a constraint on a type that is in a negative position
and the constraint bounds it from above; or,
\item it appears in a constraint on a type that is in a positive position
and the constraint bounds it from below.
\end{itemize}
%
A type appears in a positive position if:
\begin{itemize}
\item it is the type of a mutable field; or,
\item it is a method return type; or,
\item it appears in a constraint on a type that is in a negative position
and the constraint bounds it from below; or,
\item it appears in a constraint on a type that is in a positive position
and the constraint bounds it from above.
\end{itemize}
\fi

\subsection{Class invariant}

\subsection{Method parameters}

Methods and constructors may have type parameters.
For instance, the \xcd"List" class below defines a \xcd"map"
method that maps each element of a list of \xcd"T"
to a value of another type \xcd"S", constructing a new list of
\xcd"S".
\begin{xten}
class List[T] {
    val array: Array[T];
    def map[S](f: T => S): List[S] {
        val newArray = new Array[S](array.length);
        for (i in [0:array.length-1]) {
            newArray(i) = f(array(i));
        }
        return new List(newArray);
    }
}
\end{xten}


A parameterized method can is invoked by giving type arguments before the
expression arguments.  For example, the following code takes a
list of \xcd"String"s and returns a list of string lengths of
type \xcd"int"
\begin{xten}
xs: List[String] = ...;
ys: List[int] = xs.map[int](
        (x: String) => x.length());
\end{xten}

\subsection{Method where clauses}

Method and constructor parameters, both value parameters and
type parameters,
can be constrained with a where clause on the method.
For type parameters,
this feature is similar to generalized constraints proposed for
C\#~\cite{emir06}.
%
In the following code, the \xcd"T" parameter is covariant
and so the \xcd"append" methods below are illegal:
\begin{xten}
class List[+T] {
   def append(other: T): List[T] = { ... }
        // illegal
   def append(other: List[T]): List[T] = { ... }
        // illegal
}
\end{xten}
%
However, one can introduce a method parameter and then constrain
the parameter from below by the class's parameter:
For example, in the following code,
\begin{xten}
class List[+T] {
   def append[U](other: U)
        {T <: U}: List[U] = { ... }
   def append[U](other: List[U])
        {T <: U}: List[U] = { ... }
}
\end{xten}

The constraints must be satisfied by the callers of \xcd"append".
For example, in the following code:
\begin{xten}
xs: List[Number];
ys: List[Integer];
xs = ys; // ok
xs.append(1.0); // legal
ys.append(1.0); // illegal
\end{xten}
the call to \xcd"xs.append" is allowed and the result type is \xcd"List[Number]", but
the call to \xcd"ys.append" is not allowed because the caller cannot show that
${\tt Number} \subtype {\tt Double}$.

\subsection{Method overriding}

Legal if any call to super method can call sub method.

covariant return
contravaraint args
weaker where clause

\subsection{Constructor definitions}

Constructors are defined using the syntax \xcd"def this",
as shown in Figure~\ref{fig:grammar}.
%
Constructors must ensure that all properties of the new object
are initialized and that the class invariants of the object's
class and its superclasses and superinterfaces hold.

Properties are initialized with a \xcd"property" statement.
For instance, the
constructor for \xcd"Cell" ensures that the type property \xcd"T" is bound.
\begin{xten}
    def this[T](x: T) =
      { property[T](); this.x = x; }
\end{xten}
The \xcd"property" statement is used to set all the properties
of the new object simultaneously; the syntax is similar to a \xcd"super"
constructor call.

If the \xcd"property" statement is omitted, the compiler implicitly
initailizes the properties from the formal type and value parameters
of the constructor.  The property statement for \xcd"Cell"'s constructor,
for example, could have been omitted.

Constructors have ``return
types'' that can specify an invariant satisfied by the object being
constructed.  The compiler verifies that the
constructor return type and the class invariant are implied by the
\xcd"property" statement and any \xcd"super"
or \xcd"this" calls in the constructor body.

Classes that do not declare a constructor
have a default constructor with a type parameter for each
type property and a value parameter for each value property.

\section{Formal semantics}

\newcommand\gxx{GenX10\xspace}

We present a core calculus, \gxx, for X10 with generics.
\gxx is based on Constrained Featherweight
Java~\cite{constrained-types}.

\todo{
Add method overriding rules: covariant return, contravariant
args, weaker constraints
}

The grammar for \gxx is shown in 
Figure~\ref{fig:grammar}.  The calculus elides features of the
full X10 language not relevant to this paper.

\begin{figure}[tp]
\begin{center}
\begin{tabular}{lrcl}
classes & {\tt L} & ::= &
\xcdmath"class C[$\bar{\tt X}$]($\bar{\tt x}$: $\bar{\tt T}$){c}" \\
& & & \xcdmath"  extends T { K $\bar{\tt M}$ }" \\
types & {\tt T} & ::= & \xcd"C" \\
            & & \bnf & \xcd"X" \\
            & & \bnf & \xcd"e.X" \\
            & & \bnf & \xcd"T{c}" \\
            & & \bnf & $\exists\Xcd{x}\ty\Xcd{T}$.~\xcd"T" \\
            & & \bnf & $\exists\Xcd{X}\ty\Xcd{type}$.~\xcd"T" \\
constructors      & {\tt K} & ::= &
\xcdmath"def this[$\bar{\tt X}$]($\bar{\tt x}$: $\bar{\tt T}$){c}: T = {" \\
                      &         &     &
\xcdmath"  super[${\tt X}_{1..i}$](${\tt x}_{1..j}$);" \\
                      &         &     &
\xcdmath"  property[${\tt X}_{i+1..m}$](${\tt x}_{j+1..n}$); }" \\
%\xcdmath"  property[${\tt X}_{i+1..m}$](${\tt x}_{j+1..k}$);" \\
                      %&         &     &
%\xcdmath"  $\bar{\tt f}$ = ${\tt x}_{k+1..n}$; }" \\
methods     & {\tt M} & ::= &
\xcdmath"def m[$\bar{\tt X}$]($\bar{\tt x}$: $\bar{\tt T}$){c}: T = e" \\
expressions & {\tt e} & ::= & \dots \\
constraint terms & {\tt t} & ::= & \\
\quad literals        &         &      & \xcd"true" \bnf $n$ \bnf \xcd"C" \\
\quad variables       &         & \bnf & \xcd"x" \bnf \xcd"X" \\
\quad properties      &         & \bnf & \xcd"t".\xcd"x" \bnf \xcd"t".\xcd"X" \\
\quad atoms           &         & \bnf & \xcdmath"f(t$_1$,$\dots$,t$_n$)" \\
constraint & {\tt c} & ::=  & \Xcd{true} \\
                  &  & \bnf & $\Xcd{t}_1 \equals \Xcd{t}_2$ \\
                  &  & \bnf & $\Xcd{t}_1 \subtype \Xcd{t}_2$ \\
                  &  & \bnf & $\exists$\Xcd{x}.~\Xcd{c} \\
                  &  & \bnf & $\bar{\Xcd{c}}$ \\
                  &  & \bnf & \xcdmath"p(t$_1$,$\dots$,t$_n$)" \\
environments & $\Gamma$ & ::=  & $\epsilon$ \\
            &          & \bnf & $\Gamma$, $\Xcd{x} \ty \Xcd{T}$ \\
            &          & \bnf & $\Gamma$, $\Xcd{X} \ty \Xcd{type}$ \\
\end{tabular}
\end{center}
\caption{\gxx grammar}
\label{fig:grammar}
\end{figure}

\subsection{
Constraint system
}

% Handbook of philosophical logic, Gabbay

The X10 compiler permits the constraint system to be extended
with compiler plugins.  The base compiler supports equality
constraints over literals and final variables and subtyping
and equality
constraints over types.
The core constraint system is presented here.  We assume a
constraint solver {\cal C} implementing the plugged-in
constraint systems.

The constraint system does not distinguish between values and
types.  Logical variables \xcd"x" may represent program variables
or type variables.  Field accesses and member type references
are special cases of atomic
formulas; we write \Xcd{p.f} as sugar for \Xcd{f(p)}.

The constraint system is shown in Figure~\ref{fig:constraints}.
$\bar{\Xcd{c}}$ is a set of constraints.
The constraint system satisfies the structural rules, and
supports equality and subtyping
constraints over terms.

\begin{figure}

\infax[I]{ \bar{\Xcd{c}}, \Xcd{c} \vdashC \Xcd{c} }

\infrule[Cut]{ \bar{\Xcd{c}} \vdashC \Xcd{e} \andalso
\bar{\Xcd{c}}, \Xcd{e} \vdashC \Xcd{d} }
                     { \bar{\Xcd{c}} \vdashC \Xcd{d} }
\infrule[Contraction]{ \bar{\Xcd{c}}, \Xcd{c}, \Xcd{c} \vdashC \Xcd{d} }
                     { \bar{\Xcd{c}}, \Xcd{c} \vdashC \Xcd{d} }
% \infrule[Permutation]{ \bar{\Xcd{c}}, \Xcd{c}, \Xcd{d} \vdashC \Xcd{e} }
                     % { \bar{\Xcd{c}}, \Xcd{d}, \Xcd{c} \vdashC \Xcd{e} }
% \infrule[Extension]{ \bar{\Xcd{c}}, \vdashC \Xcd{c} }
                     % { \bar{\Xcd{c}}, \bar{\Xcd{c}}' \vdashC \Xcd{c} }
\eat{
\infrule[R-$\rightarrow$]{ \bar{\Xcd{c}}, \Xcd{c} \vdashC \Xcd{d} }
                     { \bar{\Xcd{c}} \vdashC \Xcd{c} \rightarrow \Xcd{d} }
\infrule[L-$\rightarrow$]{
        \bar{\Xcd{c}}, \Xcd{c} \rightarrow \Xcd{d} \vdashC \Xcd{c}
                \andalso
        \bar{\Xcd{c}}, \Xcd{c} \rightarrow \Xcd{d}, \Xcd{d} \vdashC \Xcd{e} }
                     { \bar{\Xcd{c}}, \Xcd{c} \rightarrow \Xcd{d} \vdashC \Xcd{e} }
}

\infrule[Eq-atom]
{ \bar{\Xcd{c}} \vdashC \bar{\Xcd{s}} \equals \bar{\Xcd{t}} }
{ \bar{\Xcd{c}} \vdashC \Xcd{f(}\bar{\Xcd{s}}\Xcd{)} \equals \Xcd{f(}\bar{\Xcd{t}}\Xcd{)} }

% \infrule[Eq-field]{ \bar{\Xcd{c}} \vdashC \Xcd{t}_1 \equals \Xcd{t}_2 }
                  % { \bar{\Xcd{c}} \vdashC \Xcd{t}_1.\Xcd{f} \equals \Xcd{t}_2.\Xcd{f} }
% \infrule[Eq-type]{ \bar{\Xcd{c}} \vdashC \Xcd{t}_1 \equals \Xcd{t}_2 }
                  % { \bar{\Xcd{c}} \vdashC \Xcd{t}_1.\Xcd{X} \equals \Xcd{t}_2.\Xcd{X} }

\infax[Eq-refl]{ \bar{\Xcd{c}} \vdashC \Xcd{t} \equals \Xcd{t} }

\infrule[Eq-trans]{
        \bar{\Xcd{c}} \vdashC \Xcd{t}_1 \equals \Xcd{t}_2
        \andalso
        \bar{\Xcd{c}} \vdashC \Xcd{t}_2 \equals \Xcd{t}_3
        }
        { \bar{\Xcd{c}} \vdashC \Xcd{t}_1 \equals \Xcd{t}_3 }

\infrule[Eq-sym]{
        \bar{\Xcd{c}} \vdashC \Xcd{t}_1 \equals \Xcd{t}_2
        }
        { \bar{\Xcd{c}} \vdashC \Xcd{t}_2 \equals \Xcd{t}_1 }

\infrule[Eq-sub]{
\bar{\Xcd{c}} \vdashC \Xcd{T}_1 \subtype \Xcd{T}_2 \\
\bar{\Xcd{c}} \vdashC \Xcd{T}_2 \subtype \Xcd{T}_1
}{
\bar{\Xcd{c}} \vdashC \Xcd{T}_1 \equals \Xcd{T}_2
}

\infrule[Sub-cons]{
\bar{\Xcd{c}} \vdashC \Xcd{C\{c\}} \ty \Xcd{type}
\andalso
\bar{\Xcd{c}}, \Xcd{c} \vdashC \Xcd{d}
}{
\bar{\Xcd{c}} \vdashC \Xcd{C\{c\}} \subtype \Xcd{C\{d\}}
}

\infrule[Sub-super]{
\mbox{\Xcdmath{C[$\bar{\tt X}$]($\bar{\tt x}$: $\bar{\tt T}$)\{c\} ext T \{\ $\bar{\tt M}$\ $\bar{\tt F}$\ \}}}
}{
\vdashC \Xcd{C} \subtype \Xcd{T} \\
}

\infrule[Sub-eq]{
\bar{\Xcd{c}} \vdashC \Xcd{T}_1 \equals \Xcd{T}_2
}{
\bar{\Xcd{c}} \vdashC \Xcd{T}_1 \subtype \Xcd{T}_2
}

\infrule[Sub-trans]{
\bar{\Xcd{c}} \vdashC \Xcd{T}_1 \subtype \Xcd{T}_2
\andalso
\bar{\Xcd{c}} \vdashC \Xcd{T}_2 \subtype \Xcd{T}_3
}{
\bar{\Xcd{c}} \vdashC \Xcd{T}_1 \subtype \Xcd{T}_3
}

\caption{Constraints}
\label{fig:subtyping}
\label{fig:constraints}
\end{figure}



\subsection{
Constraint projection
}

First, for a type environment $\Gamma$,
we define the \emph{constraint projection},
$\sigma(\Gamma)$ thus:

\begin{align*}
\sigma(\epsilon) &= \Xcd{true} \\
\sigma(\Gamma, \Xcd{x} \ty \Xcd{T}) &=
        \sigma(\Gamma),
        \cons{\Xcd{T}}{\Xcd{x}}
\\
\sigma(\Gamma, \Xcd{c}) &= \sigma(\Gamma), \Xcd{c} \\
\end{align*}

The
auxiliary function $\mathit{cons}$
specifies the constraint for a type \Xcd{T} with \Xcd{self}
bounds to \Xcd{x}.
For type variables, the
the constraint projection uses an atomic formula \Xcd{cons}.

\begin{align*}
\cons{\Xcd{C}}{\Xcd{z}} &= \Xcd{true} \\
\cons{\Xcd{C\{c\}}}{\Xcd{z}} &= \Xcd{c}[\Xcd{z}/\Xcd{self}] \\
\cons{\Xcd{p.X}}{\Xcd{z}} &= \Xcd{cons(p.X,z)} \\
\cons{\Xcd{X}}{\Xcd{z}} &= \Xcd{cons(X,z)} \\
\end{align*}

\noindent
Thus, for example, the constraint projection of the environment:
\begin{quote}
\xcdmath"b: D, a: C{self.X==D{d},self.Y<:b.Z}"
\end{quote}
\noindent is:
\begin{quote}
\xcdmath"a.X==D{d}, a.Y<:b.Z" \\
\end{quote}

\eat{
\subsection{
        Judgements
}

The following judgements will be defined:

\begin{itemize}
\item
     The type {\tt T} is well-formed, given the assumptions $\Gamma$:

    $\Gamma \vdash {\tt T} \ty {\tt type}$

\item
     The type {\tt S} is a subtype of {\tt T}, under the assumption $\Gamma$:

      $\Gamma \vdash {\tt S} \subtype {\tt T}$

    \item The expression {\tt e} is of type {\tt T}, given the assumptions $\Gamma$:

      $\Gamma \vdash {\tt e} \ty {\tt T}$

    \item The method {\tt M} is well-defined for the class {\tt C}
given assumptions $\Gamma$:

      $\Gamma \vdash {\tt M}~\mbox{OK in}~{\tt C}$

    \item The field {\tt f: T} is well defined for the class {\tt C} given assumptions $\Gamma$:

      $\Gamma \vdash {\tt f: T}~\mbox{OK in}~C$

    \item The class definition {\tt L} is well defined given assumptions $\Gamma$:

      $\Gamma \vdash {\tt L}~\mbox{OK}$

\end{itemize}


In what follows we will sometimes think of the family of five judgements
as a single judgement $\Gamma \vdash \phi$ where $\phi$ ranges over the
formulas 
    ${\tt T} \ty {\tt type}$,
      ${\tt S} \subtype {\tt T}$,
      ${\tt e} \ty {\tt T}$,
      ${\tt M}~\mbox{OK in}~{\tt C}$,
      ${\tt f: T}~\mbox{OK in}~C$, and
      ${\tt L}~\mbox{OK}$.


Now, these judgements need to satisfy certain properties:

\begin{enumerate}

\item
    $\Gamma \vdash {\tt T} \ty {\tt type}$
whenever 
      $\Gamma \vdash {\tt e} \ty {\tt T}$; that is,
if we can conclude that {\tt e}
      has type {\tt T} (under certain assumptions), then under those
      assumptions we must be able to conclude that {\tt T} is well-defined.

\item
    $\Gamma \vdash {\tt S} \ty {\tt type}$ and
    $\Gamma \vdash {\tt T} \ty {\tt type}$ whenever
      $\Gamma \vdash {\tt S} \subtype {\tt T}$.

\item
If 
      $\Gamma \vdash {\tt e} \ty {\tt T}$ and if {\tt x}
is a variable occurring free in ${\tt e} \ty {\tt T}$, then for some
      type {\tt U},
      $\Gamma \vdash {\tt x} \ty {\tt U}$.
That is, all free variables on the right-hand
      side of the judgement are actually defined on the left-hand side.
\end{enumerate}


Keeping in mind these requirements, the rules are as follows. Below,
whenever we use the assertion ``{\tt x} free'' in the antecedent of
a rule we mean
that {\tt x} is not free in the consequent of the rule.


\subsection{
      Structural and Logical Rules
}


First, we present the structural rules for $\vdash$. The judgement
$\Gamma\vdash {\tt e} \ty {\tt T}$ is
intuitionistic. That is, $\Gamma$ is considered a multiset of assertions, and
the judgement possesses the inference rules:

\infrule{
\Gamma \vdash {\tt e} \ty {\tt T}
\andalso
\Gamma \vdash {\tt S} \ty {\tt type}
\andalso
    \mbox{{\tt x} not in $\mathit{var}(\Gamma)$}
}{
\Gamma, {\tt x} \ty {\tt S} \vdash {\tt e} \ty {\tt T}
}



\infrule{
\Gamma \vdash {\tt e} \ty {\tt T}
\andalso
\Gamma \vdash {\tt c} \ty {\tt boolean}
}{
\Gamma, {\tt c} \vdash {\tt e} \ty {\tt T}
}


We also assume the following rule for conjunctions on the left and right:

\infrule{
\Gamma, \phi_1 , \phi_2 \vdash \phi
}{
\Gamma, (\phi_1 , \phi_2 ) \vdash \phi
}


\infrule{
\Gamma \vdash \phi_1 
\andalso
     \Gamma \vdash \phi_2  
}{
\Gamma \vdash (\phi_1 , \phi_2 )
}



Existential quantification is governed by the following standard rules,
specialized for the particular kinds of formulas we are dealing with:


\infrule{
\Gamma \vdash {\tt e} \ty {\tt T}[{\tt t}/{\tt x}]
\andalso
\Gamma \vdash {\tt t} \ty {\tt S}
}{
\Gamma \vdash {\tt e} \ty ({\tt x} \ty {\tt S};~{\tt T})
}


\infrule{
\Gamma, {\tt x} \ty {\tt S}, {\tt c} \vdash {\tt e} \ty {\tt T}
\andalso
\mbox{{\tt x} fresh}
}{
\Gamma, ({\tt x} \ty {\tt S};~{\tt c}) \vdash {\tt e} \ty {\tt T}
}


\infrule{
\Gamma, {\tt x} \ty {\tt S}, {\tt y} \ty \Xcd{C\{c\}} \vdash {\tt e} \ty {\tt T}
\andalso
\mbox{{\tt x} fresh}
}{
\Gamma, {\tt y} \ty \Xcd{C\{x:S; c\}} \vdash {\tt e} \ty {\tt T}
}

}

\subsection{
Type well-formedness
}

\begin{figure}

\infrule{
\mbox{\Xcdmath{C[$\bar{\tt X}$]($\bar{\tt x}$: $\bar{\tt T}$)\{c\} ext T \{\ $\bar{\tt M}$\ $\bar{\tt F}$\ \}}}
}{
\vdash \Xcd{C} \ty \Xcd{type}
}

\infrule{
\vdash \Xcd{C} \ty \Xcd{type}
\andalso
\Gamma \vdash \Xcd{c} \ty \Xcd{boolean}
}{
\Gamma \vdash \Xcd{C\{c\}} \ty \Xcd{type}
}

\infrule{
\Gamma \vdash \Xcd{p} \ty \Xcd{T}
\andalso
\vdash \Xcd{T}~\Xcd{has}~\Xcd{X}_i
}{
\Gamma \vdash \Xcd{p.X}_i \ty \Xcd{type}
}

\infax{
\Gamma, \Xcd{X} \ty \Xcd{type} \vdash \Xcd{X} \ty \Xcd{type}
}

\caption{Type well-formedness}
\label{fig:type-wf}
\end{figure}

\subsection{
      Type inference rules
}

\subsubsection{Constraint rules}

\begin{figure}

\infrule[Has-class]{
\mbox{\Xcdmath{C[$\bar{\tt X}$]($\bar{\tt x}$: $\bar{\tt T}$)\{c\} ext T \{\ $\bar{\tt M}$\ $\bar{\tt F}$\ \}}}
}{
\vdash {\tt C}~{\tt has}~{\tt X}_i \\
\vdash {\tt C}~{\tt has}~{\tt x}_i \ty {\tt T}_i \\
\vdash {\tt C}~{\tt has}~{\tt M}_i \\
\vdash {\tt C}~{\tt has}~{\tt F}_i
}

\infrule[Has-sub]{
\Gamma \vdash {\tt T_1}~{\tt has}~{\tt Z_i}
\andalso
\Gamma \vdash {\tt T_2} \subtype {\tt T_1}
}{
\Gamma \vdash {\tt T_2}~{\tt has}~{\tt Z_i}
}

\caption{Structural constraints}
\label{fig:structural}
\end{figure}

\subsubsection{
        Expression typing judgement
}

TODO: should merge subsumption into other rules ?

\begin{figure}

\infrule[T-sub]{
\bar{\Xcd{c}}, \Gamma \vdash \Xcd{e} \ty \Xcd{S}
\andalso
\bar{\Xcd{c}} \vdashC \Xcd{S} \subtype \Xcd{T}
}{
\bar{\Xcd{c}}, \Gamma \vdash \Xcd{e} \ty \Xcd{T}
}

\infax[T-var]{
\bar{\Xcd{c}}, \Gamma, \Xcd{x} \ty \Xcd{T} \vdash \Xcd{x} \ty \Xcd{T}
}

\infrule[T-cast]{
\bar{\Xcd{c}}, \Gamma \vdash \Xcd{e} \ty \Xcd{S}
\andalso
\bar{\Xcd{c}}, \Gamma \vdash \Xcd{T} \ty \Xcd{type}
}{
\bar{\Xcd{c}}, \Gamma \vdash \Xcd{e}~\Xcd{as}~\Xcd{T} \ty \Xcd{T}
}

\infrule[T-field]{
\bar{\Xcd{c}}, \Gamma \vdash \Xcd{e} \ty \Xcd{T}
\\
%C, \Gamma \vdash \Xcd{T}~\Xcd{has}~\Xcd{var}~\Xcd{f}_i\Xcd{\{c\}} \ty \Xcd{T}_i
\mathit{ftype}(\Xcd{T}, \Xcd{f}_i) = \Xcd{f}_i\Xcd{\{c\}} \ty \Xcd{T}_i \\
\Xcd{z}~\mbox{fresh}
\\
\bar{\Xcd{c}}, \sigma(\Gamma, \Xcd{this} \ty \Xcd{T}), \Xcd{this} \equals \Xcd{z} \vdashC \Xcd{c}
}{
\bar{\Xcd{c}}, \Gamma \vdash \Xcd{e}.\Xcd{f}_i \ty \Xcd{T}_i[\Xcd{z}/\Xcd{this}]
}

\infrule[T-invk]{
\Gamma \vdash \Xcd{e}_0: \Xcd{T}_0
\andalso
\Gamma \vdash \bar{\Xcd{e}} \ty \bar{\Xcd{T}}
\\
\Xcd{T}_0~\Xcd{has}~\Xcd{def}~\Xcd{m[}\bar{\Xcd{Z}}\Xcd{](}\bar{\Xcd{z}} \ty \bar{\Xcd{S}}\Xcd{)\{c\}} \ty {\tt U}~\Xcd{=}~\Xcd{e}
\\
    \Xcd{z}_0, \bar{\Xcd{z}}, \bar{\Xcd{Z}}~\mbox{fresh}
\\
\Gamma' = \Gamma, \bar{\Xcd{Z}} \ty \Xcd{type},
        \Xcd{z}_0 \ty \Xcd{T}_0,
        \bar{\Xcd{z}} \ty \bar{\Xcd{T}}
\\
\sigma(\Gamma') \vdashC (\Xcd{c}, \bar{\Xcd{V}}\equals
\bar{\Xcd{Z}}, \bar{\Xcd{T}} \subtype \bar{\Xcd{S}})
}{
\Gamma \vdash
\Xcd{e}_0.\Xcd{m[}\bar{\Xcd{V}}\Xcd{](}\bar{\Xcd{e}}\Xcd{)} \ty
(\bar{\Xcd{Z}} \ty \Xcd{type};~\Xcd{z}_0 \ty \Xcd{T}_0;~\bar{\Xcd{z}} \ty \bar{\Xcd{T}};~{\Xcd{U}})
}

\infrule[T-invk-inferred]{
\bar{\Xcd{Y}}~\mbox{fresh}
\\
\Gamma, \bar{\Xcd{Y}} \ty {\tt type}
\vdash
\Xcd{e}_0.\Xcd{m[}\bar{\Xcd{Y}}\Xcd{](}\bar{\Xcd{e}}\Xcd{)} \ty
(\bar{\Xcd{Z}} \ty \Xcd{type};~\Xcd{z}_0 \ty
\Xcd{T}_0;~\bar{\Xcd{z}} \ty \bar{\Xcd{T}};~\Xcd{U})
}{
\Gamma \vdash
\Xcd{e}_0.\Xcd{m(}\bar{\Xcd{e}}\Xcd{)} \ty
(\bar{\Xcd{Z}} \ty \Xcd{type};~\Xcd{z}_0 \ty \Xcd{T}_0;~\bar{\Xcd{z}} \ty \bar{\Xcd{T}};~{\Xcd{U}})
}

\infrule[T-new]{
\Gamma \vdash \bar{\Xcd{e}} \ty \bar{\Xcd{T}}
\\
\mathit{fields}(\Xcd{C}, \Xcd{z}_0) = \bar{\Xcd{f}} \ty \bar{\Xcd{S}}
\\
    \Xcd{z}_0, \bar{\Xcd{z}}, \bar{\Xcd{Z}}~\mbox{fresh}
\\
\Gamma' = \Gamma, \bar{\Xcd{Z}} \ty \Xcd{type}, \Xcd{z}_0 \ty
\Xcd{C}, \bar{\Xcd{z}} \ty \bar{\Xcd{T}},
\Xcd{z}_0.\bar{\Xcd{f}} \equals \bar{\Xcd{z}}
\\
\sigma(\Gamma') \vdashC \mathit{inv}(\Xcd{C},\Xcd{z}_0),
\bar{\Xcd{V}}\equals \bar{\Xcd{Z}}, \bar{\Xcd{T}} \subtype \bar{\Xcd{S}}
\\
\sigma(\Gamma') \vdash_{\cal C}
}{
\Gamma \vdash
\Xcd{new}~\Xcd{C[}\bar{\Xcd{V}}\Xcd{](}\bar{\Xcd{e}}\Xcd{)} \ty \Xcd{C\{}
\Xcd{z}_0 \ty \Xcd{C};~
\bar{\Xcd{z}} \ty \bar{\Xcd{T}};~
\Xcd{z}_0.\bar{\Xcd{f}}\equals \bar{\Xcd{z}},
\Xcd{self}\equals \Xcd{z}_0\Xcd{\}}
}

\caption{Typing rules}
\label{fig:typing}
\end{figure}

The cast rule
\rn{T-cast}
requires that the cast type be well-formed. 



The field access rule \rn{T-field}
differs from the rule in the paper in that there is no need to
substitute a fresh variable for the receiver. Note that {\tt this} may be free
in {\tt S}---that would be a reference to the current object in the code in
which {\tt e.f} occurs, not a reference to the receiver of the {\tt e.f} field
selection (i.e., the object obtained by evaluating {\tt e}).

\begin{align*}
\sigma(\Xcd{p}) &= \Xcd{p} \\
\sigma(\Xcd{e}) &= \Xcd{z} \qquad \mbox{otherwise; (\Xcd{z} fresh)} \\
\end{align*}

\noindent
if we allow adding constraints to arbitrary types---do we?

TODO: type parameters!

Now we consider the rule for method invocation. Assume that in a type
environment $\Gamma$ the expressions ${\tt e_0}, \dots, {\tt e_n}$
have the types ${\tt T_0}, \dots, {\tt T_n}$.
Since the
actual values of these expressions are not known, we shall assume that
they take on some fixed but unknown values
                                     ${\tt z_0}, \dots, {\tt z_n}$
of types ${\tt T_0}, \dots, {\tt T_n}$.
Now, for ${\tt z_0}$ as receiver, let us assume that the type
${\tt T_0}$ has a method named ${\tt m}$
with signature
$[\bar{\tt Z}](\bar{\tt z} \ty \bar{\tt S})\Xcd{\{c\}} \to {\tt U}$
(Let ${\tt T_0} = \Xcd{C\{d\}}$.
 If there is no
method named {\tt m} for the class {\tt C} then this method invocation cannot be
type-checked. Without loss of generality, we may assume that the
type parameters of this method are named
                                     ${\tt Z_1}, \dots, {\tt Z_k}$, and
the value parameters are named
                                     ${\tt z_1}, \dots, {\tt z_n}$
since we are free to choose
variable names as we wish.)
Now, for the method to be invocable,
it must be the case that the types
    ${\tt T_1}, \dots, {\tt T_n}$
are subtypes of
    ${\tt S_1}, \dots, {\tt S_n}$.
(Note
that there may be no occurrences of {\tt this} in
    ${\tt S_1}, \dots, {\tt S_n}$---they have been
replaced by ${\tt z_0}$.)
Further, it must be the case that for these parameter
values, the constraint {\tt c} is entailed. Given all these assumptions it
must be the case that the return type is {\tt U}, with all the parameters
    ${\tt z_0}, \dots, {\tt z_n}$
existentially quantified.


\subsubsection{
        Class OK judgement
}

The following rule is modified from what we had in the paper to ensure
that all the types are well-formed (under the assumption {\tt this} \ty {\tt C}).
Note
that the variables $\bar{\tt x}$ are permitted to occur in the types ${\tt T_0}, \bar{\tt T}$,
hence their typing assertions must be added to $\Gamma$.

\infrule[Method OK]{
\Gamma = \Xcd{this} \ty \Xcd{C\{self==this},\mathit{inv}(\Xcd{C})\Xcd{\}}, \bar{\Xcd{x}} \ty \bar{\Xcd{T}}\Xcd{\{self==\}}\bar{\Xcd{x}}\Xcd{\}}
\\
\sigma(\Gamma), \Xcd{c};~\Gamma \vdash \Xcd{e} \ty \Xcd{U}
\\
\sigma(\Gamma), \Xcd{c} \vdashC \Xcd{U} \subtype \Xcd{T}
}{
\Xcd{def}~\Xcd{m[}\bar{\Xcd{X}\Xcd{}](}\bar{\Xcd{x}} \ty
\bar{\Xcd{T}}\Xcd{)\{c\}} \ty \Xcd{T}~\Xcd{=}~\Xcd{e}~\mbox{OK in}~\Xcd{C}
}


This rule did not exist in our submission. This is necessary to ensure
that the types of fields are well-formed.

\infrule[Field OK]{
\sigma(\Xcd{this} \ty \Xcd{C}), \Xcd{c};~\Xcd{this} \ty \Xcd{C} \vdash \Xcd{T} \ty \Xcd{type}
}{
\Xcd{val}~\Xcd{f}\Xcd{\{c\}} \ty \Xcd{T}~\mbox{OK in}~\Xcd{C}
}


This rule is now modified to ensure that all the types and methods in
the body of the class are well-formed.

\infrule[Class OK]{
\bar{\tt M}~\mbox{OK in}~{\tt C}
\\
\bar{\tt F}~\mbox{OK in}~{\tt C}
\\
{\tt this} \ty {\tt C} \vdash {\tt T} \ty {\tt type}
}{
\mbox{\Xcdmath{C[$\bar{\tt X}$]($\bar{\tt x}$: $\bar{\tt T}$)\{c\} ext T \{\ $\bar{\tt M}$\ $\bar{\tt F}$\ \}}}~\mbox{OK}
}

TODO: method overriding


\subsubsection{
        Subtype judgement
}

\infrule{
\sigma(\Gamma) \vdash_{\cal C} {\tt T_1} \subtype {\tt T_2}
}{
\Gamma \vdash {\tt T_1} \subtype {\tt T_2}
}


\section{Odds and ends}

static methods cannot mention T

interfaces can have static methods; a property can implement I,
allowing T.m() static calls

Extensions: structural constraints, optional methods, interfaces
        enabled flag trick


\section{Constraint solver}

The goal of the constraint solver is 
to check an assertion ${\tt c} \vdash_{\cal C} {\tt d}$.

$\sigma(\Gamma, x: \Xcd{C\{c\}}) = 
        \sigma(\Gamma), x.type.class==C, x.type.cons==c[x/self]
$

The first step is to normalize constraints.
Normalization splits constraints into type constraints and
value constraints.  Produces a set of constraint judgments
$\Gamma \vdash \Xcd{c}$ where $\Xcd{c}$ contains no conjunctions.

Otherwise:

\[
\SB{ \Gamma \vdash \Xcd{c} }
=
\Gamma \vdash \Xcd{c}
\]

Theorem:
normalized(c) |- normalized(d)
iff
c |- d

Theorem:
c |- d 
iff
|- c => d


Once in normalized form, can solve as follows:

Select a constraint $\Gamma \vdash \Xcd{c}$.
If not consistent, fail.
If valid, ok.
If not valid, generate assignment of variables that makes it true.

Question: is there an good method for generating the assignment?
Or just brute force?
Pick an unassigned variable, find weakest assignment that makes just
this clause true.  Does that exist?

DO NOT WANT:
If assignment makes another clause false, rollback.

Question: can we ensure each clause involves only one or two
unknowns?

Weakest assignment:

\begin{verbatim}
p==q --> add p==q
C<:D --> either valid or not, nothing to do
C<:Z.class --> Z.class<:Object        -- allowed to refine lower;
Z.class<:C --> Z.class<:C                assignment will pick GLB
C<:Z.class --> add C<:Z.class to set of constraints to check after assignment

Z.cons == c --> add Z.cons==c
        replace Z.cons in assumptions with c
        (what if env not appropriate)
c |- Z.cons
\end{verbatim}

Now, to check c |- d, check normalized(c) |- normalized(d).

        all constraints are either ==, simple <:, or =>



                
        

type inference:

build a big constraint per method

\begin{verbatim}
S1; S2             --> cons(S1), cons(S2)
if (x) S1 else S2  --> x => cons(S1), !x => cons(S2)
x = y              --> y.type <: x.type 
x + y              --> x.type <: number, y.type <: number,
                       (x+y).type == promote(x.type, y.type)
\end{verbatim}

solve:

        break into constraints G |- c where c is primitive

        e.g., G |- C{c} <: D{d}
        -->
        G |- C <: D,
        G, c |- d

        put all constraints into a set C

        infer new constraints A

        solve(C, A) =
                  if c in C s.t. A c not valid
                  then
                        solve(C, refine(A,c))
                  else
                        A

        need to make refine(A, c) determinstic and efficient





inference rules are of the form:

\infax{
\Gamma;~S \vdash e \ty T
}

where $\Gamma$ is a set of assumptions and $S$ is a set of inferred
constraints.

check rule:

\infrule{
\Gamma \vdash \Xcd{e} \ty \Xcd{T}
\andalso
\Xcd{T has def m(): T}'
}{
\Gamma \vdash \Xcd{e.m()} \ty \Xcd{T}'
}

infer rule:

\infrule{
\Gamma \vdash e \ty T
}{
\Gamma; T has () \Rightarrow T' \vdash e.m() \ty T'
}

bi-directional checking combines the two kinds of rules


Some transforming of the constraints:


\infax{
\Gamma \vdash \Xcd{x} \ty \Xcd{T} \longrightarrow \Xcd{x}.\Xcd{type}\Xcd{==}\Xcd{T} 
}

\infrule{
{\tt z}~\mbox{fresh}
}{
\Gamma \vdash \Xcd{C\{c\}} \Xcd{<:} \Xcd{D\{d\}}   \longrightarrow
        \vdash \Xcd{C} \Xcd{<:} \Xcd{D},
        \Gamma, \Xcd{z} \ty \Xcd{C},
                \Xcd{c}[\Xcd{z}/\Xcd{self}] \vdash \Xcd{d}[\Xcd{z}/\Xcd{self}]
}

\infrule{
\Gamma \vdash {\tt p} \ty \Xcd{C\{c\}} \longrightarrow {\cal C}
}{
\Gamma \vdash {\tt p.X} \Xcd{<:} {\tt T}   \longrightarrow
        {\cal C},
        \Gamma, \Xcd{c}[\Xcd{p}/\Xcd{self}] \vdash
        \Xcd{C}(\Xcd{T})[\Xcd{p}/\Xcd{self}]
}


%\newcommand\eqedge{\rightleftharpoons}
\newcommand\eqedge{\sim}
\newcommand\flowedge{\to}
\newcommand\treeedge[1]{\mapsto_{#1}}
\newcommand\typeedge{\mapsto_{\tt type}}

Represent a constraint as a graph $G$.
Each node represents a constraint term for a value or a type.
The node for a path $p$ is written $v_p$;
the node for a type $T$ is written $V_T$.
There are four kinds of edges:
\begin{enumerate}
\item undirected equivalence edges,
        $v_p \eqedge v_q$ and $V_S \eqedge V_T$,
\item type edges, $v_p \typeedge V_T$,
\item tree edges, $v_p \treeedge{f} v_{p.f}$
              and $v_p \treeedge{X} V_{p.X}$, and
\item flow edges, $V_S \flowedge V_T$.
\end{enumerate}

First, each constraint term is mapped to a node in the graph as
follows.
Associate each term $t$ with a node
$v_t$.  For each access path {\tt p.x}, add a tree edge
$v_{{\tt p}} \treeedge{{\tt x}} v_{{\tt p.x}}$.
For each path type {\tt p.X}, add a tree edge
$v_{{\tt p}} \treeedge{{\tt X}} V_{{\tt p.X}}$.
For each atomic formula ${\tt f}(\bar{t})$, add the tree edge
$v_{{\tt f}(\bar{t})} \treeedge{i} v_{t_i}$ for all $i$.
If term $t$ has type $T$, add $v_t \typeedge V_{t{\tt .type}}$
and
add $V_T \eqedge V_{t{\tt .type}}$ to $G$.

Type nodes are sets of classes.

Next, constraints are incorporated into the graph:

\begin{itemize}
\item
For constraint {\tt p==q}, add $v_{\tt p} \eqedge v_{\tt q}$ to $G$.

\item
For constraint {\tt S==T}, add $V_{\tt S} \eqedge V_{\tt T}$ to $G$.

\item
For constraint {\tt S<:T},
add $V_{\tt S} \flowedge V_{\tt T}$
to $G$.

\end{itemize}

A flow-path is a path that follows flow and equivalence edges
only.
A type-path is a path that follows type and equivalence edges
only.

Now, we saturate: 
If there is a type-path $v_t \typeedge^* V_{\tt C\{c\}}$,
add $c[t/\Xcd{self}]$ to the worklist.

        Can saturate lazily when doing a lookup.
        EXCEPT: a type may have an arbitrary constraint
                \xcd"C{self.x==3 && y > 7}"
        EXCEPT: c is x.f==...
                with x: C{c}
                need to avoid infinite loop

The inference algorithm adds
flow edges, $v \flowedge w$, to the graph $G$.

For constraint {\tt S<:T},
add the flow edge $v_{\tt S} \flowedge v_{\tt T}$
to $G$.

TODO: self constraints
TODO: existentials

Initialize $W$ to the set of equivalence edges for the set of
equational constraints {\tt p==q}.
Initialize $G$ with flow edges only.

\paragraph{Merge fields.}
For all $t$ in the constraint, for all
$v_{t'}$ reachable by flow edges from $v_t$,
if $t$ has a type member {\tt X},
add $v_{t.{\tt X}} \eqedge v_{t'.{\tt X}}$ to $W$;
if $t$ has a field {\tt f},
add $v_{t.{\tt f.type}} \eqedge v_{t'.{\tt f.type}}$ to $W$.

\paragraph{Process equational constraints.}
While $W$ is non-empty, extract and remove  $v_{\tt p} \eqedge v_{\tt q}$
from $W$.
If the edge is already in $G$, continue with the next constraint.

If the edge connects $v_{\tt S}$ and $v_{\tt T}$
and {\tt S} and {\tt T} cannot be equal, fail.

If $v_{p.X} \eqedge v_T$
and there is a type edge from $v_p$ to $v_{\Xcd{C\{c\}}}$
add in ${\tt c[p/self]}$.

If adding the edge would create a cycle, merge the nodes.

Let $\mathit{src}(v)$ be the set of class/interface nodes from which
$v$ is reachable by flow and equivalence edges.
These are the nodes that represent subtypes of $v$'s type.

Let $\mathit{snk}(v)$ be the set of class/interface nodes reachable from
$v$ by flow and equivalence edges.
These are the nodes that represent supertypes of $v$'s type.

If there is a $v$ in both $\mathit{src}(v_{\tt p})$
              and $\mathit{snk}(v_{\tt q})$,
add $v \eqedge v_{\tt p}$
to $W$.

If there is a $v$ in both $\mathit{src}(v_{\tt q})$
              and $\mathit{snk}(v_{\tt p})$,
add $v \eqedge v_{\tt q}$
to $W$.

Add the edge to $G$ and continue with $W$.




\section{Type inference}

Because constrained types can be verbose, X10 supports type
inference to reduce the type annotation burden on the
programmer.

The type inference algorithm allows types to be omitted
altogether from many declarations and from method
and constructor invocations.
The algorithm also allows programmers to write a
partially constrained type or just the base type in a
declaration and to have a more precise constrained type
inferred.
For instance, it infers the type \xcd"int{self==3}" for the
local variables \xcd"x", \xcd"y", \xcd"z" in the following code:
\begin{xten}
val x = 3;
val y: int = x;
val z: int{self>0} = x;
\end{xten}
The algorithm is local: method and constructor parameter types,
as well as the types of mutable fields,
must be declared explicitly.  For non-\xcd"private" members,
this requirement is essential for enabling separate compilation.
Limiting the scope of inference also eliminates one cause of
potentially confusing error messages when types cannot be inferred.

The algorithm uses the subtyping constraint system described in
Section~\ref{sec:constraints}.

In general, an expression may have more than one satisfying type.

One requirement of the algorithm
is that it report not only that there exists a satisfying
assignment, but also reports the assignment itself.
The algorithm chooses the most precise assignment.

Because methods can be overridden, the inferred return type may be too
precise, preventing subclasses from overriding the method.

\infrule{
\Gamma \vdash e_0 \ty C\{c\} \\
\Gamma \vdash \mathit{mtype}(C, m) =
[X_1,\dots,X_k](x_1:T_1,\dots,x_n:T_n)\{d\} \flowedge T \\
\Gamma \vdash e_i \ty S_i \\
\sigma(\Gamma) \vdash_{\cal C}
\exists {\tt this} \ty C\{c\} .  \exists x_i: T_i .  S_i \subtype T_i \wedge d
}{
\Gamma \vdash e_0.m(e_1, \ldots, e_n) \ty T
}

\begin{verbatim}
Types can be inferred if the constraints are satisfied.
Need to materialize the constraints.

1. union-find on equality constraints
2. solve the subtyping constraints -- collapse cycles into union-find
        if SCC has a contradiction, complain
3. materialize bounds

impl: use XConstraint for union-find

        - T <: S
        - whenever we ask if T <: S, ask TypeSystem, then add <:(T,S)
          to constraint if true
        - whenever we ask if T == S, ask TypeSystem, then add ==(T,S)
          to constraint if true

Based on Henglein, TAPOS 99

lower bound of X
        union type of types Ti with Ti --> X
upper bound of X
        interesection type of types Ti with X --> Ti

C{c} & D{d} = (C&D){c||d}
C{c} | D{d} = (C|D){c&&d}

C&D = gcd(C,D)
C|D = lca(C,D)

X <: int ||
X <: float
-->
X <: int|float
-->
X <: number

int <: X || float <: X
-->
int&float <: X
-->
void <: X

p==q || p==q  -->  p==q
p==q || p==r  -->  true
S<:T || S<:U  -->  S<:(T|U)
T<:S || U<:S  -->  (T&U)<:S

\end{verbatim}

A key difference is that X10 supports where clauses that
constrain method and constructor type and value arguments.
The algorithm should infer not only the base type of a
constrained type, but also the type and value constraints.


X10 should perform type inference of local variable
types and of type arguments for method and constructor calls.%

\if 0
The algorithm infers a type for a local variable by
type-checking the variable initializer and assigning
that type to the variable.
When checking calls with omitted type arguments,
the algorithm attempts to find an instantiation of the type
parameters for which the call will type check.
\fi

Consider the following method from \cite{adding-wildcards}:
\begin{xten}
def choose[T](a: T, b: T): T { ... }
\end{xten}
%
In the following snippet, the algorithm should infer the type
\xcd"Collection" for \xcd"x".
\begin{xten}
intSet: Set[int];
stringList: List[String];
val x = choose(intSet, stringList);
\end{xten}
%
And in this snippet, the algorithm should infer the type
\xcd"Collection[int]" for \xcd"y".
\begin{xten}
intSet: Set[int];
intList: List[int];
val y = choose(intSet, intList);
\end{xten}
%
Finally, in this snippet, the algorithm should infer the type
\xcd"Collection{T <: Number}" for \xcd"z".
\begin{xten}
intSet: Set[int];
numList: List{T <: Number};
val z = choose(intSet, numList);
\end{xten}
The inference algorithm for Java 5 produces analogous results.

Now, consider the following example:
\begin{xten}
def union[T](a: Set[T], b: Set[T]) : Set[T];
\end{xten}
The union method cannot be called with just arguments of type \xcd"Set".
\begin{xten}
set1: Set;
set2: Set;
val a = union(set1, set2);
\end{xten}
This is illegal because the type system cannot demonstrate that
\xcd"set1.T" and \xcd"set2.T" are equal.
The following, however, is acceptable:
\begin{xten}
set1: Set;
set2: Set[set1.T];
val a = union(set1, set2);
\end{xten}

As another example from \cite{adding-wildcards}, consider
the following method signature:
\begin{xten}
def unmodifiableSet[T](set: Set[T]): Set[T];
\end{xten}

In Java, this method could be called with an argument of
type \xcd"Set<?>".
This instantiates the method on \xcd"?"; that is, the
wildcard is captured by the call, since any element type will be
safe.  A type variable can capture only one wildcard.

In X10, the method can be called with just a \xcd"Set" because there
are no constraints on \xcd"T".  Using desugared syntax, the method is
equivalent to:
\begin{xten}
def unmodifiableSet[T](set: Set{self.T==T}): Set{self.T==T};
\end{xten}
Any \xcd"Set" can be passed in: for an argument \xcd"e", the method
is instantiated on \xcd"e.T".
%
Note that if this method were defined as:
\begin{xten}
def unmodifiableSet(set: Set): Set;
\end{xten}
then the connection between the element types of the
argument and of the return types would be broken.
However, in X10, one could write use the following signature to keep the
connection:
\begin{xten}
def unmodifiableSet(set: Set): Set[set.T];
\end{xten}

\if 0
\section{Introspection}

\xcd"Cell[Cell[T<:A]]"

If not invariant, need run-time constraint solving.
\fi

\section{Implementation}

This section describes an implementation approach for
constrained types on a Java virtual machine.
We describe the implementation as a translation to Java.

The design
is a hybrid design based on the implementation of parameterized classes in
NextGen~\cite{allen03,allen04} and the implementation of
PolyJ~\cite{polyj}.
Generic classes are translated into template classes
that are instantiated on demand at run time by binding the type properties
to concrete types.  To implement run-time type checking (e.g.,
casts), type properties are represented at run time
using \emph{adapter objects}.

This design, appropriately extended to handle language features
not described in this paper, has been implemented in the X10
compiler.  The X10 compiler is built on the Polyglot framework
and translates X10 source to Java source\footnote{There is also
a translation from X10 to C++ source, not described here.}

\subsection{Method parameters}

The first step in translation is to remove method parameters by
introducing a generic member class for each generic method.
The member class is static iff the method is static.
Constructor type parameters are left unchanged.
After this step, the code consists only of generic classes.
The remaining translation introduces a run-time representation
for the type properties of these classes.

\subsection{Classes}

Each class is translated into a \emph{template class}.
The template class is compiled by a Java compiler (e.g., javac)
to produce a class file.
At run time, when a constrained type \xcd"C{c}" is first referenced, a
class loader loads the template class for \xcd"C" and then transforms the
template class bytecode, specializing it to the constraint
\xcd"c".

------------------

Define $\mathit{reptype}($\xcd"T"$)$ to be the representation
type of \xcd"T".

\infax{
\Gamma \vdash \mathit{reptype}({\tt C}) = {\tt C}
}

\infrule{
\Gamma \vdash {\tt p} \ty {\tt T}
}{
\Gamma \vdash \mathit{reptype}({\tt p.X}) = \mathit{reptype}({\tt X})
}

\infrule{
\Gamma \vdash {\tt p} \ty {\tt C\{self.X==T\}}
}{
\Gamma \vdash \mathit{reptype}({\tt p.X}) = \mathit{reptype}({\tt T})
}

\infrule{
\Gamma \vdash {\tt p} \ty {\tt C\{self.X<:T\}}
}{
\Gamma \vdash \mathit{reptype}({\tt p.X}) = \mathit{reptype}({\tt T})
}

\infrule{
\Gamma \vdash {\tt p} \ty {\tt C\{self.X:>T\}}
}{
\Gamma \vdash \mathit{reptype}({\tt p.X}) = {\tt Object}
}

\infrule{
}{
\Gamma \vdash \mathit{reptype}({\tt C\{self.X==T\}}) = {\tt C\$T}
}

\infrule{
}{
\Gamma \vdash \mathit{reptype}({\tt C\{self.X<:T\}}) = {\tt C}
}

--------------

For example, consider the following classes.
\begin{xten}
class A[T] {
    var a: T;
}
class C {
    val x: A[Int] = new A[Int]();
    val y: Int = x.a;
}
\end{xten}

The compiler generates the following code:
\begin{xten}
class A {
    // Dummy class needed to type-check uses of T.
    @TypeProperty(1) static class T { }

    T a;

    // Dummy getter and setter; will be eliminated at run time
    // and replaced with actual gets and sets of the field a.
    @Getter("a") <S> S get$a() { return null; }
    @Setter("a") <S> S set$a(S v) { return null; }
}

class C {
    @ActualType("A$Int")
    final A x = Runtime.<A>alloc("A$Int");
    final int y = x.<Integer>get$a();
}
\end{xten}

The member class \xcd"A.T" is used in place of the
type property \xcd"T". 
The \xcd"Runtime.alloc" method is used
used in place of a constructor call.
This code is compiled to Java bytecode.


Then, at run time, suppose the expression \xcd"new C()" is
evaluated.  This causes \xcd"C" to be loaded.
The class loader transforms the bytecode as if it had
been written as follows:

\begin{xten}
class C {
    final A$Int x = new A$Int();
    final int y = x.a;
}
\end{xten}

The \xcd"ActualType" annotation is used to change the
type of the field \xcd"x" from \xcd"A" to \xcd"A$Int".
The call to \xcd"Runtime.alloc" is replaced with a
constructor call.  The call to \xcd"x.get$a()" is
replaced with a field access.

The implementation cannot generate this code directly because
the class \xcd"A$Int" does not yet exist; the Java source compiler
would fail to compile \xcd"C".

Next, as the \xcd"C" object is being constructed, the expression
\xcd"new A$Int()" is evaluated, causing the class \xcd"A$Int" to
be loaded.  The class loader intercepts
this, demangles the name, and loads the bytecode for the
template class \xcd"A".

The bytecode is transformed, replacing the type property \xcd"T"
with the concrete type \xcd"int", the translation of \xcd"Int".

\begin{xten}
class A {
    x10.runtime.Type T;
}

class A$Int extends A {
    int x;
}
\end{xten}

Type properties are mapped to the Java primitive types and to
Object.  Only nine possible instantiations per parameter.
Instantiations used for representation.
Adapter objects used for run time type information.

Could do instantiation eagerly, but gets out of hand quickly: 9
instantiations for one type properties, 81 for two type
properties, 729 for three.
Most of these are not used.

Value constraints are erased from type references.

Constructors are translated to static methods of their enclosing
class.
Constructor calls
are translated to calls to static methods.


Consider the code in Figure~\ref{fig:translation1}.  It contains most of the
features of generics that have to be translated.
\begin{figure*}[tp]
\begin{xten}
class C[T] {
    var x: T;
    def this[T](x: T) { this.x = x; }
    def set(x: T) { this.x = x; }
    def get(): T { return this.x; }
    def map[S](f: T => S): S { return f(this.x); }
    def d() { return new D[T](); }
    def t() { return new T(); }
    def isa(y: Object): boolean { return y instanceof T; }
}

val x : C = new C[String]();
val y : C[int] = new C[int]();
val z : C{T <: Array} = new C[Array[int]]();
x.map[int](f);
new C[int{self==3}]() instanceof C[int{self<4}];
\end{xten}
\caption{Code to translate}
\label{fig:translation1}
\end{figure*}

\subsection{Eliminating method type parameters}

\begin{figure*}[tp]
\begin{xten}
class C[T] where T has T() {
    var x: T;

    def this[T](x: T) { this.x = x; }

    def set(x: T) { this.x = x; }
    def get(): T { return this.x; }

    def d() { return new D[T](); }
    def t() { return new T(); }

    def isa(y: Object): boolean { return y instanceof T; }

    // Translation of map to an inner class
    class map$[T,S] {
        def apply(c: C[T], f: Fun1[T,S]) { return f(c.x); }
    }
}

val x : C = new C[String]();
val y : C[int] = new C[int]();
val z : C{T <: Array} = new C[Array[int]]();
new map$[x.T,int]().apply(x,f);
new C[int{self==3}]() instanceof C[int{self<4}];
\end{xten}
\caption{After removing method parameters}
\label{fig:translation2}
\end{figure*}

\begin{figure*}[tp]
\begin{xten}
class C{0} implements C {
    final Type T = {0}$Type.it;
    {0} x;
    C{0}({0} x) { this.x = x; }

    void set$(Object x) { set(({0}) x); }
    void set({0} x) { this.x = x; }

    Object get$() { return ({0}) get(); }
    {0} get() { return this.x; }

    D d$() { return d(); }
    D{0} d() { return new D{0}(); }

    Object t$() { return t(); }
    {0} t() { return new {0}(); }

    boolean isa(Object y) { return T.instanceof$(y); }

    static class map$Type extends Type {
        ...
        static map$Type instantiate$(Type T, Type S) { ... }
    }

    static class map$Type{0}{1} extends Map$Type {
        map$ new$() { return new map${0}{1}(); }
    }

    interface map$ {
        Object apply$(C c, Fun1 f);
    }

    class map${0}{1} implements map$ {
        final Type T = {0}$Type.it;
        final Type S = {1}$Type.it;
        Object apply$(C c, Fun1 f)
          { return apply((C{0}) c, (Fun1{0}{1}) f); }
        {1} apply(C{0} c, Fun1{0}{1} f) { return f(c.x); }
    }
}

C x = new C$String();
C$int y = new C$int();
C z = new C$Array$int();
C.map$Type.instantiate$(x.T, int$Type.it).new$().apply$(x,f);
C$int$self$lt$4.instanceof$(new C$int$self$eqeq$3());
\end{xten}

\caption{Translation to Java}
\label{fig:translation4}
\end{figure*}

\begin{figure*}[tp]
\begin{xten}
class C$Type implements Type {
    static Type it = new C$Type();
    boolean instanceof$(Object x) { return x instanceof C; }

    static Map<Type,Type> instantiations;

    static Type instantiate$(Type T) {
        instantiations.get(T);
    }
}

class C{0}$Type implements Type {
    static Type it = new C{0}$Type();
    boolean instanceof$(Object x) { return x instanceof C{0}; }
}

interface C {
    void set$(Object x);
    Object get$();
    D d$();
    Object t$();
    boolean isa$(Object y);
}
\end{xten}

\caption{Translation to Java}
\label{fig:translation3}
\end{figure*}

\subsection{Run-time instantiation}

In this translation the type properties are represented as
instances of a \xcd"Type" class, analogous to \xcd"java.lang.Class".
Each generic class has a \xcd"Type"-typed field for each of
its type properties initialized by the class's constructor.
The \xcd"Type" objects
are used to implement {\tt instanceof} and cast operations.
\begin{xten}
interface Type {
    boolean instanceof$(Object x);
    <T> T cast$(Object x);
}
\end{xten}


In this translation, which is partially based on the
NextGen~\cite{allen03,allen04} translation,
a generic class is translated into a \emph{base interface} and
a \emph{template class} that implements the base interface.
At runtime, the first time a generic class is instantiated
a class loader loads \emph{template class}, rewriting the
bytecode to instantiate the type properties as appropriate.

For example, the
code for class {\tt C} above is translated into the template
class in Figure~\ref{fig:translation4}
with supporting classes Figure~\ref{fig:translation3}.
When instantiating the template, the string ``{\tt \{0\}}'' is
substituted with the name of the actual type
property.\footnote{In a real implementation, the names would be
mangled as appropriate.}
Since methods of {\tt C} can be called in a context where the
property instantiation is not known,
each method in the template class has to be implemented twice:
once with an Object interface and once with an instantiated
interface.

We translate \xcd"instanceof" and cast operations to calls to
methods of a \xcd"Type" because the actual implementation of
the operation may require run-time constraint solving or other
complex code that cannot be easily substituted in when rewriting
the bytecode during instantiation.

\section{Structural constraints}
\label{sec:structural}

XXX this is an extension of the type system

\begin{figure}[tp]
\begin{center}
\begin{tabular}{lrcl}
expressions & {\tt e} & ::= & \dots \\
            &        & \bnf & \xcd"T has Sig" \\
signatures  & {\tt Sig} & ::= &
\xcdmath"def this[$\bar{\tt X}$]($\bar{\tt x}$: $\bar{\tt T}$){c}: T" \\
            &        & \bnf &
\xcdmath"def m[$\bar{\tt X}$]($\bar{\tt x}$: $\bar{\tt T}$){c}: T" \\
            &        & \bnf &
\xcdmath"val x{c}: T" \\
            %&  & \bnf & \xcdmath"var x{c}: T" \\
\end{tabular}
\end{center}
\caption{Grammar for structural constraints}
\label{fig:structural}
\end{figure}

The type system is general enough to support not only subtyping
constraints, but also structural constraints on types.  The type
system need not change except by extending the constraint
system.  The syntax for structural constraints is shown in
Figure~\ref{fig:structural}.

Structural constraints on types are found in many languages.
Haskell~\cite{haskell} supports type classes.
%ML's module system allows modules to be constrained by
%structural signatures~\cite{ml}.
In Modula-3, type equivalence and subtyping are structural
rather than nominal as in object-oriented languages of the C
family such as C++, Java, Scala, and X10.
%
The language PolyJ~\cite{polyj} allows type parameters to be bounded using
structural where clauses, a form of F-bounded
polymorphism~\cite{fbounds}.
For example, a sorted list class in PolyJ can be written as follows:
\begin{xten}
class SortedList[T] where T { int compare(T) } {
    void add(T x) { ... x.compare(y) ... }
}
\end{xten}
The where clause states that the type parameter \xcd"T" must have a
method \xcd"compare" with the given signatures.

To support this, X10 provides structural constraints on types.
The analogous X10 code for \xcd"SortedList" is:
\begin{xten}
class SortedList[T] where T has compare(T): int {
    def add(x: T) = { ... x.compare(y) ... }
}
\end{xten}

A structural constraint is of the form \emph{Type}~\xcd"has"~\emph{Signature}.
A constraint is satisfied if the type has a member of the appropriate name
and with a compatible type.
The constraint \xcd"X has f(T1): T2"
is satisfied by a type \xcd"T" if it has a method \xcd"f"
whose type is a subtype of \xcd"(T1 => T2)"$[{\tt T}/{\tt X}]$.
As an example,
the constraint \xcd"X has equals(X): boolean"
is satisfied by all three of the following classes:
\begin{xten}
class C { def equals(x: C): boolean; }
class D extends C { }
class E { def equals(x: Object): boolean; }
\end{xten}

By using function types and where clauses on constructors,
X10 can go further than PolyJ.
Unlike in PolyJ, where the \xcd"compare" method must be provided by \xcd"T",
in X10 the \xcd"compare" function can be external to \xcd"T".
This is achieved as follows:
\begin{xten}
class SortedList[T] {
    val compare: (T,T) => int;
    def this(cmp: (T,T) => int) = { compare = cmp; }
    def add(x: T) = { ... compare(x,y) ... }
}
\end{xten}

This permits
\xcd"SortedList" to be instantiated using different compare functions:
\begin{xten}
val unixFiles    = new SortedList[String]
                        (String.compareTo.(String));
val windowsFiles = new SortedList[String]
                        (String.compareToIgnoreCase.(String));
\end{xten}

But, a problem with this approach is that the compare function must be
provided to the constructor at each instantiation of \xcd"SortedList".
The problem can be resolved by using constructors with different
structural constraints:
\begin{xten}
class SortedList[T] {
    val compare: (T,T) => int;
    def this[T]() where T has compareTo(T): int = {
        this[T](T.compareTo.(S));
    }
    def this[T](cmp: (T,T) => int) = { compare = cmp; }
    def add(x: T) = { ... compare(x,y) ... }
}
\end{xten}
Now, \xcd"SortedList" can be instantiated with any type that has
a \xcd"compareTo"
method without expliclty specifying the method at each constructor call.

\section{Discussion}

\subsection{Type properties versus type parameters}

Type properties are similar, but not identical to type parameters.  The
differences may potentially confuse programmers used to Java generics or C++
templates.  The key difference is that type properties are instance members and
are thus accessible through access paths: \xcd"e.T" is a legal type.

Type properties, unlike type parameters, are inherited.
For example, in the following code, \xcd"T" is defined in \xcd"List"
and inherited into \xcd"Cons".  The property need not be
declared by the \xcd"Cons" class.
\begin{xten}
class List[T] { }
class Cons extends List {
    def head(): T = { ... }
    def tail(): List[T] = { ... }
}
\end{xten}
The analogous code for \xcd"Cons" using type parameters would be:
\begin{xten}
class Cons[T] extends List[T] {
    def head(): T = { ... }
    def tail(): List[T] = { ... }
}
\end{xten}
% This code is perfectly acceptable in X10 as well, but introduces a redundant
% type property \xcd"T" equal to the \xcd"T" inherited from \xcd"List".

We can make the type system behave as if type properties were
type parameters very simply.  We need only make the syntax \xcd"e.T"
illegal and permit type properties to be accessible only
from within the body of their class definition via the implicit \xcd"this"
qualifier.

\subsection{Wildcards}

Wildcards in Java~\cite{Java3,adding-wildcards} were motivated
by the following example (rewritten in X10 syntax)
from \cite{adding-wildcards}.
Sometimes a class needs a field or method
that is a list, but we don't care what the element type is.
For methods, one can give the method a type parameter:
\begin{xten}
def aMethod[T](list: List[T]) = { ... }
\end{xten}
This method can then be called on any \xcd"List" object.
However, there is no way to do this for fields since they
cannot be parameterized.
Java introduced wildcards to allow such fields to be
typed:
\begin{xten}
List<?> list;
\end{xten}
In X10, a similar effect is achieved by not constraining the
type property of \xcd"List".
One can write the following:
\begin{xten}
list: List;
\end{xten}
Similarly, the method can be written without type parameters by
not constraining \xcd"List":
\begin{xten}
def aMethod(list: List) = { ... }
\end{xten}

In X10, \xcd"List"
is a supertype of
\xcd"List[T]" for any \xcd"T",
just as in Java
\xcd"List<?>" is a supertype of
\xcd"List<T>" for any \xcd"T".
This follows directly from the definition of the type \xcd"List"
as \xcd"List{true}", and the type \xcd"List[T]"
as \xcd"List{X==T}", and the definition of subtyping.

Wildcards in Java can also be bounded.
We achieve the same
effect in X10 by using type constraints.
For instance, the following Java declarations:
\begin{xten}
void aMethod(List<? extends Number> list) { ... }
<T extends Number> void aParameterizedMethod(List<T> list) { ... }
\end{xten}
may be written as follows in X10:
\begin{xten}
def aMethod(list: List{T <: Number}) = { ... }
def aParameterizedMethod[T{self <: Number}](list: List[T]) = { ... }
\end{xten}

Wildcard bounds may be covariant, as in the following example:
\begin{xten}
List<? extends Number> list = new ArrayList<Integer>();
Number num = list.get(0);     // legal
list.set(0, new Double(0.0)); // illegal
list.set(0, list.get(1));     // illegal
\end{xten}
This can also be written in X10, but with an important
difference:
\begin{xten}
list: List{T <: Number} = new ArrayList[Integer]();
num: Number = list.get(0);    // legal
list.set(0, new Double(0.0)); // illegal
list.set(0, list.get(1));     // legal! (when list is final)
\end{xten}
Note because \xcd"list.get" has return type \xcd"list.T", the
last call in above is well-typed in X10; the analogous call in
Java is not well-typed.

Finally,
one can also specify lower bounds on types.  These are useful for
comparators:
\begin{xten}
class TreeSet[T] {
    def this[T](cmp: Comparator{T :> this.T}) { ... }
}
\end{xten}
Here, the comparator for any supertype of \xcd"T" can be used as
to compare \xcd"TreeSet" elements.

Another use of lower bounds is for list operations.
The \xcd"map" method below takes a function that maps a supertype
of the class parameter \xcd"T" to the method type parameter \xcd"S":
\begin{xten}
class List[T] {
    def map[S](fun: Object{self :> T} => S) : List[S] = { ... }
}
\end{xten}

\subsection{Proper abstraction}

Consider the following example adapted from \cite{adding-wildcards}:
\begin{xten}
def shuffle[T](list: List[T]) = {
    for (i: int in [0..list.size()-1]) {
        val xi: T = list(i);
        val j: int = Math.random(list.size());
        list(i) = list(j);
        list(j) = xi;
    }
}
\end{xten}
The method is parameterized on \xcd"T" because the method body needs
the element type to declare the variable \xcd"xi".

However, the method parameter can be omitted by using the type \xcd"list.T"
for \xcd"xi".  Thus, the method can be declared with the signature:
\begin{xten}
def shuffle(list: List) { ... }
\end{xten}
This is called \emph{proper abstraction}.

This example illustrates a key difference between type properties
and type parameters:
A type property is a member of its class, whereas a type parameter is
not.  The names of type properties are visible outside the body of
their class declaration.

\if 0
Type properties can be used as the basis of a parameterized type
system.  This is done simply by making type properties private.
Using the syntactic sugar described above,
the resulting system behaves identically to a system with type
parameters.
\fi

In Java,
Wildcard
capture allows the parameterized method to be called with any \xcd"List",
regardless of its parameter type.
However,
the method parameter cannot be omitted: declaring a parameterless version
of shuffle requires delegating to a private parameterized version that
``opens up'' the parameter.

\subsection{Virtual types}

Type properties share many similarities with virtual types~\cite{mp89-virtual-classes,beta}, particularly
with sound formulations of virtual types using path-dependent types,
as found in gbeta~\cite{ernst99-gbeta}, Scala~\cite{scala},
and J\&~\cite{nqm06}.
%
Constrained types are more expressive than virtual
types since they can be constrained at the use-site,
can be refined on a per-object basis without explicit subclassing,
and can be refined contravariantly
as well as covariantly.

Thorup~\cite{thorup97}
proposed adding genericity to Java using virtual types.  For example,
a generic \xcd"List" class can be written as follows:
\begin{xten}
abstract class List {
    abstract typedef T;
    void add(T element) { ... }
    T get(int i) { ... }
}
\end{xten}
This class can be refined by bounding the virtual type \xcd"T" above:
\begin{xten}
abstract class NumberList extends List {
    abstract typedef T as Number;
}
\end{xten}
And this abstract class can be further refined to \emph{final bind}
\xcd"T" to a particular type:
\begin{xten}
class IntList extends NumberList {
    final typedef T as Integer;
}
\end{xten}
These classes are related by subtyping:
${\tt IntList} \subtype {\tt NumberList} \subtype {\tt List}$.
Only classes where \xcd"T" is final bound can be non-abstract.

In X10, an analogous \xcd"List" class would be written as follows:
\begin{xten}
class List[T] {
    def add(element: T) = { ... }
    def get(i: int): T = { ... }
}
\end{xten}

\xcd"NumberList" and \xcd"IntList" can be written as follows:
\begin{xten}
class NumberList extends List{T<:Number} { }
class IntList extends NumberList{T==Integer} { }
\end{xten}

However, note that X10's \xcd"List" is not abstract.
Instances of \xcd"List"
can instantiate \xcd"T" with a particular type and there is no need to declared classes for \xcd"NumberList" and \xcd"IntList".  Instead, one can use the types
\xcd"List[+Number]" and \xcd"List[Integer]".

Unlike virtual types, type properties can be refined contravariantly.
For instance, one can write the type \xcd"List[-Integer]",
and even \xcd"List{Integer<:T, T<:Number}".


\section{Related work}

\cite{unifying-genericity}
\cite{adding-wildcards}
\cite{emir06}
\cite{myers94}
\cite{polyj}
\cite{allen04}
\cite{allen03}
\cite{beta}
\cite{mp89-virtual-classes}
\cite{thorup97}

\section{Conclusions}

We have presented a preliminary design for supporting genericity
in X10 using type properties.  This type system generalizes the
existing X10 type system.  The use of constraints on type
properties allows
the design to capture many features of generics in languages
like Java 5 and C\# and then to extend these features with new
more expressive power.
We expect that the design admits an efficient
implementation and intend to implement the design shortly.

\newpage

\bibliographystyle{plain}
\bibliography{master}

% \appendix
% \onecolumn

% \section{An extended example}
% \input{longex}

\end{document}
