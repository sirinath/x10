% Problem statement
% X10 ... new language design
% OO, imperative, concurrent
% catch errors -> types
% dependent types, generics
% practical, pluggable

Modern architectural advances are leading to the development of
complex computational systems, such as heterogeneous multi-core
systems (e.g., Cell), large CPU count systems such as the Blue Gene,
hybrid accelerated clusters such as the Road Runner.  Such systems
pose a central challenge: How can application programmers write
high-performance programs for such machines while building on the
productivity gains of modern OO languages?

The \Xten{} programming language \cite{x10-concur,x10-oopsla05,x10} was
designed to address the challenges of ``productivity with
performance'' on these diverse architectures. Developed on
the {\em asynchronous partitioned global address} (APGAS) model, 
\Xten{} organizes computation into a collection of
logical {\em places}. A place encpasulates data and one or more {\em
activities} that operate on the data. Places capture the idea of {\em
locality} (data in the same place is ``close'', data in a different
place is ``far'') and {\em heterogenity} (one place may target for a
collection of tightly integrated cores, another may target a
GPGPU). Data in all places resides in a global address space; thus a
field of an object can point to an object in a different place. Remote
data is not operated on directly, rather light-weight activities
(tasks) must be spawned remotely to operate on them.

The design of \Xten{} requires the development of a rich type system
to enable code reuse, permit a large variety of errors to be caught at
compile-time, and to generate efficient code. For instance, a central
data-structure in \Xten{} is the dense, distributed, multi-dimensional
array. Arrays are defined over a set of indices known as {\em regions}
and may support an arbitrary base type, and accesses through {\em
points} which must lie in the underlying region. For performance it is
necessary that as far as possible array index accesses are
bounds-checked statically. Further, certain regions (such as
rectangular regions) may be represented particularly
efficiently. Hence if a variable is to range only over arrays over
rectangular regions, it is important that this information be conveyed
statically (through the type system) so that efficient code can be
generated. To support $P$-way data parallelism it is often necessary
to logically partition an array into $P$ pieces. A type system that
can establish that a given division is a partition will ensure that no
race conditions arise due to simultaneous read and write accesses by
multiple activities to different divisions.

These requirements motivated us to develop a framework for dependent
types in OO languages \cite{constrained-types}.  {\em Dependent type
systems}~\cite{dependent-types,xi99dependent,ocrz-ecoop03,aspinall-attapl,cayenne,epigram-matter,calc-constructions}
have been extensively developed over the past few decades in the
context of logic and functional programming---they permit types to be
parametrized by {\em values}.

The key idea behind our approach is to focus on the notion of a {\em
constraint system}. Constraint systems were originally developed in
\cite{cccc} to provide a simple framework for a large variety of
inference systems used in programming languages, in particular as a
foundation for constraint programming languages.  Patterned after
Scott's information systems~\cite{info-sys}, a constraint system is
organized around the notion of {\em constraints} or tokens of partial
information (e.g., {\tt X+Y>Z*3}), together with an entailment
relation $\vdash$.  Tokens may have first-order structure; existential
quantification is supported. The entailment relation is required to
support a certain set of inference rules arising from a Gentzen-style
formulation of intuitionistic logic.

In applying constraint systems to OO languages, the principal insight
is that objects typically have some immutable state constraints on
which are of interest to the application.  For instance, in \Java{}
the length of an array may not be statically known but is fixed once
the array is created. Hence we can enrich the notion of a type: for a
class {\tt C} we permit a type {\tt C\{c\}} where {\tt c} is a
constraint on the immutable fields of the class. Thus,
\Xcd{Array\{self.length==N\}} is a type satisfied by any array whose length
is {\tt N}---a (final) variable whose value may be unknown
statically. Subtyping is easily defined: a type {\tt C\{c\}} is a
subtype of {\tt D\{d\}} (in the sense that any value satisfying {\tt
C\{c\}} may be used wherever a value satisfying {\tt D\{d\}} is
expected) provided that {\tt C} is a subclass of {\tt D} and {\tt c}
entails {\tt d} in the underlying constraint system.

Constrained types maintain a key phase distinction between
compile-time computation (entailment checking in the underlying
constraint system) and run-time (normal OO computation).  Dynamic type
casting is permitted---it leads to code being generated for execution
at run time to check that properties of the given object satisfy the
given constraint. 

The constrained types approach enjoys many nice properties in contrast
to similar approaches such as DML(X)\cite{xi99dependent}.  Constrained
types are a very natural extension to OO languages, and quite easy to
use. Constraints may also be used to specify class invariants, and
conditions on the availability of fields and methods (conditional
fields and methods).  Final variables in the computation can be used
directly in types; there is no need for a separate parallel universe
of index expressions in the type system.  Constrained types always
permit field selection and equality at object types; hence the
programmer may specify constraints at any user-specified object type
(not just over the built-in constraint system).  Finally, constrained
types open the door to {\em user-defined} predicates and functions,
effectively permitting the user to enrich $\cal C$ (hence the power of
the compile-time type-checker) by developing application-specific
constraints using a constraint programming language such as CLP($\cal
C$) \cite{clp} or the richer RCC($\cal C$) \cite{rc}.

\subsection{Generic types}

In this paper we extend the constrained types approach to handle {\em
generic
types}~\cite{clu,ada,GJ,java-popl97,thorup97,Java3,csharp-generics}---types such as {\tt List<T>} in Java that are parametrized by other
types. Generic types are vital for implementing type-safe, reusable
libraries, especially collections classes. For instance the data type
{\tt Array} discussed above is generic on its member type.

To permit genericity, variables {\tt X} must be admitted over types.
What constraints can be used to specify conditions on such variables?
In nominally typed OO languages such as \Java, the answer is
relatively clear and a simple semantic framework can be sketched out.
A type is a class {\em name}.\footnote{This can be extended naturally
to account for interfaces.} Intuitively, an object belongs to a type
if it is an instance of the class. Types are equipped with a partial
order (the {\em subtyping} order) generated from the user program
through the ``{\tt extends}'' relationship.  Further, each type is
associated with (public) members. Members are of two kinds.  A {\em
field} has a name and an associated type. A {\em method} has a name
and an associated signature (the type of arguments and the return
type).  The members available at a type and its supertype are related:
members ``flow'' from supertypes to subtypes in a manner determined by
the overriding rules of the language.

This motivates a very natural constraint system on types.  For a type
variable {\tt X} we should be able to assert the constraint
\Xcd{X} \subtype \Xcd{T}: a valuation (mapping from variables to types) realizes
this constraint if it maps {\tt X} to a type that is a subtype of {\tt
T}. Similarly, it should be able to require that a type has a
particular member---a field with a given name and type, or a method
with a given name and signature. We introduce the constraints
\Xcd{T has f:T} and \Xcdmath{T has m($\tbar{x}\ty\tbar{S}$):T} to express this.

The entailment relation between these pieces of partial information is
straightforward to specify, given the interpretation specified in the
previous paragraph. For instance, the $\extends$ relation must be
transitive. If the user program does not specify that a class {\tt C}
extends {\tt D} (transitively), then {\tt C} does {\em not} extend
{\tt D} (closed world assumption). Section~\ref{sec:O} describes the
resulting Object constraint system, $\cal O$, in more detail.

The next question is: where should variable types be permitted?
Clearly, one must permit methods to have type parameters (as permitted
for instance in Java~\cite{Java3}, Scala~\cite{scala} and in
functional languages such as ML~\cite{ml} and Haskell~\cite{haskell}).
It is necessary as well to permit classes to be dependent on
types---for instance, {\tt Array} should be dependent on the type of its
member elements. While it is possible to develop an approach that
classes have type {\em parameters} (cf \cite{Java3}), the constrained
type approach suggests an alternative: classes may have type-valued
properties (=immutable instance fields). To create an instance of such
a class a type must be supplied to initialize this property. As with
other state of the object, this value is available at run time---and
can hence be used in dynamic cast expressions.

A pleasing aspect of the resulting design is that the same fundamental
mechanism of constrained types---imposing constraints on properties
-- is used to specify both value- and type-dependency of types.

\begin{example}[Array]
  Consider the class {\tt Array} declared as:
{\footnotesize
\begin{xten}
class Array[T](r:Region) {
  def get(p: Point{self in this.r}): this.T = ...;
  def set(p: Point{self in this.r}, v: this.T) = ...;
  ...
}
\end{xten}}
{}\noindent The class has two properties, a type-valued property {\tt
T} (enclosed in square brackets), and a value property {\tt r} of type
{\tt Region}. The {\tt get} method for the array requires a point {\tt
p} which must lie in the object's region.\footnote{Within the body of
a class, class members may be referenced without using the ``{\tt
this.}'' selector, as usual for OO languages. Hence occurrences of
{\tt this.r} and {\tt this.T} can be replaced by {\tt r} and {\tt T}
respectively.}
\end{example}

The type \Xcd{Array\{self.T==int\}} specifies the type of all arrays
whose base type (\Xcd{T}) is \Xcd{int}. The type
\Xcd{Array\{self.T} \Xcd{<:} \Xcd{Numeric,} \Xcd{self.r.rank==2\}} specifies the type of all arrays whose base
type is a subtype of {\tt Numeric}, and whose region has rank {\tt 2}.
The type \Xcd{Array\{self.T==List\{self.length==N\},self.r.rank==N\}}
specifies an {\tt N}-dimensional array whose elements are lists (of
unknown type) that are precisely {\tt N} long.

Note that for any expression \xcd"a" of type \xcd"Array", \xcd"a.T" is
a type, equivalent to the type to which \xcd"T" was initialized when
the object \xcd"a" was instantiated (e.g., {\tt String} or
\Xcd{Point\{self in R\}}.  Thus if {\tt a} is a ``final'' access path
(e.g., {\tt x.f.g}, where {\tt x} is an immutable variable, and {\tt f}
and {\tt g} are immutable fields), the expression {\tt a.T} may itself
be used as a type (cf. the return type {\tt this.T} for the {\tt
Array.get}).

Many features of modern object-oriented type systems fall out
naturally from this type system.

\subsection{The \FX($\cal C$) family}
To further the foundations of constrained type, we develop the \FX{}
family of languages. The core expression language is essentially
\FJ \cite{FJ}, with constrained types and constraints on classes, fields
and methods. A single set of rules specifies the static and dynamic
semantics for all languages in the family.  The static semantics is
shown to sound with respect to the operational semantics.

Different members of the family are associated with different
constraint systems. \FXZ{} is
\FX{} instantiated over the vacuous constraint system---the only
user-specifiable constraint permitted is the vacuous {\tt true}. \FXZ{}
corresponds to \FJ. \FXG{} permits user-specifiable constraints from the 
Object constraint system $\cal O$ described above---it corresponds to
\FGJ{} (being somewhat richer in permitting path types). \FXD{} permits
the use of constraints from some constraint system $\cal A$---it
corresponds to a language with a pure value-dependent type system as
described in \cite{OOPSLA08}. \FXGD{} permits the use of constraints
from $\cal O$ and $\cal A$---thus permitting value- and
type-dependence---and is the main topic for this paper.

\subsection{Design and implementation of \Xten{} type system}
\FXGD{} is the basis for the design of the type system for \Xten{} v1.7, a new
version of the language scheduled to be released in Fall 08.  We
discuss the details of the design. We describe the implementation.
The implementation supports run-time type introspection and
instantiation of generic types on primitive types.  The performance of
primitive arrays, especially, is critical for the high-performance
applications for which \Xten{} is intended.
Our design does not require primitive values be boxed.

\paragraph{Contributions.}
We extend the constrained types approach to handle generic types.  We
present a family of formal languages, $\FX(\cal C)$ that capture the
essence of the idea of constrained types. By appropriately choosing
$\cal C$, one can get languages that support simple types, just
value-dependent types, just type-dependent types, and both. We
establish the soundness of the type system for all members of the
family. We present the design and implementation of the type system
for a concrete language \Xten{} based on these ideas. We show how
several other ideas in OO typing (such as structural types) can also
be handled in this framework.

\paragraph{Outline.}

The rest of the paper is organized as follows.
%
An informal overview of generic constrained types in \Xten{}
is presented in
Section~\ref{sec:lang}.  
%
Section~\ref{sec:semantics} presents a formal semantics and a
proof of soundness.
%
We discuss extensions of the type system, including for
virtual types and self types, in
Section~\ref{sec:discussion}.
%
The implementation of generics in \Xten{} by translation to Java is described in 
Section~\ref{sec:translation}.
%
Section~\ref{sec:related} discusses related work.
%
Finally, Section~\ref{sec:conclusions} concludes.


