\Xten{} is a class-based object-oriented language.
that provides both dependent and generic types.
The language has a sequential core similar to Java or Scala, but
also
constructs for concurrency and distribution.
Like Java, the language provides single class
inheritance and multiple interface inheritance.
%\footnote{We plan
%to support traits in a future version of the language.}

A constrained type in \Xten{} is written \xcd"C{c}", where \xcd"C" is the
name of a class and \xcd"c" is a constraint on the properties
of \xcd"C" and the immutable state in scope at the type.  The
constraint \xcd"c" may refer to the value being constrained through
the special variable \xcd"self", which has type \xcd"C" in the
constraint.  Constraints are drawn from a constraint language that,
syntactically, is a subset of the boolean expressions of \Xten{}.  For
brevity, the constraint may be omitted and interpreted as \xcd"true".

Constraints may also be used as \emph{class invariants}, 
which are constraints on the class's members and type parameters 
that must be established by the class's
constructor and that subsequently hold for all instances of the class.
Methods and constructors may also be guarded by constraints on
their formal parameters---including type parameters. The
caller of a guarded method must ensure the constraint is
satisfied.

To illustrate the features of \Xten{}, we
develop a simple \xcd"Vector"
class, shown in Figure~\ref{fig:vector}.
The \xcd"Vector" class has a type parameter \xcd"T" and an \xcd"int"
property \xcd"len" (line 1).
Classes in \Xten{} may be declared with any number of type
parameters and properties.

Properties of a class may be constrained with 
a \emph{class invariant}.
\xcd"Vector"'s class invariant (line 1, in curly braces)
specifies that the length of
the vector be non-negative.
The class invariant must be established by all constructors of
the class and subsequently can be assumed for all instances of the class.
The class invariant may also place constraints on the type
parameters, discussed below.

\begin{figure}
{\footnotesize
\begin{numberedxten}
class Vector[T](len: int) {len >= 0} {
  val data: Rail[T]{self.length==this.len};

  def this(n: int{self>=0}, init: (int) => T):
        Vector[T]{len==n} {
    super();
    property(n);
    data = Rail.make[T](n);
    for (var i: int = 0; i < n; i++) {
      data(i) = init(i);
    }
  }

  def map[S](f: T => S): Vector[S]{self.len==this.len} {
    return new Vector[S](len, (i: int) => f(data(i)));
  }

  def get(i: int{0 <= self, self < len}){len > 0}: T {
    return data(i);
  }

  def print(){T $\extends$ Printable} {
    for (var i: int = 0; i < n; i++) {
      if (i > 0)
        print(", ");
      data(i).print();
    }
  }
}
\end{numberedxten}}
\caption{A Vector class in \Xten}
\label{fig:vector}
\end{figure}

\paragraph{Fields.}

As in Scala, fields are declared using the keywords \xcd"var"
or \xcd"val".  The \xcd"Vector" class has a single
immutable (final) \xcd"data" field (line 2), of type \xcd"Rail[T]"---a ``rail'' in \Xten is a zero-based, one-dimensional array similar to Java's \xcd"T[]".
The type of \xcd"data" is
has a constraint specifying that the length of
the \xcd"data" rail is the same as the vector length.
Note that \xcd"this" occurring
in the constraint refers to the instance of the enclosing
\xcd"Vector" class,
and \xcd"self" refers to the value being
constrained---\xcd"this.data" in this case.

\paragraph{Constructors.}

Objects in \Xten{} are initialized with constructors, which
must ensure that all properties of the new object
are initialized and that the class invariants of the object's
class and its superclasses and superinterfaces hold.
\Xten{} uses the syntax \xcd"def" \xcd"this" for constructors.
In \Xten{}, constructors have a ``return type'', which constrains
the properties of the new object.  The constructor in
Figure~\ref{fig:vector} (lines 4--12) takes
two arguments---an integer \xcd"n", and a function from integers
to \xcd"T", \xcd"init"---and 
initializes the
object to have type \xcd"Vector[T]{len==n}".
For both constructors and methods,
final formal parameters may be used in constraints
in the 
other formal parameter types and in the return type.

The body of the constructor
begins with a \xcd"super" call that invokes the superclass
constructor.  In this case, the superclass is
\xcd"Object" and its constructor takes no arguments.
Nullary \xcd"super" calls can be elided from \Xten programs.
A \xcd"property" statement then initializes the
properties of the new instance.  All properties are initialized
simultaneously and it is required that the property assignment
entails the constraint in the constructor return type.
The remainder of the constructor assigns the fields of the
instance from the constructor arguments.

\paragraph{Methods.}

Methods are declared with the \xcd"def" keyword.
Methods in \Xten may have type parameters.  
For instance, the \xcd"map" method (lines 14--16)
has a type parameter \xcd"S" and a value parameter that is a
function from \xcd"T" to \xcd"S".
A parametrized method is invoked by giving type arguments before the
expression arguments, e.g., \xcd"v.map[int](f)".\footnote{In \Xten, actual type
arguments can be inferred from the types of the value arguments.  However, type
inference is out of the scope of this paper.}

The method \xcd"get" (lines 18--20) takes an integer argument \xcd"i"
and returns the element at that position.  The type of \xcd"i"
is constrained to be within the bounds of the vector. 

Method declarations in \Xten
may also have additional
constraints, or \emph{guards}, on the method parameters.  A
method guard must be satisfied by the caller of the method, and
the guard holds throughout the method body.
The guard may constrain both the value and type parameters of
the method; it may also constrain other types in
scope at the declaration, including the enclosing class's type parameters.

The method \xcd"get"
has a constraint on the type of \xcd"i" that requires
that it be within the vector bounds.
The method also has a guard that
requires that the actual
receiver's
\xcd"len" property be positive---calls to \xcd"get" on empty
vectors are not permitted.
A method with a guard is called a \emph{conditional method}.

Method guards can also constrain type parameters.
For instance, the \xcd"print" method can be invoked only if
the type parameter \xcd"T" is instantiated on a type that implements
\xcd"Printable".  Since the guard holds throughout the body of the
method, the \xcd"print" method can be invoked on each element of \xcd"data"---it
is guaranteed to implement \xcd"Printable".
This feature is similar to optional methods in CLU~\cite{clu} and to generlized type constraints in C$\sharp$~\cite{emir06}.
% Using structural constraints on \xcd"T" would give more
% expressive power; optional methods are discussed further in
% Section~\ref{sec:structural}.
Constructors in \Xten may also have guards.

Method overriding is similar to Java: a method of a subclass
with the same name and parameter types overrides a method of the
superclass.  An overridden method may have a return type that is
a subtype of the superclass method's return type.
A method guard may be weakened by an overriding
method; that is, the guard in the superclass must entail the  
guard in the subclass.

Method overloading in \Xten is not constraint-sensitive.  It is
illegal for a class to contain two methods with the same name
and the same parameter types when constraints are erased from the 
types.  Constraints are also not evaluated during method
dispatch, as in predicate dispatch~\cite{jpred}.

\eat{
\xcd"List" also defines three constructors: the first
constructor takes no value arguments and initializes
the length to \xcd"0".  Note that \xcd"head" and \xcd"tail" are
not assigned since they are inaccessible.
The second constructor takes an argument for the head of the
list; the third takes both a head and tail.
}

\paragraph{Type constraints and variance}
\label{sec:variance-overview}

For generic types, the class invariant may also be used to provide 
bounds on the type parameters.
For example, in the following code,
\xcd"SortedList" 
specifies that the element type \xcd"T"
be a subtype of \xcd"Comparable[T]":
\begin{xtenmathnoindent}
 class SortedList[T] {T$\extends$Comparable[T]} extends List[T] {
   def sort() { ... x.compare(y) ... }
 }
\end{xtenmathnoindent}
Constraints can specify either subtype (\xcd"<="), supertype (\xcd">="),
or equality bounds (\xcd"==").

\Xten supports definition-site variance annotations.
Parameters may be declared invariant, covariant, or
contravariant.
If a parameter \xcd"X" of a class \xcd"C" is covariant,
then if \xcd"S" is a subtype of
\xcd"T", the type \xcd"C[S]" is a subtype of \xcd"C[T]".
Similarly, if \xcd"X" is contravariant, 
\xcd"C[T]" is a subtype of \xcd"C[S]".
Invariant parameters are the default; a covariant parameter is
declared by prepending ``\xcd"+"'' to the parameter name in the
class header; a contravariant parameter is declared by
prepending ``\xcd"-"''.

It is illegal for a covariant parameter to occur in a negative
position in its class declaration and for a contravariant
parameter to occur in a positive position.  A position is
negative if it is a formal parameter type, or occurs in a method
where clause.  A position is positive if it is a return type or
occurs in a method constraint.

\todo{
Variant type parameters used in method guards and in other
constraints in method signatures must also be
restricted.  
}



