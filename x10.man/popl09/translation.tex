This section describes an implementation approach for
generic types in \Xten{} on a JVM.
We describe the implementation as a translation to Java.

The design is a hybrid design combining techniques of run-time
instantiation from
NextGen~\cite{nextgen,allen03,allen04} and type-passing from
PolyJ~\cite{java-popl97}.  Generic classes are translated
into ``template'' classes that are instantiated on demand at run time by
binding the type properties to concrete types.
%
Value constraints are erased from type references.
Adapter objects are used to represent type
properties and constraints.  
Run-time type tests (e.g., casts) are translated
into code that checks those constraints at run time.
%
This design has been implemented in the \Xten{} compiler, built
on the Polyglot framework, which
translates \Xten{} source to Java source.\footnote{There is also
a translation from \Xten{} to C++ source, not described here.}

\subsection{Classes}
Each class is translated into a \emph{template class}.
The template class is compiled by a Java compiler (e.g., javac)
to produce a class file.
At run time, when a constrained type \xcd"C{c}" is first referenced, a
class loader loads the template class for \xcd"C" and then
transforms its bytecode, specializing it to the constraint
\xcd"c".  The implementation specializes constraints on
types, not values; we leave value-constraint specialization to
future work.
%
For example, consider the following classes.
{\footnotesize
\begin{xten}
class A[T] {
    var a: T;
}
class C {
    val x: A[int] = new A[int]();
    val y: int = x.a;
}
\end{xten}}

The compiler generates the following code:
{\footnotesize
\begin{xten}
@Parameters({"T"})
class A {
    @TypeProperty public static class T { }
    public x10.runtime.Type T;

    T a;

    // Dummy constructor; will be eliminated at run time
    @Synthetic public A(Class T) { this(); }
}

class C {
    final A x = new A(int.class);
    final int y = Runtime.to$int(x.a);
}
\end{xten}}

The member class \xcd"A.T" is used in place of the
type property \xcd"T".   The field \xcd"T" of type
\xcd"x10.runtime.Type" captures the actual constrained type on which \xcd"A"
is instantiated, and is used for run-time type tests.
The \xcd"Parameters" annotation on \xcd"A" is used during
run-time instantiation to identify the parameters.
Synthetic constructors with added \xcd"Class" parameters are
used to pass instantiation arguments to the \xcd"new"
expression.
This code is compiled to Java bytecode.

When an expression (e.g., \xcd"new C()") is evaluated,
the class \xcd"C" is loaded.
The class loader transforms the bytecode as if it had
been written as follows:

{\footnotesize
\begin{xten}
class C {
    final A$$int x = new A$$int();
    final int y = x.a;
}
\end{xten}}

The class loader rewrites allocations of template classes
(e.g., \xcd"A") with allocations of the
instantiated classes (e.g., \xcd"A$$int").
The name of the instantiated class is a mangled name derived from the name
of the template class and the type properties.
The implementation cannot generate this code directly because
the class \xcd"A$$int" does not yet exist; the Java source compiler
would fail to compile \xcd"C".

Upon evaluation of the constructor,
class \xcd"A$$int" is loaded.
The class loader intercepts
this, demangles the name, and loads the bytecode for the
template class \xcd"A".
The bytecode is transformed, replacing the type property \xcd"T"
with the concrete type \xcd"int".

For the Java primitive types and \xcd"Object",
the methods
\xcd"Runtime.to$X(Object)" and \xcd"Runtime.from(X)" are used
to coerce a type to and from the actual type \xcd"X", possibly
with additional casts.
Both are eliminated from the transformed
bytecode, but are needed for the template class to type-check.

\eat{
Currently, the class loader instantiates the template for
every encountered combination of parameters.  If desired,
it is possible (and relatively easy) to optimize this scheme
to instantiate only for the Java primitive types and Object,
giving nine possible instantiations per parameter.
}

%Instantiations are used for representation.
%Adapter objects are used for run time type information.
%
%Could do instantiation eagerly, but quickly gets out of hand without
%whole-program analysis to limit the number of instantiations: 9
%instantiations for one type property, 81 for two type
%properties, 729 for three.

%Constructors are translated to static methods of their
%enclosing
%class.
%Constructor calls
%are translated to calls to static methods.

\eat{
Consider the code in Figure~\ref{fig:translation1}.  It contains most of the
features of generics that have to be translated.
\begin{figure*}[tp]
{\footnotesize
\begin{xten}
class C[T] {
    var x: T;
    def this[T](x: T) { this.x = x; }
    def set(x: T) { this.x = x; }
    def get(): T { return this.x; }
    def map[S](f: F[T,S]): S { return f._(this.x); }
    def d() { return new D[T](); }
    def t() { return new T(); } // FIXME
    def isa(y: Object): boolean { return y instanceof C[T]; }
}
abstract class F[T,S] { S _(T x); }

val x : C = new C[String]();
val y : C[Int] = new C[Int]();
val z : C{T <: Array} = new C[Array[Int]]();
val f : F[String,Int] = ...;
x.map[Int](f);
new C[Int{self==3}]() instanceof C[Int{self<4}];
\end{xten}}
\caption{Code to translate}
\label{fig:translation1}
\end{figure*}

The translated version is shown in Figure~\ref{fig:translation2}.
\begin{figure*}[tp]
{\footnotesize
\begin{xten}
@Parameters({"T"})
class C {
    @TypeProperty public static class T { }
    T x;
    C(T x) { this.x = x; }
    @Synthetic C(Class T, T x) { this(x); }
    @Synthetic public static boolean instanceof\$(Object o, String constraint) { assert(false); return true; }
    public static boolean instanceof\$(Object o, String constraint, boolean b) { /*check constraint*/; return b; }
    public static Object cast\$(Object o, String constraint) { /*check constraint*/; return (C)o; }
    void set(T x) { this.x = x; }
    T get() { return this.x; }
    @Synthetic
    @Parameters("S")
    public static class map {
        public static class S { };
        public C c;
        public map(C c) { this.c = c; }
        @Synthetic
        public map(Class S, C c) { this(c); }
        public S apply(@InstantiateClass({"C\$T", "C\$map\$S"}) F f) { return f._(c.x); }
        @Synthetic
        public T apply(Class T, T x, T y) { return apply(x, y); } // We might only need one
    }
    @Synthetic
    @ParametricMethod("T")
    Object make\$map(Class T) { assert(false); return null; }
    @Synthetic
    Object make\$map(Class T, boolean ignored) {
        Object retval = null;
        try {
            X10RuntimeClassloader cl = (X10RuntimeClassloader)C.class.getClassLoader();
            Class<?> c = cl.instantiate(map.class, T); 
            retval = c.getDeclaredConstructor(new Class[] { C.class }).newInstance(this);
        }
        catch (IllegalAccessException e) { }
        catch (NoSuchMethodException e) { }
        catch (InstantiationException e) { }
        catch (InvocationTargetException e) { }
        return retval;
    }
    @InstantiateClass({"C\$T"}) D d() { return new D(T.class); }
    T t() { return new T(); } // FIXME
    boolean isa(Object y) { return Runtime.instanceof\$(C.instanceof\$(y, null), T.class); }
}
@Parameters({"T","S"})
abstract class F { ... }

C x = new C(String.class);
C y = new C(int.class);
C z = new C(((X10RuntimeClassloader)C.class.getClassLoader()).getClass("Array\$\$int"));
F f = ...;
((C.map)(Object)(C.map)x.make\$map(int.class)).apply(int.class, f);

Runtime.instanceof\$(C.instanceof\$(new C(int.class)(), "self<4"), int.class);
\end{xten}}
\caption{Translated code}
\label{fig:translation2}
\end{figure*}
}

\subsection{Eliminating method type parameters}

We generate parameterized adapter classes for each
parameterized method.  Invoking a method thus involves
instantiating such an adapter class and invoking its
\xcd"apply()" method.

\subsection{Translation to Java}

\subsection{Run-time instantiation}

We translate \xcd"instanceof" and cast operations to combinations
of instanceof tests/casts and calls to
methods of a \xcd"Type" because the actual implementation of
the operation may require run-time constraint solving or other
complex code that cannot be easily substituted in when rewriting
the bytecode during instantiation.
