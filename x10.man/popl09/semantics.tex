\section{Judgements}

Here is the syntax for \GFX.

\begin{tabular}{r@{\quad}rcl}
(C Term) & {\tt t} &{::=}& {\tt x}\alt \self  \alt {\tt t.f} \\
&&& \alt {\tt C}($\bar{\tt t}$) \alt{\tt g}($\bar{\tt t}$) \\
(Const.) & {\tt c},{\tt d} &{::=}&\true\alt {\tt p}($\bar{\tt t}$) \alt {\tt t=t}\\
&&& \alt {\tt c,c}\alt{\tt  x:T;~c}\\
(Class) & {\tt L} &{::=}& \klass\ {\tt C}[$\bar{\tt X}$]($\bar{\tt f}$:$\bar{\tt T}$)\{{\tt c}\}\ {\tt extends}\ {\tt T}\ \{$\bar{\tt M}$\} \\
(Method)& {\tt M} &{::=}& {\tt def}\ {\tt m}[$\bar{\tt X}$]($\bar{x}:\bar{T}$)\{c\}:T=e;\\
(Exp.)& {\tt e} &{::=}& \tt {\tt x} \alt {\tt e.f} \alt {\tt e.m}[$\bar{\tt T}$]($\bar{\tt e}$)\\
&&& \alt \new\ C[$\bar{\tt T}$]($\bar{\tt e}$) \alt {\tt e}\ \mbox{as {\tt T}} \\ 
(Type)& {\tt S},{\tt T},\\
&{\tt U},{\tt Z}&{::=}& {\tt X} \alt {\tt p.X} \alt {\tt C} \alt {\tt T\{d\}}\\
(Path) & {\tt p}&{::=}& {\tt x} \alt {\tt p.f}
\end{tabular}

\noindent The constraint {\tt x:C;T} is thought of as the existential
quantification (projection) of {\tt x} (of type {\tt C}) in {\tt T}. We think of the type
$\tt C\{c_1\}\{c_2\}$ as another notation for the type $\tt C\{c_1,c_2\}$.

In the rest of this paper we will assume give some fixed but unknown
constraint system $\cal D$. We will assume that the program $P$ is
written using constraints from $\cal D$, and further that classes
defined in $P$ do not have a cyclic inheritance struture. 

\subsection{The Object constraint system, $\cal O$}\label{sec:O}

From $P$ and $\cal D$ we also generate a new constraint system $\cal
O$, the constraint system of {\em objects} over $P$ and $\cal D$ as
follows. Let $\tt C,D$ range over names of classes in $P$, $\tt f$ over
field names, $\tt m$ over method names, $\tt S,T$ over types, $\tt c$ over
constraints in the underlying data constraint system $\cal D$.
The constraints of $\cal O$ are given by:

\begin{tabular}{r@{\quad}rcl}
(Const.) & {\tt c},{\tt d} &{::=}& $\klass(\tt C)$ \alt ${\tt S}\ \extends\ {\tt T}$ \\
&&& \alt $\fields(\tt x)= \bar{\tt f}:\bar{\tt T}$ \\
&&& \alt $\mtype({\tt x},{\tt m},\bar{\tt x})=(\bar{T},{\tt c} \rightarrow {\tt T}))$\\
\end{tabular}

The constraint system satisfies the following axioms and inference
rules. 

\infrule[Class]
{\klass\ {\tt C[\bar{\tt X}](\bar{\tt f}:\bar{\tt T})\ extends\ D\ \ldots \in P}}
{\vdash_{\cal O} {\tt C} \extends {\tt D}}

\infrule[Fields]
{\bar{X},\bar{\tt f}:\bar{\tt C\{e\}} \mbox{ type and value fields defined or inherited at class $D$}}
{{\tt z}:{\tt D\{d\}} \vdash_{\cal O} \fields(\tt z)=
 \bar{X},\bar{\tt f}:\bar{\tt C\{e[z/\this],\self {\tt == z}.{\tt f_i},d[z/\self]\}}}

\infax[Sel-V]{\vdash_{\cal O} D[\bar{\tt T}](\bar{\tt t}).{\tt f_i=t_i}}
\infax[Sel-T]{\vdash_{\cal O} D[\bar{\tt T}](\bar{\tt t}).{\tt X_i=t_i}}

\infrule[mtype]
{{\tt m}(\bar{\tt x}:\bar{\tt E})\{{\tt c}\}:{\tt F}=\{\ldots\}\ \mbox{defined or inherited at $\tt D$}\\
\theta = [{\tt z},\bar{\tt z}/\this,\bar{\tt x}]}
{{\tt z}:{\tt D\{d\}} \vdash_{\cal O} \mtype({\tt z},{\tt  m}, \bar{\tt z})=
(\bar{\tt E},{\tt c}\rightarrow {\tt F}\{{\tt d}[{\tt z}/\self]\})\theta}

The constraint system $\cal C$ is the (disjoint) conjunction $\cal
D,O$ of the constraint systems $\cal D$ and $\cal O$. (This requires
the assumption that $\cal D$ does not have any constraints in common
with $\cal O$.)

{\em Note: Figure out whether consistency checks need to be added.}

\section{Rules}

\subsection{Judgements}
\begin{definition}[Designator] The class of {\em designators}
is given by:
\begin{tabular}{r@{\quad}rcl}
(Designator) & {\tt d} &{::=}& {\tt x}\alt C($\bar{\tt d}$)  \alt {\tt d.f} \\
\end{tabular}
\end{definition}

In the following $\Gamma$ is a {\em well-typed context}, i.e.{} a
(finite, possibly empty) sequence of formulas $\tt x:T$, $\tt T\
\type$ and constraints $\tt c$ satisfying:
\begin{enumerate}
  \item for any formula $\phi$ in the sequence all variables $\tt x$
    ({\tt X}) occuring in $\phi$ are defined by a declaration $\tt
    x:T$ ({\tt X\ \type}) in the sequence to the left of $\phi$.

  \item for any variable $\tt x$ ({\tt X}), there is at most one
  formula $\tt x:T$ ({\tt X\ \type})  in $\Gamma$.
\end{enumerate}

The judgements of interest are:
\begin{description}
  \item[Type well-formedness]  $\Gamma \vdash {\tt T} \ {\tt type}$
  \item[Subtyping] $\Gamma \vdash {\tt S} \subtype {\tt T}$
  \item[Typing]    $\Gamma   \vdash {\tt e:T}$
  \item[Method ok] $\Gamma \vdash M\ \mbox{OK in $C$}$ (method $\tt M$ is well-defined for the class $\tt C$). 
  \item[Field ok]  $\Gamma \vdash f:T\ \mbox{OK in $C$}$ (field $\tt f:T$ is well-defined for the class $\tt C$).
  \item[Class ok] $\Gamma \vdash {\tt Cl} \ OK$ (class definition {\tt Cl} is ok). 
\end{description}


In what follows we will sometimes think of the family of five
judgements as a single judgement $\Gamma \vdash \phi$, where $\phi$
ranges over the formulas $T\ \tt type$, $e:T$, $S \subtype T$, $f:T\
\mbox{OK in $C$}$, $M\ \mbox{OK in $C$}$, and $C\ \mbox{OK}$.

In defining these judgements we will use $\Gamma \vdash_{\cal C} c$,
the judgement corresponding to the underlying constraint system. For simplicity,
we define $\Gamma \vdash {\tt c}$ to mean $\sigma(\Gamma)\vdash_{\cal C} {\tt c}$,
where the {\em constraint projection}, $\sigma(\Gamma)$ is defined thus:

\begin{tabular}{l}
$\sigma(\epsilon)={\tt true}$\\
$\sigma(x:C\{c\}, \Gamma)$=c[x/\self], $\sigma(\Gamma)$\\
$\sigma(c,\Gamma)$ = c, $\sigma(\Gamma)$
\end{tabular}

\subsection{Well formedness rules}

We use the judgement for well-typedness for expressions to represent
well-typedness for constraints. That is, we posit a special type {\tt
o} (traditionally the type of propositions), and regard constraints as
expressions of type {\tt o}. Further, we change the formulation
slightly so that there are no constraints of the form {\tt p(t1,...,
tn)}; rather instance method invocation syntax is used to express
invocation of pre-defined constraints. This logically leads to the
step of simply marking certain classes as ``predicate'' classes -- all
the (instance) methods of these classes whose return type is {\tt o}
then correspond to ``primitive constraints.''

Syntactically, we will continue to use the symmetric syntax
{\tt p(t1,\ldots, tn)} rather than {\tt t1.p(t2,\ldots, tn)}.

(The alternative is to introduce static methods, and static method
invocations in the expression language. This is not too difficult, but
it is annoying to have to repeat most of the formulation of instance
methods, and to have one more case to prove.)

So this means that the only cases left to handle are all the simple
ones, expressing the availability of certain constants and operators
at type {\tt o} (see Figure~\ref{Figure:Wff}).

\begin{figure*}
\footnotesize

\tabcolsep=0pt

\begin{tabular}{p{0.25\textwidth}p{0.25\textwidth}p{0.25\textwidth}p{0.25\textwidth}}
\infax[{\tt true}]{\Gamma \vdash {\tt true}: o}
&
\infrule[Equals]
{\Gamma \vdash t_0: T_0 \andalso \Gamma \vdash t_1: T_1 \andalso  (\Gamma \vdash T_0 \subtype T_1 \vee \Gamma \vdash T_1 \subtype T_0)}
{\Gamma \vdash t_0=t_1:o}
&
\infrule[And]
{\Gamma \vdash c_0: o \andalso \Gamma \vdash c_1: o}
{\Gamma \vdash (c_0,c_1):o}
&
\infrule[Some]
{\Gamma \vdash t: T \andalso \Gamma \vdash c[t/x]:o}
{\Gamma \vdash x:T;c: o}
\\
\infrule[Class]
{\Gamma \vdash \klass({\tt C})}
{\Gamma \vdash {\tt C}\ \type} 
&
\infax[Id-X]{\Gamma, {\tt X}\ \type \vdash {\tt X}\ \type}
&
\infrule[Dep]
{\Gamma \vdash T\ \type \andalso \Gamma, \self:T \vdash c:o}
{\Gamma \vdash T\{c\}\ {\tt type}} 
&
\infrule[Path]
{\Gamma \vdash {\tt p:T} \andalso \Gamma, {\tt x:T} \vdash \fields(x)=\bar{\tt X},\bar{\tt f}:\bar{\tt T}}
{\Gamma \vdash {\tt p.X_i}\ {\tt type}} 
\end{tabular}
\caption{Constraint and Type Well-formedness rules}\label{Figure:Wff}
\end{figure*}

\section{Type inference rules}
\subsection{Subtype judgement}

Only one inference rule needs to be specified:
\infrule[Dep type]
{\Gamma \vdash C\ \extends\ D \andalso \Gamma \vdash C\{c\}\ \type, D\{d\}\ \type \\
\Gamma, \self:C,c\vdash d}
{\Gamma \vdash C\{c\} \subtype D\{d\}}

\subsection{Expression typing judgement}

Now we consider the rule for method invocation. Assume that in a type
environment $\Gamma$ the expressions $\bar{e}$ have the types
$\bar{T}$. Since the actual values of these expressions are not known,
we shall assume that they take on some fixed but unknown values
$\bar{z}$ of type $\bar{T}$.  Now for $z$ as receiver, let us assume
that the type $T\equiv C\{d\}$ has a method named {\tt m} with
signature $\bar{z}: \bar{Z}, c \rightarrow U$.  If there is no method
named {\tt m} for the class {\tt C} then this method invocation cannot
be type-checked. Without loss of generality we may assume that the
parameters of this method are named $\bar{z}$, since we are free to
choose variable names as we wish because of $\alpha$-equivalence. Now
in order for the method to be invocable, it must be the case that the
types $\bar{T}$ are subtypes of $\bar{Z}$. (Note that there are no
occurrences of {\tt this} in $\bar{Z}$; they have been replaced by
$z$ -- see Section~\ref{sec:O}) Further, it must be the case that for these parameter values,
the constraint $c$ is entailed. Given all these assumptions it must be
the case that the return type is $U$ --- with all the parameters
$\bar{z}$ existentially quantified.

\begin{figure*}
\footnotesize
\tabcolsep=0pt
\begin{tabular}{p{0.25\textwidth}p{0.25\textwidth}p{0.47\textwidth}}
\infax[T-Var]
{\Gamma, {\tt x}:{\tt T} \vdash {\tt x}:{\tt T\{\self{\tt ==x}\}}}
%\infrule[T-Var]
%{\sigma(\Gamma, \self:C), c \vdash_{\cal C} d \\
% \Gamma \vdash  C\{d\}\ \type}
%{\Gamma, x:C\{c\} \vdash x:C\{d\}}
&
\infrule[T-Cast]
{\Gamma \vdash {\tt e}:{\tt U} \andalso \Gamma \vdash {\tt T} \ \type}
{\Gamma \vdash {\tt e}\ \as\ {\tt T}: {\tt T}} &
\infrule[T-Field]
{\Gamma \vdash {\tt e}: {\tt S} \andalso \Gamma,{\tt z}:{\tt S}\vdash {\tt z}\ \has\ {\tt f}:{\tt T} \andalso \mbox{({\tt z} fresh)} }
{\Gamma \vdash {\tt e}.{\tt f}:  ({\tt z}:{\tt S};{\tt T})}
\end{tabular}

\begin{tabular}{p{0.50\textwidth}p{0.47\textwidth}}
\infrule[T-INVK]
{\Gamma \vdash {\tt e}:{\tt T},\bar{\tt e}:\bar{\tt T} \andalso \\
\Gamma,{\tt z}:{\tt T},\bar{\tt z}:\bar{\tt T} \vdash \mtype({\tt z}, {\tt m}, \bar{\tt z})=\bar{\tt Z}, {\tt c} \rightarrow {\tt U} \andalso \mbox{({\tt z},$\bar{\tt z}$ fresh)} \\
\Gamma, {\tt z}:{\tt T}, \bar{\tt z}:\bar{\tt T} \vdash \bar{\tt T} \subtype \bar{\tt Z},{\tt c}}
{\Gamma \vdash {\tt e}.{\tt m}(\bar{\tt e}): ({\tt z}:{\tt T};\bar{\tt z}:\bar{T};U)}
&
\infrule[T-NEW]
{\Gamma \vdash \bar{\tt e}:\bar{\tt T} \andalso \\ 
\Gamma,{\tt z}:{\tt C}\vdash \fields({\tt z})=\bar{\tt f}:\bar{\tt Z}  \andalso \mbox{({\tt z},$\bar{\tt z}$\ fresh)}\\
\Gamma, {\tt z}:{\tt C}, \bar{\tt z}:\bar{\tt T}, {\tt z}.\bar{\tt f}=\bar{\tt z} 
\vdash \bar{\tt T} \subtype \bar{\tt Z}, inv({\tt C},{\tt z})}
{\Gamma \vdash \new\ {\tt C}(\bar{\tt e}): C\{\bar{\tt z}:\bar{\tt T}; \self.\bar{\tt f}=\bar{\tt z},inv({\tt C},\self)\}} \\
\infrule[Method OK]
{\this:{\tt C}, \bar{\tt x}:\bar{\tt T},{\tt c} \vdash {\tt T} \ \type, \bar{\tt T} \ \type, {\tt e}:{\tt U}, {\tt U} \subtype {\tt T}}
{{\tt def}\ {\tt m}(\bar{\tt x}:\bar{\tt T})\{{\tt c}\}:{\tt T}= {\tt e};\ \mbox{OK in}\ C}
&
\infrule[Class OK]
{\bar{\tt M}\ \mbox{OK in}\ {\tt C} \andalso \this:{\tt C},{\tt c} \vdash \bar{\tt T}\ \type, {\tt T}\ \type}
{\mbox{\tt class}\ {\tt C}(\bar{\tt f}:\bar{\tt T})\{{\tt c}\}\ \mbox{\tt extends}\ {\tt T}\{\bar{\tt M}\} \ \mbox{OK}}
\end{tabular}
\caption{Type judgement}\label{fig:typing judgement}
\end{figure*}




