\documentclass[preprint,nocopyrightspace,9pt]{sigplanconf}
%\documentclass{llncs}

\def\val{\mbox{\tt val}}
\def\klass{\mbox{\tt class}}
\def\var{\mbox{\tt var}}
\def\self{\mbox{\tt self}}
\def\this{\mbox{\tt this}}
\def\new{\mbox{\tt new}}
\def\extends{\mbox{\tt extends}}
\def\return{\mbox{\tt return}}
\def\true{\mbox{\tt true}}
\def\as{\mbox{\tt as}}
\def\fields{\mbox{\tt fields}}
\def\type{\mbox{\tt type}}
\def\mtype{\mbox{\tt mtype}}
\def\feild{\mbox{\tt field}}
\def\Xten{{\sf X10}}
\def\GXten{{\sf Gen X10}}
\def\CFJ{{\sf CFJ}}

\newif\iflncs
\lncsfalse

\usepackage{times-lite}
\usepackage{mathptm}
\usepackage{txtt}
\usepackage{stmaryrd}
\usepackage{code}
\usepackage{bcprules}
%\usepackage{ttquot}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{afterpage}
\usepackage{balance}
\usepackage{floatflt}
\usepackage{defs}
\usepackage{utils}
\usepackage[pdftex]{graphicx}
\usepackage{xspace}
\usepackage{ifpdf}
\usepackage{listings}
\usepackage{x10}

\newif\ifsemantics
%\semanticsfalse
\semanticstrue

\hfuzz=1pt

\pagestyle{plain}


\ifpdf
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}
\fi


% \input{../../../../vj/res/pagesizes}
% \input{../../../../vj/res/vijay-macros}
\newcommand\alt{\bnf}

\newcommand\Implies{\Rightarrow}

\iflncs
\else
\newtheorem{example}{Example}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newenvironment{proof}{
\trivlist
\item[\hskip \labelsep \textsc{Proof.}]
\selectfont
\ignorespaces}{$\Box$}

%\newtheorem{proof}[theorem]{Proof}
\fi

\begin{document}
\title{Type system for \Xten, v0.2 7/4/2008}
\iflncs
\author{a}
\else
\authorinfo{a}
\fi
\maketitle

\begin{abstract}
Notes on a formal semantics for dependently typed \Xten, and generically typed \Xten.
\end{abstract}

\section{Judgements}

Here is the syntax for \CFJ, converted to the new X10 1.7 style
syntax. {\em (Nate: we should convert the OOPSLA paper to this syntax as
well.)}

{\em Need to answer reviewer's question: Does the invariant associated
with a class C change when that associated with the class D that it
extends, changes? (Yes.) Need to figure out what this means for
separate compilation. Should still be able to compile separately. It
is just the case now that when you link a new class in, the invariant
for this class will depend on the invariant that you have loaded for
its superclasses. Java and X10 do nothing to keep compile-time types
consistent with link-time types.}

\begin{tabular}{r@{\quad}rcl}
(C Term) & {\tt t} &{::=}& {\tt x}\alt \self  \alt {\tt t.f} \\
&&& \alt \new\ {\tt C}($\bar{\tt t}) \alt{\tt g}(\bar{\tt t})$ \\
(Const.) & {\tt c},{\tt d} &{::=}&$\true\alt {\tt p}(\bar{\tt t}) \alt {\tt t=t}$\\
&&& $\alt {\tt c,c}\alt{\tt  val\,x:T;~c}$\\
(Class) & {\tt L} &{::=}& $\klass\ C(\bar{f}:\bar{T})\{c\}\  \extends\ T\ \{\bar{M}\}$ \\
(Method)& {\tt M} &{::=}& ${\tt def}\ {\tt m}(\bar{x}:\bar{T})\{c\}:T=e;$\\
(Exp.)& {\tt e} &{::=}& $\tt x \alt e.f \alt e.m(\bar{e})\alt \new\ C(\bar{e})$\\
&&&  $\alt {\tt e}\ \mbox{as {\tt T}}$ \\
(Type)& {\tt S},{\tt T},\\
&{\tt U},{\tt Z}&{::=}& $\tt C\{d\}$\\
\end{tabular}

We will use the abbreviation  $\val x:S,y_1:T_1,\ldots,y_n:T_n;T$
for $\val\ x:S; \val\ y_1:T_1;\ldots;\val\ y_n:T_n;T$.

In the rest of this paper we will assume give some fixed but unknown
constraint system $\cal D$. We will assume that the program $P$ is
written using constraints from $\cal D$, and further that classes
defined in $P$ do not have a cyclic inheritance struture. 

\subsection{The Object constraint system, $\cal O$}\label{sec:O}

From $P$ and $\cal D$ we also generate a new constraint system $\cal
O$, the constraint system of {\em objects} over $P$ and $\cal D$ as
follows. Let $C,D$ range over names of classes in $P$, $f$ over
field names, $m$ over method names, $T$ over types, $c$ over
constraints in the underlying data constraint system $\cal D$.
The constraints of $\cal O$ are given by:

\begin{tabular}{r@{\quad}rcl}
(Const.) & {\tt c},{\tt d} &{::=}& $\klass(C)$ \alt $C\ \extends\ D$ \\
&&& \alt $\fields(x, \bar{f}:\bar{T})$ \\
&&& \alt $\mtype(x,m, (\bar{x}:\bar{T},c \rightarrow T))$\\
\end{tabular}

In the method signature formula $(\bar{x}:\bar{T},c \rightarrow T))$,
the variables $\bar{x}$ are considered bound; formulas with bound variables are considered
equivalent upto $\alpha$-renaming.

The constraint system satisfies the following axioms and inference
rules. 

For every class $C$ defined in $P$, we have: $\vdash_{\cal O} \klass(C)$.

The $\extends$ relation is transitive and $C\ \extends\ D$ whenever
$C$ extends $D$ in the given program.

Let $\bar{f}:\bar{T}$ be the fields defined or inherited at class $C$.
The $\vdash_{\cal_O}$ also satisfies:

\infax[fields]{\Gamma, z:D\{d\} \vdash_{\cal O} \fields(z, \bar{f}:\bar{T'})}

\noindent where for any constraint $e$, $e'$ is the constraint $\val\ \this;\this=z,d,e$,
and for any type $F\{f\}$, the type $F'$ is $F\{f'\}$.

For every method
$m(\bar{x}:\bar{E})\{c\}:F=\{\ldots\}$ defined or inherited at class $D$,
$\vdash_{\cal_O}$ satisfies:

\infax[mtype]{\Gamma,z:D\{d\} \vdash_{\cal O} \mtype(z, m, \bar{x}:\bar{E'},c'\rightarrow F')}

\noindent where $E',c',F'$ are as above.

The constraint system $\cal C$ is the (disjoint) conjunction $\cal
D,O$ of the constraint systems $\cal D$ and $\cal O$. (This requires
the assumption that $\cal D$ does not have any constraints in common
with $\cal O$.)

{\em Note: Figure out whether consistency checks need to be added.}

\section{Rules}

\subsection{Judgements}

The following judgements will be defined. In all of them $\Gamma$ is a
well-typed context.
\begin{itemize}
  \item Given $\Gamma$, the type $T$ is well-formed: $\Gamma \vdash T
  \ {\tt type}$
  \item Given $\Gamma$, the type $S$ is a subtype of $T$: $\Gamma \vdash S \subtype T$
  \item Given $\Gamma$, the expression $e$ is of type $T$: $\Gamma
  \vdash e:T$
  \item Given $\Gamma$, the method $M$ is well-defined for the class $C$: 
  $\Gamma \vdash M\ \mbox{OK in $C$}$
  \item Given $\Gamma$, the field $M$ is well-defined for the class $C$:
    $\Gamma \vdash f:T\ \mbox{OK in $C$}$
  \item Given $\Gamma$, the class definition \mbox{\em Cl} is well-defined: $\Gamma \vdash \mbox{{\em Cl}\ OK}$
\end{itemize}


In what follows we will sometimes think of the family of five
judgements as a single judgement $\Gamma \vdash \phi$, where $\phi$
ranges over the formulas $T\ \tt type$, $e:T$, $S \subtype T$, $f:T\
\mbox{OK in $C$}$, $M\ \mbox{OK in $C$}$, and $C\ \mbox{OK}$.

In defining these judgements we will use $\Gamma \vdash_{\cal C} c$,
the judgement corresponding to the underlying constraint system. For simplicity,
we define $\Gamma \vdash c$ to mean $\sigma(\Gamma)\vdash_{\cal C} c$,
where the {\em constraint projection}, $\sigma(\Gamma)$ is defined thus:

\begin{tabular}{l}
$\sigma(\epsilon)={\tt true}$\\
$\sigma(x:C\{c\}, \Gamma)$=({\tt val} x:C;(x=\self,c)), $\sigma(\Gamma)$\\
$\sigma(c,\Gamma)$ = c, $\sigma(\Gamma)$
\end{tabular}

Now, these judgements need to satisfy certain properties:
\begin{itemize}
  \item $\Gamma \vdash T {\tt type}$ whenever $\Gamma \vdash e:T$. 

That is, if we can conclude that {\tt e} has type {\tt T} (under
certain assumptions), then under those assumptions we must be able to
conclude that {\tt T} is well-defined.

\item $\Gamma \vdash S\ \type$ and $\Gamma \vdash T\ \type$ whenever $\Gamma \vdash
S \subtype T$.
\item If $\Gamma \vdash e:T$ and $x$ is a variable occurring free in
$e$ then for some type $U$, $\Gamma \vdash x:U$. That is, all free
variables on the RHS are actually defined by the LHS.
\end{itemize}

Keeping in mind these requirements, the rules are as follows. Below
whever we use the assertion 
``$x$ free'' in the antecedent of a rule we
mean that $x$ is not free in the consequent of the rule.

\subsection{Structural and Logical Rules} 

All the judgements are intuitionistic. In particular this means that
all constraint systems satisfy the rules and axioms of inference
below.

\begin{figure*}
\footnotesize

\tabcolsep=0pt

\begin{tabular}{p{0.25\textwidth}p{0.25\textwidth}p{0.47\textwidth}}
\infax[Id]{\Gamma, c\vdash c} &
\infrule[Cut]{\Gamma \vdash c \andalso \Gamma, c\vdash d}
{\Gamma \vdash d} & \\
\infrule[Weak-1]
{\Gamma \vdash \phi \andalso \Gamma \vdash S\ \type \andalso x\not\in \var(\Gamma)}
{\Gamma, x:S \vdash \phi}
&
\infrule[Weak-2]
{\Gamma \vdash \phi \andalso \Gamma \vdash c:o}
{\Gamma, c \vdash \phi}
& 
\infrule[And-L]
{\Gamma, \psi_0,\psi_1 \vdash \phi}
{\Gamma, (\psi_0,\psi_1)\vdash \phi}
\\

\infrule[And-R]
{\Gamma \vdash \psi_0 \andalso \Gamma\vdash \psi_1}
{\Gamma \vdash \psi_0,\psi_1}
&
\infrule[Exists-R]
{\Gamma \vdash \phi [t/x] \andalso \Gamma \vdash t:S}
{\Gamma \vdash \val\ x; \phi}

&
\infrule[Exists-L]
{\Gamma , x:S, \psi \vdash \phi \andalso (x\ \mbox{fresh})}
{\Gamma, \val\ x:S;\psi \vdash \phi}
\end{tabular}
\caption{Logical rules}
\end{figure*}

\subsection{Well formedness rules}

We use the judgement for well-typedness for expressions to represent
well-typedness for constraints. That is, we posit a special type
{\tt o} (traditionally the type of propositions), and regard
constraints as expressions of type {\tt o}. Further, we change the
formulation slightly so that there are no constraints of the form
{\tt p(t1,..., tn)}; rather instance method invocation syntax is
used to express invocation of pre-defined constraints. This logically
leads to the step of simply marking certain classes as ``predicate''
classes -- all the (instance) methods of these classes whose return
type is {\tt o} then correspond to ``primitive constraints.''

Syntactically, we will continue to use the symmetric syntax
{\tt p(t1,\ldots, tn)} rather than {\tt t1.p(t2,\ldots, tn)}.

(The alternative is to introduce static methods, and static method
invocations in the expression language. This is not too difficult, but
it is annoying to have to repeat most of the formulation of instance
methods, and to have one more case to prove.)

So this means that the only cases left to handle are all the simple
ones, expressing the availability of certain constants and operators
at type {\tt o} (see Figure~\ref{Figure:Wff}).

\begin{figure*}
\footnotesize

\tabcolsep=0pt

\begin{tabular}{p{0.25\textwidth}p{0.47\textwidth}p{0.25\textwidth}}

\infax[{\tt true}]{\Gamma \vdash {\tt true}: o}
&
\infrule[Equals]
{\Gamma \vdash t_0: T_0 \andalso \Gamma \vdash t_1: T_1 \andalso  (\Gamma \vdash T_0 \subtype T_1 \vee \Gamma \vdash T_1 \subtype T_0)}
{\Gamma \vdash t_0=t_1:o}
&
\infrule[And]
{\Gamma \vdash c_0: o \andalso \Gamma \vdash c_1: o}
{\Gamma \vdash (c_0,c_1):o}
\\
\infrule[Some]
{\Gamma \vdash t: T \andalso \Gamma \vdash c[t/x]:o}
{\Gamma \vdash {\tt val}\ x:T;c: o}
&
\infrule[type]
{\Gamma \vdash \klass(C) \andalso \Gamma, \self:C \vdash c:o}
{\Gamma \vdash C\{c\}\ {\tt type}}
\end{tabular}
\caption{Well formedness rules}\label{Figure:Wff}
\end{figure*}

\section{Type inference rules}
\subsection{Subtype judgement}

Only one inference rule needs to be specified:
\infrule[Dep type]
{\Gamma \vdash C\ \extends\ D \andalso \Gamma \vdash C\{c\}\ \type, D\{d\}\ \type \\
\Gamma, \self:C,c\vdash d}
{\Gamma \vdash C\{c\} \subtype D\{d\}}


\subsection{Expression typing judgement}

Now we consider the rule for method invocation. Assume that in a type
environment $\Gamma$ the expressions $\bar{e}$ have the types
$\bar{T}$. Since the actual values of these expressions are not known,
we shall assume that they take on some fixed but unknown values
$\bar{z}$ of type $\bar{T}$.  Now for $z$ as receiver, let us assume
that the type $T\equiv C\{d\}$ has a method named {\tt m} with
signature $\bar{z}: \bar{Z}, c \rightarrow U$.  If there is no method
named {\tt m} for the class {\tt C} then this method invocation cannot
be type-checked. Without loss of generality we may assume that the
parameters of this method are named $\bar{z}$, since we are free to
choose variable names as we wish because of $\alpha$-equivalence. Now
in order for the method to be invocable, it must be the case that the
types $\bar{T}$ are subtypes of $\bar{Z}$. (Note that there are no
occurrences of {\tt this} in $\bar{Z}$; they have been replaced by
$z$ -- see Section~\ref{sec:O}) Further, it must be the case that for these parameter values,
the constraint $c$ is entailed. Given all these assumptions it must be
the case that the return type is $U$ --- with all the parameters
$\bar{z}$ existentially quantified.

\begin{figure*}
\footnotesize
\tabcolsep=0pt
\begin{tabular}{p{0.25\textwidth}p{0.25\textwidth}p{0.47\textwidth}}
\infax[T-Var]
{\Gamma, x:T \vdash x:T}
%\infrule[T-Var]
%{\sigma(\Gamma, \self:C), c \vdash_{\cal C} d \\
% \Gamma \vdash  C\{d\}\ \type}
%{\Gamma, x:C\{c\} \vdash x:C\{d\}}
&
\infrule[T-Cast]
{\Gamma \vdash e:U \andalso \Gamma \vdash T \ \type}
{\Gamma \vdash e\ \as\ T:T} &
\infrule[T-Field]
{\Gamma \vdash e:S \andalso \Gamma,{\tt this}:S\vdash \fields(\this,\bar{f}:\bar{U})}
{\Gamma \vdash e.f_i:  \val\ \mbox{\tt this}:S;U_i}
\end{tabular}

\begin{tabular}{p{0.50\textwidth}p{0.47\textwidth}}
\infrule[T-INVK]
{\Gamma \vdash e:T,\bar{e}:\bar{T} \andalso \\
\Gamma,z:T \vdash \mtype(z, m, \bar{z}:\bar{Z}, c \rightarrow U) \andalso z,\bar{z}\ \mbox{fresh} \\
\Delta \equiv \Gamma, z:T, \bar{z}:\bar{T} \andalso \Delta\vdash \bar{T} \subtype \bar{Z},c}
{\Gamma \vdash e.m(\bar{e}): \val\ z:T,\bar{z}:\bar{T};U}
&
\infrule[T-NEW]
{\Gamma \vdash \bar{e}:\bar{T} \andalso \\ 
\Gamma,z:C\vdash \fields(z,\bar{f}:\bar{Z})  \andalso z,\bar{z}\ \mbox{fresh}\\
\Delta\equiv\Gamma, z:C, \bar{z}:\bar{T}, z.\bar{f}=\bar{z}\andalso 
\Delta \vdash \bar{T} \subtype \bar{Z}, inv(C,z)}
{\Gamma \vdash \new\ C(\bar{e}): C\{\val\ z:C,\bar{z}:\bar{T}; z.\bar{f}=\bar{z},\self=z,inv(C,z)\}} \\
\infrule[Method OK]
{\Delta\equiv\this:C, \bar{x}:\bar{T},c \andalso 
\Delta \vdash T \ \type, \bar{T} \ \type, e:U, U \subtype T}
{{\tt def}\ m(\bar{x}:\bar{T})\{c\}:T= e;\ \mbox{OK in}\ C}
&
\infrule[Class OK]
{\bar{M}\ \mbox{OK in}\ C \andalso \this:C,c \vdash \bar{T}\ \type, T\ \type}
{\mbox{\tt class}\ C(\bar{f}:\bar{T})\{c\}\ \mbox{\tt extends}\ T\{\bar{M}\} \ \mbox{OK in}\ C}
\end{tabular}
\caption{Type judgement}\label{fig:typing judgement}
\end{figure*}

\subsection{Class OK judgement}

Note that the variables  $\bar{x}$ are permitted to
occur in the types $T,\bar{T}$, hence their typing assertions must
be added to $\Gamma$.


\end{document}
