% Problem statement
% X10 ... new language design
% OO, imperative, concurrent
% catch errors -> types
% dependent types, generics
% practical, pluggable

% @@@ Cut this.  Plagiarizes from OOPSLA now.
% Jump to motivation for dep types.
% Then motivation for generic types
% This work...

Modern architectural advances are leading to the development of
complex computational systems, such as heterogeneous multi-core,
hardware accelerators, and large CPU-count hybrid clusters.
The \Xten{} programming language \cite{X10-concur,x10-oopsla05,X10} was
designed to address the challenge of developing
high-performance applications for such machines, building on the
productivity gains of modern object-oriented languages.

\Xten{} requires a rich type system
to enable code reuse, rule out a large variety of errors at
compile-time, and to generate efficient code.
A central
data structure in \Xten{} is the dense, distributed, multi-dimensional
array.  Arrays are defined over a set of indices known as \emph{regions},
and support arbitrary base types and accesses through {\em
points} that must lie in the underlying region. For performance it is
necessary that array accesses are
bounds-checked statically as far as possible.
Further, certain regions (such as
polyhedral regions) may be represented particularly
efficiently.  Hence, if a variable is to range only over
polyhedral regions, it is important that this information be conveyed
statically (through the type system) to the code 
generator. To support $P$-way data parallelism it is often necessary
to logically partition an array into $P$ pieces. A type system that
can establish that a given division is a partition can ensure that no
race conditions arise due to simultaneous accesses by
multiple activities to different pieces.

\subsection{Constrained types}

These requirements motivated us to develop a framework for dependent
types in object-oriented languages \cite{constrained-types}.  \emph{Dependent type
systems}~\cite{dependent-types,xi99dependent,calc-constructions}
have been extensively developed over the past few decades in the
context of logic and functional programming---they permit types to be
parametrized by \emph{values}.

The key idea behind our approach is to focus on the notion of a
\emph{constraint system}~\cite{cccc}. Constraint systems were originally developed
to provide a simple framework for a large variety of
inference systems used in programming languages, in particular as a
foundation for constraint programming languages.  Patterned after
Scott's information systems, a constraint system is
organized around the notion of \emph{constraints} or tokens of partial
information (e.g., \Xcd{x+y>z*3}), together with an entailment
relation $\vdash$.  Tokens may have first-order structure; existential
quantification is supported. The entailment relation is required to
support a certain set of inference rules arising from a Gentzen-style
formulation of intuitionistic logic.

In applying constraint systems to object-oriented
languages\footnote{The use of constraints for types has a
distinguished history going back to Mitchell~\cite{mitchell84}.
Our work is closely related to the \hmx{} approach
\cite{sulzmann97type}---see Section~\ref{sec:related} for
details.}, the principal insight
is that objects typically have some immutable state, and constraints on
this state are of interest to the application.  For instance, in \Java{}
the length of an array might not be statically known, but is fixed once
the array is created. Hence, we can enrich the notion of a type: for a
class \Xcd{C} we permit a \emph{constrained type} \Xcd{C\{c\}} where \Xcd{c}
is a
constraint on the immutable fields, or \emph{properties}, of the
class as well as any immutable variables and constants in
scope~\cite{constrained-types}.
Constraints are drawn from a constraint language that,
syntactically, is a subset of the boolean expressions of \Xten{}.  For
brevity, the constraint may be omitted and interpreted as \xcd"true".
Thus, 
\Xcd{Point\{self.rank==N\}} is a type satisfied by any
\Xcd{N}-dimensional point, that is, any
instance of \xcd"Point" whose \xcd"rank" property
is \Xcd{N}.  \Xcd{N}, here, is a (final) variable whose value may be unknown
statically. In a constraint, \Xcd{self} refers to 
a value of the base type being constrained, in this case \Xcd{Array}.
Subtyping is easily defined: a type \Xcd{C\{c\}} is a
subtype of \Xcd{D\{d\}} 
provided that \Xcd{C} is a subclass of \Xcd{D} and \Xcd{c}
entails \Xcd{d} in the underlying constraint system.

Constrained types maintain a phase distinction between compile time
(entailment checking in the underlying constraint system) and run time
(computation).  Dynamic type casting is permitted---code is generated
to check at run time that the properties of the given object satisfy
the given constraint.

The constrained types approach enjoys many nice properties in contrast
to similar approaches such as DML~\cite{xi99dependent}.  Constrained
types are a natural extension to OO languages, and quite easy to
use. Constraints may also be used to specify class invariants, and
conditions on the accessibility of fields and methods (conditional
fields and methods).  Final variables in the computation can be used
directly in types; there is no need to define a separate
parallel language of index expressions to be used in the type system.
Constrained types always
permit field selection and equality at object types; hence the
programmer may specify constraints at any user-specified object type,
not just over the built-in constraint system.  

\subsection{Generic types}

The need for \Xten to support
\emph{generic types}~\cite{clu,ada,GJ,java-popl97,thorup97,Java3,csharp-generics}---types
such as \Xcd{List<T>} in Java that are parametrized by other
types---was quickly apparent.  Generic types are vital for implementing type-safe, reusable libraries,
especially collections classes. For instance, the data type
\Xcd{Array} discussed above is generic on its element type.
In this paper, we describe the design considerations for adding
generics to \Xten and the rationale for the design we eventually
chose.  The main design questions were:
\begin{itemize}
        \item What are the type variables?
        \item How are type variables constrained?
        \item How are generics implemented?
\end{itemize}
The interaction with constraints on values was the primary
challenge.

\subsection{The \FXGL{L} family}

The subtle issues
encountered when designing and implementing the \Xten type
system exposed the need for a formal framework in which to
explore the design space and to reason about fundamental issues
such as soundness, completeness, and decidability. The resulting
framework consists of a family of formal languages---the \FXG
family---that share a common base language, operational
semantics, and type system.

The core expression language of languages in \FXG is essentially
Featherweight Java (\FJ~\cite{FJ}) extended with constraints
over types and values.
The family defines a core language \FXGZ{} that corresponds to
\FGJ.  \FXGZ{} provides a minimal constraint system permitting
only the constraint \Xcd{true}.
This core language can be extended
by enriching the constraint system
and
by extending the set of inference rules of
the core type system.
The static semantics of \FXGZ{} is
shown to be sound with respect to the operational semantics.

We then describe a methodology by which extensions of the
language can be formalized, identifying requirements for
ensuring soundness of the resulting type system.  We apply this 
methodology to several extensions of the core language,
modelling more features of \Xten language, including generics
types, and also modelling possible extensions of the
\Xten language, demonstrating how several ideas in OO typing
(such as structural types) can be handled in this framework.

\eat{
\subsection{Contributions}

We extend the constrained types approach to handle generic types.  We
present the design and implementation of the type system for a
concrete language \Xten{} based on these ideas. We show how several
other ideas in OO typing (such as structural types) can also be
handled in this framework. We present a family of formal languages,
\FXGL{L} that capture the essence of the idea of constrained
types. By appropriately choosing $\cal L$, one can get languages that
support simple types, just value-dependent types, just type-dependent
types, and both. We establish the soundness of the type system for all
members of the family.
}

\paragraph{Outline.}

The rest of the paper is organized as follows.
%
An discussion of the design considerations of generics in \Xten{}
is discussed in Section~\ref{sec:lang}.
%
Section~\ref{sec:semantics} presents a formal semantics and a
proof of soundness.
%\todo{implementation}
\eat{
The implementation of generics in \Xten{} is
described in Section~\ref{sec:translation}.}
%
Section~\ref{sec:discussion} discusses extensions of the type system,
including extensions for virtual types and self types.
%
Related work is discussed in Section~\ref{sec:related}.
%
Finally, Section~\ref{sec:conclusions} concludes.


