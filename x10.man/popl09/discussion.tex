
Generic constrained types generalize virtual types and 
have a connection to parametric types with use-site variance
annotations, such as Java's wildcards.  

\subsection{Virtual types}

{\em Virtual classes}~\cite{beta,mp89-virtual-classes,ernst06-virtual}.
are a language-based extensibility
mechanism that where
originally introduced in the language
BETA~\cite{beta} as a mechanism
for supporting genericity.
Virtual classes in BETA are not statically type safe, but this has been
remedied in recent formulations~\cite{ernst99-gbeta,ernst06-virtual} and in
variants of 
virtual classes~\cite{scala,nqm06,cdnw07-tribe,variant-path-types}
using path-dependent types.  

{\em Virtual types}, also introduced in BETA~\cite{beta},
are similar to virtual
classes.  A virtual type is a type binding nested within an
enclosing instance.
Virtual types
may be used to provide genericity; indeed
Thorup~\cite{thorup97} proposed extending Java with virtual types
as a genericity mechanism.  Virtual types influenced Java's 
wildcards~\cite{adding-wildcards,Java3,wildcards-safe}.

%Igarashi and Pierce~\cite{ip99-virtual-types}
%model the semantics of virtual types
%and several variants
%in a typed lambda-calculus with subtyping and dependent types.


Type properties share many similarities with virtual
types~\cite{mp89-virtual-classes,beta,ernst99-gbeta,ernst06-virtual,cdnw07-tribe}
and similar constructs built on path-dependent types found in
languages such as Scala~\cite{scala}, and J\&~\cite{nqm06}.
Indeed, one of the first proposals for adding genericity to Java
was via virtual types~\cite{thorup97}, and Java
wildcards (i.e., parameters with use-site variance)
were developed from a line of work beginning with virtual
types~\cite{unifying-genericity,variant-parametric-types,adding-wildcards}.

Constrained types are more expressive than virtual
types in that they can be constrained at the use-site,
can be refined on a per-object basis without explicit subclassing,
and can be refined contravariantly
as well as covariantly.

Thorup~\cite{thorup97}
proposed adding genericity to Java using virtual types.  For example,
a generic \xcd"List" class can be written as follows:
{\footnotesize
\begin{xten}
abstract class List {
  abstract typedef T;
  T get(int i) { ... }
}
\end{xten}}
\noindent
This class can be refined by binding the virtual type \xcd"T":
{\footnotesize
\begin{xten}
abstract class NumberList extends List {
  abstract typedef T as Number;
}
class IntList extends NumberList {
  final typedef T as Integer;
}
\end{xten}}
\noindent
These classes are related by subtyping:
{\tt IntList} \subtype {\tt NumberList} \subtype {\tt List}.
Only classes where \xcd"T" is final bound can be non-abstract.
%
The analogous definition of 
\xcd"List" in \Xten{} using type properties is as follows:
{\footnotesize
\begin{xten}
class List[T] {
  def get(i: int): T = { ... }
}
\end{xten}}

The \Xten{} version of \xcd"List" is not abstract;
\xcd"T" need not be instantiated by a subclass because it can be
instantiated on a per-object basis:
rather than declaring subclasses
\xcd"NumberList" and \xcd"IntList", 
one uses the types
\xcd"List{T<:Number}" and \xcd"List{T==Integer}".

In addition,
unlike virtual types, type properties can be refined contravariantly.
For instance, one can write the type \xcd"List{T:>Integer}",
and even \xcd"List{Integer<:T, T<:Number}".

\subsection{Type parameters and wildcards}
\label{sec:parameters-vs-fields}

Type properties are also similar, but not identical to, type
parameters.  The key difference is that type properties are
instance members bound during object construction.  Type
properties are thus accessible through expressions: \xcd"e.T" is
a legal type.

We can make the type system behave as if type properties were
type parameters very simply.  We need only make the syntax \xcd"e.T"
illegal and permit type properties to be accessible only
from within the body of their class definition via the implicit \xcd"this"
qualifier.

Wildcards in Java~\cite{Java3,adding-wildcards} can be motivated
by the following example.
Consider a \xcd"Set" class and a variable \xcd"EMPTY" containing
the empty set.  What should be the type of \xcd"EMPTY"?
In Java, one can use a wildcard, and 
assign the type \xcd"Set<?>"; that is the type of all \xcd"Set"
instantiated on {\em some} parameter.  Clients of this
type do not know what parameter the actual instance of \xcd"Set"
is bound to, which restricts the methods that can be invoked on
the object.

Wildcards can
also be bounded above and below with
{\tt ?} {\tt extends} {\tt T} and {\tt ?} {\tt super} {\tt T} respectively.
%
In \Xten{}, a similar effect to wildcards is achieved by leaving the
element type property of \xcd"Set" unconstrained.
%
We can thus define the following straightforward translation
from Java wildcards to \Xten{}.
Type parameters are translated to type properties whose name
encodes their position in the parameter list.
Types are translated as follows:
{\footnotesize
\begin{align*}
\SB{ \Xcd{X} } &= \Xcd{_}i ~~~~\mbox{where \xcd{X} is the $i$th type parameter} \\
\SB{ \Xcdmath{C<?, $\dots$>} } &= \Xcdmath{C\{$\dots$\}} \\
\SB{ \Xcdmath{C<? extends T, $\dots$>} } &= \Xcdmath{C\{_1 <: $\ \SB{\tt{T}}$, $\dots$\}} \\
\SB{ \Xcdmath{C<? super T, $\dots$>} } &= \Xcdmath{C\{_1 :> $\ \SB{\tt{T}}$, $\dots$\}} \\
\SB{ \Xcdmath{C<T, $\dots$>} } &= \Xcdmath{C\{_1 == $\ \SB{\tt{T}}$, $\dots$\}}
\end{align*}}
Through such a translation, the \FXG\ calculus in
Section~\ref{sec:semantics} can capture the essence of Java's
wildcards, but extended with support for run-time type
introspection.

\eat{
Finally,
one can also specify lower bounds on types.  These are useful for
comparators:
{\footnotesize
\begin{xten}
class TreeSet[T] {
  def this[T](cmp: Comparator{T :> this.T}) { ... }
}
\end{xten}}
Here, the comparator for any supertype of \xcd"T" can be used as
to compare \xcd"TreeSet" elements.

Another use of lower bounds is for list operations.
The \xcd"map" method below takes a function that maps a supertype
of the class parameter \xcd"T" to the method type parameter \xcd"S":
{\footnotesize
\begin{xten}
class List[T] {
  def map[S](fun: Object{self :> T} => S) : List[S] = { ... }
}
\end{xten}}
}

\eat{
Constrained types also support
\emph{proper abstraction}~\cite{adding-wildcards}.  To illustrate, a
\xcd"reverse"
operation can operate on \xcd"List" of any type:
{\footnotesize
\begin{xten}
def reverse(list: List) = {
  for (i: int in [0..list.length-1]) {
    val tmp: list.T = list(i);
    list(i) = list(list.length-1-i);
    list(list.length-1-i) = tmp;
  }
}
\end{xten}}

The client of \xcd"reverse" need not provide the concrete type
on which the list is instantiated; the \xcd"list" itself
provides the element type---it is stored in the \xcd"list"
to implement run-time type introspection.

In Java, this method would be written with a type parameter on
the method.
Wildcard
capture allows the parametrized method to be called with any \xcd"List",
regardless of its parameter type.
However,
the method parameter cannot be omitted: declaring a parameterless version
of \xcd"reverse" requires delegating to a private parametrized version that
``opens up'' the parameter.
}

%\input{self-types.tex}


\eat{
\subsection{Ownership types}

Consider the following example of generic ownership
derived from Potanin et al.~\cite{ogj-oopsla06}.

\begin{xten}
class Object(owner: Object) { }

// Map inherits Object.owner
// No need to add explicit vOwner and kOwner properties for Key, Value
class Map[Key, Value]{Key <: Comparable, Value <: Object}
{
    private nodes: Vector[Node[Key, Value](this)](this);

    public def put(key: Key, value: Value): Void = {
        nodes.add(new Node[Key, Value](key, value, this)());
    }

    public def get(key: Key): Value = {
        for (mn: Node[Key, Value](this) in nodes) {
            if (mn.key.equals(key))
                return mn.value;
        }
        return null;
    }

    // OGJ will prevent this from being called, since caller
    // can only assign the result to a supertype of Vector(this),
    // which would be only Vector(this) or Object(this)
    // BUT: we have Vector :> Vector(this)
    // Need to require that all class types have an equality constraint
    // on the owner property
    public def exposeVector(): Vector(this) { return nodes; }
}

class Node[Key, Value]
    {Key <: Comparable, Value <: Object}
{
    val key: Key;
    val value: Value;

    public def this[K, V](k: Key, v: Value, o: Object): Node[K, V](o) {
        super(o);               // set the owner
        property[K, V];         // set the type properties
        this.key = k;
        this.value = v;
    }
}
\end{xten}

Restrictions:
\begin{itemize}
\item owner property must be constrained (define this!)
\item owner is always equal to or inside the owner of all other type properties
\item types with an actual owner == this, can only be accessed via this
\end{itemize}

}

\subsection{Structural constraints}
\label{sec:structural}
\label{sec:structural-typing}

Type constraints need not be limited to subtyping constraints.
By introducing structural constraints on types, one can
instantiate
type properties on any type with a given set
of methods and fields.
A structural constraint is satisfied if the type has a member of
the appropriate name and with a compatible type.
This feature is useful for reusing code
in separate libraries since it does not require
code of one library to implement an interface to satisfy a
constraint of another library.

In this section, we consider an extension of the \Xten{} type system
to support structural type constraints.  Formally, the extension
is straightforward; indeed the \FX{} family already supports structural constraints
via the rules {\sc Has-F},
{\sc Method-B},
{\sc Method-I},
and
{\sc Method-C,E} in Figure~\ref{fig:O}.
The constraint system need change only to add 
structural
constraints of the form ``{\tt T} {\tt has} {\tt I}''
trivially derived from the existing constraints.

Structural constraints on types are found in many languages.
Haskell supports type
classes~\cite{haskell,haskell-type-classes}.

%ML's module system allows modules to be constrained by
%structural signatures~\cite{ml}.
In Modula-3, type equivalence and subtyping are structural
rather than nominal as in object-oriented languages of the C
family such as C++, Java, Scala, and \Xten{}.
%
The language PolyJ~\cite{java-popl97} allows type parameters to be
bounded using
structural \emph{where clauses}~\cite{where-clauses}.
For example, a sorted list class % from Figure~\ref{fig:sorted}
could be
be written as follows in PolyJ:
{\footnotesize
\begin{xten}
class SortedList[T] where T {int compareTo(T)} {
    void add(T x) { ... x.compareTo(y) ... }
    ...
}
\end{xten}}
The where clause states that the type parameter \xcd"T" must have a
method \xcd"compareTo" with the given signature.

The analogous code for \xcd"SortedList" in the structural
extension of \Xten{} would be:
{\footnotesize
\begin{xten}
class SortedList[T]{T has def compareTo(T): int} {
    def add(x: T) = { ... x.compareTo(y) ... }
    ...
}
\end{xten}}

\eat{
A structural constraint is satisfied if the type has a member of
the appropriate name and with a compatible type.
The constraint
\xcdmath"Z has def m[$\tbar{X}$]($\tbar{x}\ty\tbar{T}$): U"
is satisfied by a type \xcd"T" if it has a method \xcd"m"
with signature
\xcdmath"def m[$\tbar{Y}$]($\tbar{y}\ty\tbar{S}$): V"
and where
(\xcdmath"[$\tbar{Y}$]($\tbar{y}\ty\tbar{S}$) => V")$[\Xcd{T}/\Xcd{Z}]$
is a subtype of
(\xcdmath"[$\tbar{X}$]($\tbar{x}\ty\tbar{T}$) => U")$[\Xcd{T}/\Xcd{Z}]$.
As an example,
the constraint \xcd"X has def compareTo(X): int"
is satisfied by both of the following classes:
{\footnotesize
\begin{xten}
class C { def compareTo(x: C): int = ...; }
class D { def compareTo(x: Object): int = ...; }
\end{xten}}
}

\subsubsection{Function-typed properties}

\Xten{} supports first-class functions.
Function-typed properties provide a useful alternative to
structural constraints.
Consider the following version of the
\xcd"SortedList" class:
{\footnotesize
\begin{xten}
class SortedList(compare: (T,T)=>int) extends List {
    def add(x: T) = { ... compare(x, y) ... }
    ...
}
\end{xten}}
\noindent
The class has a property \xcd"compare" of type
\xcd"(T,T)=>int"---a function that takes two \xcd"T"s and
returns an \xcd"int".  

Using this definition, one can create lists with distinct types
of, for example, case-sensitive and case-insensitive strings:
{\footnotesize\begin{xten}
val unixFiles
  = new SortedList[String]
        (String.compareTo.(String));
val windowsFiles
  = new SortedList[String]
        (String.compareToIgnoreCase.(String));
\end{xten}}

\noindent
The lists \xcd"unixFiles" and \xcd"windowsFiles" are constrained
by different comparison functions.  This allows the programmer
to write code, for instance, in which it is illegal to pass a list of UNIX
files into a function that expects a list of Windows files, and
vice versa.

\subsubsection{Optional methods}

Structural method constraints permit the introduction of
CLU-style optional methods~\cite{clu}.  Consider the following
\xcd"Array" class:
{\footnotesize
\begin{xten}
class Array[T] {
  def add(a: Array[S])
    {T has add(S): U}: Array[U] = { ... }
  ...
}
\end{xten}}

\noindent
The \xcd"Array" class defines an \xcd"add" method that takes 
an array of \xcd"S", adds each element of the array to the
corresponding element of \xcd"this", and returns an array of the
results.  The method constraint specifies that the method may
only be invoked if \xcd"T" has an \xcd"add" method of the
appropriate type.  Thus, for example, an \xcd"Array[int]"
can be added to an \xcd"Array[double]" because \xcd"int"
has a method \xcd"add" (corresponding to the \xcd"+" operation)
that adds an \xcd"int" and a \xcd"double", retuning a
\xcd"double".  However, \xcd"Array[Rabbit]", for example, does not support
the \xcd"add" operation because \xcd"Rabbit" does not have an
\xcd"add" method.




\eat{
\subsection{Definition-site variance}

\subsection{Conditional methods and generalized constraints}

For type parameters, method constraints are 
similar to generalized constraints proposed for
\csharp~\cite{emir06}.
%
In the following code, the \xcd"T" parameter is covariant
and so the \xcd"append" methods below are illegal:
{\footnotesize
\begin{xten}
class List[+T] {
  def append(other: T): List[T] = { ... }
      // illegal
  def append(other: List[T]): List[T] = { ... }
      // illegal
}
\end{xten}}
%
However, one can introduce a method parameter and then constrain
the parameter from below by the class's parameter:
For example, in the following code,
{\footnotesize
\begin{xten}
class List[+T] {
  def append[U](other: U)
      {T <: U}: List[U] = { ... }
  def append[U](other: List[U])
      {T <: U}: List[U] = { ... }
}
\end{xten}}

The constraints must be satisfied by the callers of \xcd"append".
For example, in the following code:
{\footnotesize
\begin{xten}
xs: List[Number];
ys: List[Integer];
xs = ys; // ok
xs.append(1.0); // legal
ys.append(1.0); // illegal
\end{xten}}
the call to \xcd"xs.append" is allowed and the result type is \xcd"List[Number]", but
the call to \xcd"ys.append" is not allowed because the caller cannot show that
${\tt Number} \subtype {\tt Double}$.

}
