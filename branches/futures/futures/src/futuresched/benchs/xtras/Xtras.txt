            var shares: Int = 0;
            val ins = node.inNeighbors;
            val insIter = ins.iterator();
            while (insIter.hasNext()) {
               val inN = insIter.next();
               val outDeg = g.outNeighbors().size() as Int;
               shares = shares + 1 / outDeg;
            }


      Heart.beat(
         g.nodes
         (node: Node) => {
            if (node.oddPhase) {
               // Set the share of neighbors:
               val neighbors = node.neighbors;
               val deg = node.degree();
               val share = node.prevRank / deg;
               val iter = neighbors.iterator();
               while (iter.hasNext()) {
                  val n = iter.next();
                  n.currShares.addAndGet(share);
               }
               // Set the current rank
               val currRank = (dampFact * node.prevShares) + (1 - dampFact) / v;
               node.currRank.set(currRank);
               node.oddPhase = false;
               return true;
            } else {
               node.prevRank = node.currRank;
               node.prevShares = node.currShares.get();
               node.currShares.set(0);
               node.oddPhase = true;

               return ;
            }
         }
      );
