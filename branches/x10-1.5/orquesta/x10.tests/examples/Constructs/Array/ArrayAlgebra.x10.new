/*
 *
 * (C) Copyright IBM Corporation 2006
 *
 *  This file is part of X10 Test.
 *
 */
import harness.x10Test;;

/**
 * Constant promotions to arrays: (D n)
 * disjoint union and overlay of arrays
 * array lift, scan and reduce.
 *
 * @author kemal 4/2005
 */
public class ArrayAlgebra extends x10Test {

	public const N: int = 24;
	def makeArray(val D: dist, val k: int): Array[int]{distribution==D} = {
		return new Array[int](D, (var p: point): int => { return k; });
	}

	public def run(): boolean = {
		final val D: dist = distmakeBlockCyclic([0..N-1], 2);
		final val D01: dist{rank==D.rank} = D | [0..N/2-1];
		final val D23: dist{rank==D.rank} = D | [(N/2)..N-1];
		final val D0: dist{rank==D.rank} = D | [0..N/4-1];
		final val D1: dist{rank==D.rank} = D | [(N/4)..N/2-1];
		final val D2: dist{rank==D.rank} = D | [(N/2)..3*N/4-1];
		final val D3: dist{rank==D.rank} = D | [(3*N/4)..N-1];
		final val ia1: Array[int] = makeArray(D, -99).overlay((makeArray(D01, -1) || makeArray(D23, -2))
					.overlay(makeArray(D3, 3)).overlay(makeArray(D0, 9)));
		arrEq(ia1 | D0, makeArray(D0, 9));
		arrEq(ia1 | D1, makeArray(D1, -1));
		arrEq(ia1 | D2, makeArray(D2, -2));
		arrEq(ia1 | D3, makeArray(D3, 3));
		chk(ia1.sum() == 9*N/4);
		arrEq(ia1.scan(intArray.add, 0),
				new Array[int](D, (var point [i]: point): int => { return (ia1 | [0..i]).reduce(intArray.add, 0); }));
		arrEq(makeArray(D01, 1).lift(intArray.add, makeArray(D01, -4)),
				makeArray(D01, -3));
		// are we still supporting +,-,... on arrays?
		arrEq(makeArray(D01, 1) + makeArray(D01, -4),
				makeArray(D01, -3) * makeArray(D01, 1));
		return true;
	}

	/**
	 * Throw an error iff x and y are not arrays with same
	 * content and dist
	 */
	static def arrEq(val x: Array[int], val y: Array[int]): void = {
		chk(x.dist.equals(y.dist));
		finish ateach (val p: point in x) chk(x(p) == y(p));
	}

	public static def main(var args: Rail[String]): void = {
		new ArrayAlgebra().execute();
	}
}
