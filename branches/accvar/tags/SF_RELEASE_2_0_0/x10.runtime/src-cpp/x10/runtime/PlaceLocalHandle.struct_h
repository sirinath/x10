#ifndef X10_RUNTIME_PLACELOCALHANDLE_STRUCT_H
#define X10_RUNTIME_PLACELOCALHANDLE_STRUCT_H

#include <x10rt17.h>

#include <x10/lang/String.h>

namespace x10 {
    namespace runtime {

        void _initRTTHelper_PlaceLocalHandle(x10aux::RuntimeType *location, const x10aux::RuntimeType *rtt);
        
        template <class T> class PlaceLocalHandle  {
        public:
            RTT_H_DECLS_STRUCT

            T FMGL(localStorage);
            x10_int FMGL(id);
            bool FMGL(cached);

            PlaceLocalHandle<T>* operator->() { return this; }

            static PlaceLocalHandle<T> createHandle() {
                PlaceLocalHandle<T> result;
                x10_int id = x10aux::place_local::nextId();
                result.FMGL(id) = id;
                result.FMGL(cached) = false;
                return result;
            }

            void set(T newVal) {
                assert(!FMGL(cached));
                FMGL(localStorage) = newVal;
                FMGL(cached) = true;
                T *tmp = x10aux::alloc<T>();
                *tmp = newVal;
                x10aux::place_local::registerData(FMGL(id), (void*)tmp);
            }

            T get() {
                if (!FMGL(cached)) {
                    T *tmp = (T*)(x10aux::place_local::lookupData(FMGL(id)));
                    FMGL(localStorage) = *tmp;
                    FMGL(cached) = true;
                }
                return FMGL(localStorage);
            }

            x10aux::ref<x10::lang::String> toString() {
                if (FMGL(cached)) {
                    return x10aux::to_string(FMGL(localStorage));
                } else {
                    return x10::lang::String::Lit("PlaceLocalHandle(uncached data)");
                }
            }

            x10_int hashCode() {
                return x10aux::hash_code(FMGL(id));
            }


            x10_boolean _struct_equals(PlaceLocalHandle<T> that) {
                return FMGL(id) == that->FMGL(id);
            }
            
            static void _serialize(PlaceLocalHandle<T> this_, x10aux::serialization_buffer &buf, x10aux::addr_map &m);

            static PlaceLocalHandle<T> _deserialize(x10aux::deserialization_buffer& buf);
        };

        template <> class PlaceLocalHandle<void>  {
        public:
            static x10aux::RuntimeType rtt;
            static const x10aux::RuntimeType* getRTT() { return &rtt; }
        };

        template<class T> void PlaceLocalHandle<T>::_initRTT() {
            rtt.canonical = &rtt;
            x10::runtime::_initRTTHelper_PlaceLocalHandle(&rtt, x10aux::getRTT<T>());
        }
        
        template<class T> x10aux::RuntimeType PlaceLocalHandle<T>::rtt;

        template <class T> void PlaceLocalHandle<T>::_serialize(PlaceLocalHandle<T> this_, x10aux::serialization_buffer &buf, x10aux::addr_map &m) {
            // NOTE specialized semantics.  Only id is serialized, cached and localStorage are place local!
            buf.write(this_->FMGL(id),m);
        }

        template<class T> PlaceLocalHandle<T> PlaceLocalHandle<T>::_deserialize(x10aux::deserialization_buffer& buf) {
            // NOTE specialized semantics.  Only id is serialized, cached is automatically set to false; will be looked up on first use.
            PlaceLocalHandle<T> this_;
            this_->FMGL(id) = buf.read<x10_int>();
            this_->FMGL(cached) = false;
            return this_;
        }
    }
}
#endif

