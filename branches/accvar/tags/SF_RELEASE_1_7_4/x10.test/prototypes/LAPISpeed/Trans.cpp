/***
Trans.[java|cpp] are SPMD programs that use LAPI to transpose large
arrays of doubles.  The idea is to determine if a serialization-less
JVM->JVM copy can be effected quickly enough to compete with C (or C++)

LAPISupport.cpp is the LAPI support library and is used by both the
Java and C++ versions.  For the Java version it requires Trans.h and
VMInfo.h which are generated by javah.

xlC -g -o Trans -O Trans.cpp LAPISupport.cpp -bmaxdata:0x80000000 -llapi_r
javac Trans.java
javah Trans
javah VMInfo
xlC_r -DFOR_JAVA -g -qnolm -qnoeh -qnotempinc -bM:SHR -bnoentry -bexpall -I${classesdir} -I$JAVA_HOME/bin/include -I$JAVA_HOME/include -llapi_r -o libLAPISupport.a LAPISupport.cpp
***/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>

typedef void JNIEnv;
extern bool CPP_VMInfo_init(char *confFileName, unsigned int thisIsTask, unsigned int numGlobalBlocks);
extern void CPP_VMInfo_term();
extern void CPP_Trans_AcceptBlockHere(unsigned int block, double *placeDataHere_, volatile bool *updateThisWhenComplete_);
extern void sendMyArrayBlock(unsigned int tgt, unsigned int globalBlockNum, double *data, unsigned int l, JNIEnv *);
extern void LAPIGlobalFence();
extern unsigned int numLAPITasks();

class TransposableMatrix {
public:
    // Blocks are numbered (initially):
    // 0,               1,         2, ...,     Q-1
    // Q,             Q+1,       Q+2, ...,   2*Q-1
    // 2*Q,         2*Q+1,     2*Q+2, ....,  3*Q-1
    //  .              .          .             .
    //  .              .          .             .
    // (P-1)*Q, (P-1)*Q+1, (P-1)*Q+2, ..., (P*Q)-1
    //
    // LAPI task 0 gets blocks 0, numLAPITasks,   2*numLAPITasks, ...
    // LAPI task 1 gets blocks 1, numLAPITasks+1, 2*numLAPITasks+1, ...
    //   .    .  .  .      .   .        .                 .
    // etc. up to LAPI task numLAPITasks-1
    //
    // To transpose this, we transpose the blocking factors as
    // well as the actual data.  This allows us to simply send
    // the same sized blocks around the system.
    //
    // So, using the initial labels for blocks, they are
    // copied:
    // 0,               Q,       2*Q, ....,   (P-1)*Q
    // 1,             Q+1,     2*Q+1, ...., (P-1)*Q+1
    // .               .          .                .
    // .               .          .                .
    // Q-1,         2*Q-1,     3*Q-1, ....,   (Q*P)-1
    //
    // These are then renamed:
    // 0,               1,         2, ...,     P-1
    // Q,             P+1,       P+2, ...,   2*P-1
    // 2*P,         2*P+1,     2*P+2, ....,  3*P-1
    //  .              .          .             .
    //  .              .          .             .
    // (Q-1)*P, (Q-1)*P+1, (Q-1)*P+2, ..., (Q*P)-1
    //

    #define NUMTIMERS 5
    TransposableMatrix(unsigned int p, unsigned int q,
                       unsigned int P, unsigned int Q,
                       unsigned int thisIsTask,
                       unsigned int numLAPITasks,
                       bool doLocalXpos) :
        p_(p), q_(q), P_(P), Q_(Q),
        thisIsTask_(thisIsTask),
        numLAPITasks_(numLAPITasks),
        numGlobalBlocks_(P * Q),
        doLocalXpos_(doLocalXpos)
        {
            numLocalBlocks_ = (P*Q) / numLAPITasks;
            if (thisIsTask < ((P*Q) % numLAPITasks)) ++numLocalBlocks_;
            myLocalBlocks0_ = (double **) malloc(numLocalBlocks_ * sizeof(double *));
            if (myLocalBlocks0_ == NULL) {
                fprintf(stderr, "Task %d could not allocate myLocalBlocks0_\n", thisIsTask_);
            }
            myLocalBlocks1_ = (double **) malloc(numLocalBlocks_ * sizeof(double *));
            if (myLocalBlocks1_ == NULL) {
                fprintf(stderr, "Task %d could not allocate myLocalBlocks1_\n", thisIsTask_);
            }
            expectedBlocks_ = (unsigned int *) malloc(numLocalBlocks_ * sizeof(unsigned int));
            if (expectedBlocks_ == NULL) {
                fprintf(stderr, "Task %d could not allocate expectedBlocks_\n", thisIsTask_);
            }
            receivedFlags_ = (volatile bool *) malloc(numLocalBlocks_ * sizeof(volatile bool));
            if (receivedFlags_ == NULL) {
                fprintf(stderr, "Task %d could not allocate receivedFlags_\n", thisIsTask_);
            }
            for (unsigned int i = 0; i < numLocalBlocks_; ++i) {
                myLocalBlocks0_[i] = (double *) malloc(sizeof(double) * p * q);
                if (myLocalBlocks0_[i] == NULL) {
                    fprintf(stderr, "Task %d could not allocate myLocalBlocks0_[%d]\n", thisIsTask_, i);
                }
                myLocalBlocks1_[i] = (double *) malloc(sizeof(double) * p * q);
                if (myLocalBlocks1_[i] == NULL) {
                    fprintf(stderr, "Task %d could not allocate myLocalBlocks1_[%d]\n", thisIsTask_, i);
                }
                unsigned int j = (i * numLAPITasks) + thisIsTask;
                expectedBlocks_[i] = ((j % P) * Q) + (j / P);
            }
            outGoingCount_ = inComingCount_ = 0;
            for (unsigned int i = 0; i < NUMTIMERS; ++i) {
                executionTimes_[i] = 0;
            }
        }

    ~TransposableMatrix() {
        for (unsigned int i = 0; i < numLocalBlocks_; ++i) {
            free(myLocalBlocks0_[i]);
            free(myLocalBlocks1_[i]);
        }
        free(myLocalBlocks0_);
        free(myLocalBlocks1_);
    }
    
    void MatGen(unsigned int timeStep = 0) {
        for (unsigned int i = 0; i < numLocalBlocks_; ++i) {
            unsigned int blockNum = (i * numLAPITasks_) + thisIsTask_;
            for (unsigned int r = 0; r < p_; ++r) {
                for (unsigned int c = 0; c < q_; ++c) {
                    myLocalBlocks0_[i][(r*q_)+c] = (blockNum * 1000000) + (r * 1000) + c;
                }
            }
            myLocalBlocks0_[i][0] = timeStep_ = timeStep;
        }
    }

    void globalFence() {
        LAPIGlobalFence();
    }

    void transpose() {
        // First we need to tell LAPI where to send all the incoming
        // blocks that we expected
        for (unsigned int i = 0; i < numLocalBlocks_; ++i) {
            if ((expectedBlocks_[i] % numLAPITasks_) == thisIsTask_) {
                // We are expecting to send this block to ourselves
                double *tmp = myLocalBlocks0_[i];
                myLocalBlocks0_[i] = myLocalBlocks1_[i];
                myLocalBlocks1_[i] = tmp;
                receivedFlags_[i] = true;
            } else {
                receivedFlags_[i] = false;
                CPP_Trans_AcceptBlockHere(expectedBlocks_[i], myLocalBlocks1_[i], &receivedFlags_[i]);
            }
        }
        // Tell the world that we're all set to receive
        clock_t start_time0 = clock();
        globalFence();
        clock_t finish_time0 = clock();
        executionTimes_[0] += (finish_time0 - start_time0);

        // Now send out all of the blocks we need to
        start_time0 = clock();
        for (unsigned int i = 0; i < numLocalBlocks_; ++i) {
            unsigned int globalBlockNum = (i * numLAPITasks_) + thisIsTask_;
            unsigned int tgt = (((globalBlockNum % Q_) * P_) + (globalBlockNum / Q_)) % numLAPITasks_;
            if (tgt != thisIsTask_) {
                sendMyArrayBlock(tgt, globalBlockNum, myLocalBlocks0_[i], p_ * q_, NULL);
                ++outGoingCount_;
            }
        }
        finish_time0 = clock();
        executionTimes_[1] += (finish_time0 - start_time0);

        // now we wait until we have received everything we want to
        start_time0 = clock();
        unsigned int numReceived = 0;
        do {
            numReceived = 0;
            for (unsigned int i = 0; i < numLocalBlocks_; ++i) {
                if (receivedFlags_[i]) ++numReceived;
            }
        } while (numReceived != numLocalBlocks_);
        finish_time0 = clock();
        executionTimes_[2] += (finish_time0 - start_time0);

        // now really transpose each local block
        start_time0 = clock();
        for (unsigned int i = 0; i < numLocalBlocks_; ++i) {
            if ((expectedBlocks_[i] % numLAPITasks_) == thisIsTask_) {
            } else {
                ++inComingCount_;
                CPP_Trans_AcceptBlockHere(expectedBlocks_[i], NULL, NULL);
            }
            if (doLocalXpos_) {
                for (unsigned int r = 0; r < p_; ++r) {
                    for (unsigned int c = 0; c < q_; ++c) {
                        myLocalBlocks0_[i][(c*p_)+r] = myLocalBlocks1_[i][(r*q_)+c];
                    }
                }
            }
        }
        finish_time0 = clock();
        executionTimes_[3] += (finish_time0 - start_time0);
        start_time0 = clock();
        globalFence();
        finish_time0 = clock();
        executionTimes_[4] += (finish_time0 - start_time0);
    }

    void dumpCounts() {
        printf("task %d: %d blocks sent, %d received. Wait times (microsecond)", thisIsTask_, outGoingCount_, inComingCount_);
        for (unsigned int i = 0; i < NUMTIMERS; ++i) {
            printf(" %ld", executionTimes_[i]);
        }
        printf("\n");
    }

private:
    unsigned int p_;            // rows in each block
    unsigned int q_;            // columns in each block
    unsigned int P_;            // rows of blocks
    unsigned int Q_;            // columns of blocks
    unsigned int thisIsTask_;
    unsigned int numLAPITasks_;
    unsigned int numLocalBlocks_;
    double **myLocalBlocks0_;
    double **myLocalBlocks1_;
    unsigned int numGlobalBlocks_;
    unsigned int * expectedBlocks_;
    volatile bool *receivedFlags_;
    unsigned int timeStep_;
    bool doLocalXpos_;
    unsigned int outGoingCount_;
    unsigned int inComingCount_;
    unsigned long executionTimes_[NUMTIMERS];
};

int main(int argc, char *argv[]) {
    unsigned int p = 2;         // rows in each block
    unsigned int q = 2;         // columns in each block
    unsigned int P = 2;         // rows of blocks
    unsigned int Q = 2;         // columns of blocks
    char *confFile = "myConf";
    unsigned int thisIsTask = 0;
    unsigned int numTimes = 10;
    bool do_local_xpos = false;

    int argPos = 1;
    unsigned int *parmAddr[] = { &p, &q, &P, &Q };
    unsigned int parmIndex = 0;
    while (argPos < argc) {
        if (argv[argPos][0] == '-') {
            if (strcmp(argv[argPos],"-conf") == 0) {
                ++argPos;
                confFile = argv[argPos++];
            } else if (strcmp(argv[argPos],"-vm") == 0) {
                ++argPos;
                sscanf(argv[argPos++],"%u", &thisIsTask);
            } else if (strcmp(argv[argPos],"-n") == 0) {
                ++argPos;
                sscanf(argv[argPos++],"%u", &numTimes);
            } else if (strcmp(argv[argPos],"-x") == 0) {
                ++argPos;
                do_local_xpos = true;
            } else {
                ++argPos;
           }
        } else {
            if (parmIndex < sizeof(parmAddr) / sizeof(parmAddr[0])) {
                sscanf(argv[argPos++], "%u", parmAddr[parmIndex++]);
            } else {
                ++argPos;
            }
        }
    }

    if (CPP_VMInfo_init(confFile, thisIsTask, P*Q)) {
        TransposableMatrix *tm = new TransposableMatrix(p,q,P,Q,thisIsTask,numLAPITasks(),do_local_xpos);
        unsigned long accumulatedTime = 0;
        for (int t = 0; t < numTimes; ++t) {
            tm->MatGen(t);
            clock_t start_time0 = clock();
            tm->transpose();
            clock_t finish_time0 = clock();
            accumulatedTime += (finish_time0-start_time0);
        }
        CPP_VMInfo_term();
        printf("Number of microseconds for task %d: %ld\n", thisIsTask, accumulatedTime);
        tm->dumpCounts();
        delete tm;
    } else {
        fprintf(stderr, "Could not initialize LAPI for task %d\n", thisIsTask);
    }
}
