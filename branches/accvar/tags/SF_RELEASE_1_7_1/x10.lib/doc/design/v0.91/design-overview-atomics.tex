\subsubsection{Atomics}
Atomic sections are implemented using locks. Each place will have 
a set of locks.  An activity may request to 
perform an atomic operation at a place which in turn will be
translated to obtaining the locks at the designated place before
performing the operation. These locks are globally ordered,
precluding deadlocks. Obtained locks cannot be passed from one
activity to another, and all locks required by an activity need to be
obtained together. 

On a cluster of Power5 SMP nodes, we primarily have two types of atomics: {\it
primitive} atomics and {\it compound} atomics. {\it Primitive} atomics
do not block within the same SMP node and use {\tt lwarx} and {\tt
stwcx} instructions to atomically update within a SMP node. However,
across SMP nodes, we need {\it compound} atomics which explicitly
obtains lock at the designated place to perform the operation and are
blocking in nature. It can be observed that primitive atomics designed
specifically to improve performance on a cluster of Power5 SMP nodes.

Consider the RandomAccess code fragment given in
Section~\ref{sec:deploy:example}. The spawn of asynchronous activities
in Statement 6 can be optimized to leverage the {\it primitive}
atomics concept on Power5 and can get rid of the cost of creating 
new asynchronous activities and obtaining locks within the same SMP
node.


\REM{
Support for conditional atomics is provided. A special type of
variable, a {\tt WatchedVariable}, may be declared and allocated on
the heap. An async may be attached to a {\tt WatchedVariable},
together with a triggering {\tt CallRecord}. The triggering {\tt
CallRecord} must be pure, that is it must have no
side-effects. Typically it will simply check the value of the variable
and return true or false. Triggers are evaluated whenever the value of
the {\tt WatchedVariable} is set. If the trigger evaluates to true, the
trigger is removed and the associated async is executed (or scheduled
for execution).
}
