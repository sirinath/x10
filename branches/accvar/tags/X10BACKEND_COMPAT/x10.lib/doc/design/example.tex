
  // and do remote atomic updates on corresponding table elements
    finish ateach (point p[i]: ranStarts.distribution) {
      long ran = nextRandom(ranStarts[i]);
      for (point count: [1:N_UPDATES_PER_PLACE]) {
        final int  j = f(ran);
        final long k = smallTable[g(ran)];
        async(table.distribution[j])
          atomic {
            table[j] = table[j] ^ k;
          }
        ran = nextRandom(ran);
      }
    }