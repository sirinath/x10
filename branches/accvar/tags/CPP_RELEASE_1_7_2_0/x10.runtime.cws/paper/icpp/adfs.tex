   final class V  extends Vertex {
   V next; // link for batching
   V [] neighbors;
   V parent;
   V parent() { return parent;}
   V(int i){super(i);}
  static final int LOG_MAX_BATCH_SIZE = 7;
     void compute(Worker w) throws StealAbort {
        w.popAndReturnFrame();
        int batchSize = 0; // computed lazily
        V newList = null;
        int newLength = 0;
        V oldList = this;
        V par = parent;
        do {
          V v = oldList;
          V[] edges = v.neighbors;
          oldList = v.next;
          int nedges = edges.length;
          for (int k = 0; k < nedges; ++k) {
            V e = edges[k];
            if (e != null && e.level == 0 &&
              UPDATER.compareAndSet(e,0,1)) {
              e.parent = par;
              e.next = newList;
              newList = e;
              if (batchSize == 0) {
                int s = w.getLocalQueueSize();
                batchSize = ((s < 1)? 1 :
                       ((s >= LOG_MAX_BATCH_SIZE)?
                        (1 << LOG_MAX_BATCH_SIZE) :
                        (1 << s)));
              }
              if (++newLength >= batchSize) {
                newLength = 0;
                batchSize = 0;
                if (oldList == null)
                  oldList = newList;
                else
                  w.pushFrame(newList);
                newList = null;
              }
            }
          }
          if (oldList == null) {
            oldList = newList;
            newList = null;
            newLength = 0;
          }
        } while (oldList != null);
      }
}
    

