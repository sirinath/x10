\section{\Xten{} Work Stealing}\label{sec:XWS}

\subsection{Support for Improperly Nested Tasks}
Cilk requires {\em fully-strict} (properly nested) programs in which a
task waits for all its descendents to complete before returning.

The \Xten{} runtime system is designed to leverage the Cilk design
while supporting a larger class of programs. \Xten{} provides support
for {\em strict} ({\em improperly nested}) computations, in which an
ancestor task need not wait for its descendent tasks to be completed.

Properly nested tasks $t$ satisfy the property that at the moment when
the slow version terminates (method:{\java compute()}) the frame at
the bottom of the worker's dequeue is $t$. Hence the task can be
completed (i.e., removed from the dequeue) by including a {\java
w.popFrame()} call at the end of the compute method. In essence, if a
worker is executing only properly nested tasks (this is true when it
is executing Cilk code), there is a one-to-one correspondence between
the frame stack and the tasks being processed.

\Xten{} permits improperly nested tasks. Such tasks $q$ are used, for
instance, to implement the pseudo-depth-first search discussed in this
paper. Such a task may add a task $r$ to the deque of its worker (say
$w$) without necessarily transferring control to $r$. This has two
consequences. First, recall that as soon as a worker's dequeue
contains more than one task the worker may be the target of a
theft. Therefore as soon as $q$ pushes $r$ onto $w$'s dequeue, $q$ is
available to be stolen.  Therefore $q$'s compute method must first pop
$q$ off the deque before spawning new asyncs. (Hence the {\java
w.popAndReturnFrame()} in the body of {\tt compute} in
Example~\ref{example:dfs}.)

With improperly nested tasks, a worker no long enjoys the property
that when control returns to it from the invocation of an execute
method on the top-level task, the deque is empty. Indeed, control may
return to the scheduler leaving several tasks on the deque, including
the task whose execute method has just returned. The scheduler must
now enter a phase in which it executes the task at the bottom of the
deque.

\subsection{Global Quiescence}

In fully-strict computations completion of the first task and the
return of the corresponding closure indicates termination.
Improperly-nested tasks that do not require a return call chain can do
away with the closures. We have implemented a mechanism to efficiently
identify termination without closures; in essence the mechanism detects
the stable property ``all deques are empty.'' 

The workers share a barrier with count {\tt checkCount} -- this will
measure the number of workers with non-empty deques.  Initially the
count is $0$. Whenever a worker checks out a job from the submission
queue, it increments the count. Whenever a worker finds its deque is
empty and starts stealing, it decrements the count. Whenever it
successfully steals, it increments the count before releasing the lock
on the victim (thus ensuring that the count remains positive).

Note an important property of this mechanism. Suppose a worker $W_0$
checks out a task from the submission queue. Its execution generates
very few tasks which end up being executed by $W_0$. In this case the
count will go up to $1$ and then down to $0$ when $W_0$'s queue is
empty, and the job will be considered completed. This is the case even
though $P-1$ workers have not participated in the barrier. Thus this
mechanism does not require all workers to participate, only those that
actually steal work.

\subsection{Phased Computations}
We also added support for phased computations in which tasks in this
phase create tasks to be executed in the next phase (cf BFS search).
Phased computations are supported as a generalization of global
quiescence. Each worker maintains two dequeues (the {\em now} deque and the
{\em next} deque).  Depending on the phase specified when spawning
tasks, a task can be added to the now deque or the next deque.

When global quiescence is detected for the current phase, the barrier
action steps the computation to the next phase. Each worker keeps
track of the phase number it thinks it is in. After each round of
stealing, it checks to see if the barrier's phase is the same as its
phase; if not, it advances the phase and swaps its next and now
deques. When checking into the barrier, each worker specifies whether
it has work to do in the next phase. When the barrier is advanced {\tt
checkCount} is initialized with this number, thus maintaining the
invariant associated with the barrier.  If this count is $0$, the job
is terminated.

Note that this design permits workers to {\em jump phases}. A worker
$W_i$ may finish computation in phase $k$ and start searching for
work. Meanwhile other workers may check into the barrier causing it to
move to phase $k+1$. This phase may contain very little work, and the
barrier may trip repeatedly reaching phase $k+m$, before $W_i$
discovers the phase has advanced and updates its phase to $k+m$. (The
algorithm design ensures that $W_i$ may skip phases only if its next
deque is empty.) 

