Design/Implementation
---------------------

/*execution environment*/
1. Executed using the MPI framework (mpirun,...) on the target
   platform. A main() is predefined for convenience, and the user
   defines a main activity that will be processed till \em finish. 

/*activities*/
1. Activities define a run() method that is used to execute the
   activity object. 
2. Activities are not directly instantiated in other activities. An
   Maker object is created that can be serialized and deserialized. At
   the remote node, a make() method implemented by this object returns
   a constructed activity. This allows the activities themselves to be
   non-serializable. In addition, they allow construction of minimal
   objects to be serialized. This is especially useful in the context
   of an activity utilizing the pre-defined pre-processor macros to
   manipulate activities, as will be explained below. 
3. The method calls provided to the user are designed to be
   non-blocking so as to enable maximum overlap of computation and
   communication. 
4. Programmers can write code in a continuation-passing style, in
   which an activity once ready, always runs to completion. 
5. Alternatively, pre-processor directives are provided that can
   potentially eliminate the need to write continuation-passing style
   code. These are similar in spirit to protothreads
   (http://www.sics.se/~adam/pt/) and the implementation of
   co-routines in C
   (http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html). This
   requires the adherence to certain guidelines.  
   a. The ASYNC() macro is used to spawn a new Activity. It is a
      non-blocking macro and the execution proceeds past that
      statement. The other macros are blocking. 
   b. The run() method cannot have any local variables. More
      precisely, local variables are not retained across calls to a
      blocking macro. If needed, users will have to save (and restore)
      local variables before (and after) blocking macros.
   c. The method's body is enclosed within a START and END. 
   d. Invocation of blocking macros cannot be enclosed in a switch
      statement. 
   e. Invocation of blocking macros can be only at the "top-level",
      i.e., lexically in the run() method. 

/*Exectuion/Spawning of activities*/
1. Activities will be executed in the main thread, not within the
   communication thread. 
2. The runtime at each node (ARMCI or a layer above) manages some
   buffers to bootstrap creation of asyncs. Asyncs with buffer
   requirement below a particular size can be directly invoked using
   this scheme. (This is one class of GPCs in ARMCI, potentially
   implemented within the communicator thread? Thread-safety?). 
3. Large asyncs have an additional roundtrip. A bootstrap async first
   allocates a buffer of required and returns its pointer. The actual
   async is then initiated using this buffer. (This is a bootstrap GPC
   to allocate memory, a bunch of puts, a fence if necessary, and then
   a GPC call with a pointer and a function pointer).

/*clocks*/
1. Clocks are opaque objects that behave very similar to those in the
   X10 language specification. 
2. The primary difference is that the methods to manipulate clocks are
   invoked in the context of an Activity object, with the clock
   usually as an argument. 
3. (Need to think about the semantics of clocks. Are they assignable?
   How do we provide a quick lookup from a list of clocks that an
   activity has?)

/*finish scopes*/
1. A program implemented using the provided pre-processor macros
   does not need to directly handle finish scopes. 
2. When not using these macros, a user can register a new finish scope
   for an activity to be spawned. He/she can also check for
   termination of all activities enclosed by this scope. 
3. A spawned activities finish scope cannot be modified. 

/*futures and setting results*/


/*Implementation guidelines*/
1. Try to separate out the implementation as much as possible from the
   underlying messaging system. If not possible, mark (in some way)
   classes that have been organized to take advantage of a particular
   messaging system. Typical lower-level functionality would be
   spawning of activities, setting of results?, etc.
2. Provide minimal but working serialization. Note its limitations
   clearly. Some functionality we might definitely need would be -
   handling of inheritence, ... As a first cut users might be expected
   to - handle object tracking to handle repeated pointers and
   circular data structures. (Think about how one would implement
   serialization/de-serialization of a circular linked list. The
   interface should probably enable someone to write their of
   (de-)serializer for such a data structure). 
3. The implementation should be correct even if the user ends up using
   the public methods directly. In this regard, the implementor needs
   to identify if any methods that should not be directly invoked by
   the user, even if they are part of the public interface. The
   protocols in such scenarios should (ideally) not be complex. For
   example, the scenario of a user spawning an activity on a newly
   registered finish scope and not waiting on it should be handled
   properly. The registered finish should "report" to the enclosing
   finish (somehow) if it is not checked for termination. 


/*Usage guidelines*/
1. Avoid spawning activities/futures unless you are required to
   block. Spawning activities or futures involves dynamic memory
   allocation, which is very expensive. The code should preferably be
   reorganized into functions that perform the computation locally is
   possible, and create activities/futures only when the computation
   cannot continue. (Support might be provided, if found generically
   feasible, to automate this in a future iteration of the
   implementation.) 

/*global collections*/

/*atomic blocks*/
1. No support might be provided for atomic blocks in the first
   iteration. 
2. One implementation choice would be to allow creation of a fixed
   number of clocks in all the places. 
3. 

/*Concepts in the X10 language not yet incorporated into the C++
runtime. Somehow of these might not be implemented in this iteration. */
//1. Future/force
2. Rooted exceptions
3. Remote references
4. Atomic blocks.
//5. Global collections.

