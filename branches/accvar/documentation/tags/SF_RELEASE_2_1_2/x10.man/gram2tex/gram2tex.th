{
  inputFileName = "/Users/bard/x10/manual/x10-2-1-grammar-productions.txt"; 
  productionsText = inputFileName.file.contents;
  productionsLines = productionsText.split("\n");

  renamings = [
     ["Declaration", "Decl"],
     ["Parameter", "Param"],
     ["Instance", "Inst"],
     ["Expression", "Exp"],
     ["Constructor", "Ctor"],
     ["MethodModifiersopt", "MethMods"],
     ["Modifier", "Mod"],
     ["opt", "\\opt"],
     ["Identifier","Id"],
//    ["Clause", "Cl"],
//    ["FormalParam", "Formal"],
//    ["MethodMods", "MethMods"],
//    ["TypeParams", "TyPar"],
//    ["HasResultType", "ResType"],
//    ["MethodBody", "MBody"],
//    ["PropertyMethod", "PropMeth"],
//    ["Invocation", "Invo"],
//    ["Explicit", "Expl"],
//    ["WithVariance", "WVar"],
  ];

  bs = "\\";
  texNL = "$bs$bs";
  
  var inProduction := false;
  var nextLineShouldNotBeContinue := true;
  var scanningTerminals := false;
  var scanningSoftKeywords := false;
  var skipThisProduction := false;
  
  linesPerLaterPage = 50;
  var linesPerPage := 15; // for first page.

  charsOfRHSPerNewLine = 60;

  var linesOnThisPage := 0;
  
  terminals = ord();
  softKeywords = ord();

  fun produceLine(s) {
    ss = (s + texNL);
    println(ss);
    linesOnThisPage += 1 + (ss.len div charsOfRHSPerNewLine).floor;
    if (linesOnThisPage > linesPerPage) {
      println("\\end{bbgrammar}\n\n\\begin{bbgrammar}\n");
      linesOnThisPage := 0;
      linesPerPage := linesPerLaterPage;
    }
  };
  
  fun xcd(s) = '\\xcd"$s"';

  fun quotify(s) = s.replace("\$", "\\\$");

  fun renamed(s) = 
      %after(t | for [x,y] <- renamings, var t := s %then t.replace(x,y));


  fun trans(".") = xcd(".");
    | trans("Error.*" / []) = null;
    | trans("\\\$.*" / []) = "";
    | trans("'(.*)'"/[s]) = xcd(s);
    | trans(s && "[^a-zA-Z].*" / []) = "" + xcd(s);
    | trans(s && (s in terminals.lst)? ) = xcd(s);
    | trans(s) = (s);
  
  fun genRHS(rhs) {
    // may return null if this line should not be genned
    splut = rhs.trim.split(" +");
    //println("SPLUT: " + (splut.joined("&")));
    pocked = %[trans(sym) | for sym <- splut]; 
    //println("POCKED " + pocked);
    if (null in pocked) {
       // println("<><><><>!");
       return null;
    }
    return " ".join(pocked);
//OLD-MAX-CHARS      var soFar := "";
//OLD-MAX-CHARS      var currRHS := "";
//OLD-MAX-CHARS      for(p <- pocked) {
//OLD-MAX-CHARS         if (currRHS.len + p.len > charsOnRHS) {
//OLD-MAX-CHARS            soFar += "\\\\\n          &&" + p;
//OLD-MAX-CHARS            linesOnThisPage += 1;
//OLD-MAX-CHARS            currRHS := p;
//OLD-MAX-CHARS         }
//OLD-MAX-CHARS         else {
//OLD-MAX-CHARS            currRHS += " " + p;
//OLD-MAX-CHARS            soFar += "  " + p;
//OLD-MAX-CHARS         }
//OLD-MAX-CHARS      }
//OLD-MAX-CHARS      return soFar;
  }

  fun genStarter(lineno, lhs, rhs) {
     if (lhs.trim ~ (".*opt")/[]) {
        skipThisProduction := true;
        return;
     }
     else {
        //println("PLODGE " + lhs);
     }
     if (lhs != "'\$accept' " && genRHS(rhs) ~ +grhs) {
        
        lbl = "\\refstepcounter{equation}\\label{prod:" + lhs.trim + "} ";
        eqno = "& (\\arabic{equation})";
        produceLine(" $lhs $lbl $bs: $grhs $eqno");
        nextLineShouldNotBeContinue := false;
        skipThisProduction := false;
     }
     else {
        // println("Skipping line $lineno $lhs ::= $rhs due to skippy skippage");
        nextLineShouldNotBeContinue := true;
        skipThisProduction := true;
     }
  }

  fun grabTerminal(line) {
     tline = line.trim;
     if (tline != "") {
        //println("Gotta termianl $tline");
        terminals @= tline;
     }
     if (scanningSoftKeywords) {
        softKeywords @= tline;
     }
  }
  
  fun genContinuation(lineno, cont) {
     if (skipThisProduction) {
        //println("SKIP!");
        return;
     }
     if(genRHS(cont) ~ +grhs) {
       if (nextLineShouldNotBeContinue) {
         println("DOOM!  nextLineShouldNotBeContinue! But it is! $lineno");
       }
        produceLine("    \\| $grhs");
     }
     else {
       // println("Skipping line $lineno $cont due to dippy skippage.");
     }
  }
  
  fun softserve(kw && (kw in softKeywords)?) = "$kw (*)";
    | softserve(kw) = kw;
  
  fun produceCommentedTerminalTable(){
    reserved = %[ r | for r <- terminals.lst, if r ~ "[a-z].*"/[]];
    skip = reserved.len div 4;    
    println("\\iffalse\n");
    for(i <- 0 .. (skip-1)) {
      a = softserve(reserved(i));
      b = softserve(reserved(i+skip));
      c = softserve(reserved(i+2*skip));
      i3 = i + 3*skip;
      d = softserve(reserved(i3)) if i3 < reserved.len else "";
      println("%-15s%-15s%-15s%-15s".format(a,b,c,d));
    }
    println("\n\\fi\n");
  }produceCommentedTerminalTable

  
  println("\\chapter{Grammar}\n\n");
  println("In this grammar, \$X^?\$ denotes an optional \$X\$ element.\n\n");
  //println("{\\small\n\n");
  println("\\begin{bbgrammar}\n");
  
  // SCAN LINES
  for(baseline <- productionsLines) {
    line = renamed(baseline);
    if (line ~ "^Terminals: *"/[]) {
       scanningTerminals := true;
       scanningSoftKeywords := false;
    }
    else if (line ~ "^Soft Keywords: *"/[]) {
       scanningTerminals := true;
       scanningSoftKeywords := true;
    }
    else if (scanningTerminals && line ~ "^[A-Z].*"/[]) {
       scanningTerminals := false;
    }
    else if (scanningTerminals) {
       // println("SCANTERM $line");
       grabTerminal(line);
    }
    else if (line ~ "([0-9]+) +([^:]*)::=(.*)" / [lineno, lhs, rhs]) {
       //println("STARTER: $lineno $lhs $rhs");
       genStarter(lineno, lhs, rhs);
    }
    else if (line ~ "([0-9]+) +\\|(.*)" / [lineno, cont]) {
       //println("CONTINUATION: $lineno $cont");
       genContinuation(lineno, cont);

    }
    else if (line ~ "([0-9]+)(.*)" / [lineno, eep]) {
       println("WTF-WTF-WTF: $lineno $eep");
    }
  }
  println("\\end{bbgrammar}\n");
  
  produceCommentedTerminalTable();
  
  //println("\n}");

  
  
}
