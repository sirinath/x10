%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{pstricks, pst-node, pst-blur}

\begin{document}

\conferenceinfo{PGAS '10}{October, New York.} 
\copyrightyear{2010} 
\copyrightdata{[to be supplied]} 

\titlebanner{PGAS 2010}        % These are ignored unless
\preprintfooter{Deadlock-Free, Determinate X10 and its Compilation}   % 'preprint' option specified.


\title{Deadlock-free, Determinate X10}
%\subtitle{Subtitle Text, if any}

\authorinfo{Nalini Vasudevan}
           {Columbia University}
           {naliniv@cs.columbia.edu}

\authorinfo{Vijay Saraswat}
           {IBM Research}
           {vsaraswa@us.ibm.com}


\authorinfo{Olivier Tardieu}
           {IBM Research}
           {tardieu@us.ibm.com}


\authorinfo{Julian Dolby}
           {IBM Research}
           {dolby@us.ibm.com}


\maketitle

\lstdefinestyle{small}{
  basicstyle={\fontsize{8}{9}\selectfont\rmfamily},
  identifierstyle={\rmfamily\itshape},
  keywordstyle={\rmfamily\itshape\bfseries},
}

\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}
\newcommand{\tabref}[1]{Table~\ref{tab:#1}}
\newcommand{\lemref}[1]{Lemma~\ref{lem:#1}}
\newcommand{\algref}[1]{Algorithm~\ref{alg:#1}}
\newcommand{\lineref}[1]{line~\ref{line:#1}}

\lstset{
  language=C,
  basicstyle={\fontsize{8.5}{9.5}\selectfont\rmfamily},
  identifierstyle={\rmfamily\itshape},
  keywordstyle={\rmfamily\itshape\bfseries},
  commentstyle={\rmfamily\color{blue}},
  columns=fullflexible,
  escapechar=\#,
  numbers=left,
  numberstyle=\scriptsize,
  numbersep=4pt,
  stepnumber=1,
  escapeinside={/*@}{@*/}
%  alsoletter=0123456789,
}




\begin{abstract}
Most concurrent programming languages come with a repertoire of problems.
The two major ones are non- 
determinism and deadlocks. By determinism, we mean the output behavior of the program is 
independent of the interleaving caused by the schedule and depends only on the 
input behavior. A few concurrent languages ensure deterministic behavior by providing 
constructs like barriers and locks that impose additional synchronization, 
but the incorrect usage of these constructs 
leads to problems like deadlocks. 

In this paper, we propose new techniques that guarantee
the two desirable properties of concurrency - determinism and deadlock-freedom.
We have applied these techniques to IBM's X10 programming language.
Any X10 program that forces these techniques will be deterministic; the output of the program
will solely depend on the input and not on the interleaving of the tasks in the program.
Additionally, these techniques do not introduce deadlocks.

\end{abstract}

%\category{CR-number}{subcategory}{third-level}

%\terms
%term1, term2

%\keywords
%Determinism, Deadlock-Freedom

\section{Introduction}
X10 is a parallel, distributed object-oriented language. To a Java-like sequential core 
it adds constructs for concurrency and distribution through the
concepts of activities and places.  
An activity is a unit of work, like a thread in
Java; a place is a logical entity that contains both activities and data objects.

Activities in X10 may run concurrently and share variables. This gives
rise to programmer bugs such as data races and non-determinism.
Such non-determinism makes debugging nearly impossible because unwanted
behavior is not always reproducible.
Our techniques aid the compiler to check for non-determinism. 
In addition, we provide new language constructs that allow programmers
to write efficient deterministic code easily. We elaborate these methods
in the next section.

\section{Our Approach}
We use a combination of techniques to assert determinism. The compiler looks for shared variable
conflicts by using effect and barrier analysis tools. In addition to compile-time
analysis, we  provide the programmer with new constructs
such as collecting $finish$ and clocked variables
that allow the programmers to share variables deterministically.  

\subsection{Effects analysis}
The goal of the effect system is to establish that parallel programs are safe
parallelizations of their serial elision. 
That is, executing the parallel program in
a given state $s$ will result in a state $t$ which is equivalent to the state obtained
by executing the underlying sequential program.
The serial elision of an X10 program is obtained
by removing the keywords that contribute to parallelism in the code.

The basic idea is to abstract the effect of execution of statements on mutable
locations through an effect, which describes the set of mutable locations accessed
by the statement, and operations performed on it. Compositional rules are then
provided that specify how effects of compound statements are built given effects
of their constituents.


\subsection{Barrier analysis}
Unfortunately, effect analysis does not work in the presence of barriers
because it is harder to get the serial elision of a program with barriers.
The barrier analysis is a more sophisticated analysis that reports blocks of 
code that may happen in parallel in the presence of barriers.
Once we do a may-happen-in-parallel analysis, we calculate the effects of 
the parallel blocks
 and see if they collide.


\subsection{Collecting $finish$}

Although we could prove that a large number of X10 programs are deterministic
with the analysis tools, some programs failed the test even though
they were deterministic. Therefore, we
introduced new programming language constructs that allow us
to express some programs deterministically. The collecting $finish$, for
instance, is an extension to X10's $finish$ statement.
The $finish$ statement in X10 waits for all tasks in its scope to 
terminate. The collecting $finish$ allows the tasks in its scope to
also offer values to the $finish$. When the tasks terminate, the offered values
are deterministically reduced using a commutative, associative operator and the task
executing the finish uses this reduced value.

\subsection{Clocked Variables}
Clocked variables are more generalized than collecting $finish$ and they
also tackle non-determinism.
Non-determinism arises when multiple tasks access a shared variable
concurrently. With clocked variables, multiple tasks may modify a clocked shared
variable locally, but the updates are made available to each other only
when they explicitly synchronize. During synchronization, these updates
are reduced using a commutative associative operator. 

Both collecting $finish$ and clocked variables cannot introduce deadlocks
even if the programmer does not use them correctly. Therefore, these constructs
provide both the desirable properties of concurrency.


\section{Conclusions}
\label{sec:conclusions}
We have presented techniques and tools that address the
two major problems of concurrency: non-determinism and deadlocks.
We were able to assert determinism at compile-time in a number of JGF and 
HPCC benchmarks with all or a subset of techniques described
in the previous section.

The current state of our techniques cannot deal with data structures on the heap,
because it requires more complicated analysis.

{\it Our ultimate goal is {\bf \it efficient} concurrency
 with determinism and  deadlock-freedom}.
We believe this will be a necessary
step along the way to pervasive parallelism in programming.



\end{document}

