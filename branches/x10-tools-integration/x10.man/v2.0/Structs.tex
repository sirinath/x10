\chapter{Structs}
\label{XtenStructs}
\label{StructClasses}
\label{Structs}
\index{structs}

An instance of a class \Xcd{C} (an \emph{object} ) is represented in \Xten{} as
a contiguously allocated chunk of words in the heap, containing the
fields of the object as well as one or more words used in method
lookup (itable/vtable). Variables with base type \Xcd{C} (or a supertype of
\Xcd{C}) are implemented as cells with enough memory to hold a
\emph{reference} to the object. The size of a reference (32 bits or 64
bits) depends on the underlying operating system.


For many high-performance programming idioms, the overhead of one
extra level of indirection represented by an object is not
acceptable. For instance, a programmer may wish to define a type
\Xcd{Complex} (consisting of two double fields) and require that instances
of this type be represented precisely as these two fields. A variable
or field of type complex should, therefore, contain enough space to
store two doubles. An array of complex of size \Xcd{N} should store \Xcd{2*N}
doubles. Method invocations should be resolved statically so that
there is no need to store vtable/itable words with each
instance. Parameters of type complex should be passed inline to a
method as two doubles. If a method's return type is complex the method
should return two doubles on the stack. Two values of this type should
be equal precisely when the two doubles are equal (structural
equality).

\Xten{} supports the notion of \emph{structs} which are precisely
objects that can be implemented inline with a contiguous chunk of
memory representing their fields, without any vtable/itable. Structs
are introduced by struct definitions. struct definitions look very
similar to class definitions, but have additional restrictions.

\paragraph{Implementation Note} In \XtenCurrVer{}, structs are
only implemented as inline headerless objects when using the C++
backend. In the Java backend, structs are mapped directly to Java
classes and therefore have the same space and indirection
characteristics as classes. 

\section{Struct declaration}

\Xten{} supports user-defined primitives (called
\emph{structs}). Like classes, structs define zero or more fields and
zero or more methods, and may implement zero or more interfaces. A
struct has the same modifiers as a class. However, structs are
implicitly \xcd`val` and do \emph{not} participate in any code
inheritance relation. (This makes structs very easy to implement,
without vtables.)

\begin{xtenmath}
$\mbox{\emph{StructModifiers}}^{\mbox{?}}$
struct C[X$_1$, $\ldots$, X$_n$](p$_1$:T$_1$, $\ldots$, p$_n$:T$_n$){c} 
   implements I$_1$, $\ldots$, I$_k$ {
$\mbox{\emph{StructBody}}$
}
\end{xtenmath}

Each field and method in a struct is implicitly marked \Xcd{global}.  

The size of a variable of struct type \Xcd{C} is the size of the fields
defined at \Xcd{C} (up to alignment considerations). No extra space is
allocated for a vtable or an itable. This means that unlike classes,
structs cannot be defined recursively. That is, a struct \Xcd{S} cannot
contain a field of type \Xcd{S}, or a field of struct type \Xcd{T} which,
recursively, contains a field of type \Xcd{S}.

\begin{itemize}
\item More precisely, we require that the set of \emph{size equations}
  for all structs and classes must have a unique solution. A size
  equation for a struct \Xcd{S} is defined as follows. Assume \Xcd{S} has $m$ fields
  of type \Xcd{S}$_i$ (for $i$ in $0,\ldots,m-1$), and $n$ fields of type (class) \Xcd{C}$_j$
  (for $j$ in $0,\ldots,n-1$). Then the size equation for \Xcd{S} is 
\begin{xtenmath}
size(S) = size(S$_0$)+$\ldots$+size(S$_{m-1}$)+size(C$_0$)+$\ldots$+size(C$_{n-1}$) 
\end{xtenmath}
The size
equation for a class \Xcd{C} is just \Xcd{size(C) = AddressSize}, where
\Xcd{AddressSize} is a compile-time parameter.
\end{itemize}

Values of a struct \Xcd{C} type can be created by invoking a constructor
defined in \Xcd{C}, but without prefixing it with \Xcd{new}.

Constrained types can be built on top of the base \Xcd{C} in the same way as
they can be built on top of a class \Xcd{D}. In struct \Xcd{C[T1,..., Tn]\{c\}},
the type of \Xcd{self} in \Xcd{c} is \Xcd{C[T1,..., Tn]}.

\section{Boxing of structs}
If a struct \Xcd{S} implements an interface \Xcd{I} (e.g., \Xcd{Any}),
a value \Xcd{v} of type \Xcd{S} can be assigned to a variable of type
\Xcd{I}. The implementation creates an object \Xcd{o} that is an
instance of an anonymous class implementing \Xcd{I} and containing
\Xcd{v}.  The result of invoking a method of \Xcd{I} on \Xcd{o} is the
same as invoking it on \Xcd{v}. This operation is termed {\em auto-boxing}
\index{auto-boxing!struct to interface}
\label{auto-boxing}

In a generic class or struct obtained by instantiating a type parameter
\Xcd{T} with a struct \Xcd{S}, variables declared at type \Xcd{T} in the body
of the class are not boxed. Rather they are implemented as if they were declared at
type \Xcd{S}. 

\section{Implementation of \Xcd{Any} methods}
\label{StructAnyMethods}
\index{Any!structs}

Unlike objects, structs do not have global identity. Instead, two
structs are equal (\Xcd{==}) if and only if their corresponding fields
are equal (\Xcd{==}). This is the central property of structs.

All structs implement \Xcd{x10.lang.Any}. All 
structs have the following methods implicitly defined on them:
\begin{xten}
  property def home()=here;
  property def at(Place)=true;
  property def at(Object)=true;
\end{xten}
\noindent It is an error for a programmer to attempt to define them.

Structs are required to implement the following methods: 
\begin{xten}
  public global safe def equals(Any):Boolean;
  public global safe def hashCode():Int;
  public global safe def typeName():String;
  public global safe def toString():String;  
\end{xten}

These methods are defined automatically if they are not supplied by
the programmer.  A programmer who provides an explicit implementation
of \Xcd{equals(Any)} for a struct \Xcd{S} should also consider
supplying a definition for \Xcd{equals(S):Boolean}. This will often
yield better performance since the cost of an upcast to \Xcd{Any} and
then a downcast to \Xcd{S} can be avoided.

Expressions of a struct type may be used in \Xcd{instanceof} and
\Xcd{as} expressions.

\section{``Primitives''}

The package \Xcd{x10.lang} provides the following structs. Most of
the functionality of these structs is implemented natively.

\begin{xten}
boolean, char, 
byte, short, int, long
float, double
ubyte, ushort, uint, ulong
\end{xten}
 
\section{Generic programming with structs}

An unconstrained type variable \Xcd{X} can be instantiated with \Xcd{Object} or
its subclasses or structs or functions.

Within a generic struct, all the operations of \Xcd{Any} are available
on a variable of type \Xcd{X}. Additionally, variables of type \Xcd{X} may
be used with \Xcd{==, !=}, in \Xcd{instanceof}, and casts.

The programmer must be aware of the different interpretations of
equality for structs and classes and ensure that the code is correctly
written for both cases. If necessary the programmer can write code
that distinguishes between the two cases (a type parameter \Xcd{X} is
instantiated to a struct or not) as follows:

\begin{xten}
val x:X = ...;
if (x instanceof Object) { // x is a real object
   val x2 = x as Object; // this cast will always succeed.
   ...
} else { // x is a struct
   ...
}
\end{xten}
 
  
\section{Programming Methodology}

 A programmer should by default organize his/her code in a class
 hierarchy, providing structs only in those well-thought situations
 where concrete types are appropriate.

\subsection{Compatibility Note}

A value class in \Xten{} v1.7 can often be translated into a struct in \Xten{} 2.0. The crucial conditions to be checked manually are: \begin{itemize}
\item  A struct is of bounded size. 
\item  Each method is global. 
\item  The class is final.
\end{itemize}
 

If these conditions are not met, the value class should be converted
into a class with \Xcd{global} fields and methods.

\subsection{Examples}

An example illustrating pairing:

%~~gen
%
%~~vis
\begin{xten}
struct Pair[S,T]  {
  val x: S;
  val y: T;
  def this(x: S, y: T) {
    this.x=x;
    this.y=y;
  }
  def x()=x;
  def y()=y;  
  public global safe def hashCode() = x.hashCode() + y.hashCode();
  public def equalsX[U](o:Pair[S,U]) = x==o.x;
  public def equalsY[U](o:Pair[U,T]) = y==o.y;
  public global safe def equals(that:Any) = this == that;
  public def equals(that:Pair[S,T]) = this==that;
}
\end{xten}
%~~siv
% 
%~~neg

The following types all make sense: 
\begin{itemize}
\item \Xcd{Pair[Complex, String]}: A struct with two fields, one inlined field of type \Xcd{Complex} and another of type \Xcd{String}. 
\item \Xcd{Pair[Complex, Int]}: A struct with two fields, one inlined field of type \Xcd{Complex} and another of type \Xcd{Int}. 
\end{itemize}

The definition of \Xcd{x10.lang.Complex} provides a good example of the use of structs.
