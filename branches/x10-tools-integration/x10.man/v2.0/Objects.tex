\chapter{Objects}\label{XtenObjects}\index{Object}

\section{Basic Design}
An object is an instance of a scalar class or an array type.  It is
created by using an allocation expression
(\Sref{ClassCreation}) or an array creation
(\Sref{ArrayInitializer}) expression, such as an array
initializer. 

All classes subclass from \xcd"x10.lang.Object".
This class has one property \xcd"home" of type
\xcd"x10.lang.Place". \index{place.home} Thus all objects in \Xten{}
are located (have a place). 

In \XtenCurrVer{} an object stays resident at the place at
which it was created for its entire lifetime. However, the
programmer may designate certain immutable field of an object
as \Xcd{global}. The value of these fields is accessible 
at every place the object can be referenced.

{}\Xten{} has no operation to dispose of a reference.  Instead, the
collection of all objects across all places is globally garbage
collected.

Unlike \java{},
{}\Xten{} objects do not have any synchronization information (e.g.,
a lock) associated with them. 
Instead, programmers should use atomic blocks
(\Sref{AtomicBlocks}) for mutual exclusion and clocks
(\Sref{XtenClocks}) for sequencing multiple parallel operations.

An object may have many references, stored in fields of
objects or components of arrays. A change to an object made through
one reference is visible through another reference. 

Note that the creation of a remote async activity
(\Sref{AsyncActivity}) \xcd"A" at \xcd"P" may cause the automatic creation of
references to remote objects at \xcd"P". (A reference to a remote
object is called a {\em remote object reference}, to a local object a
{\em local object reference}.)  For instance \xcd"A" may be created
with a reference to an object at \xcd"P" held in a variable referenced
by the statement in \xcd"A".  Similarly the return of a value by a
\xcd"future" may cause the automatic creation of a remote object
reference, incurring some communication cost.  An {}\Xten{}
implementation should try to ensure that the creation of a second or
subsequent reference to the same remote object at a given place does
not incur any (additional) communication cost.

A reference to an object carries with it the values of  \Xcd{global} \xcd`val`
fields
of the object. The implementation should try to ensure that the cost
of communicating the values of \xcd`val` fields of an object from the
place where it is hosted to any other place is not incurred more than
once for each target place.

{}\Xten{} does not have an operation (such as Pascal's ``dereference''
operation) which returns an object given a reference to the
object. Rather, most operations on object references are transparently
performed on the bound object, as indicated below. The operations on
objects and object references include:
\begin{itemize}

{}\item Field access (\Sref{FieldAccess}). An activity holding a
reference to an object may perform this operation only if the
object is local.  (By contrast, an activity holding a reference to a struct
may perform this operation regardless of the location of the struct, 
since structs can be copied freely from place to place.).  The
implementation should try to ensure that the cost of copying the field
from the place where the object was created to the referencing place
will be incurred at most once per referencing place, according to the
rule for \xcd`val` fields discussed above.

{}\item Method invocation (\Sref{MethodInvocation}).  
\label{GlobalAnnotation}
A method may be
marked \Xcd{global}. A \Xcd{global} method may be invoked at any
place. It may access only the global fields of the object. The
mutable fields of an object may be accessed only by activities
operating in its home.  Any activity may use an \Xcd{at} statement
to place-shift to the place of the object. Methods may also be
marked \Xcd{pinned}, \Xcd{nonblocking}, \Xcd{sequential},
\Xcd{safe}, and \Xcd{pure} (\Sref{MethodQualifier})..

{}\item Casting (\Sref{ClassCast}).  An activity can perform this
operation on local or remote objects, and should not incur
communication costs (to bring over type information) more than once
per place.

{}\item \xcd"instanceof" operator (\Sref{instanceOf}).  An activity
can perform this operation on local or remote objects, and should not
incur communication costs (to bring over type information) more than
once per place.

\item The equality operators \xcd"==" and \xcd"!="
(\Sref{StableEquality}). On creation, each object is associated with a globally
unique identifier (guid). Two object references are \xcd"==" iff they refer to objects
with the  same guid.

\end{itemize}

\Xten{} has a rather simple \emph{distributed object model}. 

The state of an object is partitioned into \emph{global} state (a
programmer defined subset of \Xcd{val} fields, \Sref{GlobalField}) and
\emph{non-global} state.

 \begin{itemize}
\item Field definitions are marked with the qualifier \Xcd{global} if
  they are intended to be included in the global state.
\item If the \Xcd{global} qualifier is omitted, the field is
  considered non-global.
\item Properties and static fields are implicitly marked \Xcd{global}.
\item \Xcd{var} fields cannot be marked \Xcd{global}.
%\item  Fields marked \Xcd{global} cannot be overriden by fields not marked \Xcd{global}.
\end{itemize}
 
Similarly, the methods of an object may be qualified as
\Xcd{global}(\Sref{GlobalMethod}) ; if they are not global they are
said to be \emph{non-global}. 
Global methods cannot be overridden by non-global methods.

Consider the execution of an \Xcd{at (P) S} statement at a place
\Xcd{Q} different from \Xcd{P}. Suppose \Xcd{x} is an in-scope
immutable local variable and contains a reference to an object \Xcd{o}
created at \Xcd{Q}. Then within \Xcd{S}, \Xcd{x} is said to be a
\emph{remote reference} to \Xcd{o}. References to \Xcd{o} from place
\Xcd{Q} are said to be \emph{local references}. \Xten{} permits
\Xcd{global} fields to be read and \Xcd{global} methods to be invoked
through a remote reference.

Like local references, remote references are first-class entities:
they may be passed as arguments to methods, returned from methods,
stored in fields of objects.

Remote references may also be compared for equality (\Xcd{==}). Two
remote reference are equal if they are references to the same
object. Equality is guaranteed to be a constant-time operation and not
involve any communication.

When a remote reference to an object \Xcd{o} located at place \Xcd{P} is
transmitted to \Xcd{P} it automatically becomes a local reference to
\Xcd{o}. Therefore the situation in which a local reference can be compared
to a remote reference simply cannot arise.

The \Xten{} compiler ensures that non-global methods on \Xcd{o} can
only be invoked in a place where \Xcd{here== o.home()}, i.e. the place
where \Xcd{o} was created.

\paragraph{Implementation notes}
Remote references to an object \Xcd{o} are intended to be implemented
by serializing the global state of \Xcd{o} across the network,
together with a globally unique id (guid). The data is deserialized at
the receiver to create an implementation-level entity that is the
remote reference. There is no requirement that the implementation
intern such entities; however the implementation must correctly
implement equality (see below).

There is no requirement that a remote reference use only as much space as a local reference.

  
\paragraph{Local execution}
 The semantics of \Xcd{atomic} and \Xcd{when} constructs requires that their
 bodies do not execute any \Xcd{at} operations, implicitly or
 explicitly. Hence the compiler must establish that if a non-global method
\Xcd{m} is being invoked on a reference \Xcd{o} in the body of such a construct,
 then \Xcd{o} is a local reference. This can be done using place types (\Sref{PlaceType}).

  
\section{Examples}
Assume the class declarations. 

\begin{xten}
class C { } 
class D {
   var f:C=null;
}
\end{xten}

%%TODO--Add a variant of the following code to the test suite
Then the following code behaves as stated.
%~~gen
% package objects.dwiffle.and.a.half.a.moon;
% class C { } 
% class D {
%    var f:C=null;
% }
% class Fudders {
% def plongent(P:Place, Q:Place) throws Exception {
%~~vis
\begin{xten}

val x = new C(); 
// C object o1 created, reference stored in x. 
at (P) { 
      // In the body x contains a remote reference to o
      val d = new D();
      d.f  = x; // remote reference stored in d.f
      Console.OUT.println(d.f == x);        // must print true
      Console.OUT.println(x == x);          // must print true
      at (Q) { 
         // x continues to be a remote reference to o1.
         at (P) {  
             Console.OUT.println(d.f == x);   // must print true
             Console.OUT.println(x == x);   // must print true
         }
      }
}
\end{xten}
%~~siv
%}}
%~~neg
  
%%TODO--Add a variant of the following code to the test suite
%%TODO--rewrite this
Here is another example.
%~~gen
% package objects.armor.of.eyeballs;
% class C { } 
% class D {
%    var f:C=null;
% }
% class Fudders {
% def plongent(P:Place, Q:Place) throws Exception {
%~~vis
\begin{xten}
val x = new C(); 
// C object o created, reference stored in x. 
// The type inferred for x is C!
at (P) { 
    val x1 = x; 
    // The type inferred for x1 is C, not C!;
    // the change is due to the place shift 'at(P)'
  at (x.home) {
        // x is now bound to o through a local reference. So is x1.
    Console.OUT.println(x1==x); // Must print true.
      // non-global methods can be invoked on x or x1 and will 
      // execute locally on o
      // type of both x and x1 is C!.
  }
}
\end{xten}
%~~siv
%}}
%~~neg
 
\subsection{Programming Methodology}

A programmer wishing to ensure that a \Xcd{val} field is not serialized when
the containing object is serialized (e.g. because it contains a large
cache which makes sense only in the current place) must ensure the
field is \emph{not} marked global.


