\section{Regions}\label{XtenRegions}\index{region}

A region is a set of points.  {}\Xten{}
provides a built-in class, \xcd"x10.lang.Region", to allow the
creation of new regions and to perform operations on regions. 

Each region \xcd"R" has a constant integer rank, \xcd"R.rank".
%% TODO: Should be uint.

Here are several examples of region declarations:
\begin{xten}
val MAX_HEIGHT=20;
val Null = Region.makeUnit();  // Empty 0-dimensional region          
val N = 10;
val K = 2;
val R1 = 1..100; // 1-dim region with extent 1..100
val R2 = [1..100] as Region(1); // same as R1
val R3 = (0..99) * (-1..MAX_HEIGHT);   
val R4 = [0..99, -1..MAX_HEIGHT] as Region(2); // same as R3  
val R5 = Region.makeUpperTriangular(N);
val R7 = R4 && R5; // intersection of two regions
val R8 = R4 || R5; // union of two regions
\end{xten}

The expression \xcdmath"a$_1$..a$_2$"
is shorthand for the rectangular, rank-1 region
consisting of the points
$\{$\xcdmath"[a$_1$]", \dots, \xcdmath"[a$_2$]"$\}$.
Each subexpression of \xcdmath"a$_i$" must be of type \xcd"Int".
If \xcdmath"a$_1$"
is greater than \xcdmath"a$_2$", the region is empty.

A region may be constructed by converting from a rail of
regions or a rail of points, typically using a rail constructor
(\Sref{RailConstructors})
(e.g., \xcd"R4" above).
The region constructed from a rail of points represents the
region containing just those points.
The region constructed from a rail of regions
represents
the Cartesian product of each of the arguments.
\XtenCurrVer{} does not (yet) support hierarchical regions.

\index{region!upperTriangular}
\index{region!lowerTriangular}\index{region!banded}

Various built-in regions are provided through  factory
methods on \xcd"Region".  For instance:
\begin{itemize}
\item \xcd"Region.makeUpperTriangular(N)" returns a region corresponding
to the non-zero indices in an upper-triangular \xcd"N x N" matrix.
\item \xcd"Region.makeLowerTriangular(N)" returns a region corresponding
to the non-zero indices in a lower-triangular \xcd"N x N" matrix.
\end{itemize}

All the points in a region are ordered canonically by the
lexicographic total order. Thus the points of a region \xcd"R=(1..2)*(1..2)"
are ordered as 
\begin{xten}
(1,1), (1,2), (2,1), (2,2)
\end{xten}
Sequential iteration statements such as \xcd"for" (\Sref{ForAllLoop})
iterate over the points in a region in the canonical order.

A region is said to be {\em rectangular}\index{region!convex} if it is of
the form \xcdmath"(T$_1$ * $\cdots$ * T$_k$)" for some set of regions
\xcdmath"T$_i$". Such a
region satisfies the property that if two points $p_1$ and $p_3$ are
in the region, then so is every point $p_2$ between them (that is, it is {\em convex}). 
(Note that \xcd"||" may produce non-convex regions from convex regions, e.g.,
\xcd"[1,1] || [3,3]" is a non-convex region.)

For each region \xcd"R", the {\em rectangular closure} of \xcd"R" is the
smallest rectangular region enclosing \xcd"R".  For each integer \xcd"i"
less than \xcd"R.rank", the term \xcd"R(i)" represents the enumeration
in the \xcd"i"th dimension of the rectangular closure of \xcd"R". It may be
used in a type expression wherever an enumeration may be used.

\subsection{Operations on regions}
Various non side-effecting operators (i.e., pure functions) are
provided on regions. These allow the programmer to express sparse as
well as dense regions.

Let \xcd"R" be a region. A subset of \xcd"R" is also called a
{\em sub-region}.\index{region!sub-region}

Let \xcdmath"R$_1$" and \xcdmath"R$_2$" be two regions whose type
establishes that they are of the same rank. Let 
\xcdmath"S" be a region of unrelated rank.

\xcdmath"R$_1$ && R$_2$" is the intersection of \xcdmath"R$_1$" and
\xcdmath"R$_2$". 

\index{region!intersection}

\xcdmath"R$_1$ || R$_2$" is the union of the \xcdmath"R$_1$" and
\xcdmath"R$_2$".\index{region!union}

\xcdmath"R$_1$ - R$_2$" is the set difference of \xcdmath"R$_1$" and
\xcdmath"R$_2$".\index{region!set difference}

\xcdmath"R$_1$ * S" is the Cartesian product of \xcdmath"R$_1$" and
\xcdmath"S",  formed by pairing each point in \xcdmath"R$_1$" with every the point in \xcdmath"S".
\index{region!product}
Thus, \xcd"([1..2,3..4] as Region 2) * (5..6)"
is the region of rank \Xcd{3} containing the points \Xcd{(x,y,z)}
where \Xcd{x} is \Xcd{1} or \Xcd{2}, 
\Xcd{y} is \Xcd{3} or \Xcd{4}, and
\Xcd{z} is \Xcd{5} or \Xcd{6}. 


For a region \xcdmath"R" and point \xcdmath"p" of the same rank 
\xcdmath"R+p" and \xcdmath"R-p" represent the translation of the region
with \xcdmath"p". That is, point \xcdmath"q" is in 
\xcdmath"R" if and only if point \xcdmath"q+p" is in \xcdmath"R+p". (And similarly
for \xcdmath"R-p".)

%%TODO: Determine how equality is actually implemented. This should not be the definition of ==. 
%%  This could be the definition of .equals(..).

%% Two regions are equal (\xcd"==") if they represent the same set of
%% points.\index{region!==}

For more details on the available methods on \xcdmath"Region", please
consult the API documentation.
