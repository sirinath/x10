#ifndef X10_LANG_STRING_H
#define X10_LANG_STRING_H

#include <cstring>

#include <x10aux/config.h>
#include <x10aux/string_utils.h>

#include <x10/lang/Value.h>

#ifdef __CYGWIN__
extern "C" char *strdup (const char *);
#endif
namespace x10 {

    namespace lang {

        template<class T> class Rail;
        template<class T> class ValRail;

        class String : public Value {

            const char *FMGL(content);
            std::size_t FMGL(content_length);

            public:

            const char *c_str() const { return FMGL(content); }

            class RTT : public x10aux::RuntimeType {
                public:
                static RTT* const it;
                virtual void init() { initParents(1,x10aux::getRTT<Value>()); }
                virtual const char *name() const { return "x10.lang.String"; }
            };

            virtual const x10aux::RuntimeType *_type() const { return x10aux::getRTT<String>(); }


            // Set steal to true if you have just allocated the char * with
            // alloc_printf or it's otherwise OK if the String frees it.  Leave
            // steal false for string literals which ought not to be freed.
            // Leave it false for 'static' malloced char* such as the RTT type
            // names that also ought not to be freed.
            static x10aux::ref<String> _make(const char *content, bool steal = false) {
                x10aux::ref<String> this_ = new (x10aux::alloc<String>()) String();
                if (!steal) content = strdup(content);
                this_->_constructor(content,strlen(content));
                return this_;
            }
            x10aux::ref<String> _constructor(const char *content, std::size_t content_length) {
                this->FMGL(content) = content;
                this->FMGL(content_length) = content_length;
                return this;
            }
            static x10aux::ref<String> _make(x10aux::ref<String> s) {
                x10aux::ref<String> this_ = new (x10aux::alloc<String>()) String();
                this_->_constructor(s->FMGL(content), s->FMGL(content_length));
                return this_;
            }

            // This is for string literals, brought out here so we have easier control
            // (Can later make this return a String without allocation)
            static x10aux::ref<String> Lit(const char *s)
            { return _make(s); }

            // Useful when we have a malloced char* instead of a literal
            static x10aux::ref<String> Steal(const char *s)
            { return _make(s, true); }

            /*
            operator x10aux::ref<Value> () {
                return x10aux::ref<String>(this);
            }

            operator x10aux::ref<String> () {
                return _make(*this);
            }
            */

            x10aux::ref<String> toString() { return this; }

            x10_int hashCode();

            x10_int length() { return (x10_int) FMGL(content_length); }
            x10_int indexOf(x10aux::ref<String> s, x10_int i = 0);
            x10_int indexOf(x10_char c, x10_int i = 0);
            x10_int lastIndexOf(x10aux::ref<String> s, x10_int i = 0);
            x10_int lastIndexOf(x10_char c, x10_int i = 0);
            x10aux::ref<String> substring(x10_int start, x10_int end);

            x10aux::ref<String> substring(x10_int start) {
                return substring(start, this->length());
            }

            x10_char charAt(x10_int i);

            x10aux::ref<ValRail<x10_char> > chars();

            x10aux::ref<ValRail<x10_byte> > bytes();

            static void _serialize(x10aux::ref<String> this_,
                                   x10aux::serialization_buffer &buf,
                                   x10aux::addr_map &m)
            {
                if (this_==x10aux::null) {
                    String v;
                    v._serialize_body(buf,m);
                } else {
                    this_->_serialize_body(buf, m);
                }
            }

            template<class T> static x10aux::ref<T> _deserialize(x10aux::serialization_buffer &buf){
                x10_int sz = buf.read<x10_int>();
                char *content = x10aux::alloc<char>(sz+1);
                for (x10_int i=0 ; i<sz ; ++i) {
                    content[i] = (char)buf.read<x10_char>();
                }
                content[sz] = '\0';
                // there are no fields
                x10aux::ref<String> this_ = Steal(content);
                _S_("Deserialized string was: \""<<this_<<"\"");
                return this_;
            }

            static const x10aux::serialization_id_t _serialization_id;

            virtual void _serialize_id(x10aux::serialization_buffer& buf, x10aux::addr_map &m) {
                buf.write(_serialization_id, m);
            }

            virtual void _serialize_body(x10aux::serialization_buffer& buf, x10aux::addr_map &m) {
                // only support strings that are shorter than 4billion chars
                x10_int sz = FMGL(content_length);
                buf.write(sz,m);
                for (x10_int i=0 ; i<sz ; ++i) {
                    buf.write((x10_char)FMGL(content)[i],m);
                }
            }

            static x10aux::ref<String> format(x10aux::ref<String> format,
                                              x10aux::ref<ValRail<x10aux::ref<Object> > > parms);

            static x10aux::ref<String> format(x10aux::ref<String> format,
                                              x10aux::ref<Rail<x10aux::ref<Object> > > parms);

            virtual x10_boolean _struct_equals(x10aux::ref<x10::lang::Object> p0);

            String () : FMGL(content)(NULL) { }
            virtual ~String () {
                x10aux::dealloc(FMGL(content));
            }
        };


        // Adding reference classes (String+String) (String+Object) (Object+String)
        template<class T1, class T2>
        x10aux::ref<String> operator+(T1 p1, T2 p2) {
            return String::Steal(x10aux::alloc_printf("%s%s",
                                                      x10aux::safe_to_string(p1)->c_str(),
                                                      x10aux::safe_to_string(p2)->c_str()));
        }
            
        template<class T>
        x10aux::ref<String> operator+=(x10aux::ref<String> &s1, T v) {
            return s1 = s1 + v;
        }

        #ifndef NO_IOSTREAM
        inline std::ostream &operator<<(std::ostream &o, String &v) {
            return o << v.c_str();
        }
        #endif

    } // namespace x10::lang

} // namespace x10


#endif
// vim:tabstop=4:shiftwidth=4:expandtab:textwidth=100
