CCCC analysis toy.  This software is intended to demonstrate memory
ordering constraints that cover all hardware supporting Linux.  However,
it might well have uses other than validating Linux kernel code sequences.

To build the cccc toy, do the following:

	cc -g -o cccc cccc.c

Or just "sh cccc.mk".

The cccc toy takes a text file as input.  To test it out, try:

	./cccc < Tests/lock.txt

This produces voluminous output (which may be found in Tests/lock.out),
ending with:

	Cycle located:
	0.0 -> 0.1  (program order)
	0.1 -> 1.0  (manual)
	1.0 -> 0.0  (propagation)
	Task 1 sees cycle
	Cycle found: illegal execution according to CCCC

This should be reassuring, as this example models a later critical
section failing to see the effects of prior critical sections.  Such
a failure had -better- be illegal!

The input format will take old-timers back to the punched-card era.
There are two formats, statements and explicit dependencies.  These are
fixed format, and the fields must be in the columns indicated separated
by a single space character.  The first field must start in column 1
(but I have indented here for clarity).  The lock.txt input file is
as follows:

	# Test lock-release-acquire scenario.

	0.0 W x 1
	0.1 W l 0
	1.0 R l 0 # might need atomic op...
	1.1 W l 1
	1.2 R x 0

	0.1 -> 1.0
	1.2 -> 0.0

The "#" is a comment character.  Empty lines are ignored.  The first
meaningful line is "0 0 w x 1", which indicates that task 0's 0-th
statement is an ordered write to the value "1" to variable "x".  The second
line indicates that task 0's first line is an ordered write to the value "1"
to variable "l" (which represents the lock).  The statements for
task 1 proceed similarly.  As you might guess, "R" stands for ordered read,
and "A" stands for ordered atomic operations (e.g., CAS, atomic increment,
or whatever).  The lower-case counterparts are not ordered, in which
case explicit memory barriers must be used, as will be demonstrated
in a later example.  Statements must appear in numerical order.

The last two lines specify dependencies.  The "0.1 -> 1.0" indicates
that task 1's 0-th statement depends on task 0's first statement.
This makes sense, because task 1's read from the lock variable should
see the value task 0 wrote.  (The cccc toy does not yet model atomic
operations.  Or any kind of arithmetic, for that matter.)  Similarly the
"1.2 -> 0.0" indicates that task 0's 0-th statement depends on task 1's
second statement.  This is the test dependency: such a dependency could
only happen if the underlying lock implementation was broken.

Dependencies will be inferred from write and read values when possible:
if there is only one write of a given value to a given variable, then
any read of that value from that variable will be automatically assumed
to depend on that write.  But note that a read of the value 0 or a read
that does not specify the value read must have any dependencies manually
supplied, as the program cannot figure it out in these cases.

Memory barriers may be manually specified, for example in this expression
of the gist of Dekker's algorithm:

	1.1 w x 1
	1.2 mb
	1.3 r y 0
	2.4 w y 1
	2.5 mb
	2.6 r x 0

	1.3 -> 2.4
	2.6 -> 1.1

The lower-case "r" and "w" operations are unordered, so the "mb" full
memory barrier can be used to separate them.  The Linux-kernel memory
barriers (mb, rmb, and wmb), the cpp-threads memory barriers (acq and rel),
and the Itanium memory barriers (iacq and irel) may be specified.  Note
that the Itanium memory barriers do not make sense in isolation, but
instead must be attached to a pre-existing instruction as follows:

	1.1 w x 1
	1.1 iacq
	1.3 r y 0
	2.4 w y 1
	2.4 iacq
	2.6 r x 0

	1.3 -> 2.4
	2.6 -> 1.1

Note that the iacq instructions have the same statement number as
the preceding stores, which creates the attachment.  Attaching more
than one memory barrier to a given statement is an error.  Attaching
even one explicit memory barrier to an ordered statement ("A", "R",
or "W") is an error.


This tool supports other consistency models as well:

o	cccc2006-12 implements the December 2006 formulation of CCCC.
o	mlsc is a toy "minimal lock-supporting consistency" tool for
	expository purposes.  This respects chains of writes only
	through a single variable, as opposed to the more general
	chaining permitted by CCCC.
o	mbpc is "memory-barrier pairing consistency", which is similar
	to mlsc, but does not respect chains of writes, with the effect
	being to restrict cycle-checking to the accesses of pairs
	of tasks.  This is the documented semantics of Linux-kernel
	memory barriers as of the 2.6.19 kernel.
o	mesi is "modified-exclusive-shared-invalid", which is like mbpc,
	but does not respect dependencies on read statements, even if they
	were specified by hand (warnings are issued when such dependencies
	are specified).  The purpose of this model is to ensure that
	people working with other models understand how lucky they are.


=======  Legal Stuff ======

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

Copyright (c) 2007 Paul E. McKenney, IBM Corporation.
