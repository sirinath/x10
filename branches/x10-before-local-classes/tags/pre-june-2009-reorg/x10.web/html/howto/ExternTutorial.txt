Using the extern keyword: native libraries and X10

The extern keyword allows native C libraries to be called from X10 programs.  This howto
details how to code the interface to the native libraries, and some examples of creating them.

The reference implementation of X10 is implemented in java, and as such piggybacks on JNI.


Implementing C code for Externs
===============================

This section explains the mechanics behind support of the x10 'extern' keyword.

Simple usage of the keyword looks like:

class C {
  public static extern void foo();
  public static extern long doit(int x);
  public static extern long doit(float f,int i);
  };
  
  ...
  C.foo();          //-- (1)
  x = C.doit(12);   //-- (2)
  float f = ...
  y = C.doit(f,11); //-- (3)
  
  
  in some X10 program.  At the call points, the user will expect that a C routine with the
  format <ContainingClass> "_" <methodName> will be called  ie for foo, a C routine
  C_foo(void) would be called.
  
  The specification does not say what happens with overloaded methods, so I've taken the
  JNI approach of adding a suffix "__"+<signature> ie two '_' characters and a string
  of characters, one for each parameter, the mapping being the same as in JNI (e.g. V = void, J = long
  F = float, I= int etc).
  
  So, for the two overloaded methods doit, we'd expect
  C_doit__I
  and
  C_doit__FI
  
  The x10 compiler will produce C files with a suffix "_x10stub.c" for each of the classes containing
  an extern declaration.  These will contain the JNI calls wrapping the C calls the user expects.
  Within the X10 program, the java equivalent would create wrappers, and look like:
  --- java program---
  class C {
  public static native void C_foo();
  public static native long C_doit(int x);
  public static native long C_doit(float f,int i);
  public static  void foo() { C_foo();}
  public static  long doit(int x){ return C_doit(x);}
  public static  long doit(float f,int i){ return C_doit(f,i);}
  };
  
  A file called C_x10stub.c would be created, and it would look like:
  
 ---- file begins--- 
  *
 * Filename:C_x10stub.c
 * Generated: 1/11/05 7:34 PM */
/*Automatically generated -- DO NOT EDIT THIS FILE */
#include <jni.h>
#ifdef __cplusplus
extern "C" {
#endif

/* * * * * * * */
extern void C_foo();
JNIEXPORT void JNICALL
Java_C_C_1foo(JNIEnv *env, jobject obj){
   C_foo()
}

/* * * * * * * */
extern long C_doit__I(int x);
JNIEXPORT jlong JNICALL
Java_C_C_1foo__I(JNIEnv *env, jobject obj,jint x){
   return C_doit__I(x);
}

/* * * * * * * */
extern long C_doit__IF(float f,int i);
JNIEXPORT jlong JNICALL
Java_C_C_1foo__FI(JNIEnv *env, jobject obj,jfloat f ,jint i){
   return C_doit__FI(f,i);
}
#ifdef __cplusplus
}
#endif

--- file ends ---
  
  The Java_... methods are what the java JNI framework will call from the JVM, which in turn
  will call the user's routine.
  The user will have to create a dynamically linked library containing the stub files, and in addition call
  System.loadLibrary() to load this library.
  
  One future possibility is for the x10c script to automatically create a linked library containing
  just the stub files, and include it under the covers in any invocation of x10 programs.  The user will
  still have to provide a dll containing the implementation of their routines (and specify this dll to 
  x10).
  
  MORE COMPLICATED ISSUES
  There are curerntly two major issues identified when interfacing to native code.  First, 'long'
  variables,    secondly multiply dimensioned arrays.
  
  Longs:
    Long in java is different from a long in C or C++.  In java, a long is always 64 bits.  In C/C++,
    it's the 'natural' size of the architecture ie could be 32 or 64 bits.  So, on a 32 bit machine,
    passing a long to native code could easily lead to errors.  JNI has the same issue, and we solve
    the problem in the same way: we utilize the JNI typedefs found in jni.h for long, specifically
    jlong, which is typecast to a 64 bit type for all platforms.  Manipulating this value in native
    code may require some work, however, as arithmetic operators may or may not work, depending
    on compiler support.
  
  Arrays:
    The native code must know the layout in memory of any multidimensioned array passed from an x10 program.  Single dimension arrays are trivial
    to traverse, however with multiple-dimension arrays, the native code must know whether the arrays is row or column major, and the size of the row/column,
    in order to scale the indicies correctly.  In X10, all arrays are allocated in row-major order ie in C style.
    X10 generates array descriptors to help deal with this issue.  An array descriptor consists of an array of integers, where the first element (index 0) is the
    rank (number of dimensions) of the array.  Each subsequent element is the size of each dimension, from left to right.  An array descriptor is generated for each 
    array passed to a native routine, and is found immediately following the argument declaration for the array itself ie if the nth argument is an array, a
    descriptor will be generated as the n+1th, and all argument declarations shifted by one.
    
    
    Example of usage:
   class X{ ...
     final region R= [0:(N+3), 0:(N+1)];
     final distribution D = distribution.factory.block(R);
     
     ...
     static void extern Initialize(double[.] dbl a);
     ...
     void runit(){
        final double[D] a= new double unsafe[D];
     ...
        Initialize(a);
        ...
     }
     
     and corresponding C code:
     
     void X_Initialize(double arrPtr[],int a_descriptor[]){
       int i,j,rank,innerSize,outerSize;
       rank = a_descriptor[0];
       
       //Expecting 2-dimensional arrays
       if(rank != 2) {
          printf("Unexpected rank %d != 2\n",rank);
          return;
       }
       
       outerSize = a_descriptor[1]; //This will be  N+4
       innerSize = a_descriptor[2]; //This will be  N+2
       
       for(i=0;i<outerSize;++i)
         for(j=0;j<innerSize;++j)
            arrPtr[i*innerSize + j] = 0; /* scale by rowSize*/
      }
  
  
  LIMITATIONS:
  Currently extern method names with unicode characters are not handled properly.
  
  
  Creating Native Shared Libraries
  ================================
  This differs system to system, but in all cases the source code will be including jni.h, which
  is typically packaged along with your java installation.  
  
  The created shared library (aka dynamic linked library) must also be visible to the X10 runtime e.g. the
  directory containing the shared library could be specified by -Djava.library.path.
  
  Example of creating a native library on Windows XP, where java is installed in C:\Program Files\IBM\Java.
  
  (Note, this call is in a Cygwin environment)
  
  cl "-Ic:/Program Files/IBM/Java142/include" "-Ic:/Program Files/IBM/Java142/include/win32" -LD RandomAccess_longExternImpl.cpp -FeRandomAccessLong.dll
  
  AIX Example:
  xlC -I /work_jit/JVM/sdk142-20040626-GA/include -qmkshrobj -o libIntArrayExternUnsafe.so IntArrayExternUnsafeImpl.c
  
  Obviously the include path changes with the location of the jni.h header file.