\subsection{\Xten}
The \Xten{} language provides support for a non-SPMD style
functional-parallelism oriented programming. The unit of parallelism
in an \Xten{} program is an {\em activity}. The \Xten{} computation
starts with a single activity. Activities execute in {\em places}; a
single \Xten{} computation runs over many places, scattered over
multiple nodes in a cluster. Activities are resident in the place in
which they are created, and they can read and write data in the place
in which they run. The may also create new local data items. Data
items once created do not move. An activity can spawn other activities
to be executed in parallel in the current place or in other places.
All access to remote data is through activities and serialization of
remote objects.

An activity may also create a global data-structure, such as a global
array. Such a data-structure has state scattered across multiple
places. Operations on the data-structure may be invoked by an activity
in any place and typically result in computation across many places.

Of particular interest in \Xten{} are distributed arrays. These are
organized around a {\em region} -- a data-structure representing the
set of {\em points} over which the array is defined -- and a {\em
distribution}, a partitioning of the region over some subset of
places. Sometimes the programmer may wish to operate upon an array in
parallel using multiple activities within the same place; in this case
a {\em tiled region} may be used to divide the array up between these
activities. A tiled region is an array of regions. (In subsequent
versions of the language we intend to introduce hierarchically tiled
arrays.)

{}\Xten{} supports a notion of {\em immutable} data. Objects that are
immutable may may be freely copied from place to place by the
implementation and are hence not associated with a particular place.

In addition to the activity-based communication model, \Xten{}
supports libraries for efficient copying of sections of arrays from
one place to another.

Finally, \Xten{} supports a few constructs for coordinating multiple
activities. As noted above, an activity may spawn multiple activities
in the same place or in other places. Further it may wait until all
activities spawned during the course of execution of a statement have
(recursively) terminated, using the {\tt finish S}
construct. Activities may use {\em conditional atomic blocks} for
synchronization ({\tt when (c) S}). Such a block permits an activity
to wait until a specified condition {\tt c} is true, and then in one
atomic step execute the statements in {\tt S} (in the same state in
which {\tt c} is true). Conditional atomic blocks are a very simple
and powerful synchronization construct, and can be used to elegantly
implement all the usual concurrency coordination idioms
(producer/consumer synchronization, mutual exclusion, barrier
synchronization etc). Of particular interest in \Xten{} are {\em barriers}


Atomic blocks are supported, with implicit locking.