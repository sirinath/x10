%III. Applied constrained calculii. (3 pages)
%
%For each example below, formal static and dynamic semantics rules for
%new constructs extension over the core CFJ. Subject-reduction and
%type-soundness theorems. Proofs to be found in fuller version of
%paper.
%
%(a) arrays, region, distributions -- type safe implies no arrayoutofbounds
%exceptions, only ClassCastExceptions (when dynamic checks fail).
%
%Use Satish's conditional constraints example.
%-- emphasize what is new over DML. 
%
%(b) places, concurrency -- place types.
%
%(c) ownership types, alias control.
%

The following section presents examples using several different
constraint systems.

In the following we will use the shorthand $\tt C(\bar{t}:c)$ for the
type $\tt C(:\bar{f}=\bar{t},c)$ where the declaration of the class
{\tt C} is $\tt \class\ C(\bar{\tt T}\ \bar{\tt f}:c)\ldots$.  Also,
we abbreviate $\tt C(\bar{t}:\true)$ as $\tt C(\bar{t})$.  Finally, we
will also have need to use the shorthand ${\tt C}_1(\bar{t}_:{\tt
c}_1)\& \ldots {\tt C}_k(\bar{\tt t}_k:{\tt c}_k)$ for the type
${\tt C}_1(:\bar{\tt f}_1=\bar{\tt t}_1, \ldots, \bar{\tt
f}_k=\bar{\tt t}_k,{\tt c}_1,\ldots,{\tt c}_k$ 
provided that the ${\tt C}_i$ form a subtype chain
and the declared fields of ${\tt C}_i$ are ${\tt f}_i$.

Constraints naturally allow for partial specification
(e.g. inequalities) or incomplete specification (no constraint on a
variable) with the same simple syntax. In the example below,
the type of {\tt a} does not place any constraint on the second
dimension of {\tt a}, but this dimension can be used in other
types (e.g., the return type).
{\footnotesize
\begin{verbatim}
  class Matrix(int m, int n) {
    Matrix(m,a.n) mul(Matrix(:m=this.n) a) {...}
    ...
  }
\end{verbatim}}

Constraints also naturally permit the expression of existential types:
{\footnotesize
\begin{verbatim}
  class List(int length) { 
    List(:self.length <= length) filter(Comparator k) {...} 
    ...
  }
\end{verbatim}}
\noindent
Here, the length of the list returned by the "filter" method is 
unknown, but is bound by the length of the original list.

\subsection{X10}

\subsection{Self types and binary methods}

Self types~\cite{bsg95,bfp-ecoop97-match} can be implemented
using a {\tt klass} property on objects.  The {\tt klass}
property represents the run-time class of the object.
Self types can be used to solve the binary method problem \cite{bruce-binary}.

In the example below, the {\tt Set} interface has a "union" method
whose argument must be of the same class as {\tt this}.
\noindent This enables the {\tt IntSet} class's {\tt union}
method to access the {\tt bits} field of its argument {\tt s}.
{\footnotesize
\begin{verbatim}
  interface Set(:Class klass) {
    Set(this.klass) union(Set(this.klass) s);
  }
  class IntSet(:Class klass) implements Set(klass) {
    long bits;

    IntSet(IntSet.class)() { property(IntSet.class); }

    IntSet(IntSet.class)(int(:0 <= self, self <= 63) i) {
      property(IntSet.class);
      bits = 1 << i; }

    Set(this.klass) union(Set(this.klass) s) {
      IntSet(this.klass) r = new IntSet(this.klass);
      r.bits = this.bits | s.bits;
      return r; }
  }
\end{verbatim}}
\noindent
The key to ensuring that this code type-checks is the
\rn{T-constr}
rule.
With a constraint system ${\cal C}_{\mathsf{klass}}$ aware of
the {\tt klass} property, the rule 
\rn{T-var} is used to subsume an expression of type
${\tt Set(this.class)}$ to type ${\tt IntSet(this.class)}$
when {\tt this} is known to be an {\tt IntSet}:
{\footnotesize
\[
\from{\begin{array}{c}
{\tt IntSet}~{\tt this}, {\tt Set}({\tt this.klass})~{\tt s}
        \vdash {\tt Set}({\tt this.klass})~{\tt s} \\
{\tt IntSet}~{\tt this}, {\tt Set}({\tt this.klass})~{\tt s}
        \vdash_{{\cal C}_{\mathsf{klass}}} {\tt IntSet}({\tt this.klass})~{\tt s} \\
\end{array}}
\infer{
{\tt IntSet}~{\tt this}, {\tt Set}({\tt this.klass})~{\tt s}
        \vdash {\tt IntSet}({\tt this.klass})~{\tt s}}
\]}

\subsection{AVL trees and red--black trees}

AVL trees can be modeled so that the data structure invariant is
enforced statically.

{\footnotesize
\begin{verbatim}
class AVLList(int(:self >= 0) height) {...}
class Leaf(Object key) extends AVLList(0) {...}
class Node(Object key, AVLList l, AVLList r
         : int d=l.height-r.height; -1 <= d, d <= 1) 
    extends AVLList(max(l.height,r.height)+1) { ... }
\end{verbatim}}

Red/black trees may be modeled similarly. Such trees have the
invariant that (a) all leaves are black, (b) each non-leaf node has
the same number of black nodes on every path to a leaf (the black
height), (c) the immediate children of every red node are black.
{\footnotesize
\begin{verbatim}
class Tree(int blackHeight) {...}
class Leaf extends Tree(0) { int value; ...}
class Node(boolean isBlack, 
           Tree(:this.isBlack || isBlack) l, 
           Tree(:this.isBlack || isBlack,
                 blackHeight=l.blackHeight) r)
    extends Tree(l.blackHeight+1) { int value; ... }
\end{verbatim}}

\subsection{Bounds checks}

Xi and Pfenning proposed using dependent types for eliminating
array bounds checks~\cite{xi98array}.

In CFJ, an array of type {\tt T[]} indexed by (signed) integers
can be modeled as a class with the following
signature:\footnote{For this example, we assume the language supports generics.}
\begin{verbatim}
class Array<T>(int(:self >= 0) length) {
  T get(int(:0 <= self, self < this.length) i);
  void set(int(:0 <= self, self < this.length) i, T v);
}
\end{verbatim}

Constraint system based on Presburger arithmetic:
\begin{verbatim}
a ::= b < b | b = b
b ::= t | n | b*b | b+b
\end{verbatim}

Some code that iterates over an array (sugaring {\tt get} and {\tt set}):
\begin{verbatim}
double dot(double[] x, double[] y
         : x.length = y.length) {
  double r = 0.; 
  for (int(:self >= 0, self < x.length)
       i = 0; i < x.length; i++) {
    r += x[i] * y[i];
  }
  return r;
}
\end{verbatim}

\eat{
Another one:
\begin{verbatim}
double[](:length = x.length) saxpy(double a, double[] x, double[] y : x.length = y.length) {
    double[](:length = x.length) result = new double[x.length];
    for (int(:self >= 0, self < x.length) i = 0; i < x.length; i++) {
        result[i] = a * x[i] + y[i];
    }
    return result;
}
\end{verbatim}
}


\eat{
\subsection{Binary search}

An informal study by Jon Bentley~\cite{programming-pearls}
found that x\% of professional programmers attending in a course
could not correctly implement binary search.

Dependent types can help here by adding the invariants to the
index types.

\subsection{Quicksort}

\begin{verbatim}
int(:left <= self & self <= right)
partition(T[] array, int left, int right, int pivotIndex : left <= pivotIndex & pivotIndex <= right) {
     T pivotValue = array[pivotIndex];

     // Move pivot to end
     swap(array, pivotIndex, right);

     int(:left <= self & self <= right) storeIndex;
     storeIndex = left;
     for (int(:left <= self & self <= right-1) i = left; i < right; i++) {
         if (array[i] <= pivotValue) {
             swap(array, storeIndex, i);
             storeIndex++;
         }
     }

     // Move pivot to its final place
     swap(array, right, storeIndex)
     return storeIndex;
}

void swap(T[] array,
          int(:0 <= self & self < array.length i,
          int(:0 <= self & self < array.length j) {
    T tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
}

void quicksort(T[] array, int left, int right : left <= right) {
    if (left < right) {
         // select a pivot index
         int(:left <= self & self <= right) pivotIndex = (left + right) / 2;
         pivotNewIndex = partition(array, left, right, pivotIndex)
         quicksort(array, left, pivotNewIndex-1)
         quicksort(array, pivotNewIndex+1, right)
    }
}
\end{verbatim}
}

\subsection{Nullable types}

A constraint system that supports disequalities can be used to
enforce a non-null invariant on reference types.
A non-null type {\tt T} can be written simply as {\tt T(:self != null)}.

\subsection{A distributed binary tree}
This example is due to Satish Chandra. We wish to specify a balanced
distributed tree with the property that its right child is always at
the same place as its parent, and once the left child is at the same
place then the entire subtree is at that place:

{\footnotesize
\begin{verbatim}
class Tree(boolean localLeft,
  Tree(: this.localLeft => (loc=here,self.localLeft)) left, 
  Tree(: loc=here) right) extends Object { ...}
\end{verbatim}}

\subsection{Places}

% \begin{figure}
% \input{place}
% \end{figure}

\subsection{$k$-dimensional regions}

% \begin{figure}
% \input{region}
% \end{figure}

\subsection{Point}


% \begin{figure}
% \input{point}
% \end{figure}

\subsection{Distribution}


% \begin{figure}
% \input{dist}
% \end{figure}

\subsection{Arrays}

Following ZPL~\cite{ZPL}, arrays in X10
are defined over sets of $n$-dimensional {\em index points}
called {\em regions}~\cite{gps06-arrays}.
For instance, the region {\tt [0:200,1:100]} specifies a
collection of two-dimensional points {\tt (i,j)} with {\tt i}
ranging from {\tt 0} to {\tt 200} and {\tt j} ranging from
{\tt 1} to {\tt 100}.

Constrained types ensure array bounds
violations do not occur.
An array access type-checks if the index point can be statically
determined to be in the region over which the array is defined.

Region constraints have the following syntax:

\begin{tabular}{rrcl}
  (atom)   &{\tt a} &::=& ${\tt r} \subseteq {\tt r}$ \\
  (region) &{\tt r} &::=& ${\tt t} \bnf [{\tt b}_1:{\tt
  d}_1,\ldots,{\tt b}_k:{\tt d}_k] \bnf {}$  \\
           &        && ${\tt r} | {\tt r} \bnf {\tt r} \mbox{\tt \&} {\tt r} \bnf {\tt r} - {\tt r} \bnf {\tt r} + {\tt p}$ \\
  (point)  &{\tt p} &::=& ${\tt t} \bnf [{\tt b}_1,\ldots,{\tt b}_k]$ \\
(integer)&{\tt b},{\tt d} &::=& ${\tt t} \bnf {\tt n}$ \\
\end{tabular}

Constraints include subset constraints between regions.
Regions used in constraints are either constraint terms,
region constants, union ({\tt |}), intersection ({\tt \&}), and
set difference ($-$), or regions where each point is
shifted by a point ({\tt p}).

\eat{
Arrays have the following properties:
distribution rank region rect rail onePlace zeroBased

Regions:
rank rect zeroBased

Distributions:
rank region rect onePlace zeroBased

Points:
rank
}

\begin{figure*}
\input{sor}
\caption{Successive over-relaxation with regions}
\label{fig:sor}
\end{figure*}

For example, the code in Figure~\ref{fig:sor} performs a successive
over-relaxation~\cite{sor} of an $n \times n$ matrix {\tt G}.
The type-checker establishes that the {\tt region}
property of the point {\tt ij} (line 16) is
{\tt inner \& [i,i:d1min,d1max]}, and that this
region is a subset of {\tt outer}, the region of the array {\tt G}.

%\begin{figure}
%\input{array}
%\end{figure}

\subsection{Clocks}

Clock types

\subsection{Capabilities}

Capablities (from Radha and Vijay's paper on neighborhoods)

\subsection{Ownership types}

\begin{figure}
\input{LO}
\caption{Ownership types}
\label{fig:ownership}
\end{figure}

Figure~\ref{fig:ownership} shows
 a fragment of {\tt List} class, 
demonstrating how ownership
types~\cite{ownership-types} can be encoded in CFJ.
Each {\tt Owned} object has an {\tt owner} property.
Objects also have properties used as owner parameters.
The {\tt List} class has a property {\tt valOwner} that is
instantiated with the owner of the values in the list, stored
in the {\tt head} field of each element.
The {\tt tail} of the list is owned by the list object itself.

To enforce the ``owners as dominators'' property, the owner of
the values {\tt valOwner} must be contained within the owner
of the list itself; that is, {\tt valOwner} must be {\tt owner}
or {\tt valOwner}'s owner must be contained in {\tt owner}.
This is captured by the constraint {\tt owner contains valOwner}.

The {\tt expose} method incorrectly leaks the
list's {\tt tail} pointer.
The constraint system catches this XXX.

\subsection{Discussion}

\paragraph{Control-flow.}
Tricky to encode.  Need something like "pc" label~\cite{jif}.

\paragraph{Type state.}
Type state depends on the mutable state of the 
objects.  Cannot do in this framework.

Dependent types are of use in annotations~\cite{ns07-x10anno}.
