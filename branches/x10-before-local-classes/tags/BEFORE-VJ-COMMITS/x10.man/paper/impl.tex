%IV. Implementation (0.5 page)
%
%Specify what has been implemented and how. What is interesting about
%the implementation.

The dependent type system is implemented in the X10
compiler~\cite{X10}, which is implemented as an extension of
Java using the Polyglot compiler framework~\cite{ncm03}.

Polyglot implements a source-to-source base Java compiler 
that is extended to translate X10 to Java.  For purposes of this
paper, we ignore the additional statement and expression types
introduced in X10 and treat the language as simply Java
extended with constrained types.

Type-checking is implemented as two passes.  The first pass
performs type-checking using the base compiler implementation
augmented with additional code for new statement and expression
types introduced in X10. In this pass, expressions used in
dependent types are type-checked using the non-dependent type
system, however, no constraint solving is performed.
The second pass generates and solves constraints via an
ask--tell interface~\cite{my-thesis-book}.
If constraints cannot be solved, an error is reported.

After constraint checking, the X10 code is translated to Java.
The basic idea behind the translation is simple. Each dependent class
is translated into a single class of the same name without dependent
types). The explicit properties of the dependent class are translated
into {\tt public final} (instance) fields of the target class.
A {\tt property} statement in a constructor is translated to a
sequence of assignments to initialize the property fields.

For each property, there is also a getter method in the class.
Properties declared in interfaces are translated into getter
method signatures.  Subclasses implementing these interfaces
thus provide the required properties by implementing the
generated interfaces.

Usually, constraints are simply erased from the generated code.
However, dependent types may be used in casts
and {\tt instanceof} expressions.  These are translated to Java
in straightforward manner by evaluating the constraint with
{\tt self} bound to the expression being tested.
For examples, casts are translated as:
\eat{
\begin{code}
  $\Lb$e instanceof C(:c)$\Rb$ = 
    new Object() \{
      boolean check(Object o) \{
        if (o instanceof C) \{
          C self = (C) o;
          return $\Lb$c$\Rb$;
        \}
        return false;
      \}
    \}.check($\Lb$e$\Rb$)
\end{code}
}
\begin{code}
  $\Lb$(C(:c) e$\Rb$ = 
    new Object() \{
      C cast(C self) \{
        if ($\Lb$c$\Rb$)
          return self;
        throw new ClassCastException();
      \}
    \}.cast((C) $\Lb$e$\Rb$)
\end{code}



