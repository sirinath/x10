/*
 *
 * (C) Copyright IBM Corporation 2006
 *
 *  This file is part of X10 Test.
 *
 */
import x10.lang.Object;
import harness.x10Test;;

/**
* Building arrays distributed accross places using the encapsulation approach 
* (2D array of 2D arrays).
* @author Tong
  11/29/2006
*/
public class EncapsulatedArray2D_Dep extends x10Test /*
 *
 * (C) Copyright IBM Corporation 2006
 *
 *  This file is part of X10 Test.
 *
 */
import x10.lang.Object;
import harness.x10Test;

/**
* Building arrays distributed accross places using the encapsulation approach 
* (2D array of 2D arrays).
* @author Tong
  11/29/2006
*/
public class EncapsulatedArray2D_Dep extends x10Test {
	
	static value Wrapper{.{.{*
 *
 * (C) Copyright IBM Corporation 2006
 *
 *  This file is part of X10 Test.
 *
 */
import x10.lang.Object;
import harness.x10Test;

/**
* Building arrays distributed accross places using the encapsulation approach 
* (2D array of 2D arrays).
* @author Tong
  11/29/2006
*/
public class EncapsulatedArray2D_Dep extends x10Test {
	
	static value Wrapper{
		var m_array: Array[double];
		def this(var a_array: Array[double]): Wrapper = {
			m_array=a_array;
		}
	}
	
        public def run(): boolean = {
        	final val size: int = 5;
        	final val R: region{rank==2} = [0..size-1, 0..size-1];
        	final val D: dist{rank==2} = (dist{rank==2}))dist.factory.cyclic(R); //the casting here is not natural.
        	
        	final val A: Array[Wrapper]{rank==2} = new Array[Wrapper](D);
        	finish ateach (val (i,j): point in D) A(i, j)=new Wrapper(new Array[double](R));
        		
        	//for (int i=0;i<numOfPlaces;i++){	
        	finish ateach (val (i,j): point in D) { 
        		final val temp: Array[double]{rank==2} = (Array[double]{rank==2})A(i, j).m_array; 
        		for (val p: point in temp) temp(p)=i+j;
        	}
    	
	    return true;
	}
	
	public static def main(var args: Rail[String]): void = {
		new EncapsulatedArray2D_Dep().execute();
	}

}
