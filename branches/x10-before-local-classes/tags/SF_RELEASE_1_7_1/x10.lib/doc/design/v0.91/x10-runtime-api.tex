\section{\Xten\ RTS API Definition} \label{sec:runtime}

\subsection{Scenario}

Each \Xten\ place is executed in exactly one \Xten\ process. An \Xten\ place can
have multiple OS threads for activity computation. The \Xten\ runtime is invoked
using an {\tt initialize} routine and terminated using {\tt finalize} routine.
The \Xten\ runtime starts the execution of the application program in a boot
activity which acts as the global termination point for subsequent parallel
computations in the application program. 


Each \Xten\ place apart from having a bunch of OS threads, maintain a
Doubly-Ended Queue (Deque) of activities. Activities can be added on either-end
but can only be removed from the bottom. For the rest of our discussion, we
will assume the Deque to be unbounded.  

An activity can be ``blocking'' or ``non-blocking'' based on the kind of
operation it performs in its body. Note that {\tt atomic} 
constructs in our implementation are non-blocking; {\tt finish{}},{\tt force()}
and {\tt clock.next()} are blocking operations. During compiler analysis phase
if we can find an activity to be non-blocking, we will try and inline many of
such non-blocking activities as if they were sub-routine calls from their
respective parent activities. If inlining is not possible, we will annotate the
activity creation with non-blocking flags which can then be used by the runtime
for additional inlining option. {\it There may be some exception to the extent
of inlining -- for example {\tt foreach} construct iterating over a huge region
-- we may not want to get rid of intra-place parallelism completely if the body
of {\tt foreach} is non-blocking.} 

We define the term {\it finish-proxy} for an activity as follows: the finish
proxy for an activity is the activity containing the innermost finish scope.
All the application level activities which are not created within any finish
scope will have the boot activity as their finish-proxy.

The boot activity is resident at 0th Place and is immediately picked by OS
threads for computation. The boot activity can:

\begin{itemize}

\item Create a local child activity ({\tt async }): Using the compiler
annotations, if we can determine the child activity to be "non-blocking", we
can execute the body of the activity as if it were a sub-routine call.  If the
local child activity is blocking, the child activity is added to the bottom of
the deque at the local place. The parent activity continues its execution.

\item Create a remote child activity ({\tt async (P)}): The activity is added
to the top of the deque at the remote place. The parent activity continues
execution.

\item Executes {\tt finish} block: The parent activity marks itself as the
finish-proxy for any subsequent child activity created in the {\tt finish}
scope. The body of the {\tt finish} block is implemented using {\it
protothreads} and {\it co-routines} -- certain constraints exist (Look at
Sriram's design x10lib/docs/x10lib-design.pdf -- page 4). Any child remote
activity created within the body of the {\tt finish} block will have to report
its termination to its finish-proxy. Instead of sending individual
finish-notifications, we can club multiple termination reports for the same
place (optimizations possible).

\item Executes {\tt future-force} block: If the future block is targetted to
the local place and is non-blocking, we will inline the body of the future
block. Otherwise, the future block is implemented using {\it protothreads} and
{\it co-routine} as like {\tt finish}

\item Executes {\tt atomic} block: Use specialized non-blocking instructions on
SMP to implement {\tt atomic}.

\item Perform clock non-blocking operations: standard interfaces needed for
{\tt register}, {\tt drop}, {\tt resume}, {\tt isRegistered}.

\item Perform clock blocking operation ({\tt next}): Use similar technique of
{\it protothreads} and {\it co-routine} to perform suspend and enablement.
\end{itemize}

\subsection{Declaration and Initialization}

The \Xten\ runtime header for the translation:
\begin{itemize}
\item \begin{verbatim} <x10\_rts.h> \end{verbatim} 
This contains the description of all data structures for activities, places,
clocks, states, stack, activity deque, etc. and the {\tt extern} interfaces
mentioned below. Many of the interfaces have {\tt int} as return type for returning 
{\it error\_type\_t}.
\end{itemize}

\subsubsection{Activity Spawn}
Assumption: There exists an activity object with pointers to its place of execution.
\\
{\it \Xten\ syntax:}
\\
\begin{verbatim}
async (place) S;
\end{verbatim}
{\it C syntax:}
\begin{verbatim}
#include ``x10_rts.h''

int activity_dispatch (place_t place, activity_t child, activity_t parent, bool_t may_block, 
int (*activity_body_func_ptr)());
\end{verbatim}

{\it Description:} 
\\
The command is invoked from the parent activity. It decides either to inline
the child activity or not based on the flag {\tt may\_block}. If it decides not
to inline, it adds the body of the activity to the destination places deque
(local place -- bottom of deque; remote place -- top of deque).

\subsubsection{Activity Block}
{\it \Xten\ syntax:}
\begin{itemize}		 
\item \begin{verbatim} force \end{verbatim}
\item \begin{verbatim} next \end{verbatim}	
\item \begin{verbatim} finish \end{verbatim}
\end{itemize}

{\it C syntax:}
\begin{verbatim}
#include ``x10_rts.h''

int activity_block_start (place_t place, activity_t a, data_t block_data_structure);
int activity_block_stop (place_t place, activity_t a, data_t block_data_structure);
\end{verbatim}
{\it Description:}
Use the techniques of {\it protothreads} and {\it co-routines} to implement blocking semantics in X10.


\subsubsection{Activity Completes}

{\it C syntax:}
\begin{verbatim}
#include ``x10_rts.h''

int activity_finish (place_t place, activity_t a, activity_t innermost_finish_scope_activity};
\end{verbatim}
{\it Description:}
Send a finish notification to the finish-proxy. Propagate
any exception.



\subsubsection{Clock Registration}

{\it \Xten\ syntax:}
\\
\begin{itemize}
\item \begin{verbatim} new clock() \end{verbatim}
\item \begin{verbatim} async (place) clocked c1,c2 S; \end{verbatim}
\end{itemize}
{\it C syntax:}
\begin{verbatim}
#include ``x10_rts.h''

int register_clock (activity_t a, clock_t *c);
bool is_registered (activity_t a, clock_t *c;
\end{verbatim}

{\it Description:}
Register the activity with the set of clocks if not already done. Note that
the clock objects are already created.

\subsubsection{Clock Deregistration}

{\it \Xten\ syntax:}
\\
\begin{itemize}
\item \begin{verbatim} c1.drop() \end{verbatim}
\end{itemize}
{\it C syntax:}
\begin{verbatim}
#include ``x10_rts.h''

int deregister_clock (activity_t a, clock_t *c);
\end{verbatim}

{\it Description:}
Deregister the activity with the set of clocks explicitly. 

\subsubsection{Clock Resume}

{\it \Xten\ syntax:}
\\
\begin{itemize}
\item \begin{verbatim} c1.resume() \end{verbatim}
\end{itemize}
{\it C syntax:}
\begin{verbatim}
#include ``x10_rts.h''

int resume_clock (activity_t a, clock_t *c);
\end{verbatim}

{\it Description:}
Resumption on a set of clocks for an activity.

\subsubsection{Clock quiescence}

{\it \Xten\ syntax:}
\\
\begin{itemize}
\item \begin{verbatim} next() \end{verbatim}
\end{itemize}
{\it C syntax:}
\begin{verbatim}
#include ``x10_rts.h''

int next_phase_clock (activity_t a, clock_t *c);
\end{verbatim}

{\it Description:}
Perform clock quiescence using the blocking technique described above.

