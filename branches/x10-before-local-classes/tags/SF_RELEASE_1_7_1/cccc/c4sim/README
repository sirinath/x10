%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% c4sim, a CCCC simulator
%
% Author:     Tom Schrijvers
% E-mail:     Tom.Schrijvers@cs.kuleuven.ac.be
% Copyright:  2007, K.U.Leuven
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Requirements:
-------------

 * SWI-Prolog (www.swi-prolog.org)
 * Graphviz (www.graphviz.org) [optional]

Installation:
-------------

On Windows use as is, from batch file.

On Linux

	$ make all

generates stand-alone executable c4sim.

Syntax:
-------

	init var1 = value;
	...

	thread {
	  label : var2 = value;
	  label : localvar = var3;
	  ...
	} |
	... 
	|
	thread {
	...
	} 

	dependency {
	  label1 -> label2;
	  ...
	}


Rules (Doug Lea's CCCC rules)
-----

NOTATION:

G = (S,<<) is a set of nodes S and a binary (directed) relation << on
   the nodes. Nodes are of type:
     e ranges over read and write events,
     r over read events and
     w over write events.
G is a partial order if << is transitive and irreflexive.
G is a total order if << is a partial order and for any two
     distinct nodes a and b in S, either a << b or b << a.
G | T is graph G restricted to subset T; that is, the graph with nodes
     in T and with a << b in T iff a << b in S.
G* is the transitive closure of graph G.
'u' is set union

p(e) is the processor which executed event e,
E(p) is the set of events executed by processor p.
W(x) is the set of all write events on variable x
W    is the set of all write events (across all variables)
w(S) is set S together with all elements of W with an edge into or out of S.

RULES:

An execution is a graph G=(S, <<) over a set of events S satisfying:

[Write Serialization]
  For each variable x, G | W(x) is a total order, with minimal
  element w0 setting x to 0.

[Freshness]
  For every read r of x, min(W(x)) << r and G | (W(x) u {r}) is a
  total order.

[Causal Propagation]
  e << e'' if there is an e' in E(p(e)) u E(p(e'')) st e << e' << e'' .

[Local Consistency]
  For all processors i, (G | w(E(i))* is a partial order (i.e., is acyclic)
  Additionally, volatiles obey local program order:
    For all processors p, G | E(p) is a total order.

Use:
----

From source (windows) (this has not been tested yet, feedback is welcome):

	$ winc4sim.bat [-dot] file

With stand-alone executable (linux):

	$ c4sim [-dot] file


The -dot option generates a .dot file for every possible linking.
The .dot files are in the Graphviz (www.graphviz.org) dot format,
i.e. can be visualized automatically by the Graphviz dot tool in
any of its output formats (ps,jpeg,...).

If the -dot option is omitted, all data for every solution is dumped to
standard output.



E.g.

 * independent read, independent write, 1 solution:

	$ cat examples/iriw.c4
	init x = 0;
	init y = 0;
	
	thread {
		1 : x = 1;
	} |
	thread {
		2 : y = 1;
	} |
	thread {
		3.1 : r1 = x;
		3.2 : r2 = y;
	} |
	thread {
		4.1 : r3 = y;
		4.2 : r4 = x;
	}
	
	dependency {
		1 -> 3.1;
		3.2 -> 2;
		2 -> 4.1;
		4.2 -> 1;
	}

	$ ./c4sim -dot examples/iriw.c4
	--------------------------------------------------------------------------------
	writing examples/iriw1.dot
	--------------------------------------------------------------------------------
	1 solutions found.

	$ cat examples/iriw1.dot
	digraph G {
		ranksep=1;
		nodesep=1;
		subgraph clusterthread4 {
			label = "thread4";
			4.2;
			4.1;
		}
		subgraph clusterthread3 {
			label = "thread3";
			3.2;
			3.1;
		}
		subgraph clusterthread2 {
			label = "thread2";
			2;
		}
		subgraph clusterthread1 {
			label = "thread1";
			1;
		}
		subgraph clusterinit {
			label = "init";
			init2;
			init1;
		}
		init2 [label="init2 : init y = 0 ; "];
		init1 [label="init1 : init x = 0 ; "];
		2 [label="2 : y = 1 ; "];
		1 [label="1 : x = 1 ; "];
		4.2 [label="4.2 : r4 = x ; (0)"];
		4.1 [label="4.1 : r3 = y ; (1)"];
		3.2 [label="3.2 : r2 = y ; (0)"];
		3.1 [label="3.1 : r1 = x ; (1)"];
		3.1 -> 3.2;
		4.1 -> 4.2;
		1 -> 3.1;
		1 -> 3.2;
		3.2 -> 2;
		3.1 -> 2;
		2 -> 4.1;
		2 -> 4.2;
		4.2 -> 1;
		4.1 -> 1;
		init1 -> 1;
		init1 -> 4.2;
		init2 -> 2;
		init2 -> 3.2;
	}

	$ dot -Tjpg examples/iriw1.dot -o examples/iriw1.jpg

 * Dekker example, overconstrained, so no solutions:

	$ cat examples/dekker.c4
	init x = 0;
	init y = 0;
	
	thread {
	        1.1 :   x = 1;
	        1.2 :   r1 = y;
	} |
	thread {
	        2.1 :   y = 1;
	        2.2 :   r2 = x;
	}
	
	dependency {
	        1.2 -> 2.1;
	        2.2 -> 1.1;
	}

	$ ./c4sim examples/dekker.c4
	Inconsistency: no solutions!

 * Dekker example, underconstrained, so multiple solutions:

	$ cat examples/dekker_good.c4
	init x = 0;
	init y = 0;
	
	thread {
	        1.1 :   x = 1;
	        1.2 :   r1 = y;
	} |
	thread {
	        2.1 :   y = 1;
	        2.2 :   r2 = x;
	}
	
	dependency {
	}


	$ ./c4sim examples/dekker_good.c4
	--------------------------------------------------------------------------------
	event(2.2, thread2, read, r2, x)
	event(2.1, thread2, write, y, 1)
	event(1.2, thread1, read, r1, y)
	event(1.1, thread1, write, x, 1)
	event(init2, init, init, y, 0)
	event(init1, init, init, x, 0)
	init2<<2.2
	init2<<2.1
	2.2<<1.2
	2.1<<1.2
	2.1<<1.1
	2.2<<1.1
	init1<<2.2
	init1<<1.2
	init1<<1.1
	2.1<<2.2
	1.1<<1.2
	local_label(init, 2.1)
	local_label(thread2, 1.1)
	local_label(thread1, 2.1)
	local_label(init, 1.1)
	local_label(thread2, 2.2)
	local_label(thread2, 2.1)
	local_label(thread1, 1.2)
	local_label(thread1, 1.1)
	local_label(init, init2)
	local_label(init, init1)
	local_po(init, init2, 1.1)
	local_po(init, init2, 2.1)
	local_po(init, 2.1, 1.1)
	local_po(thread2, 2.2, 1.1)
	local_po(thread2, 2.1, 1.1)
	local_po(thread1, 2.1, 1.1)
	local_po(thread1, 2.1, 1.2)
	local_po(init, init1, 1.1)
	local_po(thread2, 2.1, 2.2)
	local_po(thread1, 1.1, 1.2)
	read_value(1.2, 1)
	read_value(2.2, 0)
	--------------------------------------------------------------------------------
	event(2.2, thread2, read, r2, x)
	event(2.1, thread2, write, y, 1)
	event(1.2, thread1, read, r1, y)
	event(1.1, thread1, write, x, 1)
	event(init2, init, init, y, 0)
	event(init1, init, init, x, 0)
	1.2<<2.2
	1.1<<2.1
	1.2<<2.1
	init2<<1.2
	init2<<2.2
	init2<<2.1
	1.1<<2.2
	init1<<1.2
	init1<<1.1
	2.1<<2.2
	1.1<<1.2
	local_label(thread1, 2.1)
	local_label(init, 2.1)
	local_label(thread2, 1.1)
	local_label(init, 1.1)
	local_label(thread2, 2.2)
	local_label(thread2, 2.1)
	local_label(thread1, 1.2)
	local_label(thread1, 1.1)
	local_label(init, init2)
	local_label(init, init1)
	local_po(init, init1, 2.1)
	local_po(init, 1.1, 2.1)
	local_po(thread2, 1.1, 2.1)
	local_po(thread1, 1.2, 2.1)
	local_po(thread1, 1.1, 2.1)
	local_po(init, init2, 2.1)
	local_po(thread2, 1.1, 2.2)
	local_po(init, init1, 1.1)
	local_po(thread2, 2.1, 2.2)
	local_po(thread1, 1.1, 1.2)
	read_value(1.2, 0)
	read_value(2.2, 1)
	--------------------------------------------------------------------------------
	event(2.2, thread2, read, r2, x)
	event(2.1, thread2, write, y, 1)
	event(1.2, thread1, read, r1, y)
	event(1.1, thread1, write, x, 1)
	event(init2, init, init, y, 0)
	event(init1, init, init, x, 0)
	2.1<<1.2
	init2<<2.2
	init2<<2.1
	1.1<<2.2
	init1<<1.2
	init1<<1.1
	2.1<<2.2
	1.1<<1.2
	local_label(thread1, 2.1)
	local_label(init, 2.1)
	local_label(thread2, 1.1)
	local_label(init, 1.1)
	local_label(thread2, 2.2)
	local_label(thread2, 2.1)
	local_label(thread1, 1.2)
	local_label(thread1, 1.1)
	local_label(init, init2)
	local_label(init, init1)
	local_po(thread1, 2.1, 1.2)
	local_po(init, init2, 2.1)
	local_po(thread2, 1.1, 2.2)
	local_po(init, init1, 1.1)
	local_po(thread2, 2.1, 2.2)
	local_po(thread1, 1.1, 1.2)
	read_value(1.2, 1)
	read_value(2.2, 1)
	--------------------------------------------------------------------------------
	3 solutions found.
