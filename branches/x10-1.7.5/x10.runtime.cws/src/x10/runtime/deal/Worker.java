package x10.runtime.deal;

/*
*
* (C) Copyright IBM Corporation 2007
*
*  This file is part of X10 runtime. It is 
*  governed by the licence under which 
*  X10 is released.
*
*/


public class Worker extends Thread {
	public static boolean reporting=false;
	public static Worker[] workers;
	
	public final Pool pool;
	public final int poolSize;
	public final int index;
	public final Barrier barrier;
	protected int phaseNum=0;
	protected boolean done;
	protected boolean isActive;
	protected String name;
	/**
	 * We use a red/black scheme to read and write tasks. In the current
	 * phase, use dealtTasks[phaseNum%2] to read tasks to be executed and
	 * dealtTasks[phaseNum+1%2] to deal tasks to be executed in the next phase.
	 */
	protected  final Executable[] redTasks, blackTasks;
	/**
	 * Count of tasks generated by this worker to be executed in the next phase.
	 */
	protected int nextTasks=0;
	public Worker(Pool pool, int index) {
		this.pool=pool;
		this.index = index;
		this.poolSize = pool.workers.length;
		this.barrier = pool.barrier;
		//this.dealtTasks = new Executable[2][poolSize];
		this.redTasks = new Executable[poolSize];
		this.blackTasks = new Executable[poolSize];
		
		this.nextTasks=0;
		setDaemon(true);
		this.name = "Worker " + index;
	}
	
	/**
	 * Return the task in this worker's task arrays for
	 * the worker with index index.
	 * @param index -- index of worker requesting task.
	 * @return task, if any, assigned by this worker to the index'th worker.
	 */
	protected Executable getTask(int i, int p) {
		assert ((Worker) Thread.currentThread()).index==i;
		Executable[] target = target(p);
		Executable result = target[i];
		return result;
	}
	protected Executable[] target(int phase) {
		return (phase & 1) == 1 ? redTasks : blackTasks;
	}
	protected Executable getAndNullTask(int i, int p) {
		assert ((Worker) Thread.currentThread()).index==i;
		Executable[] target = target(p);
		if (reporting) 
			System.err.println(workers[i] + " looking for work in " 
					+ "Worker " + index + (target == redTasks ?  ".red[" : ".black[" ) + 
					 i + "].");
		Executable result = target[i];
		target[i]=null;
		if (result != null)
			if (reporting) 
				System.err.println(workers[i] + " found work " + result + " from " 
						+ (target == redTasks ? "red[" : "black[" ) + 
						 i + "]");
		return result;
	}
	
	protected int next;
	/**
	 * Called by application code to deal a task to some worker
	 * for the next phase.
	 * @param e
	 */
	public void dealTask(Executable e) { 
		int i = nextIndex();
		dealTask(i, e); 
	}
	protected int nextIndex() {
		if (++next >= poolSize) next=0;
		return next;
	}
	public int phaseNum() {
		return phaseNum;
	}
	int randNext;
	protected void setRandSeed(int seed) {
		randNext = seed;
	}
	protected int rand() {
		randNext = randNext*1103515245  + 12345;
		int result = randNext >> 16;
		if (result < 0) result = -result;
		return result;
	}
	/**
	 * Intended to be called by this worker.
	 * @param index
	 * @param e
	 */
	public void dealTask(int i, Executable e) {
		assert (i >=0 && i < poolSize);
		assert e.next()==null;
		nextTasks++;
		Executable[] target = target(phaseNum+1);
		e.setNext(target[i]);
		target[i] = e;
	
			if (reporting) 
				System.err.println(this + " deals work " + e + " to " 
						+ (target == redTasks ? "red[" : "black[" ) + 
						 i + "]");
	}
	boolean isActive() {
		return isActive;
	}
	static class AdvancePhaseException extends Exception{}
	protected void doWork() {
		//Executable[] target  = target(phaseNum+1);
		//for (int i=0; i < target.length; ++i) target[i]=null;
		for (Worker w : workers) {
			Executable e = w.getAndNullTask(index, phaseNum);
			while (e != null) {
				try {
					e.compute(this);
				} catch (AssertionError z) {
					System.err.println(this + ": continuing after assertion error while executing " + e);
					z.printStackTrace();
					throw z;
				}
				e=e.next();
			}
		} 
	}
	public void run() {
		
		while (! done) {
			//setJob(pool.currentJob);
			boolean completed = false;
			try {
				if (reporting)
					System.err.println(this + " completes work in phase " + phaseNum);
				isActive=false;
				completed=barrier.arrive(this,phaseNum, nextTasks);
				//assert phaseNum+1 == barrier.phaseNum;
				phaseNum = barrier.phaseNum;
				nextTasks=0;
				next = rand() % poolSize;
				if ( reporting)
					System.err.println(this + " enters phase " + phaseNum);
				isActive=true;
			} catch (AdvancePhaseException z) {
				throw new RuntimeException(z);
			}
			if (completed) {
				Job job = pool.getJob();
				if (reporting)
					System.out.println(this + " has received job " + job);
				barrier.awakenOthers();
				if (job==null) break;
				else {
					if (reporting)
						System.err.println(this + " starts working in phase " + phaseNum);
					job.compute(this);
				}
			} else {
				if (phaseNum==0 && pool.currentJob==null) // no more work to do
					break;
				if ( reporting)
					System.err.println(this + " starts working in phase " + phaseNum);
				doWork();
			}
		}
		if (reporting)
			System.out.println(this + " terminates.");
		
	}
	public String toString() { return "Worker[" + index + "," + phaseNum+"]";}
	
}