#include "cilk.h"
#include "cilk-lib.cilkh"
#include <stdio.h>
#include <stdlib.h>
#include "graph.h"

volatile int * color;
volatile int * bufferRed, *bufferBlack, *label, *localBufferSizeRed,*localBufferSizeBlack;
volatile int bufferSize;
//Cilk_lockvar * lock;
Cilk_lockvar lock;

/*Nov 7,03: the previous random graph generator may create repeated edges between two vertices, fixed*/
/*Jun 4, 04: m 's value can be changed as we add edges to make it a connected graph*/
/*Aug 17, 07: BSF added by Tong Wen @ IBM*/
V* r_graph(int n,int m)
{
    int i,j,v1,v2,v,top,tail,r;
    E *L;
    char * color;
    int * * M;
    int * D,*info,*stack;
    V* graph;

    L=(E *) malloc(sizeof(E)*m);
    j=0; 
    for(i=0;i<m;i++)
     {
	v1=(int)(drand48()*n)%n;
	v2=(int)(drand48()*n)%n;
	while(v2==v1) v2=(int)(drand48()*n) %n;
        L[j].v1=v1;
	L[j++].v2=v2;
     } 
    printf(" number of edges got is %d\n",j);

    M = malloc(sizeof(int *)*n);
    D = malloc(sizeof(int)*n);

    for(i=0;i<n;i++) D[i]=0;

    for(i=0;i<m;i++) {
	D[L[i].v1]++;
	D[L[i].v2]++;
    }

    for(i=0;i<n;i++) {
	M[i]=malloc(sizeof(int)*(D[i]+2)); /*+2 leaves space for making connected*/
    }
    printf("finished allocating structures\n");

    for(i=0;i<n;i++) D[i]=0;

    for(i=0;i<m;i++)
    {
		r=0;
		for(j=0;j<D[L[i].v1];j++)
			if(L[i].v2==M[L[i].v1][j]) r=1; 
		if(r==1) continue;
		
		M[L[i].v1][D[L[i].v1]]=L[i].v2;
        M[L[i].v2][D[L[i].v2]]=L[i].v1;
        D[L[i].v1]++;
        D[L[i].v2]++;
    }   
    free(L);
    printf("finished generating the matrix\n");
    printf("checking if is connected\n");
    printf("n is %d\n",n);
    color = malloc(sizeof(char)*n);
    stack = malloc(sizeof(int)*n);
    info  = malloc(sizeof(int)*n);
    
    if(!color || ! stack || ! info ){
      printf("error allocating memory\n");
      exit(0);
    }

    for(i=0;i<n;i++)  color[i]=0;
    top=-1;
    tail=0;
    
    for(i=0;i<n;i++)
    {
      if(color[i]==1) continue;
      else info[tail++]=i;
      
      stack[++top]=i;
      color[i]=1;
      while(top!=-1) {
      v = stack[top];
      top--;
     
      for(j=0;j<D[v];j++)
        if(color[M[v][j]]==0){
	         top++;
		 stack[top]=M[v][j];
		 color[M[v][j]]=1;
         }
      }
    }

    printf("checking done,tail is %d\n",tail);
    for(i=0;i<tail-1;i++)
    {
       M[info[i]][D[info[i]]++]=info[i+1];
       M[info[i+1]][D[info[i+1]]++]=info[i];
    } 
    	
   graph = (V*)malloc(n *sizeof (V));
   if(graph==NULL)
   {
        printf("1 mem alloc error\n");
        return (NULL);
   }
   for(i=0;i<n;i++)
   {
        /*there should be n neighbors for this vertex*/
		/*graph[i].self=i;*/
 		graph[i].n_neighbors=D[i];
        graph[i].my_neighbors=(int *)malloc(D[i]*sizeof(int));
		/*graph[i].is_tree_edge=(int *)malloc(D[i]*sizeof(int));*/
        if(graph[i].my_neighbors==NULL) {
                printf("2 mem alloc error\n");
                return(NULL);
        }
        for(j=0;j<D[i];j++)
        {
            graph[i].my_neighbors[j]=M[i][j];
	   /* graph[i].is_tree_edge[j]=0; */
        }
   }

    printf("done generating graph structure\n");
    for(i=0;i<n;i++)
     free(M[i]);
    free(M);
    free(D);   
    free(stack);
    free(info);
    free(color); 
    return(graph);
 }

V* torus(int k)
{
  int *Buff;
  int ** Adj;
  int i,j,l,s; 
  V* graph;
  int n = k*k; 
  
  Buff = malloc(sizeof(int)*n);
  Adj  = malloc(sizeof(int*)*n);
  for(i=0;i<n;i++) Adj[i]=malloc(sizeof(int)*4);

#if 1
  for(i=0;i<n;i++) Buff[i]=i;

  for(i=0;i<n/2;i++){
	l=(int)(drand48()*n)%n;
 	s=(int)(drand48()*n)%n;
	j=Buff[l];
	Buff[l]=Buff[s];
	Buff[s]=j;
  }
	
  for(i=0;i<k;i++)
    {
      for(j=0;j<k;j++)
	{
	  Adj[Buff[i*k+j]][0]= Buff[((k+i-1)%k)*k+j];
	  Adj[Buff[i*k+j]][1]= Buff[((i+1)%k)*k+j];
	  Adj[Buff[i*k+j]][2]= Buff[i*k+((k+j-1)%k)];
	  Adj[Buff[i*k+j]][3]= Buff[i*k+((j+1)%k)];
	}
  
    }	
#endif


#if 0

	for(i=0;i<k;i++)
    {
      for(j=0;j<k;j++)
	{
	  Adj[i*k+j][0]= ((k+i-1)%k)*k+j;
	  Adj[i*k+j][1]= ((i+1)%k)*k+j;
	  Adj[i*k+j][2]= i*k+((k+j-1)%k);
	  Adj[i*k+j][3]= i*k+((j+1)%k);
	}
  
    }
	
#endif
	  
   graph = (V*)malloc(n *sizeof (V));
   if(graph==NULL)
   {
        printf("1 mem alloc error\n");
        return (NULL);
   }
   for(i=0;i<n;i++)
   {
        /*there should be n neighbors for this vertex*/
		/*graph[i].self=i;*/
 		graph[i].n_neighbors=4;
        graph[i].my_neighbors=(int *)malloc(4*sizeof(int));	
	/*graph[i].is_tree_edge=(int *)malloc(4*sizeof(int));*/	
        if(graph[i].my_neighbors==NULL) {
                printf("2 mem alloc error\n");
                return(NULL);
        }
        for(j=0;j<4;j++)
        {
            graph[i].my_neighbors[j]=Adj[i][j];
	    /*graph[i].is_tree_edge[j]=0;*/
        }
   }
  
  for(i=0;i<n;i++) free(Adj[i]);
  free(Adj);
  free(Buff);
  return(graph);

 }


V* k_graph(int n, int k)
{
  int neighbor;
  char * visited;
  int * stack,*super;
  int i,j,u,v,nextn,top=-1,n_comp=0,rep,s;
  int ** array,*counter; 
  V* graph;
  
  int TIMES=3;
  int THRESHOLD=100;

  array = malloc(sizeof(int *)*n);
  visited = malloc(sizeof(char)*n);
  counter = malloc(sizeof(int )*n);

  if(array==NULL || visited==NULL || counter==NULL) 
    {
      printf("not enough mem\n");
      exit(-1);
    }

  for(i=0;i<n;i++)
  {
    array[i]=malloc(sizeof(int)*k*TIMES);
    if(array[i]==NULL) { 
      printf("not enough mem\n");
      exit(-1);
    }
    counter[i]=0;
    visited[i]=0;
  }

 
  stack = malloc(sizeof(int)*(n)/2);
  super = malloc(sizeof(int)*(n)/2);
  
  if(stack==NULL || super==NULL)
    {
      printf("not enough mem\n");
      exit(-1);
    }

  for(i=0;i<n;i++)
  {
     for(j=counter[i];j<k;j++)
     {
     	if(i<n-THRESHOLD)
       		neighbor=(int)(drand48()*(n-i))%(n-i)+i;
       	else neighbor=(int)(drand48()*THRESHOLD)%(THRESHOLD);
		rep=0;
		for(s=0;s<counter[i];s++) 
	   		if(array[i][s]==neighbor) rep=1;
		while(rep==1)
		{
			rep=0;
			if(i<n-THRESHOLD)
       			neighbor=(int)(drand48()*(n-i))%(n-i)+i;
       		else neighbor=(int)(drand48()*THRESHOLD)%(THRESHOLD);
			for(s=0;s<counter[i];s++) 
	   			if(array[i][s]==neighbor) rep=1;
		}
#if 0
        neighbor=rand()%(n-i)+i;
       else neighbor=rand()%THRESHOLD;
#endif
	while(counter[neighbor]>TIMES*k-1 || neighbor==i) neighbor=(neighbor+1)%n;
        array[i][counter[i]]=neighbor;
        counter[i]++;
        array[neighbor][counter[neighbor]]=i;
        counter[neighbor]++;
     }
  }

  printf("check if it is connected\n");

  /* now make the graph connected if it is not*/
  for(i=0;i<n;i++)
    {
      if(!visited[i]){
	visited[i]=1;
	stack[++top]=i;
	super[n_comp++]=i;

	while(top!=-1)
	  {
	    v = stack[top];
	    top--;

	    for (j=0; j<counter[v]; j++) {
	      nextn = array[v][j];
	      if(!visited[nextn]) {  /* not seen yet */
		visited[nextn]=1;
		stack[++top]=nextn;
	      }
	    }
	  }
      }
    }
  
  for(i=1;i<n_comp;i++)
    {
      u = super[i];
      v = super[i-1];
      array[u][counter[u]++]=v;
      array[v][counter[v]++]=u;
    }
  
   graph = (V*)malloc(n *sizeof (V));
   if(graph==NULL)
   {
        printf("1 mem alloc error\n");
        return (NULL);
   }
   for(i=0;i<n;i++)
   {
        /*there should be n neighbors for this vertex*/
		/*graph[i].self=i;*/
 		graph[i].n_neighbors=counter[i];
        graph[i].my_neighbors=(int *)malloc(counter[i]*sizeof(int));
		/*graph[i].is_tree_edge=(int *)malloc(counter[i]*sizeof(int));*/
        if(graph[i].my_neighbors==NULL) {
                printf("2 mem alloc error\n");
                return(NULL);
        }
        for(j=0;j<counter[i];j++)
        {
            graph[i].my_neighbors[j]=array[i][j];
	/*graph[i].is_tree_edge[j]=0;*/
        }
   }

  for(i=0;i<n;i++) free(array[i]);
  free(array);
  free(counter);
  free(stack);
  free(super);
  free(visited);
  return(graph);
}

cilk void traverse(V* G,int r)
{
   int i,v;
 
   for(i=0;i<G[r].n_neighbors;i++)
   {
      v = G[r].my_neighbors[i];
      if(Cilk_xchg(&color[v],1)==0) {
	 color[v]=1;
	 spawn traverse(G,v);
      }
   }
}

cilk void ST(V* G,int n)
{
    spawn traverse(G,0);
    sync;
}
/* bufferRed, bufferBlack, bufferSize, and label are global data structures */
/*
cilk void findChildren(V *G, int idx, int lbl, int n_vertices){
	volatile int *bufferA, *bufferB;
	int i,j,k,l, tempSize =0;
	int * temp;
	
	if (lbl%2 == 1){
		bufferA = bufferRed; bufferB = bufferBlack;
	}else{
		bufferA = bufferBlack; bufferB = bufferRed;
	}
	k= G[bufferA[idx]].n_neighbors;
	//temp  = Cilk_alloca(sizeof(int)*k);
	for (i = 0; i < k; i++){
		j = G[bufferA[idx]].my_neighbors[i];
		if (label[j] == n_vertices){ //not labeled
			label[j] = lbl;
			//temp[tempSize++]=j; 
			//l = bufferSize;
			Cilk_lock(lock);bufferB[bufferSize++] = j;Cilk_unlock(lock);
		}
	}
	//printf("copy buffer %d %d \n",k, tempSize); 
	//Cilk_lock(lock);
	//for (i =0; i<tempSize; i++)
		//bufferB[bufferSize++] = temp[i];
	//Cilk_unlock(lock);
}

cilk void BSF(V* G, int n_vertices, int root){

	int level = 0, i, size;
	bufferSize = 1;
	bufferRed[0] = root;
	label[0] = level;
	size = bufferSize;
	
	while(size > 0){
		bufferSize = 0;
		level++;
		for (i =0; i < size; i++) 
			spawn findChildren(G, i, level, n_vertices);
		sync;
		size = bufferSize;
		printf("BSF bufferSize = %d \n", size);		
	}
	
}
*/
cilk void findChildren(V *G, int idxA, int lbl, int n_vertices, int idxB, int levelSize  ){
	volatile int *bufferA, *bufferB, *localBufferSizeB;
	int i,j,k,l;
	int startIdx, stride;
	stride = bufferSize/levelSize;
	startIdx = idxB*stride;
	l = startIdx;
	if (lbl%2 == 1){
		bufferA = bufferRed; bufferB = bufferBlack;
		localBufferSizeB = localBufferSizeBlack;
	}else{
		bufferA = bufferBlack; bufferB = bufferRed;
		localBufferSizeB = localBufferSizeRed;
	}
	k= G[bufferA[idxA]].n_neighbors;
	//printf("k= %d \n", k);
	for (i = 0; i < k; i++){
		j = G[bufferA[idxA]].my_neighbors[i];
		if (label[j] == n_vertices){ //not labeled
			label[j] = lbl;
			bufferB[l++] = j;
		}
	}
	localBufferSizeB[idxB] = l-startIdx;
}

cilk void BSF(V* G, int n_vertices, int root){
	volatile int *localBufferSizeA, * localBufferSizeB;
	int level = 0, i, j, k, size, sizeOld, startIdx, stride, idx, localSize;
	bufferRed[0] = root;
	label[0] = level;
	size = 1; sizeOld = 1;
	localBufferSizeRed[0] = 1;
	while(size > 0){
	//for (k=0; k<3; k++){
		level++;
		if (level%2 == 1){
			localBufferSizeA = localBufferSizeRed; localBufferSizeB = localBufferSizeBlack;
		}else{
			localBufferSizeA = localBufferSizeBlack; localBufferSizeB = localBufferSizeRed;
		}
		stride = bufferSize/sizeOld;
		idx = 0;
		for (i = 0; i < sizeOld; i++){ 
			localSize = localBufferSizeA[i];
			for (j = 0; j < localSize; j++){
				//printf(" i = %d j = %d \n", i, j);
				spawn findChildren(G, i*stride+j, level, n_vertices, idx++, size);
			}
		}
		sync;
		/*stride = bufferSize/size;
		idx = 0;
		for (i = 0; i < size; i++){
			 startIdx = i*stride;
			 for (j=0;j<localBufferSize[i];j++) bufferRed[idx++]=bufferBlack[startIdx+j];
		}	
		size = idx;*/
		sizeOld = size;
		size = 0;
		for (i = 0; i < sizeOld; i++) size += localBufferSizeB[i];
		//printf("BSF vertex at the next level %d = %d \n", level, size);		
	}
	printf("Total levels %d  \n", level);
}

void BFS_verify(int n_vertices){
	int result =0, i;
	for (i =0; i< n_vertices;i++)
		if (label[i] == n_vertices) result++;
	printf("BFS verification: the number of vertices missed %d (should be zero) \n", result);
}

cilk int main(int argc, char *argv[])
{
	V* G;

	int n_vertices=100000, n_edges=400000,i,size;

	Cilk_time tm_begin, tm_elapsed;
	Cilk_time wk_begin, wk_elapsed;
	Cilk_time cp_begin, cp_elapsed;

	if(argc!=3) printf("usage: ST <n> <m>\n");

	n_vertices = atoi (argv[1]);
	n_edges = atoi(argv[2]);

	printf("n_vertics=%d, n_edges=%d\n", n_vertices, n_edges);
 	G=r_graph(n_vertices,n_edges);
	color = (int *) malloc(sizeof(int)*n_vertices);
	for(i=0;i<n_vertices;i++) color[i]=0;

	/* global data structures used by BFS */
	/*
	bufferRed = (int *) malloc(sizeof(int)*n_vertices); //the size is good enough for this test problem.
	bufferBlack = (int *) malloc(sizeof(int)*n_vertices);*/

	bufferSize = (n_edges > n_vertices)? n_edges:n_vertices;
	bufferRed = (int *) malloc(sizeof(int)*bufferSize);
	bufferBlack = (int *) malloc(sizeof(int)*bufferSize);
	localBufferSizeRed = (int *) malloc(sizeof(int)*n_vertices);
	localBufferSizeBlack = (int *) malloc(sizeof(int)*n_vertices);
	label = (int *) malloc(sizeof(int)*n_vertices); 
	for(i=0;i<n_vertices;i++) label[i]=n_vertices;
	//lock = (Cilk_lockvar *)  malloc(sizeof(Cilk_lockvar)*n_vertices);
	//for(i=0;i<n_vertices;i++) Cilk_lock_init(lock[i]);
	Cilk_lock_init(lock);
	printf("r_graph done\n");
	/* Timing. "Start" timers */
	sync;
	cp_begin = Cilk_user_critical_path;
	wk_begin = Cilk_user_work;
	tm_begin = Cilk_get_wall_time();
	//spawn ST(G,n_vertices);
	spawn BSF(G,n_vertices,0);	
	sync;
	/* Timing. "Stop" timers */
	tm_elapsed = Cilk_get_wall_time() - tm_begin;
	wk_elapsed = Cilk_user_work - wk_begin;
	cp_elapsed = Cilk_user_critical_path - cp_begin;
	BFS_verify(n_vertices);
	printf("Critical path = %4f s\n\n", Cilk_time_to_sec(cp_elapsed));
	printf(" running on %d processor(s)\n\n", Cilk_active_size);
	printf("options: number of elements = %ld\n\n", size);
	printf("Running time = %4f s\n", Cilk_wall_time_to_sec(tm_elapsed));
	printf("Work = %4f s\n", Cilk_time_to_sec(wk_elapsed));
	free(color);
	free(bufferBlack);
	free(bufferRed);
	free(label);
	return(0);
}
