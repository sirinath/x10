/**************************************************************************
*                                                                         *
*             Java Grande Forum Benchmark Suite - MPJ Version 1.0         *
*                                                                         *
*                            produced by                                  *
*                                                                         *
*                  Java Grande Benchmarking Project                       *
*                                                                         *
*                                at                                       *
*                                                                         *
*                Edinburgh Parallel Computing Centre                      *
*                                                                         *
*                email: epcc-javagrande@epcc.ed.ac.uk                     *
*                                                                         *
*                                                                         *
*      This version copyright (c) The University of Edinburgh, 2001.      *
*                         All rights reserved.                            *
*                                                                         *
**************************************************************************/
package moldyn;

import jgfutil.*;;

/**
 * Moldyn ported to x10. Single place with multiple activities.
 *
 * @author kemal 3/2005
 */
public class JGFMolDynBench extends md implements JGFSection3 {

	//int size;
	public const NTHREADS: int = 4;
	public const D: dist = Dist.makeConstant([0..NTHREADS-1], here);

	public const P: Array[md] = new Array[md](D, (var point [j]: point): md => { return new md(); });

	public def this(): JGFMolDynBench = {
	}

	public def JGFsetsize(var size: int): void = {
		this.size = size;
	}

	public def JGFinitialise(): void = {
		finish foreach (val (j): point in D) (P(j)).initialise(j, NTHREADS);
	}

	public def JGFapplication(): void = {
		JGFInstrumentor.startTimer("Section3:MolDyn:Run");
		finish async {
			final val C: clock = clock.factory.clock();
			foreach (val (j): point in D) P(j).runiters(C);
		}
		JGFInstrumentor.stopTimer("Section3:MolDyn:Run");
	}

	public def JGFvalidate(): void = {
		finish foreach (val (j): point in D) {
			var myNode: md = P(j);
			// double refval[] = { 1731.4306625334357, 7397.392307839352 };
			double var refval: Array[double] = { 275.97175611773514, 7397.392307839352 };
			var dev: double = Math.abs(myNode.ek - refval(size));
			if (dev > 1.0e-10 ) {
				System.out.println("Validation failed at thread "+j);
				System.out.println("Kinetic Energy = " + myNode.ek + "  " + dev + "  " + refval(size));
				throw new Error("Validation failed");
			}
		}
	}

	public def JGFtidyup(): void = {
		System.gc();
	}

	public def JGFrun(var size: int): void = {
		JGFInstrumentor.addTimer("Section3:MolDyn:Total", "Solutions", size);
		JGFInstrumentor.addTimer("Section3:MolDyn:Run", "Interactions", size);

		JGFsetsize(size);

		JGFInstrumentor.startTimer("Section3:MolDyn:Total");

		JGFinitialise();
		JGFapplication();
		JGFvalidate();
		JGFtidyup();

		JGFInstrumentor.stopTimer("Section3:MolDyn:Total");

		JGFInstrumentor.addOpsToTimer("Section3:MolDyn:Run", (double) interactions);
		JGFInstrumentor.addOpsToTimer("Section3:MolDyn:Total", 1);

		JGFInstrumentor.printTimer("Section3:MolDyn:Run");
		JGFInstrumentor.printTimer("Section3:MolDyn:Total");
	}
}
