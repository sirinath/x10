/*
 *
 * (C) Copyright IBM Corporation 2006
 *
 *  This file is part of X10 Test.
 *
 */
import java.util.Random;
import harness.x10Test;;

/**
 * Version of the JGF SparseMatmult benchmark with
 * mostly values and no async operations (differs in
 * terms of how data is distributed from JGF).
 *
 * @author Christian Grothoff
 */
public class SparseMatmultAllValues extends x10Test {

	// DRIVER
	const RANDOM_SEED: long = 10101010;
	const size: int = 0;
	const datasizes_M: Array[int] = { 500, 100000, 500000 };
	const datasizes_N: Array[int] = { 500, 100000, 500000 };
	const datasizes_nz: Array[int] = { 2500, 500000, 2500000 };
	const SPARSE_NUM_ITER: int = 200;
	const R: Random = new Random(RANDOM_SEED);

	public static def main(var args: Rail[String]): void = {
		new SparseMatmultAllValues().execute();
	}

	public def this(): SparseMatmultAllValues = { }

	var pos: int; // hack

	public def run(): boolean = {
		final val nthreads: int = place.MAX_PLACES;
		final val d_places: dist = distmakeUnique(place.places);
		final val r_N: region = [0..datasizes_N(size-1)];
		final val r_M: region = [0..datasizes_M(size-1)];
		final val r_nz: region = [0..datasizes_nz(size-1)];
		final val r_nthreads: region = [0..nthreads-1];
		final val d_N: dist = distmakeBlock(r_N, place.places);
		final val d_M: dist = distmakeBlock(r_M, place.places);
		final val d_nz: dist = distmakeBlock(r_nz, place.places);
		final val d_nthreads: dist = distmakeUnique(place.places);

		final val row: Array[int] = new Array[int](Dist.makeConstant(r_nz, here), (var point[i]: point): int => {
				return 0; // Math.abs(R.nextInt()) % datasizes_M[size];
			});
		final val col: Array[int] = new Array[int](Dist.makeConstant(r_nz, here), (var point[i]: point): int => {
				return 0; // Math.abs(R.nextInt()) % datasizes_N[size];
			});

		// val is the representation of the sparse MxN matrix;
		// val[i,j] corresponds to matrix[row[i],col[j]]
		final val val: Array[double] = new Array[double](Dist.makeConstant(r_nz, here), (var point[i]: point): double => {
				return 0.0; // R.nextDouble();
			});

		// yucky original initialization code (also partially wrong -- % ds_M vs % ds_N for col!)

		// I would init and define x much later (but we must do it in order
		// given by JGF)
		// "x" value with which matrix is going to be multiplied
		final val x: Array[double] = RandomVector(d_N);

		for (var i: int = 0; i < datasizes_nz(size); i++) {
			final val ds_M: int = datasizes_M(size);
			final val random_1: int = R.nextInt();	// generate random row index (0, M-1)
			final val random_2: int = R.nextInt(); // generate random column index (0, N-1)
			final val random_3: double = R.nextDouble();
			final val i_final: int = i;

			row(i_final) = Math.abs(random_1) % ds_M;
			col(i_final) = Math.abs(random_2) % ds_M;
			val(i_final) = random_3;
		}

		// reorder arrays for parallel decomposition
		// reorders the matrix to group entries that will
		// be processed at the same place.

		final val rowt: Array[int] = new Array[int](Dist.makeConstant(r_nz, here));
		final val colt: Array[int] = new Array[int](Dist.makeConstant(r_nz, here));
		final val valt: Array[double] = new Array[double](Dist.makeConstant(r_nz, here));

		pos = 0;
		final val workranges: Array[region] = new Array[region](Dist.makeConstant(r_nthreads, here), (var point[j]: point): region => {
				var yrange: region = (d_M | d_places(j)).region;
				var low: int = pos;
				var high: int = low-1;
				for (var i: int = 0; i < datasizes_nz(size); i++) {
					if (! yrange.contains(point.factory.point(row(i))))
						continue;
					high++;
					rowt(high) = row(i);
					colt(high) = col(i);
					valt(high) = val(i);
				}
				pos = high + 1;
				return [low..high];
			});
		//assert (pos == datasizes_nz[size]);
		if (pos != datasizes_nz(size)) throw new Error();

		// convert to values
		final val Vrow: Array[int] = new Array[int](Dist.makeConstant(r_nz, here), (var point[i]: point): int => {
				return rowt(i);
			});
		final val Vcol: Array[int] = new Array[int](Dist.makeConstant(r_nz, here), (var point[i]: point): int => {
				return colt(i);
			});
		final val Vval: Array[double] = new Array[double](Dist.makeConstant(r_nz, here), (var point[i]: point): double => {
				return valt(i);
			});

		// "y" is the vector with which is supposed to become y : = mat(val) * x
		final val y: Array[double] = new Array[double](d_M);

		finish ateach (val p: point[i] in d_places) mul(Vval, x, y, Vrow, Vcol, SPARSE_NUM_ITER, workranges(i));

		// validate
		var ytotal: double = 0.0;
		for (val p: point in y.region) {
			// CG-style: //    ytotal += (future (y.dist[p]) { y[p] }).force();
		}
		for (val p: point[i] in rowt.region) {
			// JGF-style:
			final val i_final: int = i;
			final val row_i: int = (future (rowt.dist(i)) { rowt(i_final) }).force();
			ytotal += (future (y.dist(row_i)) { y(row_i) }).force();
		}
		double var refval: Array[double] = { 0.7379886692958086, 150.0130719633895, 749.5245870753752 };
		var dev: double = Math.abs(ytotal - refval(size));
		if (dev > 1.0e-10) {
			System.out.println("Validation failed");
			System.out.println("ytotal = " + ytotal + "  " + dev + "  " + size);
			throw new Error("Validation failed");
		} else {
			System.out.println("Validation succeeded");
		}
		return true;
	}

	private static def mul(var val: Array[double], var x: Array[double], var yt: Array[double], var row: Array[int], var col: Array[int], var num_ITERATIONS: int, var sumrange: region): void = {
		for (var reps: int = 0; reps < num_ITERATIONS; reps++)
			for (val i: point in sumrange) {
				final val rowi: int = row(i);
				yt(rowi) = yt(rowi) + x(col(i)) * val(i);
			}
	}

	// trivial helper
	private static def RandomVector(var d: dist): Array[double] = {
		return new Array[double](d, (var point[i]: point): double => {
			return R.nextDouble() * 1e-6;
		});
	}
}
