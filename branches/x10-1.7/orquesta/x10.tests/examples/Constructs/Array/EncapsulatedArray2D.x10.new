/*
 *
 * (C) Copyright IBM Corporation 2006
 *
 *  This file is part of X10 Test.
 *
 */
import x10.lang.Object;
import harness.x10Test;;

/**
* Building arrays distributed accross places using the encapsulation approach 
* (2D array of 2D arrays).
* @author Tong
  11/29/2006
*/
public class EncapsulatedArray2D extends x10Test /*
 *
 * (C) Copyright IBM Corporation 2006
 *
 *  This file is part of X10 Test.
 *
 */
import x10.lang.Object;
import harness.x10Test;

/**
* Building arrays distributed accross places using the encapsulation approach 
* (2D array of 2D arrays).
* @author Tong
  11/29/2006
*/
public class EncapsulatedArray2D extends x10Test {
	
	static value Wrapper{.{.{*
 *
 * (C) Copyright IBM Corporation 2006
 *
 *  This file is part of X10 Test.
 *
 */
import x10.lang.Object;
import harness.x10Test;

/**
* Building arrays distributed accross places using the encapsulation approach 
* (2D array of 2D arrays).
* @author Tong
  11/29/2006
*/
public class EncapsulatedArray2D extends x10Test {
	
	static value Wrapper{
		var m_array: Array[double];
		def this(var a_array: Array[double]): Wrapper = {
			m_array=a_array;
		}
	}
	
        public def run(): boolean = {
        	final val size: int = 5;
        	final val R: region = [0..size-1, 0..size-1];
        	final val D: dist = dist.factory.cyclic(R); 
        	
        	final val A: Array[Wrapper] = new Array[Wrapper](D);
        	finish ateach (val (i,j): point in D) A(i, j)=new Wrapper(new Array[double](R));
        		
        	//for (int i=0;i<numOfPlaces;i++){	
        	finish ateach (val (i,j): point in D) { 
        		final val temp: Array[double] = A(i, j).m_array; 
        		for (val p: point in temp) temp(p)=i+j;
        	}
    	
	    return true;
	}
	
	public static def main(var args: Rail[String]): void = {
		new EncapsulatedArray2D().execute();
	}

}
